<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL学习笔记1 事务并发</title>
    <url>/2021/05/03/MySQL-Learning-note-1-lock/</url>
    <content><![CDATA[<p>最近一段时间学习了MySQL的锁，各种各样的锁，全局锁、表锁、MDL、行锁、间隙锁等等。</p>
<p>每种锁都有其存在的意义，都是为了解决某一种问题。锁是解决事务并发问题的基本手段之一，除了锁，还有多版本控制等无锁手段。</p>
<p>假如不使用一些手段，那么并发事务会存在脏读、不可重复读、幻读等问题。为了学习MySQL的并发事务隔离手段，我们首先需要了解事务存在的这几类并发问题。</p>
<h1 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h1><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>什么是脏读？脏读就是读到了其他未提交事务的数据。为了让这一过程更易理解，我们使用MySQL来复现。MySQL 5.7的事务默认隔离级别是可重复读，该级别下不存在问题。所以需要将MySQL的隔离级别设置为READ UNCOMMITTED（读未提交），该级别下会存在脏读。具体过程如下：</p>
<p>session A，读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED<br>MySQL root@(none):my_db&gt; begin;</p>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 1000    |<br>+———+</p>
</blockquote>
<p>session B，修改记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; begin;<br>MySQL root@(none):my_db&gt; update account set balance &#x3D; balance + 100 where name &#x3D; ‘A’;</p>
</blockquote>
<p>session A，读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 1100     |<br>+———+</p>
</blockquote>
<p>可以发现，session A读到了尚未提交的session B的更新，属于脏读。</p>
<p>脏读存在什么问题呢？假如session B回滚，那么这个数据就是脏数据，这会影响逻辑的正确性。举一个具体例子，客户A正在ATM机提款，这时候客户B想给他转了一笔钱，业务逻辑是先扣除B的余额，再给A加上钱。在给A加完钱后的一时刻，银行后台读取了A的账户余额，客户B的操作由于某些原因回滚了，这时候读取到的就是脏数据，造成的后果是多给A钱，而客户B没有损失。</p>
<p>为了解决这个问题，MySQL引入了一致性视图的概念，在事务开启时给数据库的状态“拍”了个快照。</p>
<p>具体来说，给每个事务设置了trx id，单调递增，是事务的唯一标志。当发生查询时，会查找小于等于自己trx id版本的记录。假设在session A开始时，trx id是1。在session B开启时，trx id是2。那么在session B更新记录时，这条记录的版本号是2。而在session A查询时，它查不到这条版本号为2的记录，会找到未更新前的那条记录。这就解决了上面提到的脏读问题。</p>
<p>我们在将事务的隔离级别设置为可重复读，再实践一下：</p>
<p>session A，读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; begin<br>Query OK, 0 rows affected<br>Time: 0.000s<br>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 1000    |<br>+———+</p>
</blockquote>
<p>session B，修改记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; begin;</p>
<p>MySQL root@(none):my_db&gt; update account set balance &#x3D; balance - 100 where name &#x3D; ‘A’;</p>
</blockquote>
<p>session A，读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 1000    |<br>+———+</p>
</blockquote>
<p>可以发现session A读不到session B的更改了，解决了脏读问题。</p>
<p>总结：为了解决脏读问题，MySQL没有用到锁，而是使用了多版本控制机制，通过为每个事务开启一个视图来保持一致性。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>什么是不可重复读？不可重复读就是一个事务在没有修改的情况下，同样的普通查询在不同时刻得到了不一样的结果。</p>
<p>上面的实验看起来也是种不可重复读，但是实际上它不是。不可重复读，指的是其他已提交事务产生的影响，而不是未提交事务的影响。这就是脏读和不可重复读的区别点。</p>
<p>让我们做个实验复现一下，首先需要将session A的事务隔离级别设置为READ COMMITTED（读已提交）</p>
<p>session A，设置隔离级别并读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED</p>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 900     |<br>+———+</p>
</blockquote>
<p>session B，修改记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; update account set balance &#x3D; balance - 100 where name &#x3D; ‘A’;</p>
</blockquote>
<p>session A，读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 800     |<br>+———+</p>
</blockquote>
<p>可以发现两次session A读取的结果并不一致。注意这里session B和脏读的实验不同，没有使用<code>begin</code>开启事务。假如没有使用<code>begin</code>开启事务，那么默认情况下事务会马上提交。</p>
<p>让我们将隔离级别设置回可重复读，再实验一下：</p>
<p>session A，读取记录：</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 600     |<br>+———+</p>
<p>MySQL root@(none):my_db&gt; begin<br>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 600     |<br>+———+</p>
</blockquote>
<p>session B，修改记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; update account set balance &#x3D; balance - 100 where name &#x3D; ‘A’;</p>
</blockquote>
<p>session A，读取记录:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 600     |<br>+———+</p>
</blockquote>
<p>可以发现在可重复读的隔离级别下，可以重复读。原理同样是MVCC。</p>
<p>问题：更新的时候会读到最新值，算不可重复读吗？</p>
<p>不算，根据不可重复读的定义，只有在不修改只有读取的情况下才算不可重复读。实际上，在可重复读的级别下，更新的时候，读取到其他事务的值是符合预期的。</p>
<p>问题：这样会存在问题吗？</p>
<p>假设我们有这么一个业务场景，在扣除某个人的余额前，需要先判断它是否足额（保证非负），然后再执行更新操作。</p>
<p>经过实验发现存在这样的情况：</p>
<p>session A:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; begin;<br>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 100     |<br>+———+</p>
</blockquote>
<p>session B:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; update account set balance &#x3D; 0 where name &#x3D; ‘A’;</p>
</blockquote>
<p>session A:</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| 100     |<br>+———+<br>MySQL root@(none):my_db&gt; update account set balance &#x3D; balance - 100 where name &#x3D; ‘A’;<br>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’;<br>+———+<br>| balance |<br>+———+<br>| -100     |<br>+———+</p>
</blockquote>
<p>可以发现出现了负值了，这是我们不允许出现的。</p>
<p>问题：怎么解决这个问题呢？</p>
<p>分析：使用记录锁。假如session A依赖于第一次查询的结果，那么就应该对它加锁，防止在自己完成事务前被修改。在MySQL中，可以使用<code>for udpate</code>对查询加记录所。在session A对记录加锁后，其他事务不再允许修改相应的记录，直到session A的事务结束(commit或rollback)。在执行语句加锁，在事务结束释放锁，被称为两阶段锁协议。</p>
<p>问题：为什么要在结束的时候释放，提前释放会有问题么？</p>
<p>假如提前释放其实可以提高并发度，但是MySQL似乎不支持提前释放。有一种特殊的自增锁（auto-inc），会自动提前释放。它是用于给自增字段生成id，加锁是为了保证递增。</p>
<p>问题：两阶段锁协议解决了什么问题？</p>
<p>问题：如何验证加了什么锁？</p>
<p>可以使用Innodb Lock Monitor，具体可以查看下面的教程。</p>
<blockquote>
<p>记录锁的事务数据在SHOW ENGINE INNODB STATUS和InnoDB监视器输出中看起来类似于以下内容：</p>
<p>RECORD LOCKS space id 58 page no 3 n bits 72 index PRIMARY of table test.t trx id 10078 <strong>lock_mode X locks rec but not gap</strong></p>
</blockquote>
<p>我们分析下Monitor的输出信息，先执行一个简单的select … for update操作：</p>
<blockquote>
<p>MySQL root@(none):my_db&gt; begin<br>MySQL root@(none):my_db&gt; select balance from account where name &#x3D; ‘A’ for update;<br>+———+<br>| balance |<br>+———+<br>| 0       |<br>+———+</p>
</blockquote>
<p>查看输出信息：</p>
<blockquote>
<p>TRANSACTIONS<br>-———–<br>Trx id counter 2821<br>Purge done for trx’s n:o &lt; 0 undo n:o &lt; 0 state: running but idle<br>History list length 0<br>LIST OF TRANSACTIONS FOR EACH SESSION:<br>—TRANSACTION 421563048392544, not started<br>0 lock struct(s), heap size 1136, 0 row lock(s)<br>—TRANSACTION 2820, ACTIVE 6 sec<br>4 lock struct(s), heap size 1136, 3 row lock(s)<br>MySQL thread id 25, OS thread handle 140087744558848, query id 74 localhost root<br><strong>TABLE LOCK</strong> table <code>my_db</code>.<code>account</code> trx id 2820 <strong>lock mode IX</strong><br><strong>RECORD LOCKS</strong> space id 24 page no 4 n bits 72 index uniq_index_name of table <code>my_db</code>.<code>account</code> trx id 2820 <strong>lock_mode X</strong><br><strong>Record lock</strong>, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0<br> 0: len 1; hex 41; asc A;;<br> 1: len 8; hex 8000000000000001; asc         ;;</p>
<p><strong>RECORD LOCKS</strong> space id 24 page no 3 n bits 72 <strong>index PRIMARY of table</strong> <code>my_db</code>.<code>account</code> trx id 2820 <strong>lock_mode X locks rec but not gap</strong><br>Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 0<br> 0: len 8; hex 8000000000000001; asc         ;;<br> 1: len 6; hex 000000000921; asc      !;;<br> 2: len 7; hex 350000014f0110; asc 5   O  ;;<br> 3: len 1; hex 41; asc A;;<br> 4: len 4; hex 80000000; asc     ;;</p>
<p><strong>RECORD LOCKS</strong> space id 24 page no 4 n bits 72 <strong>index uniq_index_name</strong> of table <code>my_db</code>.<code>account</code> trx id 2820 <strong>lock_mode X locks gap before rec</strong><br>Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0<br> 0: len 1; hex 42; asc B;;<br> 1: len 8; hex 8000000000000002; asc         ;;</p>
</blockquote>
<p>我将其中关键信息加粗了一下，可以发现该事务加了4个锁。包括1个TABLE LOCK和3个RECORD LOCKS：</p>
<ul>
<li>table lock<ul>
<li>lock mode IX  意向锁，在添加行锁之前添加，不会和行级的X, S锁发生冲突，只会和表级的X, S锁发生冲突。</li>
</ul>
</li>
<li>record locks<ul>
<li>lock_mode X  对name&#x3D;A的这行上写锁</li>
<li>index PRIMARY of table, lock_mode X locks rec but not gap  是对主键索引加锁，对name&#x3D;A这行加锁</li>
<li>index uniq_index_name, lock_mode X locks gap before rec  是对二级索引uniq_index_name加锁，在记录前面加了gap锁</li>
</ul>
</li>
</ul>
<p>问题：lock_mode X和index PRIMARY of table, lock_mode X locks rec but not gap有什么区别？</p>
<p>问题：行锁有哪些？</p>
<p>记录所、gap锁。。。</p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读是什么？幻读是一个事务在没有修改的情况，在不同时刻的进行两次修改读，读取到了不同的结果。幻读是write query，而不可重复读是read query。</p>
<p>Todo</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>Todo</p>
<h2 id="Innodb-Lock-Monitor"><a href="#Innodb-Lock-Monitor" class="headerlink" title="Innodb Lock Monitor"></a>Innodb Lock Monitor</h2><p>为了观察SQL是被哪种锁锁住了，可以使用Innodb Lock Monitor。</p>
<p>启用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL innodb_status_output=ON;</span><br><span class="line">SET GLOBAL innodb_status_output_locks=ON;</span><br></pre></td></tr></table></figure>

<p>可以认为innodb_status_output是monitor的总开关，innodb_status_output_locks是lock monitor的开关，两者需要都打开才算启用成功。这两条命令的生命周期为server本次运行的周期，当server关闭后，下次启动会恢复成关闭状态。</p>
<p>获取Monitor输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p>在终端上输出时，加上<code>\G</code>可以让输出的可读性更佳。输出的字段有许多，我们主要关注和锁相关的字段。主要是<code>LATEST DETECTED DEADLOCK</code>和<code>TRANSACTIONS</code>字段。关于这两个字段的官方解释：</p>
<blockquote>
<p><code>LATEST DETECTED DEADLOCK</code></p>
<p>This section provides information about the most recent deadlock. It is not present if no deadlock has occurred. The contents show which transactions are involved, the statement each was attempting to execute, the locks they have and need, and which transaction <code>InnoDB</code> decided to roll back to break the deadlock. The lock modes reported in this section are explained in <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">Section 14.7.1, “InnoDB Locking”</a>.</p>
<p><code>TRANSACTIONS</code></p>
<p>If this section reports lock waits, your applications might have lock contention. The output can also help to trace the reasons for transaction deadlocks.</p>
</blockquote>
<p>注意点：</p>
<blockquote>
<p>When <code>InnoDB</code> monitors are enabled for periodic output, <code>InnoDB</code> writes the output to <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html"><strong>mysqld</strong></a> server standard error output (<code>stderr</code>) every 15 seconds, approximately.</p>
</blockquote>
<p>monitor的输出是周期性，大概15s会输出一次。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>可以利用mysql的唯一索引实现分布式锁。原理存在唯一索引的情况，插入重复的key会进行加锁。下面介绍会加什么锁，以及可能的问题。</p>
<p>首先创建一个的带有唯一索引的表distributed_lock：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `distributed_lock` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;自增ID&#x27;,</span><br><span class="line">  `c` int,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general</span><br></pre></td></tr></table></figure>

<p>使用两个事务，分别执行insert语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into distributed_lock (c) values(1);</span><br></pre></td></tr></table></figure>

<p>时序图如下：</p>
<img src="../../../Documents/notebook/img/image-20210626153812741.png" alt="image-20210626153812741" style="zoom:50%;" />

<p>注意到session A成功获取到了锁，那么这里到底获取的哪些锁呢？</p>
<p>我们可以使用上面介绍的Lock Monitor一探究竟。</p>
<p>下面是session B阻塞那一时刻的完整日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 7973</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 7972 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 2</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421898576025440, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 7972, ACTIVE 1 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 13, OS thread handle 140423219771136, query id 126 localhost root update</span><br><span class="line">insert into distributed_lock (c) values(5)</span><br><span class="line">------- TRX HAS BEEN WAITING 1 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 38 page no 4 n bits 72 index c of table `my_db`.`distributed_lock` trx id 7972 lock</span><br><span class="line"> mode S waiting</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 8; hex 800000000000000a; asc         ;;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">TABLE LOCK table `my_db`.`distributed_lock` trx id 7972 lock mode IX</span><br><span class="line">RECORD LOCKS space id 38 page no 4 n bits 72 index c of table `my_db`.`distributed_lock` trx id 7972 lock</span><br><span class="line"> mode S waiting</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 8; hex 800000000000000a; asc         ;;</span><br><span class="line"></span><br><span class="line">---TRANSACTION 7967, ACTIVE 6 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 17, OS thread handle 140423553578752, query id 125 localhost root</span><br><span class="line">TABLE LOCK table `my_db`.`distributed_lock` trx id 7967 lock mode IX</span><br><span class="line">RECORD LOCKS space id 38 page no 4 n bits 72 index c of table `my_db`.`distributed_lock` trx id 7967 lock</span><br><span class="line">_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 8; hex 800000000000000a; asc         ;;</span><br></pre></td></tr></table></figure>

<p>其中，transaction 7972被阻塞了，它应该就是session B。日志显示它被Record Lock阻塞了，该Record Lock应该就是c &#x3D; 5的那一行。另外可以注意到表已经被加上了IX锁，这个锁表示插入意向锁。</p>
<p>transaction 7967表示session A。它持有两个锁，一个是表的IX锁，另一个是Record Lock。日志显示not gap，表示这个Record Lock不是间隙锁，因此是c &#x3D; 5那一行的锁。</p>
<p>问题：表的IX锁有什么用？</p>
<p>问题：什么时候会加间隙锁？</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/set-transaction.html">SET TRANSACTION Statement</a></li>
<li><a href="https://bytedance.feishu.cn/wiki/wikcnbPsHVuvGZF0YaakT6YC2lf">InnoDB的事务和锁</a></li>
<li>《MySQL实战45讲》——极客时间</li>
<li><a href="https://www.percona.com/blog/2012/03/27/innodbs-gap-locks/">InnoDB Gap Locks</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-enabling-monitors.html">Enabling InnoDB Monitors</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-standard-monitor.html">InnoDB Standard Monitor and Lock Monitor Output</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">innodb-locking</a></li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 代理</title>
    <url>/2021/05/15/docker-proxy/</url>
    <content><![CDATA[<p>最近在玩docker，由于众所周知的原因，在国内访问海外的网站速度会很慢，在docker内的表现是git clone和apt install缓慢。这个问题的常见解决方法是换源、挂代理。这里我使用了挂代理的方式解决，主要是考虑比较通用，不需要给每个工具配置一遍源。</p>
<p>在container里面挂代理，需要确定container是如何和host的网络通信的。实际上，在host有一个docker0的虚拟网卡，用于container和host通信，可以这么查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># host</span></span><br><span class="line">$ ip addr show docker0</span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:64:51:fb:47 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:64ff:fe51:fb47/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>在container内，我们同样观察一下网络的路由配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># container</span></span><br><span class="line">$ ip route show</span><br><span class="line">default via 172.17.0.1 dev eth0 </span><br><span class="line">172.17.0.0/16 dev eth0  src 172.17.0.4 </span><br></pre></td></tr></table></figure>

<p>可以发现container的ip包默认会转发到172.17.0.1，这正是host的docker0网卡配置的ip。至此，我们确定了container和host通信的ip地址。</p>
<p>为了让host允许container访问所有port，需要修改host的ip路由表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># host</span></span><br><span class="line">iptables -A INPUT -i docker0 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>假设在host已经配置了一个可用的代理地址127.0.0.1:7890，那么container访问这个代理就需要使用172.17.0.1:7890。</p>
<p>在container可以如此配置代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://172.17.0.1:7890</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://172.17.0.1:7890</span><br></pre></td></tr></table></figure>

<p>这样设置后，运行<code>curl www.google.com</code>成功，就说明代理生效了。通过设置这两个变量后，apt install和git clone也成功挂上了代理。</p>
<p>参考：</p>
<ul>
<li><a href="https://docs.docker.com/network/proxy/#configure-the-docker-client">Configure Docker to use a proxy server</a></li>
<li><a href="https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container"><a href="https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container">How to access host port from docker container</a></a></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>《自控力》阅读笔记</title>
    <url>/2021/06/05/The-Willpower-Instinct-readingNote/</url>
    <content><![CDATA[<p>最近阅读完了《自控力》这本书，书里讲的一些内容挺有道理和依据的，能解释生活中的一些行为。读完本书可以明白自己为何失控、如何失控，以及如何更好地避免失控，更好地掌控自己的生活。本博文以总结技巧为主，知识点为辅，说明该如何提高自己的自控力。</p>
<p>当我们觉得自己的自控力很差时，其实其他大多数人也存在和我们一样的问题。这本书教给我一个很重要的道理，即任何人都是普通人，都会受生理的限制，会产生普通人面对诱惑时该有的表现。我们首先应该有自知之明，明白人类的自控力系统很孱弱，需要我们好好地运用技巧来“提高”自控力。</p>
<h1 id="第一章-意志力是什么"><a href="#第一章-意志力是什么" class="headerlink" title="第一章 意志力是什么"></a>第一章 意志力是什么</h1><p>我理解文中提到的意志力和自控力是同义词，都表示对自己生活的掌控能力。</p>
<p>生活中的事情，可以归为三类：我要做，我不要，我想要。意志力就是驾驭这三种事情，在这三者中寻得平衡。</p>
<p>“我想要”是自己的目标和欲望，它越强大，越能让自己做该做的事情，并让自己不做不应该做的事情。</p>
<p>每个人都会有积极的欲望和消极的欲望。积极欲望通常是更长期的目标，比如拥有规律的作息、健壮的身体、良好的学习习惯、向上的职业规划。而消极欲望，通常是短期的放纵，比如玩游戏、刷短视频、刷朋友圈。<strong>这里有个核心问题是怎么让自己的积极欲望更强大， 而消极欲望更渺小？</strong></p>
<p>书中提到，每个会有两个自我，一个会控制自己，另一个则充满冲动。前者是多做积极事情的推动者，而后者则比较本能。</p>
<p>技巧：给两个自我起个名字，以更好地认清两个自我的存在。比如可以将控制自我称为mage，而将冲动的自我称为monster。通过分别赋予前者积极的语义，后者消极的语义，以利于在做决策时，更好地唤醒明智的自己。</p>
<p>通常来说，我们做决定时，通常都像开了自动挡，或者说，我们大多数时候会被过去的习惯所驱动。</p>
<p><strong>这里有个核心问题，如何在做决定时唤醒自己？</strong></p>
<p>技巧：集中注意力。比如在做决定时，关闭电子设备，闭上眼睛，做几个深呼吸。</p>
<p>技巧：回忆做过的决定。比如可以在睡前，回忆一下今天没有去健身房健身的场景，受到了什么因素的干扰，下次应该怎么集中注意力。</p>
<p>前额皮质：大脑中用于控制行为的区域。分成三部分，分别对应三类事情。</p>
<p>技巧：练习冥想。冥想可以让更多的血液流进前额皮质，帮助自己做正确的事情。</p>
<h1 id="第二章-意志力本能"><a href="#第二章-意志力本能" class="headerlink" title="第二章 意志力本能"></a>第二章 意志力本能</h1><p>本能是指人类先天携带的应对外界刺激时的反应。有些本能是先天携带的，比如生存、进食、应对危险等。</p>
<p>本能、习惯其实都是在描述人类应对某一类事情如何表现。通常我们会说如何培养习惯，而不会说如何培养本能，因为本能是不可更改的。我们可以通过更改自己的习惯，来改变自己。</p>
<p>多巴胺：一种让自己觉得做得某件事情会很快乐的化学物质。</p>
<p>比如，在面对食物诱惑时，大脑会分泌一些多巴胺，让自己产生进食的冲动。这个应该因人而异，笔者面对食物诱惑时，多巴胺似乎分泌不足，因为自己总是不太想吃东西。另外，还有个例子是让很多人深受其恼的熬夜刷短视频，在我们想再刷几分钟就睡觉时，大脑总会分泌多巴胺让这个行为继续下去。</p>
<p>本能相对应的自控表现，称之为“三思而后行”反应，即让自己慢下来，先想想，再做行动。在这个时代，我们应该做的是多做“三思而后行”反应，少依本能行事。</p>
<p><strong>这里有个核心问题，如何让自己三思而后行？</strong></p>
<p>技巧：将时间分块，强制事情执行前先思考。假如处于诱惑中，则应先强制中断当前的事情，先远离诱惑。</p>
<p>心率变异度：反映意志力情况。越高，越能抵抗诱惑。</p>
<p><strong>问题：怎么提高心意变异率？</strong></p>
<ul>
<li>快速有效的方法，将呼吸频率降低到每分钟4~6次，也就是每分钟呼吸用10~15秒时间。</li>
<li>长期坚持的方法，每周锻炼三次。这里的锻炼包括健身房、游泳、伸展运动、公园散步、打扫房间等活动。只要让自己离开床和沙发的活动，就有所帮助。</li>
<li>充足、规律的晚上睡眠，以及适当的午休、小憩。</li>
</ul>
<p>素材：在网上搜索了一个问题，跳转到了知乎，看完了回答，刷起了短视频，本来打算查完问题就午休一会的，结果浪费了两个小时在刷视频上。睡了一觉后， 把手机扔在一边，才得以开始干活。</p>
<p>素材：晚上，特别是周五的晚上，就会感觉很兴奋，想玩手机，打游戏、刷短视频、刷消息等。不知不觉就熬夜了。</p>
<p>应对方法？</p>
<ul>
<li>属于“我不要”的挑战。</li>
<li>不是强迫自己去睡觉，而是远离那些让自己没法睡觉的东西。并且在这个过程增强自己的控制力，比如用深呼吸大法。</li>
</ul>
<h1 id="第三章-意志力极限"><a href="#第三章-意志力极限" class="headerlink" title="第三章 意志力极限"></a>第三章 意志力极限</h1><p>意志力像肌肉一样，是有极限的。</p>
<p>例子：当自己学习了一段时间后，不应该做的事情是玩手机，因为很有可能这会触发自己陷入一段很长的无意义行为中。正确的做法是脱离工作区域，随便做点和成瘾无关的事情，让自己的身心放松下来，以便迎接下一阶段的事情。</p>
<p>例子：遇到不爽的事情应该马上解决，不然会一直消耗自己的意志力，是一个debuff。</p>
<p>持续使用意志力会让它消耗，应该让它恢复。</p>
<p>问题：如何补充意志力？</p>
<ul>
<li>放松</li>
<li>补充能量</li>
</ul>
<p>虽然短期吃点东西能补充能量，提高意志力，但是这长远来看，血糖的突然波动会影响身体使用糖分的能力，即身体中的含糖量很高却没有多少能量可用。一种更好的方法是保证身体有足够的食物供应，以实现更持久稳定的能量供应。</p>
<p>实践：尝试低血糖饮食，让自己的血糖更稳定。低血糖食物包括瘦肉蛋白、坚果、豆类、粗纤维谷类、麦片、水果、蔬菜等。</p>
<p>在一些小事上持续自控会提高整体的意志力。</p>
<p>实践：以前不太记录时间的话，可以尝试增强自我监控能力，可以记录每天的时间花在哪里上了。做好这件小事，可以帮助自己认识自己到底浪费了多少时间。</p>
<p>问题：当自己觉得意志力告急，控制不了自己时，可以怎么挽救一下？</p>
<p>很多时候意志力告急可能就像跑步跑不下去一样，可以通过逼自己一把来实现突破。</p>
<p>假如是“我想要”的事情，可以假想一下挑战成功后获得的奖励是什么，我会有什么回报，是更健康、更靠谱、更幸福、更自由、更有钱，还是更成功？另外，假如挑战成功，还有谁会获益？假如是自己的榜样，他会建议自己怎么做？假如是自己讨厌的人，他会放弃吗，自己能做得比他更好吗？</p>
<p>假如是“我不要”的事情，可以假想一下持续做了这些事情带来的可怕后果，越形象越好。假如自己喜欢的人发现自己做了不该做的事情，会怎么看自己？自己讨厌的人也陷入了这些事情，自己是和他一样的吗？</p>
<h1 id="第四章-道德许可"><a href="#第四章-道德许可" class="headerlink" title="第四章 道德许可"></a>第四章 道德许可</h1><p>道德许可：在做了好事或者以为自己会做好事后，纵容自己做坏事的现象。</p>
<p>例子：</p>
<ul>
<li>在晚上进行健身后，更容易导致晚上不学习</li>
<li>在学习一段时间后，更可能纵容自己打很久的游戏，导致游戏时间远远大于学习时间</li>
<li>当为复习考试花了很多时间后，自我感觉相当良好，更可能花整晚时间和朋友打游戏“放松”</li>
<li>假想了一个很完美的计划后，很容易感觉良好，本想让自己短暂“放松”，但最终导致计划一点也没有执行</li>
<li>今天犯错了，信誓旦旦地保证明天好好补救，实际上明天还是这样</li>
</ul>
<p>道德许可意味着在前进一小步后，很可能也会退一小步，假如能克服这一点，那么就能前进一大步。</p>
<p>问题：如何克服道德许可？</p>
<ul>
<li>牢记目标，而不是行动。即关注为什么，而不是做了什么。</li>
<li>将自己做过的好事用于证明自己对目标有多坚定，而不盘点自己取得了多少进步。</li>
<li>告诉自己明天和今天毫无区别。假想一下以后每天都像今天这样放纵，会有什么可怕后果。</li>
</ul>
<h1 id="第五章-渴望不是幸福"><a href="#第五章-渴望不是幸福" class="headerlink" title="第五章 渴望不是幸福"></a>第五章 渴望不是幸福</h1>]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《代码整洁之道》阅读笔记</title>
    <url>/2021/06/14/clean-code-reading-note/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>习艺之要有二：知和行。你应当习得有关原则、模式和实践的知识，穷尽应知之事，并且要对其了如指掌，通过刻苦实践掌握它。</p>
</blockquote>
<p>假如只有知，没有行。很多时候只是在阅读的时候感觉良好，但是在实际编程的时候却又写出糟糕的代码。因此，为了真正掌握编程的良好习惯，需要跟着作者的思路，进行完整的拆解。第一部分和第三部分是理论，读完只会感觉良好，而第二部分是拆解，是核心所在，只有好好阅读这部分才能习得精湛技艺。</p>
<h1 id="第1章-整洁代码"><a href="#第1章-整洁代码" class="headerlink" title="第1章 整洁代码"></a>第1章 整洁代码</h1><p>代码永存。</p>
<p>好代码很重要。</p>
<p>稍后等于永不。</p>
<p>写整洁代码，需要遵循大量的小技巧。我们称之为代码感。要想拥有良好的代码感，需要阅读代码、写代码，琢磨为什么这么写，该怎么写。</p>
<p>本书前传：《敏捷软件开发》。本书中涉及的一些概念在前传中有提到，假如不懂可以找这本书看看。</p>
<h1 id="第2章-命名"><a href="#第2章-命名" class="headerlink" title="第2章 命名"></a>第2章 命名</h1><p>要让命名名副其实、有意义。因为这样可以让代码更容易理解和修改。</p>
<p>避免误导：防止使用某些专有名词，防止使用List来命名map，防止使用相似的名称等。</p>
<p>做有意义的区分：不要随便使用错误的拼写或数字来绕过重复的命名，而应该使用有意义的区分。避免废话，废话就是冗余，应该消除冗余。为了做有意义的区分，可以添加形容词、场景等。</p>
<p>使用读得出来的名称，因为人类擅长记忆和使用单词。不要使用缩写等不易读的、需要解决的命名。</p>
<p>使用可搜索的命名，单字母名称仅用于短方法中的本地变量，名称长短应与其作用域大小相对应。若某个变量或常量使用得较多，应赋予其便于搜索的名称。</p>
<p>尽量避免使用编码，现代的编辑环境已经可以侦测到类型错误，不需要使用这种落后的标记方式。强行使用编码，反而会让代码不易读，成为冗余。所谓编码就是在变量上添加int, string等标志，我一般会在需要类型转化时这么命名。</p>
<p>类名应该是名词或名词短语。不要使用比较泛的命名，比如Data, Info, Core等。</p>
<p>方法名应该是动词或动词短语。属性访问器、修改器和断言应该根据其值命名，并加上get, set, is前缀。重载构造器时，使用描述了参数的静态工厂方法名，比如Complex.FromRealNumber(23.0)而不是new Complex(23.0)。</p>
<p>别扮可爱，即不要使用梗来命名，这样不易被所有人理解。</p>
<p>每个概念对应一个词。举个例子，controller和manager表示的是同个意思，就只用一个就好了，假如混用两者容易让人困惑，以为它们的作用不同。</p>
<p>别用双关语。举个例子，假如Add用来表示两个数相加，那么就不要用来表示将一个数插入到集合中，而应该用Append或Insert来区分它。</p>
<p>添加有意义的语境。常用的方法是将相关的变量一起放到一个类中，赋予这些变量一个语境。</p>
<h1 id="第3章-函数"><a href="#第3章-函数" class="headerlink" title="第3章 函数"></a>第3章 函数</h1><blockquote>
<p>函数的第一条规则是要短小，第二条规则还是要更短小。</p>
</blockquote>
<blockquote>
<p>函数应该做一件事。做好这件事。只做这一件事。</p>
</blockquote>
<p>只做一件事的函数的一个标志是不可以再被切分为多个函数区段。</p>
<p>每个函数一个抽象层级。向下规则，一系列To起头段落。</p>
<p>switch语句：应该将它埋在较低的抽象层，并且用多态来让它符合SRP、OCP原则。</p>
<p>函数命名：使用描述性的名称，别害怕长名称，别害怕花时间取名字，命名方式要保持一致。</p>
<p>函数参数：</p>
<ul>
<li>最理想的参数数量是零，其次是一，再次是二，应尽量避免三。</li>
<li>过多的参数会影响可读性、测试的复杂度</li>
<li>入参将布尔变量作为标识参数，是非常丑陋的，因为它说明了这个函数不只做了一件事情，应该尽快将其分成两个函数</li>
<li>当参数过多时，应该将一些参数封装成类，进行抽象</li>
<li>函数名称一般以动词或动宾结构为佳</li>
</ul>
<p>无副作用：函数中不应该做其他被隐藏起来的事。若有副作用，可能会导致古怪的时序性耦合或出乎预期的结果。</p>
<p>尽量避免使用输出参数，所谓输出参数，是指用入参中的参数用来输出。应该使用面向对象的思想，封装起来会更易读些。在实际工程中，确实有这么写的，确实难读，<strong>需要掌握封装对象的方法。</strong></p>
<p>分隔指令与询问：在具有歧义性的多个入参的函数时，解决方案是把指令与询问分隔开来，防止混淆的发生。<strong>（指令和询问混合的例子是什么？）</strong></p>
<p>别重复自己：整个模块的可读性会因为重复的消除而得到了提升。</p>
<p>结构化编程：每个函数、函数中的每个代码块都应该只有一个入口、一个出口。遵循这些规则，意味着在每个函数中只该有一个return语句，循环中不能有break或continue语句，而且永远不能有任何goto语句。对于小函数，这些规则助益不大，只有在大函数中才会有明显的好处。</p>
<h1 id="第4章-注释"><a href="#第4章-注释" class="headerlink" title="第4章 注释"></a>第4章 注释</h1><p>作者认为无需写注释是最完美的。这一点对于业务来说可能是合适的，但是对于开源库来说，还是需要注释来简明扼要地说明函数的行为。</p>
<p>只有代码不会骗人。注释会骗人，文档也会骗人，因为随着时间的推移会过时。</p>
<p>注释不能美化糟糕的代码。假如想要写注释，那么该问问自己代码是不是写得太烂了，需要重构。</p>
<p>用代码来阐述，能用函数或变量时就别用注释。比如一个很长的if表达式，与其用注释来说明，不如将它提取成一个函数，并起个合适的函数名。</p>
<p>好注释：</p>
<ul>
<li>法律信息</li>
<li>提供有用信息的注释</li>
<li>对意图的解释</li>
<li>阐释，和解释的区别在于它是描述性的，便于阅读</li>
<li>警示</li>
<li>Todo注释</li>
</ul>
<p>坏注释：</p>
<ul>
<li>喃喃自语</li>
<li>循规式、多余的注释</li>
<li>误导性、过时的注释</li>
<li>日志式注释</li>
<li>注释掉的代码，现在的代码工具能很快找回来，简洁更重要</li>
<li>不明显的联系。假如注释本身还不够清晰，还需要注释来说明注释，显然这是个坏注释</li>
</ul>
<h1 id="第5章-格式"><a href="#第5章-格式" class="headerlink" title="第5章 格式"></a>第5章 格式</h1><p>好的格式能提高代码的可读性。这里的格式不仅是括号换行之类的问题，还包括文件的代码行数等问题。Go中有gofmt，可以帮助干一些格式的工作，但并没有囊括所有。</p>
<p>垂直格式：</p>
<ul>
<li>短文件通常比长文件易于理解。</li>
<li>源文件名称应当简单且一目了然。</li>
<li>源文件最顶部应该给出最高层次的概念和算法，细节应该往下逐次展开。</li>
<li>源文件中的不同概念，应该用空白行隔开。比如封包声明、导入声明和每个函数之间要有空白行。</li>
<li>源文件中的有联系的概念，应该相互靠近。比如有关系的几个变量。</li>
<li>关系密切相关的概念，应该放在同一个文件中。避免在源文件之间跳转。</li>
<li>注重垂直距离。<ul>
<li>变量声明：变量声明应该尽可能地靠近其使用位置。类或结构体的变量应该统一放在类的顶部或底部，关键是位置要统一。</li>
<li>相关函数：如果某个函数调用到了另外一个，就应该把他们放在一起，而且调用者应该尽可能放在调用者上面。</li>
</ul>
</li>
</ul>
<p>横向格式：</p>
<ul>
<li>一行的字符数不要超出120字符。</li>
</ul>
<p>团队规则：</p>
<ul>
<li>一个团队应该约定一套编码规范。好的代码需要拥有一致和顺畅的风格，这样能减少阅读的复杂度。</li>
</ul>
<h1 id="第6章-对象和数据结构"><a href="#第6章-对象和数据结构" class="headerlink" title="第6章 对象和数据结构"></a>第6章 对象和数据结构</h1><blockquote>
<p>对象和数据结构的区别：对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。</p>
</blockquote>
<p>书中提到的对数据结构的这种说法我是不赞同的，因为数据结构通常也提供有意义的函数，提供抽象。比如很多学过的数据结构，队列、栈、二叉树、红黑树，实际上都是暴露操作数据的函数。作者这里想表达的内容是，应该进行有意义的、更高一层的抽象，将接口定义和底层实现分开。</p>
<p>但是，书中也提到了，暴露操作和暴露数据之间，也各有适用的场景。我们称暴露数据的代码称为过程式代码，暴露操作的代码称为面向对象代码。</p>
<blockquote>
<p>过程式代码便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。</p>
<p>过程式代码难以添加数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。</p>
</blockquote>
<p>其实，我对这里的难点没有特别体会到，感觉两种方式都OK。借助于现在智能的IDE，跳转起来都还挺方便的，修改的工作量似乎也差不多。但是这里有一个点是，假如自己发现用某种做法比较难时，可以想想有没有其他更容易的做法。</p>
<p>什么是德墨忒尔定律，解决了什么问题？</p>
<p>用于解决多个模块过于耦合的问题，是一个为了让模块之间松耦合的有效方法。该定律内容简单来说，是一个模块不应该了解其他模块的底层细节。举个例子，有A, B, C三个类，对应三个实例是objA, objB, objC，假如objA依赖了objB, objB依赖了objC，那么objA应该只关心objB的方法和属性，不应该关心objC的细节，objB在和objC交互后应该将结果封装给objA。其实，在微服务中，也存在这种思想，假设有A, B, C三个服务，A依赖了B，B依赖了C，现在A需要处理下游服务的状态码，它应该只关心B服务返回的状态码，而不需要关心服务C返回的状态码。假如不这么做，假设B有很多个底层服务，那么A就需要关心很多个底层服务了，这会很耦合。</p>
<p>假如是一个结构体有多个层级，访问底层的成员时会用类似<code>a.b.c.d</code>这种方式，这并不被认为违反德墨忒尔定律，因为它很简单清晰。</p>
<h1 id="第7章-错误处理"><a href="#第7章-错误处理" class="headerlink" title="第7章 错误处理"></a>第7章 错误处理</h1><p>主要介绍了Java使用Exception处理错误的方法。在Go中，处理错误一般是逐级传递error。Exception相比于error传递的好处在于，可以不需要逐级传递，在遇到错误时throw exception，在最外层进行try catch处理exception。但是这样做也有坏处，throw的地方会散布于各处。</p>
<p>不管是抛出错误还是异常，多应该给出明确的异常发生的环境说明，方便定位问题。</p>
<p>对错误进行分类、抽象、封装，可以让错误更加清晰。</p>
<p>该章节的一些其他建议和Java比较耦合，比如不返回null。作为一个Gopher，对其缺少共鸣，在Go中是经常会返回nil的，对nil的检查也很常见。</p>
<p>总的来说，错误处理的方式是多样的，不同语言有不同的流派。写过Java的人可能更喜欢Exception的处理方式，之前在一个课程上遇见过在Go中使用Exception来处理异常的，挺hack的。</p>
<p>错误处理的目标应该是尽可能清晰、统一，我认为Go的error处理是符合这一个目标的。虽然逐级处理error有点麻烦，但是这样做可以保证可读性，足够清晰。</p>
<h1 id="第8章-边界"><a href="#第8章-边界" class="headerlink" title="第8章 边界"></a>第8章 边界</h1><p>边界是指自身代码和第三方程序、开放源代码的界限。本章节主要介绍保持软件边界整洁的实践手段和技巧。</p>
<ul>
<li>封装第三方代码。当第三方代码的接口是比较通用的时候，当接入自身系统时就需要一定的转换。为了避免在每一处代码都进行转换，可以对其进行一层封装，屏蔽转换的细节。泛型是避免转换的一种方式，自己写个数据结构封一层也是一种方式。</li>
<li>使用adapter模式使用尚不存在的代码。假如第三方的API的具体定义还不确定，可以先定义一个interface，写上我们预期的行为，此后的开放基于该interface进行开发。当第三方API确定后，定义一个adapter，使用它们的API接口实现我们定义的interface。这样，我们就可以在不被它们API阻塞的情况下完成开发。</li>
</ul>
<h1 id="第9章-单元测试"><a href="#第9章-单元测试" class="headerlink" title="第9章 单元测试"></a>第9章 单元测试</h1><p>保持测试的整洁，测试代码也应该像正式代码一样可维护。</p>
<p>FIRST原则：</p>
<ul>
<li>Fast: 可以快速执行完</li>
<li>Independent: 可以并发执行，无相互依赖</li>
<li>Repeatable: 可以重复执行，无副作用</li>
<li>Self-Validating: 可以自我验证，有意义的校验可以发现问题</li>
<li>Timely: 及时编写，在写正式代码的时候就产生测试代码</li>
</ul>
<h1 id="第10章-类"><a href="#第10章-类" class="headerlink" title="第10章 类"></a>第10章 类</h1><p>单一职责原则：类应该只有一个修改的原则。</p>
<p>为了保证上面这个原则，类应该尽可能小。</p>
<p>内聚：类中的变量尽可能都被每个方法用到。</p>
<p>可以将类拆小，将可能发生联系的方法和变量放到一个类，从而让这个类更内聚。</p>
<p>问题：10.3中举的SQL拆分例子，拆分后的类方法<code>generate()</code>，是怎么work的啊？</p>
<h1 id="第11章-系统"><a href="#第11章-系统" class="headerlink" title="第11章 系统"></a>第11章 系统</h1><p>要系统层级上面的整洁。使用抽象。</p>
<p>将系统的构造与使用分开。假如不分开，测试会有点难写，因为缺少抽象，难以mock。</p>
<p>分开方法：</p>
<ul>
<li>集中在main函数进行构造</li>
<li>工厂：可以在运行的时候调用，但是构造还是由工厂方法自己负责</li>
<li>依赖注入</li>
</ul>
<p>感觉这一章较多知识和Java相关，比如所谓的POJO, Java代理, EJB, Java AOP, AspectJ等。</p>
<p>其中，Java AOP将特定领域的东西横切成面，统一处理的思想。是有点感触的，但是不深。</p>
<p>DSL：领域特定语言，用于描述系统层级的各个领域。感觉和银平大佬推的什么宣言有点类似。</p>
<p>打造一个系统，也可以用保守主义的思想，先打造出一个大致可行的简单方案，不要一上来就进行恢弘的设计。根据后面的需求，有更多输入的情况下，再对系统进行演进。不要过度设计，不要提前恢弘设计。</p>
<h1 id="第12章-迭进"><a href="#第12章-迭进" class="headerlink" title="第12章 迭进"></a>第12章 迭进</h1><p>这一章提到了改进系统设计的实用技巧：</p>
<ol>
<li>运行所有测试</li>
<li>不可重复</li>
<li>表达力</li>
<li>减少重复</li>
</ol>
<p>第一条是改进的基础，第二到第四条是重构中要注意的点。</p>
<p>实际工作中，测试都没有跑起来，后面的几点也无从谈起啊！</p>
<h1 id="第13章-并发编程"><a href="#第13章-并发编程" class="headerlink" title="第13章 并发编程"></a>第13章 并发编程</h1><p>servlet标准模式，是Java的一种web框架，类似于Go的gin框架。提供并发处理http请求的解决方法，让工程师集中集中精力写业务逻辑，不需要关心底层的TCP连接、HTTP协议解析、复用线程、IO异常处理等。</p>
<p>许多Java相关的部分。总的来看，有以下写好并发编程代码的方法：</p>
<ul>
<li>学习并发问题的可能原因：data race；使用了公共资源池，比如线程池。</li>
<li>学习并发技术及类库：自旋锁；mutex；atomic</li>
<li>掌握并发的基本常识<ul>
<li>缩小临界区，减少锁的影响范围</li>
<li>减少共享对象，使用通信的方式（为什么？可能是让读和写更明显了）</li>
</ul>
</li>
</ul>
<h1 id="第14章-逐步改进"><a href="#第14章-逐步改进" class="headerlink" title="第14章 逐步改进"></a>第14章 逐步改进</h1><p>作者说了，案例才是这本书最精华的部分，所以要好好研读，琢磨消化。</p>
<p>派生类：基于基类的类，拥有基类的方法。解决代码重用的问题，DRY。</p>
<p>看了两三次，对于一开始介绍的最终版本没有看懂，有点受打击。先跳过吧，因为这部分内容和Java也关系有点多。</p>
<h1 id="第15章-JUnit内部"><a href="#第15章-JUnit内部" class="headerlink" title="第15章 JUnit内部"></a>第15章 JUnit内部</h1><p>看标题就是和Java相关比较大，可以先抱着粗略的态度看看。</p>
<p>实际看下来，和Java关系不大，能看懂，有收获感。重点看看作者做出某种重构的考量。</p>
<p>但是感觉实际工作中，假如抱着这样的态度去改态度，会累死&#x3D; &#x3D;、除非有契机去推动这样的事情发生。</p>
<h1 id="第16章-重构SerialDate"><a href="#第16章-重构SerialDate" class="headerlink" title="第16章 重构SerialDate"></a>第16章 重构SerialDate</h1><p>作者通过单元测试，发现这个库存在的许多问题。这说明单元测试是挺有用的，可以发现算法问题。对于业务代码，当然也是有用的，但是业务中的测试，会面临许多外部调用的mock。有什么方便的方法去mock业务中的外部调用吗，让测试更容易。</p>
<p>重点看看作者做出某种重构的考量，比如命名、函数拆分、细小改变等。感觉作者这种组织模式很不适合阅读，看起来费劲，所以我只粗略看看。</p>
<h1 id="第17章-味道与启发"><a href="#第17章-味道与启发" class="headerlink" title="第17章 味道与启发"></a>第17章 味道与启发</h1><p>作者在读了一些源代码后，在实践中提出了他积累的一个CheckList。不妨从中看看对自己有感触的部分。</p>
<p>服务编译应该追求一个脚本就可以构建。假如有仓库依赖，建议在README做好相关说明，或者在编译脚本中给出指南。</p>
<p>同理，单元测试也应该追求一个脚本就可以跑完所有单元测试。可以将必要的环境变量等信息封装到脚本中。</p>
<p>DRY原则我们都懂，大佬们也认为这是最重要的一个原则之一。努力践行这个原则，可以提升自己的设计抽象能力。</p>
<p>问题：如何践行DRY原则，有哪些具体的编程方法？</p>
<p>有OO、结构化编程、数据库范式等。</p>
<p>我发现测试不可读的一个原因，是其中存在许多隐式的约定、魔数等坏味道的代码。假如我们对待测试也像业务代码那样认真，就可以提高可读性。</p>
<p>在较高层级放置默认值，这一点比较好。我看了ares有些库，会将默认值放在底层，就不太可读，常常需要跳转好几次才能找到默认值。或者注释也是一种方法。</p>
<p>名称应该说明副作用。这一条比较有感触，自己在工作看到<code>getXXX()</code>的函数，并不一定会想到他会有写操作。用<code>createOrReturnXXX()</code>就表明可能有写操作。</p>
<h1 id="第一遍读完回顾"><a href="#第一遍读完回顾" class="headerlink" title="第一遍读完回顾"></a>第一遍读完回顾</h1><p>时间：2023年2月19日晚上</p>
<p>断断续续读了挺久的这本书，今晚终于读完了。</p>
<p>问题：如何发挥这本书的价值？</p>
<ul>
<li>最重要的是保持匠心，追求代码的整洁</li>
<li>其次，建立这本书的思维导图，心中有个全景图，做一个checkLIst</li>
<li>最后，常常回顾一下这本书，常读常新</li>
</ul>
]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>elastic/go-elasticseach仓库学习笔记</title>
    <url>/2023/09/27/elastic-go-elasticseach/</url>
    <content><![CDATA[<p>仓库地址：<a href="https://github.com/elastic/go-elasticsearch">https://github.com/elastic/go-elasticsearch</a></p>
<p>仓库简介：The official Go client for Elasticsearch</p>
<p>分支：v7.11.0</p>
<h1 id="README-MakeFile"><a href="#README-MakeFile" class="headerlink" title="README &amp; MakeFile"></a>README &amp; MakeFile</h1><p>使用了<a href="https://github.com/gojp/goreportcard">goreportcard</a>对项目的质量进行了分析。</p>
<p>使用了codecov对代码覆盖率进行测试，网站界面用起来还挺舒服的。这个项目的覆盖率有80%+，挺高的。</p>
<p>使用了Github Action对项目进行自动构建编译。</p>
<p>使用MakeFile封装了一系列构建命令，其中有Unit-test和integration-test。它使用了go的条件编译，来区分两种测试。</p>
<p>比如<code>/esutil</code>下的测试代码属于unit-test。它不需要依赖es组件。</p>
<p>比如<code>/estransport</code>下的测试代码属于integration-test。它依赖了es组件，需要在本地先起好es。</p>
<p>发现Makefile还挺强大的，可以节省很多的重复性工作。比如其中的release命令，甚至可以将代码发布到Github的流程自动化。为了方便测试，Makefile也集成了用docker起ES的命令。通过Makefile，也可以很好的实践项目到API文档的输出。</p>
<h1 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h1><p>项目的入口在于<code>elasticsearch.go</code>，它提供了创建Client的函数。另外也有对应的一些_test.go文件，包括example, benchmark, test等。</p>
<p><code>Client</code>包含了两个成员，一个是<code>esapi.API</code>，另一个是<code>estransport.Interface</code>。</p>
<p><code>API</code>: </p>
<ul>
<li><p><code>/esapi/doc.go</code>的文档提供了比较充分的说明。</p>
</li>
<li><p>API是自动根据<a href="https://github.com/elastic/elasticsearch/tree/master/rest-api-spec/src/main/resources/rest-api-spec/api">ES官方client标准</a>生成的，生成代码在&#x2F;internal&#x2F;cmd&#x2F;generate。更牛的是，ES官方还提供了client test，以保证不同语言实现的client都能复用。</p>
</li>
<li><p>API本身是个结构体，成员是函数。API的调用设计，提供了struct和function两种方式。为了实现struct方式的调用，Request定义了Do的method，感觉用起来还挺奇怪的。更倾向于使用function的模式，更紧凑一些。</p>
</li>
</ul>
<p><code>estransport.Interface</code>:</p>
<ul>
<li><p><code>/estransport/doc.go</code>有文档说明。estransport感觉蛮可配置化的，包括重试策略、节点选择、连接池、Logger等。</p>
</li>
<li><p><code>estransport.go</code>: 核心文件。主要实现函数是Perform。</p>
</li>
<li><p><code>logger.go</code>: 实现了日志的采集，其实不仅是日志，其他metrics的埋点也可以在这里做。</p>
</li>
<li><p><code>metrics.go</code>: 实现了metrics的采集。</p>
</li>
<li><p><code>connection.go</code>: 实现了连接池。只有在输入多个URL的时候有效。假如是使用云厂商的，一般会提供一个VIP，云厂商做了负载均衡。</p>
</li>
</ul>
<p><code>NewClient</code>源码阅读收获：</p>
<ul>
<li>默认是使用http.DefaultTransport，该transport没有设置读取header的超时时间，所以假如是客户端返回response慢，那么可能会导致hang住。</li>
</ul>
<p><code>Perform</code>源码阅读收获：</p>
<ul>
<li>为了实现重试，会将request body拷贝一份，因为http请求发送出去后就没了。http内置了GetBody函数可实现多次读取body。</li>
<li>默认超时是不会自动重试的，需要配置enableRetryOnTimeout为true才会。为什么这么设计？</li>
<li>为了实现并发访问，很多地方使用了Lock来实现的，包括对pool, metrics等字段的访问。</li>
<li>使用sleep来实现退避重试。</li>
<li>还是使用transport来发起请求，并在发起请求后使用logger来记录请求情况，用户可以用该logger记录日志、打点等。</li>
</ul>
<p><code>Connection</code>源码阅读收获：</p>
<ul>
<li>创建连接池只需要少量参数（host, username, password）。当真正发起请求前，需要将这些参数的绑定到Request中，以便发起http请求。</li>
<li>Next用于获取连接，OnSuccess用于归还成功的连接，OnFailure用于归还失败的连接。</li>
<li>实现了两种连接池，一种是单URL地址的连接池，另一种是多URL地址的连接池。后者相比于前者多了一个负载均衡策略，代码中定义了Selector来抽象。</li>
<li>singleConnectionPool其实只会返回自己的URL，没有建立连接的概念。这里复用连接是依赖底层的http client实现的。</li>
</ul>
]]></content>
      <tags>
        <tag>编程</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>HrbustOJ 2375: easy math problem</title>
    <url>/2018/03/28/0/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&a=showProblem&problem_id=2375">传送门</a></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目需要我们求i的3次方(1&lt;&#x3D; i &lt;&#x3D; n)的和，由于n很大，无法暴力算。</p>
<p>一般这种题的套路是利用二项式定理+求导，由于求的是i的3次方，所以我们可以通过连续”二项式方程左右两边求导乘x”3次，然后令x&#x3D;1来构造出题目所求的式子，然后通过快速幂计算即可。<br>记得CF上有一道类似的题，从3变成了k，顺便给出<a href="http://codeforces.com/problemset/problem/932/E">CF932E</a>。</p>
<p>由于不会LaTeX，所以无法贴公式，留坑。。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>180329训练赛题解</title>
    <url>/2018/03/29/0/</url>
    <content><![CDATA[<p>训练赛套题链接：<a href="http://codeforces.com/gym/101755">2018, XI Samara Regional Intercollegiate Programming Contest</a></p>
<p>感觉题目难度很友好，官方说是给蓝紫名选手做的。</p>
<h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><p>据说是水题，略。</p>
<h1 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h1><p>队友做的，留坑待填。</p>
<h1 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h1><p>这种区间求最优解的问题，一种套路就是排序+贪心。具体对这道题来说，即按照右边界、左边界从小到大排序，然后贪心地取右边界的点，同时跳过左边界在该点左边的那些区间，时间复杂度是O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii a, pii b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y == b.y)</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mark, n, ans;</span><br><span class="line">pii a[N];</span><br><span class="line">vi v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">        <span class="built_in">sort</span>(a, a+n, cmp);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            mark = a[i].y;</span><br><span class="line">            ans++;</span><br><span class="line">            v.<span class="built_in">push_back</span>(mark);</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; a[i].x &lt;= mark) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, v[i], i==v.<span class="built_in">size</span>()<span class="number">-1</span>?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h1><p>不会，留坑。</p>
<h1 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h1><p>假如两个字符串相同，那么输出“YES”。</p>
<p>否则，从左往右找到第一个不同，然后从右往左找到第一个不同，翻转这个区间的字符串，判断是否能让两个字符串相同。可以输出”YES”，不可以输出”NO”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> l, r, len, j;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s &gt;&gt; t) &#123;</span><br><span class="line">        len = s.<span class="built_in">length</span>();</span><br><span class="line">        l = r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i] != t[i]) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(s[i] != t[i]) &#123;</span><br><span class="line">                r = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                j = r - i + l;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != t[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F题"><a href="#F题" class="headerlink" title="F题"></a>F题</h1><p>不会，留坑。</p>
<h1 id="G题"><a href="#G题" class="headerlink" title="G题"></a>G题</h1><p><del>不会，留坑。</del><br><a href="https://hyzgh.github.io/blog/2018/04/02/Gym101755G">传送门</a></p>
<h1 id="H题"><a href="#H题" class="headerlink" title="H题"></a>H题</h1><p>这道题主要的难题在于ban掉怪兽能攻击到的区域，赛后经大佬指点，学会了多源bfs这种操作，新技能get :)</p>
<p>由n*m&lt;&#x3D;200000，可得1 &lt;&#x3D; n &lt;&#x3D; 200000，1 &lt;&#x3D; ｍ &lt;&#x3D; 200000，所以不能开普通的二维数组，要开vector。比赛的时候没用vector，而是弄了个id来处理，写得好丑(:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, n, m, dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, vis[N], ban[N], sx, sy, gx, gy, d, dis[N], b[N];</span><br><span class="line">string g[N];</span><br><span class="line">vector&lt;pii&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(pii t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.x * m + t.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多源bfs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">banbfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;pii&gt; que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">pii</span>(v[i].x, v[i].y));</span><br><span class="line">        vis[<span class="built_in">id</span>(v[i])] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="built_in">id</span>(v[i])] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        pii u = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="built_in">id</span>(u)] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = u.x + dx[i], ny = u.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nx, ny) &amp;&amp; !vis[<span class="built_in">id</span>(nx, ny)]) &#123;</span><br><span class="line">                vis[<span class="built_in">id</span>(nx, ny)] = <span class="number">1</span>;</span><br><span class="line">                ban[<span class="built_in">id</span>(nx, ny)] = <span class="number">1</span>;</span><br><span class="line">                b[<span class="built_in">id</span>(nx, ny)] = b[<span class="built_in">id</span>(u)] - <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">pii</span>(nx, ny));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">banbfs</span>();</span><br><span class="line">    queue&lt;pii&gt; que;</span><br><span class="line">    <span class="keyword">if</span>(!ban[<span class="built_in">id</span>(sx, sy)])</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">pii</span>(sx, sy));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="built_in">id</span>(<span class="built_in">pii</span>(sx, sy))] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="built_in">id</span>(sx, sy)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        pii u = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u.x == gx &amp;&amp; u.y == gy) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = u.x + dx[i], ny = u.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nx, ny) &amp;&amp; !vis[<span class="built_in">id</span>(nx, ny)] &amp;&amp; !ban[<span class="built_in">id</span>(nx, ny)]) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">pii</span>(nx, ny));</span><br><span class="line">                vis[<span class="built_in">id</span>(nx, ny)] = <span class="number">1</span>;</span><br><span class="line">                dis[<span class="built_in">id</span>(<span class="built_in">pii</span>(nx, ny))] = dis[<span class="built_in">id</span>(u)] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[<span class="built_in">id</span>(<span class="built_in">pii</span>(gx, gy))]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; d) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; g[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                    sx = i, sy = j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">                    v.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(i, j));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">                    gx = i, gy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I题"><a href="#I题" class="headerlink" title="I题"></a>I题</h1><p>给了一些边，每条边最多只能用一次，现在需要判断所有的边能最多能组成多少的平行四边形。根据平行四边形的性质，答案就是边长相等的边的对数除以2 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], n, ans, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            a[d]++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            ans += a[i]/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="J题"><a href="#J题" class="headerlink" title="J题"></a>J题</h1><p>不会，留坑。</p>
<h1 id="K题"><a href="#K题" class="headerlink" title="K题"></a>K题</h1><p>不会，留坑。</p>
<h1 id="L题"><a href="#L题" class="headerlink" title="L题"></a>L题</h1><p>首先开26个set，将相同字母的位置压进同一个set里面。</p>
<p>当push 某个字母时，就在这个字母的set里面查找第一个大于当前位置的位置。假如找不到，那么就是NO，假如找到了，那么就是YES。不管是YES还是NO，都要先把旧位置放进栈里面，然后更新当前位置（NO时就更新为INF）。</p>
<p>当pop某个字母时，就将当前位置更新为栈顶元素，判断栈顶元素是否为INF，假如为INF，那就是NO，否则为YES。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="type">char</span> op[<span class="number">9</span>], c;</span><br><span class="line"><span class="type">int</span> m, t;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; se[<span class="number">29</span>];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">            se[s[i]-<span class="string">&#x27;a&#x27;</span>].<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="type">int</span> pp = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                c = <span class="built_in">getchar</span>();</span><br><span class="line">                t = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                set&lt;<span class="type">int</span>&gt;::iterator it = se[t].<span class="built_in">upper_bound</span>(pp);</span><br><span class="line">                sta.<span class="built_in">push</span>(pp);</span><br><span class="line">                <span class="keyword">if</span>(it != se[t].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    pp = *it;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pp = INF;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pp = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(pp == INF)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="M题"><a href="#M题" class="headerlink" title="M题"></a>M题</h1><p>这道题要分情况讨论。</p>
<ol>
<li>三个字符串完全相同，Ambiguous。</li>
<li>存在两个字符串的差异值大于2，Impossible。</li>
<li>然后两两枚举不同的位置，再与剩余的另一个字符串diff，假如差异值大于1，那就不是可行解，否则时可行解。根据可行解的个数再分三种情况即可。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">string s1, s2, s3, t;</span><br><span class="line">vi v[<span class="number">3</span>];</span><br><span class="line">set&lt;string&gt; se;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">int</span> len, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3) &#123;</span><br><span class="line">        v[<span class="number">0</span>].<span class="built_in">clear</span>();</span><br><span class="line">        v[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">        v[<span class="number">2</span>].<span class="built_in">clear</span>();</span><br><span class="line">        len = s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])</span><br><span class="line">                v[<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(s2[i] != s3[i])</span><br><span class="line">                v[<span class="number">1</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s3[i])</span><br><span class="line">                v[<span class="number">2</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(v[i].<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; v[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; v[<span class="number">2</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Ambiguous\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            se.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                t = s1;</span><br><span class="line">                t[v[<span class="number">0</span>][i]] = s2[v[<span class="number">0</span>][i]];</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                    <span class="keyword">if</span>(t[j] != s3[j])</span><br><span class="line">                        cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= <span class="number">1</span>)</span><br><span class="line">                    se.<span class="built_in">insert</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">1</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                t = s2;</span><br><span class="line">                t[v[<span class="number">1</span>][i]] = s3[v[<span class="number">1</span>][i]];</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                    <span class="keyword">if</span>(t[j] != s1[j])</span><br><span class="line">                        cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= <span class="number">1</span>)</span><br><span class="line">                    se.<span class="built_in">insert</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">2</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                t = s3;</span><br><span class="line">                t[v[<span class="number">2</span>][i]] = s1[v[<span class="number">2</span>][i]];</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                    <span class="keyword">if</span>(t[j] != s2[j])</span><br><span class="line">                        cnt++;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= <span class="number">1</span>)</span><br><span class="line">                    se.<span class="built_in">insert</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(se.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; *se.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(se.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Ambiguous\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Gym 101755G: Underpalindromity</title>
    <url>/2018/04/02/0/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://codeforces.com/gym/101755/problem/G">Gym101755G</a></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先来考虑一下这个样例：<br>8 4<br>8 8 7 6 9 5 8 2</p>
<p>我们列出所有对答案产生贡献的元素对：</p>
<p>1-4<br>2-3, 2-5<br>3-2, 3-4, 3-6<br>4-1, 4-3, 4-5, 4-7<br>…</p>
<p>经过观察，我们发现对于某一个元素，它的贡献是有规律的。令i表示该元素的下标，则该元素对于[i-k+1, i+k-1]这个区间，每隔两个数就有一次贡献。因此，我们就将n*n个区间的贡献值转化为了n个点的贡献值。举个例子，上面那个样例中，第2个元素的贡献就是(8-7) + (9-8)。</p>
<p>为了能够快速查询某一点的贡献值，我们必须用到某种数据结构来优化，对于区间问题，容易想到用线段树或者树状数组。为了能够用数据结构优化，我们需要将数组从小到大排序。排序后，当我们计算某一点的贡献时，这个点对于比这个点小的元素的贡献。举个例子，上面第2个元素的贡献就是(8-7)，至于(9-8)，就留给第5个元素才计算。因此，树状数组需要的维护的东西有元素个数以及区间和。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok puts(<span class="string">&quot;ok&quot;</span>);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">ll sum[<span class="number">4</span>][N], n, k, ans;</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += sum[id][p];</span><br><span class="line">        p -= p &amp; -p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n) &#123;</span><br><span class="line">        sum[id][p] += v;</span><br><span class="line">        p += p &amp; -p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].x);</span><br><span class="line">            a[i].y = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> id = a[i].y &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> r = a[i].y + k - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = a[i].y - k + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//边界情况的处理</span></span><br><span class="line">            <span class="keyword">if</span>(l &lt; <span class="number">1</span>)</span><br><span class="line">                l = k - a[i].y + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &gt; n)</span><br><span class="line">                r = <span class="number">2</span>*n - a[i].y - k + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算某点对答案的贡献</span></span><br><span class="line">            <span class="keyword">if</span>(k &amp; <span class="number">1</span>)</span><br><span class="line">                ans += <span class="number">1LL</span> * a[i].x * (<span class="built_in">query</span>(r, id+<span class="number">2</span>) - <span class="built_in">query</span>(l<span class="number">-1</span>, id+<span class="number">2</span>)) - (<span class="built_in">query</span>(r, id) - <span class="built_in">query</span>(l<span class="number">-1</span>, id));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += <span class="number">1LL</span> * a[i].x * (<span class="built_in">query</span>(r, (id+<span class="number">2</span>)^<span class="number">1</span>) - <span class="built_in">query</span>(l<span class="number">-1</span>, (id+<span class="number">2</span>)^<span class="number">1</span>)) - (<span class="built_in">query</span>(r, id^<span class="number">1</span>) - <span class="built_in">query</span>(l<span class="number">-1</span>, id^<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用该点更新树状数组</span></span><br><span class="line">            <span class="built_in">add</span>(a[i].y, a[i].x, id);</span><br><span class="line">            <span class="built_in">add</span>(a[i].y, <span class="number">1</span>, id + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>动物朋友</title>
    <url>/2018/04/18/0/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p>略</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>首先构建AC自动机，于是题目转化为：在自动机上走L步，不碰到任何一个成功匹配的节点。<br>令DP[u][L]表示当前状态位于状态u，还需要走L步，满足条件的概率，记忆化搜索即可。</p>
</blockquote>
<p>这道题的思路官方题解已经写得很清楚了，不再赘述。<br>直接上代码，代码中注释蛮清楚的。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, L, n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">109</span>], c[<span class="number">109</span>];</span><br><span class="line"><span class="type">double</span> p[<span class="number">109</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acAuto</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">2009</span>][<span class="number">128</span>], fail[<span class="number">2009</span>], root, L;</span><br><span class="line">    <span class="type">bool</span> end[<span class="number">2009</span>];</span><br><span class="line">    <span class="type">double</span> dp[<span class="number">2009</span>][<span class="number">109</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立新节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            next[L][i] = <span class="number">-1</span>;</span><br><span class="line">        end[L] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> L++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立Trie</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i]] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i]] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建AC自动机的fail数组，或者称为next数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>)</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>)</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记忆化搜索实现DP，now表示现在的状态，L表示在AC自动机还需要走的步数</span></span><br><span class="line">    <span class="comment">//初始状态为AC自动机的root节点，表示一步都没走，一个字符都没有</span></span><br><span class="line">    <span class="comment">//边界条件为L=0，表示走完了，这时成功的概率是1</span></span><br><span class="line">    <span class="comment">//否则，就需要枚举拼接在当前状态后的字符，并判断拼接后是否合法（合法就是全部模式串都不匹配），增加贡献值</span></span><br><span class="line">    <span class="comment">//DP[u][L]，其中u表示状态，L表示步数，即状态数为uL，状态转移是在AC自动机上跑的，看跳转次数而定，不大，所以总时间复杂度为O(uL)</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[now][L] != <span class="number">-1</span>) <span class="keyword">return</span> dp[now][L];</span><br><span class="line">        <span class="keyword">if</span>(L == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp  = next[now][c[i]];</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">pipei</span>(temp))</span><br><span class="line">                ans += p[i] * <span class="built_in">dfs</span>(temp, L<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[now][L] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若有一个模式串匹配，返回1，若都不匹配，返回0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pipei</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(now != root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(end[now])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            now = fail[now];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2009</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= L; j++)</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Aonyx cinerea\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; %c%lf&quot;</span>, &amp;c[i], &amp;p[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6f\n&quot;</span>, ac.<span class="built_in">solve</span>(L));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6031: Innumerable Ancestors</title>
    <url>/2018/04/21/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一棵树，询问两个点集间的LCA最大深度。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先，我们通过dfs+ST表进行预处理，让每次LCA的查询只要O(1)就可以完成。接着，利用以下这个性质：</p>
<blockquote>
<p>根据 DFS 序，若两个点的 DFS 序越接近，则两个点的 LCA 的深度越大。</p>
</blockquote>
<p>我们可以先将其中一个点集B中的元素按dfs序排序，然后枚举另一个点集A的元素，不妨设为a，利用二分查找在点集B中查找到与a的dfs序最相近的两个元素，不妨设为b1，b2，最后LCA(a, b1) 的深度和 LCA(a, b2)的深度就是可能的答案，取max即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************/</span></span><br><span class="line"><span class="comment">// LCA在线算法--dfs+ST算法</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> F[<span class="number">2</span>*N];        <span class="comment">//欧拉序列, 长度为2*n-1, 下标从1开始</span></span><br><span class="line"><span class="type">int</span> rmq[<span class="number">2</span>*N];    <span class="comment">//欧拉序列对应的深度序列</span></span><br><span class="line"><span class="type">int</span> P[N];        <span class="comment">//P[i]表示点i在F中第一次出现的位置</span></span><br><span class="line"><span class="type">int</span> tot, head[N], cnt, root, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, next;</span><br><span class="line">&#125;edge[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//加边, 无向边需要加两次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[tot].to = v;</span><br><span class="line">    edge[tot].next = head[u];</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树前的初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> pre, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">    F[++cnt] = u;</span><br><span class="line">    rmq[cnt] = dep;</span><br><span class="line">    P[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u, dep+<span class="number">1</span>);</span><br><span class="line">        F[++cnt] = u;		</span><br><span class="line">        rmq[cnt] = dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建ST表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span>&#123;</span><br><span class="line">    <span class="type">int</span> mm[<span class="number">2</span>*N], dp[<span class="number">2</span>*N][<span class="number">20</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, root, <span class="number">0</span>);</span><br><span class="line">        mm[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            mm[i] = (i&amp;(i<span class="number">-1</span>)) == <span class="number">0</span> ? mm[i<span class="number">-1</span>]+<span class="number">1</span> : mm[i<span class="number">-1</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= mm[<span class="number">2</span> * n - <span class="number">1</span>]; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>)) &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">                dp[i][j] = rmq[dp[i][j<span class="number">-1</span>]] &lt; rmq[dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]] ?</span><br><span class="line">                    dp[i][j<span class="number">-1</span>] : dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        a = P[a], b = P[b];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="type">int</span> k = mm[b-a+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> F[rmq[dp[a][k]] &lt;= rmq[dp[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]] ?</span><br><span class="line">            dp[a][k] : dp[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, u, v, ta, tb, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P[a] &lt; P[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P[b[mid]] &gt;= P[val])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">addedge</span>(u, v);</span><br><span class="line">            <span class="built_in">addedge</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ta);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ta; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tb);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tb; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b+i);</span><br><span class="line">            <span class="built_in">sort</span>(b, b + tb, cmp);</span><br><span class="line">            <span class="type">int</span> ans = -INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ta; i++) &#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="number">-1</span>, r = tb - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l + <span class="number">1</span> != r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(mid, a[i]))</span><br><span class="line">                        r = mid;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        l = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> rr = r;</span><br><span class="line">                l = <span class="number">0</span>, r = tb;</span><br><span class="line">                <span class="keyword">while</span>(l + <span class="number">1</span> != r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(mid, a[i]))</span><br><span class="line">                        r = mid;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        l = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> ll = l;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, rmq[P[st.<span class="built_in">query</span>(a[i], b[ll])]]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, rmq[P[st.<span class="built_in">query</span>(a[i], b[rr])]]);</span><br><span class="line">                <span class="comment">//printf(&quot;t: %d\n&quot;, ans);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>二分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2778: DNA Sequence</title>
    <url>/2018/04/21/1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求构造不含m(0 &lt;&#x3D; m &lt;&#x3D; 10)个模式串的长度为n(1 &lt;&#x3D; n &lt;&#x3D; 2000000000)的字符串的方案数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先用m个模式串构造AC自动机，这里需要注意的是，不仅要把字符串最后一个字符所在的那一点标记为不合法状态，还需要把其他能转移到该点的节点都标记为不合法状态。然后，问题就转化为了从root出发，走了n步，这n步都避开不合法状态的方案数。设AC自动机的节点个数为L，我们可以构造一个L*L的邻接矩阵，mat[i][j]代表i到j的合法方案数。则mat矩阵的n次幂就表示走了n次的方案数。由于n很大，所以要用矩阵快速幂优化。这里要注意的是，每次循环都要将不合法的项置0，否则，有可能会多算。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod =    <span class="number">100000</span>;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="type">int</span> n, mm;</span><br><span class="line"><span class="type">char</span> s[<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acAuto</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">109</span>][<span class="number">4</span>], fail[<span class="number">109</span>], L, root;</span><br><span class="line">    ll mat[<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line">    <span class="type">bool</span> end[<span class="number">109</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">        m[<span class="string">&#x27;T&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">        m[<span class="string">&#x27;G&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            next[L][i] = <span class="number">-1</span>;</span><br><span class="line">        end[L] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> L++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = m[s[i]];</span><br><span class="line">            <span class="keyword">if</span>(next[now][j] == <span class="number">-1</span>)</span><br><span class="line">                next[now][j] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>)</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span> mat);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="type">int</span> now = i, flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != root) &#123;</span><br><span class="line">                <span class="keyword">if</span>(end[now]) flag = <span class="literal">true</span>;</span><br><span class="line">                now = fail[now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                end[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">                mat[i][next[i][j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ll t[<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line">        ll t1[<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line">        ll t2[<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">            t[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">                <span class="keyword">if</span>(end[j] == <span class="literal">true</span>)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">                        mat[i][j] = t[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(t1, t, <span class="keyword">sizeof</span> t);</span><br><span class="line">                <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; L; k++)</span><br><span class="line">                            (t[i][j] += t1[i][k] * mat[k][j]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(t2, mat, <span class="keyword">sizeof</span> mat);</span><br><span class="line">            <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span> mat);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; L; k++)</span><br><span class="line">                        (mat[i][j] += t2[i][k] * t2[k][j]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">                mat[i][j] = t[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">buildMatrix</span>();</span><br><span class="line">        <span class="built_in">ksm</span>(n);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">            (ans += mat[<span class="number">0</span>][j]) %= mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;mm, &amp;n)) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; mm; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">solve</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>计数</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 900E: Maximum Questions</title>
    <url>/2018/04/29/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个长度为n（1 ≤ <em>n</em> ≤ 100000）的字符串，这个字符串只包含‘a’，’b’，‘?’三种字符，其中’?’可以变成‘a’或‘b’。现在需要求这个字符串里包含最多个长度为m（m &lt;&#x3D; n)的字符串时的最小转变次数是多少，需要注意的是两个长度为m的字符串不能重叠。这个长度为m的字符串的构造规则是ababab…即奇数位为a，偶数位为b。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看完题意，容易发现应该用DP来写。但是，怎么判断某一个长度为m的子串是否为合法串以及构成合法串所需的花费呢？这需要我们<strong>用前缀和分奇偶统计a，b出现的次数</strong>，然后就可以在O(1)的时间判断了。接着，进行DP，dp[i].cost 表示前面i个字符构成最多合法串时的最小花费，dp[i].ma表示前面i个字符构成最多合法串的个数。dp[i] 可以由dp[i-1]或dp[i-m]转移过来，转移的条件是构成的合法串更多或者构成的合法串一样多但是花费更少。最后，dp[n].cost 即为答案。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N], d[N], n, m;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> ma, cost;</span><br><span class="line">&#125;dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; s &gt;&gt; m) &#123;</span><br><span class="line">        s = <span class="string">&#x27;0&#x27;</span> + s;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="comment">//按照奇偶下标统计a以及?出现的次数，存储到a[]</span></span><br><span class="line">        <span class="comment">//按照奇偶下标统计b以及?出现的次数，存储到b[]</span></span><br><span class="line">        <span class="comment">//统计?出现的次数，存储到c[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            c[i] = c[i<span class="number">-1</span>] + (s[i] == <span class="string">&#x27;?&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                a[i] = a[i<span class="number">-2</span>] + (s[i] == <span class="string">&#x27;?&#x27;</span> || s[i] == <span class="string">&#x27;a&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                b[i] = b[i<span class="number">-2</span>] + (s[i] == <span class="string">&#x27;?&#x27;</span> || s[i] == <span class="string">&#x27;b&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i] = (s[i] == <span class="string">&#x27;?&#x27;</span> || s[i] == <span class="string">&#x27;a&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                b[i] = (s[i] == <span class="string">&#x27;?&#x27;</span> || s[i] == <span class="string">&#x27;b&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断以i结尾的字符串是否有可能合法，假如有可能，d[]为花费，假如不可能，d[]为-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> ta = a[i] - a[<span class="built_in">max</span>(<span class="number">0</span>, i - m - <span class="number">1</span>)];</span><br><span class="line">                <span class="type">int</span> tb = <span class="built_in">max</span>(<span class="number">0</span>, b[i<span class="number">-1</span>] - b[<span class="built_in">max</span>(<span class="number">0</span>, i - m)]);</span><br><span class="line">                <span class="keyword">if</span>(ta &gt;= (m+<span class="number">1</span>)/<span class="number">2</span> &amp;&amp; tb &gt;= m/<span class="number">2</span>)</span><br><span class="line">                    d[i] = c[i] - c[i-m];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> ta = a[i<span class="number">-1</span>] - a[<span class="built_in">max</span>(<span class="number">0</span>, i - m - <span class="number">1</span>)];</span><br><span class="line">                <span class="type">int</span> tb = b[i] - b[i - m];</span><br><span class="line">                <span class="keyword">if</span>(ta &gt;= (m+<span class="number">1</span>)/<span class="number">2</span> &amp;&amp; tb &gt;= m/<span class="number">2</span>)</span><br><span class="line">                    d[i] = c[i] - c[i-m];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">//dp[i]可以由dp[i-m]以及dp[i-1]转移过来，更优的标准是凑出更多的合法串或者让一样多的合法串花费更少</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] == <span class="number">-1</span>)</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[i-m].ma + <span class="number">1</span> &gt; dp[i<span class="number">-1</span>].ma || (dp[i-m].ma + <span class="number">1</span> == dp[i<span class="number">-1</span>].ma &amp;&amp; dp[i-m].cost + d[i] &lt; dp[i<span class="number">-1</span>].cost))</span><br><span class="line">                dp[i].ma = dp[i-m].ma + <span class="number">1</span>, dp[i].cost = dp[i-m].cost + d[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[len<span class="number">-1</span>].cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 967C: Stairs and Elevators</title>
    <url>/2018/04/30/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>题意很简单，略:)</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先注意到楼梯、电梯是垂直连通整栋楼的，所以，我们没必要多次走楼梯或乘坐电梯，最多只要一次。因此，我们可以找离出发点y1最近的两个楼梯和两个电梯，这可以通过二分来实现，然后分别计算时间，取min即可。需要注意的是，楼层相同时不需要走楼梯或乘坐电梯。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cl, ce, v, a[N], b[N], q, x1, y_1, x2, y2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; cl &gt;&gt; ce &gt;&gt; v) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cl; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ce; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y_1, &amp;x2, &amp;y2);</span><br><span class="line">            <span class="keyword">if</span>(x1 == x2) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">abs</span>(y_1 - y2));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ans = INF;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">lower_bound</span>(a, a+cl, y_1) - a;</span><br><span class="line">            <span class="keyword">if</span>(p != cl)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a[p] - y_1) + <span class="built_in">abs</span>(x2 - x1) + <span class="built_in">abs</span>(a[p] - y2));</span><br><span class="line">            <span class="keyword">if</span>(--p &gt;= <span class="number">0</span>)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a[p] - y_1) + <span class="built_in">abs</span>(x2 - x1) + <span class="built_in">abs</span>(a[p] - y2));</span><br><span class="line">            p = <span class="built_in">lower_bound</span>(b, b+ce, y_1) - b;</span><br><span class="line">            <span class="keyword">if</span>(p != ce)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(b[p] - y_1) + (<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span>*<span class="built_in">abs</span>(x2 - x1) / v) + <span class="built_in">abs</span>(b[p] - y2));</span><br><span class="line">            <span class="keyword">if</span>(--p &gt;= <span class="number">0</span>)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(b[p] - y_1) + (<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span>*<span class="built_in">abs</span>(x2 - x1) / v) + <span class="built_in">abs</span>(b[p] - y2));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 967D: Resource Distribution</title>
    <url>/2018/04/30/1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>略</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设两种服务所需服务器数量分别为w1、w2，对应下限分别为p1、p2。假如p1 &gt; p2，那么，我们应该将“优质”的服务器优先分给第一种服务，然后再将剩余的服务器分给第二种服务。并且，为了满足第二种服务，p1应该越大越好。因此，排序后，贪心for两次就行了。这道题的关键是要意识到<strong>“优质”服务器应连续分给某一种服务，而不能间断着分</strong>。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x1, x2, p;</span><br><span class="line">vi v[<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val, id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">ceil</span>(<span class="number">1.0</span> * x1 / mid);</span><br><span class="line">    <span class="keyword">if</span>(t &lt;= a[p - mid + <span class="number">1</span>].val)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; x2) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].val);</span><br><span class="line">            a[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        v[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">        v[<span class="number">2</span>].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">ceil</span>(<span class="number">1.0</span> * x2 / i);</span><br><span class="line">            p = n - i;</span><br><span class="line">            <span class="keyword">if</span>(a[p + <span class="number">1</span>].val &gt;= t) &#123;</span><br><span class="line">                <span class="type">int</span> l;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = p; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                        l = i;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d %d\n&quot;</span>, l, n - p);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = p; i &gt;= p - l + <span class="number">1</span>; i--)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i].id, i == p - l + <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = p + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i].id, i == n ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(x1, x2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">ceil</span>(<span class="number">1.0</span> * x2 / i);</span><br><span class="line">            p = n - i;</span><br><span class="line">            <span class="keyword">if</span>(a[p + <span class="number">1</span>].val &gt;= t) &#123;</span><br><span class="line">                <span class="type">int</span> l;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = p; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                        l = i;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d %d\n&quot;</span>, n - p ,l);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = p + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i].id, i == n ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = p; i &gt;= p - l + <span class="number">1</span>; i--)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i].id, i == p - l + <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 967E: Big Secret</title>
    <url>/2018/05/01/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组b，问存不存在这些数的一个排列，使得这些数构造出来的另一个数组a严格上升。ai等于b数组前i个元素的异或值。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>假如数组b中有一些值为1的元素，那么某个1前面应该有偶数个奇数，否则构造出来的a数组就会下降。同理，假如数组b中有一些值为[2^k, 2^(k+1))的元素，那么某个值为[2^k, 2^(k+1))的元素前面应该有偶数个值大于2^(k+1) 且二进制形式在第k位值为1的元素，否则，构造出来的a数组也会下降。因此，我们可以通过前导0的个数给b数组中的元素分组，然后，在<strong>符合插入条件的情况</strong>下，前导0位数多的元素优先插入即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; ans;</span><br><span class="line">vector&lt;ll&gt; v[<span class="number">60</span>];</span><br><span class="line">ll n, d, t;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">59</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                <span class="keyword">if</span>(d &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    v[j].<span class="built_in">push_back</span>(d);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; flag; j++) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;&gt; i &amp; <span class="number">1</span> || v[i].<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(v[i].<span class="built_in">back</span>());</span><br><span class="line">                t ^= v[i].<span class="built_in">back</span>();</span><br><span class="line">                v[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%I64d%c&quot;</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>180429华中科技大学程序设计竞赛题解</title>
    <url>/2018/05/02/0/</url>
    <content><![CDATA[<p>题解按AC数降序排列。</p>
<h1 id="J题：Various-Tree"><a href="#J题：Various-Tree" class="headerlink" title="J题：Various Tree"></a>J题：<a href="https://www.nowcoder.com/acm/contest/106/J">Various Tree</a></h1><p>简单bfs。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">39</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> vis[N];</span><br><span class="line">    <span class="type">int</span> dis[N];</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> uu = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(uu == v) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[v]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uu + <span class="number">1</span> &lt; N &amp;&amp; !vis[uu + <span class="number">1</span>]) &#123;</span><br><span class="line">            dis[uu + <span class="number">1</span>] = dis[uu] + <span class="number">1</span>;</span><br><span class="line">            vis[uu + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(uu + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uu - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !vis[uu - <span class="number">1</span>]) &#123;</span><br><span class="line">            dis[uu - <span class="number">1</span>] = dis[uu] + <span class="number">1</span>;</span><br><span class="line">            vis[uu - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(uu - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uu + cnt[uu] &lt; N &amp;&amp; !vis[uu + cnt[uu]]) &#123;</span><br><span class="line">            dis[uu + cnt[uu]] = dis[uu] + <span class="number">1</span>;</span><br><span class="line">            vis[uu + cnt[uu]] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(uu + cnt[uu]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uu - cnt[uu] &gt;= <span class="number">0</span> &amp;&amp; !vis[uu - cnt[uu]]) &#123;</span><br><span class="line">            dis[uu - cnt[uu]] = dis[uu] + <span class="number">1</span>;</span><br><span class="line">            vis[uu - cnt[uu]] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(uu - cnt[uu]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = i;</span><br><span class="line">        <span class="keyword">while</span>(t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t &amp; <span class="number">1</span>)</span><br><span class="line">                cnt[i]++;</span><br><span class="line">            t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">        <span class="built_in">bfs</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="K题：Walking-in-the-Forest"><a href="#K题：Walking-in-the-Forest" class="headerlink" title="K题：Walking in the Forest"></a>K题：<a href="https://www.nowcoder.com/acm/contest/106/K">Walking in the Forest</a></h1><p>简单二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k, n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    ll sum = LINF, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum + a[i] &gt; mid)</span><br><span class="line">            sum = a[i], cnt++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;n)) &#123;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        ll l = <span class="number">0</span>, r = <span class="number">10000000000</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B题：Beautiful-Trees-Cutting"><a href="#B题：Beautiful-Trees-Cutting" class="headerlink" title="B题：Beautiful Trees Cutting"></a>B题：<a href="https://www.nowcoder.com/acm/contest/106/B">Beautiful Trees Cutting</a></h1><p>简单数学题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ll ans, m, n;</span><br><span class="line">vi v;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            (ans *= a) %= mod;</span><br><span class="line">        (a *= a) %= mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; m &gt;&gt; s) &#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>((s[i] - <span class="string">&#x27;0&#x27;</span>) % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">            (ans += <span class="built_in">ksm</span>(<span class="number">2</span>, v[i])) %= mod;</span><br><span class="line">        (ans *= <span class="built_in">ksm</span>(<span class="number">2</span>, n * m) - <span class="number">1</span>) %= mod;</span><br><span class="line">        (ans *= <span class="built_in">ksm</span>(<span class="built_in">ksm</span>(<span class="number">2</span>, n) - <span class="number">1</span>, mod - <span class="number">2</span>)) %= mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F题：Sorting-Trees"><a href="#F题：Sorting-Trees" class="headerlink" title="F题：Sorting Trees"></a>F题：<a href="https://www.nowcoder.com/acm/contest/106/F">Sorting Trees</a></h1><p>简单思维题。之前在Codejam上做过在k &#x3D; 2情况下的<a href="https://codejam.withgoogle.com/2018/challenges/00000000000000cb/dashboard/00000000000079cb">一道题</a>，这道题算是对那道题的推广。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">vi v[N];</span><br><span class="line"><span class="type">int</span> n, k, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span> a);</span><br><span class="line">            <span class="built_in">sort</span>(b, b + n);</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == n)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            v[i % k].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                b[i + j * k] = v[i][j];</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C题：Professional-Manager"><a href="#C题：Professional-Manager" class="headerlink" title="C题：Professional Manager"></a>C题：<a href="https://www.nowcoder.com/acm/contest/106/C">Professional Manager</a></h1><p>留坑待补。</p>
]]></content>
  </entry>
  <entry>
    <title>CF 975E: Hag&#39;s Khashba</title>
    <url>/2018/05/04/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个凸多边形，在两个钉子（位置在凸多边形的两个顶点上）的作用下，固定在了墙上。现在有两种操作，第一种操作是将其中一个钉子移走，等待凸多边形稳定后，再将钉子钉在某个位置上。第二种操作是询问某个点的坐标。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题是典型的计算几何题，涉及到的知识大概有：</p>
<ol>
<li>多边形重心的计算。</li>
<li>多边形的旋转。</li>
</ol>
<p>多边形重心的公式可以在网上搜到，这里就不再赘述了<del>（其实是因为贴不了数学公式）</del>。</p>
<p>我们知道，假如多边形没有产生形变，那么它的重心与所有顶点的距离是不变的。因此，假如我们知道一个多边形的重心坐标以及重心与所有顶点的距离，再加上重心与所有顶点的角度差，我们就可以确定所有顶点的坐标了。需要注意的是，重心与其他所有顶点的角度差在重心变更时会产生变化，因此，我们需要进行角度变换。总的时间复杂度是O(n + q)。</p>
<p>下面的代码里有些形如<strong>cosl</strong>这样形式的三角函数，与<strong>cos</strong>这种普通三角函数的不同是：<strong>cosl</strong>的参数要求为long double，返回值也为long double，从而保证了精度。这道题不用<strong>cosl</strong>也能过，但用了更保险。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">double</span>, <span class="type">long</span> <span class="type">double</span>&gt; point;</span><br><span class="line">point a[N], c;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ang[N], angle, dist[N], bx, by;</span><br><span class="line"><span class="type">int</span> n, q, t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> area = <span class="number">0</span>, cx = <span class="number">0</span>, cy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">double</span> temp = a[i].x * a[(i+<span class="number">1</span>)%n].y - a[i].y * a[(i+<span class="number">1</span>)%n].x;</span><br><span class="line">        area += temp;</span><br><span class="line">        cx += (a[i].x + a[(i+<span class="number">1</span>)%n].x) * temp;</span><br><span class="line">        cy += (a[i].y + a[(i+<span class="number">1</span>)%n].y) * temp;</span><br><span class="line">    &#125;</span><br><span class="line">    area /= <span class="number">2</span>;</span><br><span class="line">    cx /= <span class="number">6</span> * area;</span><br><span class="line">    cy /= <span class="number">6</span> * area;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>(cx, cy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">getPoint</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>(c.x + dist[idx] * <span class="built_in">cosl</span>(angle + ang[idx]), c.y + dist[idx] * <span class="built_in">sinl</span>(angle + ang[idx]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">getDist</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrtl</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t1, &amp;t2);</span><br><span class="line">        a[i].x = t1;</span><br><span class="line">        a[i].y = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    bx = a[<span class="number">0</span>].x, by = a[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i].x -= bx;</span><br><span class="line">        a[i].y -= by;</span><br><span class="line">    &#125;</span><br><span class="line">    c = <span class="built_in">getC</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dist[i] = <span class="built_in">getDist</span>(a[i], c);</span><br><span class="line">        ang[i] = <span class="built_in">atan2l</span>(a[i].y - c.y, a[i].x - c.x);</span><br><span class="line">        <span class="keyword">if</span>(ang[i] &lt; <span class="number">0</span>)</span><br><span class="line">            ang[i] += <span class="number">2</span> * PI;</span><br><span class="line">    &#125;</span><br><span class="line">    angle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, op, x, y;</span><br><span class="line">    point top, nxt;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            x--, y--;</span><br><span class="line">            <span class="keyword">if</span>(x == i) &#123;</span><br><span class="line">                i = y;</span><br><span class="line">                top = <span class="built_in">getPoint</span>(j);</span><br><span class="line">                nxt = <span class="built_in">point</span>(top.x, top.y - dist[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = y;</span><br><span class="line">                top = <span class="built_in">getPoint</span>(i);</span><br><span class="line">                nxt = <span class="built_in">point</span>(top.x, top.y - dist[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            angle += -PI/<span class="number">2</span> - <span class="built_in">atan2l</span>(c.y - top.y, c.x - top.x);</span><br><span class="line">            <span class="keyword">while</span>(angle &lt; <span class="number">0</span>)</span><br><span class="line">                angle += <span class="number">2</span> * PI;</span><br><span class="line">            <span class="keyword">while</span>(angle &gt;= <span class="number">2</span> * PI)</span><br><span class="line">                angle -= <span class="number">2</span> * PI;</span><br><span class="line">            c = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            point ans = <span class="built_in">getPoint</span>(x<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10f %.10f\n&quot;</span>, (<span class="type">double</span>)(ans.x + bx), (<span class="type">double</span>)(ans.y + by));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 976E: Well played!</title>
    <url>/2018/05/05/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>你拥有n个怪兽，每个怪兽具有hp和dam这两种属性。你可以进行两种操作：第一种是将怪兽的hp值翻倍；第二种是令怪兽的dam &#x3D; hp。第一种操作你最多可以进行a次，第二种操作你最多可以进行b次，问所有怪兽的dam和最大是多少？</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看到题目，容易想到动态规划，但是想了挺久，没思路。看了官方题解，发现了一个重要的性质：第一种操作应该只分配给某一只怪兽，这个可以通过反证法来证明，挺简单的，这里不再赘述。a个第一种操作和1个第二种操作分配完了，那么剩余的b-1个第二种操作应该怎么分配？贪心，即优先分配给hp - dam值较大的怪兽（在这之前需要排序一次）。最终此题的复杂度是O(nlogn)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">ll n, aa, b, t, ans, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll hea, dam;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.hea - a.dam) &gt; (b.hea - b.dam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; aa &gt;&gt; b) &#123;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(aa--) t *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a[i].hea, &amp;a[i].dam);</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b) sum += <span class="built_in">max</span>(a[i].hea, a[i].dam);</span><br><span class="line">            <span class="keyword">else</span> sum += a[i].dam;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b) ans = <span class="built_in">max</span>(ans, sum - <span class="built_in">max</span>(a[i].hea, a[i].dam) + <span class="built_in">max</span>(a[i].hea * t, a[i].dam));</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, sum - <span class="built_in">max</span>(a[b<span class="number">-1</span>].hea, a[b<span class="number">-1</span>].dam) + a[b<span class="number">-1</span>].dam - a[i].dam + <span class="built_in">max</span>(a[i].hea * t, a[i].dam));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 980D: Perfect Groups</title>
    <url>/2018/05/09/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，让你给这个数组分组，使得组内的元素两两相乘都是平方数，记最少分组数为d。</p>
<p>现在给你一个数组a，求出它所有连续子序列的d，然后输出每个d(1&lt;&#x3D; d &lt;&#x3D; n)的计数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>用唯一分解定理分解平方数，可以发现它的某一素因子的个数为偶数个。若两个数相乘是平方数，则两者的所有素因子中，要么两个数都具有偶数个，要么都具有奇数个。因此，我们可以将一个数表示成它那些奇数个数的素因子的乘积。然后，若两个数相同，则可以组成平方数，否则不可以。于是，问题就转化成了求连续子序列中出现不同数字的个数，容易想到用set来维护，但是由于我们需要用$ O(n^{2}) $的时间来枚举连续子序列的起点和终点，再用上个set会超时。所以，结合数组a的元素很大，我们需要将其离散化，然后用一个桶来维护。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">vi pri;</span><br><span class="line"><span class="type">int</span> n, a[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> up = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">bool</span> vis[N];</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= up; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= up; j += i)</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= up; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fac</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="keyword">return</span> d;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="number">0</span>) ans *= <span class="number">-1</span>, d *= <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(d != <span class="number">1</span> &amp;&amp; p &lt; pri.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(d % pri[p] == <span class="number">0</span>)</span><br><span class="line">            cnt++, d /= pri[p];</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)</span><br><span class="line">            ans *= pri[p];</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d != <span class="number">1</span>)</span><br><span class="line">        ans *= d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lisanhua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; se;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        se.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: se) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            m[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m[i] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] = m[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            a[i] = <span class="built_in">fac</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">        <span class="built_in">lisanhua</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>, zeroFlag = <span class="number">0</span>, b[N];</span><br><span class="line">            <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] == <span class="number">0</span>)</span><br><span class="line">                    zeroFlag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[a[j]]++ == <span class="number">0</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">if</span>(zeroFlag &amp;&amp; cnt != <span class="number">1</span>)</span><br><span class="line">                    ans[cnt<span class="number">-1</span>]++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans[cnt]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i], i == n ? <span class="string">&#x27;\n&#x27;</span>: <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数学</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 980E: The Number Games</title>
    <url>/2018/05/09/1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一棵树，节点标记为$1$~$n$，节点$i$的点权为为$2^i$，现在需要删去k个点，使得剩余的点相互联通，且点权的和最大。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看完这道题，首先想到的是贪心，即尽量删去点权小的节点，但是经过仔细思考，容易找到一些反例，因此这个思路是行不通的。这道题的思维难点在于<strong>将删去节点转化为选取节点</strong>。由数学知识得，$2^{i} &#x3D; 2^{i-1} + 2^{i-2} + … + 2^{0} + 1 $，所以，我们应该尽量选取标号大的节点。首先，标号为$n$ 的节点是一定可以选取的，把它放到联通块里面，然后我们从大到小，不断往这个联通块添加节点。判断某点能否放进联通块里面，需要看这点与联通块的最短距离是否小于剩余可放的节点数，我们可以使用ST表，在$O(logn)$的时间内来完成。总的时间复杂度就是$O(nlogn)$。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u, v, n, k, fa[N][<span class="number">29</span>], vis[N], mm[N];</span><br><span class="line">vi G[N], v1;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; se;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        fa[v][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mm[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        mm[i] = ((i &amp; (i<span class="number">-1</span>)) == <span class="number">0</span> ? mm[i<span class="number">-1</span>] + <span class="number">1</span> : mm[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= mm[n]; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[i][j<span class="number">-1</span>] == <span class="number">-1</span>)</span><br><span class="line">                fa[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">-1</span>, <span class="keyword">sizeof</span> fa);</span><br><span class="line">    <span class="built_in">dfs</span>(n);</span><br><span class="line">    <span class="built_in">buildST</span>();</span><br><span class="line">    k = n - k;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[n] = <span class="literal">true</span>;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(n);</span><br><span class="line">    k--;</span><br><span class="line">    u = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">            u--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t = u, dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[u][i] == <span class="number">-1</span> || vis[fa[u][i]] == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dis += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                u = fa[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = t;</span><br><span class="line">        dis++;</span><br><span class="line">        <span class="keyword">if</span>(dis &lt;= k) &#123;</span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(u);</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">while</span>(vis[fa[u][<span class="number">0</span>]] != <span class="literal">true</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">                u = fa[u][<span class="number">0</span>];</span><br><span class="line">                vis[u] = <span class="literal">true</span>;</span><br><span class="line">                v1.<span class="built_in">push_back</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = t - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        se.<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: v1)</span><br><span class="line">        se.<span class="built_in">erase</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: se)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队算法学习笔记（一）</title>
    <url>/2018/07/19/0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>莫队算法主要用于可以离线处理的、不带修改的、只有查询的一类区间问题。<br>升级版的莫队算法可以解决带修改的区间问题。<br>我看过的比较好的教程：<a href="https://zhuanlan.zhihu.com/p/25017840">莫队算法 (Mo’s Algorithm)</a>。</p>
<h1 id="题目1-HYSBZ-2038"><a href="#题目1-HYSBZ-2038" class="headerlink" title="题目1: HYSBZ - 2038"></a>题目1: <a href="https://vjudge.net/problem/HYSBZ-2038">HYSBZ - 2038</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个具有n个元素的数列，然后有m个询问，查询的是某个区间任取两个数，这两个数相同的概率。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>莫队算法的核心是要找到[L, R]转移到[L-1, R], [L+1, R], [L, R-1], [L, R+1]时答案是怎么改变的。<br>具体到这道题，以[L, R]转移到[L, R+1]的情况为例，由于增加了一个元素，所以凑成两个相同的数的方案数以及总的组合数都会改变，因此我们需要维护的是各数字出现的次数以及区间大小。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], l, r, len;</span><br><span class="line">ll up[N], down[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id, block;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;l = l;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        block = l / len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(block == b.block) <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">        <span class="keyword">return</span> block &lt; b.block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(ll &amp;ans, <span class="type">int</span> pos, <span class="type">int</span> fix)</span> </span>&#123;</span><br><span class="line">    ans -= <span class="number">1LL</span> * b[a[pos]] * (b[a[pos]] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    b[a[pos]] += fix;</span><br><span class="line">    ans += <span class="number">1LL</span> * b[a[pos]] * (b[a[pos]] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            q[i] = node&#123;l, r, i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q, q + m);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        l = r = <span class="number">1</span>;</span><br><span class="line">        b[a[l]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            node &amp;t = q[i];</span><br><span class="line">            <span class="keyword">while</span>(r &lt; t.r) <span class="built_in">cal</span>(ans, ++r, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(l &gt; t.l) <span class="built_in">cal</span>(ans, --l, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(r &gt; t.r) <span class="built_in">cal</span>(ans, r--, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; t.l) <span class="built_in">cal</span>(ans, l++, <span class="number">-1</span>);</span><br><span class="line">            ll t0 = ans;</span><br><span class="line">            ll t1 = <span class="number">1LL</span> * (t.r - t.l + <span class="number">1</span>) * (t.r - t.l) / <span class="number">2</span>;</span><br><span class="line">            ll g = __gcd(t0, t1);</span><br><span class="line">            t0 /= g;</span><br><span class="line">            t1 /= g;</span><br><span class="line">            up[t.id] = t0;</span><br><span class="line">            down[t.id] = t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, up[i], down[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目2-SPOJ-DQUERY"><a href="#题目2-SPOJ-DQUERY" class="headerlink" title="题目2: SPOJ - DQUERY"></a>题目2: <a href="https://vjudge.net/problem/SPOJ-DQUERY">SPOJ - DQUERY</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个具有n个元素的数列，然后有q个询问，查询的是某个区间不同数字的个数。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>我们只需要维护各数字出现的次数即可，假如在区间改变的过程，某一个数字出现的次数由1变成0，那么答案应该减1，而假如由0变成1，那么答案应该加1。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, len, a[N], b[N], l, r, sum, ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id, block;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;l = l;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        block = l / len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(block == b.block) <span class="keyword">return</span> r &lt; b.r;</span><br><span class="line">        <span class="keyword">return</span> block &lt; b.block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> &amp;sum, <span class="type">int</span> pos, <span class="type">int</span> fix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;t = b[a[pos]];</span><br><span class="line">    t += fix;</span><br><span class="line">    <span class="keyword">if</span>(fix == <span class="number">1</span> &amp;&amp; t == <span class="number">1</span>)</span><br><span class="line">        sum++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fix == <span class="number">-1</span> &amp;&amp; t == <span class="number">0</span>)</span><br><span class="line">        sum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        q[i] = node&#123;l, r, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + m);</span><br><span class="line">    l = r = sum = <span class="number">1</span>;</span><br><span class="line">    b[a[<span class="number">1</span>]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        node &amp;t = q[i];</span><br><span class="line">        <span class="keyword">while</span>(r &lt; t.r) <span class="built_in">cal</span>(sum, ++r, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(l &gt; t.l) <span class="built_in">cal</span>(sum, --l, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r &gt; t.r) <span class="built_in">cal</span>(sum, r--, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; t.l) <span class="built_in">cal</span>(sum, l++, <span class="number">-1</span>);</span><br><span class="line">        ans[t.id] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目3-Powerful-array"><a href="#题目3-Powerful-array" class="headerlink" title="题目3: Powerful array"></a>题目3: <a href="https://vjudge.net/problem/CodeForces-86D">Powerful array</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给一个具有n个元素的数列，然后有t个询问，查询的是某一区间K<sub>s</sub>·K<sub>s</sub>·s的和，其中s表示的是某一个数字，K<sub>s</sub>表示的是该数字出现的次数。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>我们只需要维护各数字出现的次数即可。维护前，先减去该数字的贡献值，维护后，再加上该数字的贡献值。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[N], l, r, len, cnt[N];</span><br><span class="line">ll ans, an[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id, block;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;l = l;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;block = l / len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.block == block) <span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">        <span class="keyword">return</span> block &lt; t.block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(ll &amp;ans, <span class="type">int</span> pos, <span class="type">int</span> fix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;t = cnt[a[pos]];</span><br><span class="line">    ans -= <span class="number">1LL</span> * t * t * a[pos];</span><br><span class="line">    t += fix;</span><br><span class="line">    ans += <span class="number">1LL</span> * t * t * a[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            q[i] = node&#123;l, r, i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q, q + m);</span><br><span class="line">        l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        cnt[a[<span class="number">1</span>]]++;</span><br><span class="line">        ans = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            node t = q[i];</span><br><span class="line">            <span class="keyword">while</span>(r &lt; t.r) <span class="built_in">cal</span>(ans, ++r, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(l &gt; t.l) <span class="built_in">cal</span>(ans, --l, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(r &gt; t.r) <span class="built_in">cal</span>(ans, r--, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; t.l) <span class="built_in">cal</span>(ans, l++, <span class="number">-1</span>);</span><br><span class="line">            an[t.id] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>, an[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>Lindström-Gessel-Vienot-Lemma学习笔记</title>
    <url>/2018/07/21/0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Lindström-Gessel-Vienot Lemma可以用来解决一类路径计数问题。<br>要想将这个引理用于解决计数问题，首先需要令图的所有边的权值等于1。<br>接着需要说明的是，从起点 $$ A&#x3D;{a_{1},\ldots ,a_{n}} $$ 到终点 $$ B&#x3D;{b_{1},\ldots ,b_{n}} $$ 的所有不相交路径，并不是指$$ {a_{i} } $$一定到$$ {b_{i} } $$，它包括得更广，起点A中的某点到达终点B中的任意一点即可，但由于严格不相交，所以它们是一个“双射”。<br>公式的右边，计算的是所有路径的有符号权值和，这里的符号由排列的逆序对个数决定，假如逆序对的个数是奇数，那么符号为负，否则为正。<br>假如我们要求从起点 $$ A&#x3D;{a_{1},\ldots ,a_{n}} $$ 到终点 $$ B&#x3D;{b_{1},\ldots ,b_{n}} $$ ，且$$ {a_{i} } $$一定到$$ {b_{i} } $$的所有不相交路径，那么等式的右边就恰好等于这个方案数。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>详情请看<a href="https://www.nowcoder.com/acm/contest/139/A">Monotonic Matrix</a>。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>官方题解：<br>考虑 01 和 12 的分界线<br>是 (n, 0) 到 (0, m) 的两条不相交(可重合)路径<br>平移其中一条变成 (n-1, -1) 到 (-1, m-1)<br>变成起点 (n, 0) 和 (n-1, -1),终点 (0, m) 和 (-1, m-1) 的严格不相交路径<br>套 Lindström–Gessel–Viennot lemma<br>答案是 $$ {C_{n+m}^n}^2 - C_{n+m}^{m - 1} C_{n+m}^{n-1}  $$</p>
</blockquote>
<p>我们设左下角的两点为起点a1, a2，右上角的两点为终点b1, b2，我们需要求的是从a1到b1、a2到b2的路径方案数，由于题目的限制，a1到b2、a2到b1的路径是不合法的，所以，公式的右边恰好就不包含a1到b2、a2到b1的路径方案数了。因此，我们就可以通过计算矩阵行列式来计算答案了。</p>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>留坑待填。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Lindstr%C3%B6m%E2%80%93Gessel%E2%80%93Viennot_lemma">Lindström–Gessel–Viennot lemma - Wikipedia</a></li>
<li><a href="https://graphicallinearalgebra.net/2017/07/31/determinants-and-the-lindstrom-gessel-vienot-lemma/comment-page-1/">Determinants and the Lindström-Gessel-Vienot Lemma</a></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队算法学习笔记（二）</title>
    <url>/2018/07/27/0/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>上一篇<a href="https://hyzgh.github.io/2018/07/19/0/">莫队算法学习笔记</a>主要写了普通莫队算法的应用，这次来写一写树上莫队和带修改莫队。<br>树上莫队，就是将树转化为序列，然后应用莫队算法来解决。<br>带修改莫队，相比于普通莫队，增加了单点修改的操作，时间复杂度由$ O(n\sqrt{n}) $ 上升到了$ O(n^{\frac{5}{3}}) $。所以，在没有其他特殊条件的情况下，对于$ n &#x3D; 1e5 $次询问，一般需要2秒的处理时间。<br>经过实战发现，莫队算法很适合处理需要统计元素出现次数的问题，而这类问题用其他数据结构，如线段树，不太好解决<del>（神犇请无视）</del>。而且，莫队算法实现起来相对容易，空间消耗小。但是，莫队算法也有它的局限性，即时间复杂度偏高，且不能处理区间修改的问题。</p>
<h1 id="题目1：CodeForces-375D-Tree-and-Queries"><a href="#题目1：CodeForces-375D-Tree-and-Queries" class="headerlink" title="题目1：CodeForces - 375D - Tree and Queries"></a>题目1：<a href="https://vjudge.net/problem/48705/origin">CodeForces - 375D - Tree and Queries</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一颗具有n个节点的有根树，每个节点染有一种颜色。然后有m个询问，询问的是某个节点子树的颜色数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假如我们知道了从根出发的dfs序，那么一颗子树就对应dfs序的一个区间，因此，原问题就转化成了求某个区间的颜色数，应用普通莫队即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, cnt, in[N], out[N], c[N], nc[N], u, k, v, n, m, f[N], sum[N], ans[N];</span><br><span class="line">vi G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, k, id, block;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;l = l;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;block = l / len ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(block == t.block) <span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">        <span class="keyword">return</span> block &lt; t.block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    in[u] = ++cnt;</span><br><span class="line">    nc[cnt] = c[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    out[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, c + i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;k);</span><br><span class="line">            q[i] = node&#123;in[u], out[u], k, i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q, q + m);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            node t = q[i];</span><br><span class="line">            <span class="keyword">while</span>(r &lt; t.r) &#123;</span><br><span class="line">                ++f[nc[++r]];</span><br><span class="line">                ++sum[f[nc[r]]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l &gt; t.l) &#123;</span><br><span class="line">                ++f[nc[--l]];</span><br><span class="line">                ++sum[f[nc[l]]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r &gt; t.r) &#123;</span><br><span class="line">                --sum[f[nc[r]]];</span><br><span class="line">                --f[nc[r--]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; t.l) &#123;</span><br><span class="line">                --sum[f[nc[l]]];</span><br><span class="line">                --f[nc[l++]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[t.id] = sum[t.k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目2：UVA-12345-Dynamic-len"><a href="#题目2：UVA-12345-Dynamic-len" class="headerlink" title="题目2：UVA - 12345 - Dynamic len"></a>题目2：<a href="https://vjudge.net/problem/25093/origin">UVA - 12345 - Dynamic len</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个具有n个元素的数列，然后有m个修改或查询。查询的是某个区间的不同数子个数，修改的是某个元素的值。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>带修改莫队模板题，需要注意的点有：</p>
<ul>
<li>分块大小为$ O( n^{\frac{2}{3}}) $ 。</li>
<li>排序时以<strong>左端点所在区块</strong>为第一关键字，<strong>右端点所在区块</strong>为第二关键字，<strong>时间戳</strong>为第三关键字。</li>
<li>每个时间戳都意味着状态的改变，所以需要保存更新到新状态和撤销回旧状态的相关信息。</li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, n, m, x, y, last[N], tot, timer, a[N], l, r, ans, an[N], cnt[<span class="number">10</span>*N];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line"><span class="type">char</span> op[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">    <span class="type">int</span> last, x, val;</span><br><span class="line">&#125;chg[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id, lblock, rblock, timer;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> id, <span class="type">int</span> timer):<span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">id</span>(id), <span class="built_in">timer</span>(timer) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lblock = l / len;</span><br><span class="line">        <span class="keyword">this</span>-&gt;rblock = r / len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lblock != t.lblock) <span class="keyword">return</span> lblock &lt; t.lblock;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rblock != t.rblock) <span class="keyword">return</span> rblock &lt; t.rblock;</span><br><span class="line">        <span class="keyword">return</span> timer &lt; t.timer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[x]] == <span class="number">1</span>)</span><br><span class="line">        ans--;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">    flag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[x]] == <span class="number">0</span>)</span><br><span class="line">        ans++;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    flag[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag[x])</span><br><span class="line">        a[x] = val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sub</span>(x);</span><br><span class="line">        a[x] = val;</span><br><span class="line">        <span class="built_in">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        len = <span class="built_in">pow</span>(n, <span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            last[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;x, &amp;y);</span><br><span class="line">            ++x;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                q[tot] = node&#123;x, y, tot, timer&#125;;</span><br><span class="line">                ++tot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                chg[++timer].last = last[x];</span><br><span class="line">                chg[timer].x = x;</span><br><span class="line">                chg[timer].val = last[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q, q + tot);</span><br><span class="line">        l = <span class="number">1</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>, timer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">            node t = q[i];</span><br><span class="line">            <span class="keyword">while</span>(timer &lt; q[i].timer) &#123;</span><br><span class="line">                timer++;</span><br><span class="line">                <span class="built_in">modify</span>(chg[timer].x, chg[timer].val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(timer &gt; q[i].timer) &#123;</span><br><span class="line">                <span class="built_in">modify</span>(chg[timer].x, chg[timer].last);</span><br><span class="line">                timer--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; t.r)</span><br><span class="line">                <span class="built_in">add</span>(++r);</span><br><span class="line">            <span class="keyword">while</span>(l &gt; t.l)</span><br><span class="line">                <span class="built_in">add</span>(--l);</span><br><span class="line">            <span class="keyword">while</span>(r &gt; t.r)</span><br><span class="line">                <span class="built_in">sub</span>(r--);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; t.l)</span><br><span class="line">                <span class="built_in">sub</span>(l++);</span><br><span class="line">            an[t.id] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, an[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="题目3：CodeForces-940F-Machine-Learning"><a href="#题目3：CodeForces-940F-Machine-Learning" class="headerlink" title="题目3：CodeForces - 940F - Machine Learning "></a>题目3：<a href="https://vjudge.net/problem/1389440/origin">CodeForces - 940F - Machine Learning </a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给一个具有n个元素的数列，然后有q次修改或查询。修改，即让某个元素的值改变。查询的是区间[L, R]的Mex，Mex的定义是最小的元素出现次数的次数为0的次数（不懂可以看原题）。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>由数学知识得，一个长度为n的数列，答案最大为$ \sqrt{2n} $，所以，假如我们维护了元素出现的次数的次数，那么我们就可以在 $ O(\sqrt{n})$得到某个区间的答案。假如没有修改操作，可以直接用普通莫队维护。但是这里有了单点的修改操作，所以我们可以考虑用带修改的莫队来实现。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ma;</span><br><span class="line"><span class="type">int</span> len, n, m, a[N], cnt[N], se[N], x, y, tot, timer, l, r, last[N], an[N], op, flag[N], dis, up;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id, lblock, rblock, timer;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> id, <span class="type">int</span> timer): <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">id</span>(id), <span class="built_in">timer</span>(timer) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lblock = l / len;</span><br><span class="line">        <span class="keyword">this</span>-&gt;rblock = r / len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lblock != t.lblock) <span class="keyword">return</span> lblock &lt; t.lblock;</span><br><span class="line">        <span class="keyword">if</span>(rblock != t.rblock) <span class="keyword">return</span> rblock &lt; t.rblock;</span><br><span class="line">        <span class="keyword">return</span> timer &lt; t.timer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, val, last;</span><br><span class="line">    <span class="built_in">node1</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node1</span>(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> last): <span class="built_in">x</span>(x), <span class="built_in">val</span>(val), <span class="built_in">last</span>(last) &#123;&#125;</span><br><span class="line">&#125;chg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;t = cnt[a[x]];</span><br><span class="line">    se[t]--;</span><br><span class="line">    se[--t]++;</span><br><span class="line">    flag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;t = cnt[a[x]];</span><br><span class="line">    se[t]--;</span><br><span class="line">    se[++t]++;</span><br><span class="line">    flag[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag[x])</span><br><span class="line">        a[x] = val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sub</span>(x);</span><br><span class="line">        a[x] = val;</span><br><span class="line">        <span class="built_in">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        len = <span class="built_in">pow</span>(n, <span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            s.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">            last[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">                q[tot] = node&#123;x, y, tot, timer&#125;;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                timer++;</span><br><span class="line">                chg[timer] = node1&#123;x, y, last[x]&#125;;</span><br><span class="line">                s.<span class="built_in">insert</span>(y);</span><br><span class="line">                last[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: s)</span><br><span class="line">            ma[i] = dis++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            a[i] = ma[a[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= timer; i++)</span><br><span class="line">            chg[i].val = ma[chg[i].val], chg[i].last = ma[chg[i].last];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 莫队</span></span><br><span class="line">        l = <span class="number">1</span>, r = <span class="number">0</span>, timer = <span class="number">0</span>;</span><br><span class="line">        up = <span class="built_in">sqrt</span>(<span class="number">2</span> * n);</span><br><span class="line">        <span class="built_in">sort</span>(q, q + tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">            node t = q[i];</span><br><span class="line">            <span class="keyword">while</span>(timer &lt; t.timer) &#123;</span><br><span class="line">                timer++;</span><br><span class="line">                <span class="built_in">modify</span>(chg[timer].x, chg[timer].val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(timer &gt; t.timer) &#123;</span><br><span class="line">                <span class="built_in">modify</span>(chg[timer].x, chg[timer].last);</span><br><span class="line">                timer--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; t.r) <span class="built_in">add</span>(++r);</span><br><span class="line">            <span class="keyword">while</span>(l &gt; t.l) <span class="built_in">add</span>(--l);</span><br><span class="line">            <span class="keyword">while</span>(r &gt; t.r) <span class="built_in">sub</span>(r--);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; t.l) <span class="built_in">sub</span>(l++);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= up; j++)</span><br><span class="line">                <span class="keyword">if</span>(se[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    an[t.id] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, an[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>2018牛客多校第二场J题 farm</title>
    <url>/2018/07/30/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个$$ n<em>m(n</em>m&lt;&#x3D;1e6) $$的矩形,每个位置有一个数。有$$ T(T&lt;&#x3D;1e6) $$次操作,每次往一个子矩形的每个格子中放入一个数。<br>求有多少个格子中被放入了至少一个与对应位置不相同的数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>官方题解：<br>先考虑一个特殊的情况:矩形中的数和T次操作放的数都为0或1。<br>对于这种情况,我们只需要用矩阵前缀和统计一下每个格子被多少个0覆盖,被多少个1覆盖。<br>如果一个格子的数为0且被放入了至少一个1或这个格子的数位1且被放入了至少一个0则就会对答案产生贡献。<br>然后考虑原问题。<br>如果某个格子的数是i,而它被放入了至少一个j,且i!&#x3D;j,则需要统计进入答案。<br>注意到,i!&#x3D;j则i和j至少有一个二进制位不相同。<br>我们枚举0~19的每一个二进制位,然后把所有数字按照这一位是0还是1划分成两个集合,就变成了上述<br>特殊情况的问题。一个格子只要至少在某一个二进制位的子问题时被统计进入答案,就加到总答案中去。<br>复杂度 $O((nm+T)log(nm)) $</p>
</blockquote>
<p>官方题解说得很清楚了，直接实现就行了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m, T, a[N], x, y, xx, yy, k, num[N][<span class="number">20</span>][<span class="number">2</span>], ans;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;T)) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[<span class="built_in">id</span>(i, j)]);</span><br><span class="line">        <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;xx, &amp;yy, &amp;k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">20</span>; bit++) &#123;</span><br><span class="line">                num[<span class="built_in">id</span>(x, y)][bit][k &gt;&gt; bit &amp; <span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(yy + <span class="number">1</span> &lt;= m) num[<span class="built_in">id</span>(x, yy + <span class="number">1</span>)][bit][k &gt;&gt; bit &amp; <span class="number">1</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(xx + <span class="number">1</span> &lt;= n) num[<span class="built_in">id</span>(xx + <span class="number">1</span>, y)][bit][k &gt;&gt; bit &amp; <span class="number">1</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(xx + <span class="number">1</span> &lt;= n &amp;&amp; yy + <span class="number">1</span> &lt;= m) num[<span class="built_in">id</span>(xx + <span class="number">1</span>, yy + <span class="number">1</span>)][bit][k &gt;&gt; bit &amp; <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">20</span>; bit++) &#123;</span><br><span class="line">                    num[<span class="built_in">id</span>(i, j)][bit][<span class="number">0</span>] += num[<span class="built_in">id</span>(i - <span class="number">1</span>, j)][bit][<span class="number">0</span>] + num[<span class="built_in">id</span>(i, j - <span class="number">1</span>)][bit][<span class="number">0</span>] - num[<span class="built_in">id</span>(i - <span class="number">1</span>, j - <span class="number">1</span>)][bit][<span class="number">0</span>];</span><br><span class="line">                    num[<span class="built_in">id</span>(i, j)][bit][<span class="number">1</span>] += num[<span class="built_in">id</span>(i - <span class="number">1</span>, j)][bit][<span class="number">1</span>] + num[<span class="built_in">id</span>(i, j - <span class="number">1</span>)][bit][<span class="number">1</span>] - num[<span class="built_in">id</span>(i - <span class="number">1</span>, j - <span class="number">1</span>)][bit][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((a[<span class="built_in">id</span>(i, j)] &gt;&gt; bit &amp; <span class="number">1</span> &amp;&amp; num[<span class="built_in">id</span>(i, j)][bit][<span class="number">0</span>]) || (!(a[<span class="built_in">id</span>(i, j)] &gt;&gt; bit &amp; <span class="number">1</span>) &amp;&amp; num[<span class="built_in">id</span>(i, j)][bit][<span class="number">1</span>]))</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>截止于180718的AOBO补题汇总</title>
    <url>/2018/07/18/0/</url>
    <content><![CDATA[<p>待补题目按AC数降序排列。</p>
<h2 id="180429（浙江省赛）"><a href="#180429（浙江省赛）" class="headerlink" title="180429（浙江省赛）"></a>180429（浙江省赛）</h2><p><a href="http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=378">补题传送门</a><br>待补：<br>D题：Sequence Swapping<br>E题：LIS<br>I题：Magic Points</p>
<h2 id="180426（2017杭州亚洲区域赛）"><a href="#180426（2017杭州亚洲区域赛）" class="headerlink" title="180426（2017杭州亚洲区域赛）"></a>180426（2017杭州亚洲区域赛）</h2><p><a href="https://vjudge.net/contest/225282">补题传送门</a><br>待补：</p>
<ul>
<li><del>K题：Master of Sequence</del></li>
<li><del>B题：Master of Phi</del></li>
</ul>
<h2 id="180422（2018-ACM-ICPC-中国大学生程序设计竞赛线上赛）"><a href="#180422（2018-ACM-ICPC-中国大学生程序设计竞赛线上赛）" class="headerlink" title="180422（2018 ACM-ICPC 中国大学生程序设计竞赛线上赛）"></a>180422（2018 ACM-ICPC 中国大学生程序设计竞赛线上赛）</h2><p><a href="https://www.jisuanke.com/contest/1227">补题传送门</a><br>待补：</p>
<ul>
<li><del>G题：Trouble of Tyrant</del></li>
<li><del>F题：Clever King</del></li>
<li><del>H题：Rock Paper Scissors Lizard Spock</del></li>
</ul>
<h2 id="180419（2017中国大学生程序设计竞赛-女生专场）"><a href="#180419（2017中国大学生程序设计竞赛-女生专场）" class="headerlink" title="180419（2017中国大学生程序设计竞赛 - 女生专场）"></a>180419（2017中国大学生程序设计竞赛 - 女生专场）</h2><p><a href="https://vjudge.net/contest/223275#overview">补题传送门</a><br>待补：</p>
<ul>
<li><del>J题：Judicious Strategy</del></li>
<li><del>I题：Innumerable Ancestors</del></li>
</ul>
<h2 id="180412（OI题目）"><a href="#180412（OI题目）" class="headerlink" title="180412（OI题目）"></a>180412（OI题目）</h2><p><a href="http://10.21.32.116/contest.php?cid=1010">补题传送门</a><br>待补：</p>
<ul>
<li>H题：以撒</li>
<li>I题：永恒</li>
<li><del>A题：动物朋友</del></li>
<li><del>D题：永恒的史诗</del></li>
<li><del>E题：中二病也要浪漫!</del></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2018杭电多校第四场B题 Harvest of Apples</title>
    <url>/2018/08/01/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有n个苹果，编号为1到n，求从中最多选取m个苹果的方案数。<br>测试组数有T组。($$ 1≤T≤10^5, 1≤m≤n≤10^5 $$)</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>官方题解:<br>定义 $$ S(n, m) &#x3D; \sum_{i &#x3D; 0} ^ {m} {n \choose i} $$，不难发现$$ S(n,m)&#x3D;S(n,m−1)+{n \choose m} $$, $$ S(n,m)&#x3D;2S(n−1,m)−{n-1 \choose m} $$.<br>也就是说，如果我们知道 S(n, m)，就能以 O(1) 的代价计算出S(n−1,m), S(n,m−1), S(n+1,m), S(n,m+1)，可以采用莫队算法。</p>
</blockquote>
<p><del>水题，</del>直接实现就行了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll fac[N], ni[N], ans, an[N], ni2;</span><br><span class="line"><span class="type">int</span> len, n, m, T;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;    <span class="comment">//辅助函数</span></span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv_Fermat</span><span class="params">(ll a, ll p)</span> </span>&#123;            <span class="comment">//费马小定理求a关于p的逆元 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow_mod</span>(a, p<span class="number">-2</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    len = <span class="built_in">sqrt</span>(<span class="number">100000</span>);</span><br><span class="line">    ni2 = <span class="built_in">inv_Fermat</span>(<span class="number">2</span>, p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100005</span>; i++)</span><br><span class="line">        fac[i] = fac[i<span class="number">-1</span>] * i % p;</span><br><span class="line">    ni[<span class="number">100005</span>] = <span class="built_in">inv_Fermat</span>(fac[<span class="number">100005</span>], p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">100004</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        ni[i] = ni[i+<span class="number">1</span>] * (i + <span class="number">1</span>) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, block, id;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> id):<span class="built_in">n</span>(n), <span class="built_in">m</span>(m), <span class="built_in">id</span>(id) &#123;</span><br><span class="line">        block = n / len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Node &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(block == rhs.block) <span class="keyword">return</span> m &lt; rhs.m;</span><br><span class="line">        <span class="keyword">return</span> block &lt; rhs.block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * ni[m] % p * ni[n-m] % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        q[i]= Node&#123;n, m, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q, q + T);</span><br><span class="line">    n = <span class="number">1</span>, m = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">        Node &amp;t = q[i];</span><br><span class="line">        <span class="keyword">while</span>(n &lt; t.n) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            (ans = ans * <span class="number">2</span> - <span class="built_in">C</span>(n<span class="number">-1</span>, m)) %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; t.m) &#123;</span><br><span class="line">            ++m;</span><br><span class="line">            (ans = ans + <span class="built_in">C</span>(n, m)) %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; t.n) &#123;</span><br><span class="line">            (ans = (ans + <span class="built_in">C</span>(n<span class="number">-1</span>, m)) * ni2) %= p;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; t.m) &#123;</span><br><span class="line">            (ans = ans - <span class="built_in">C</span>(n, m)) %= p;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + p) % p;</span><br><span class="line">        an[t.id] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, an[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>HDU 6356 Glad You Came</title>
    <url>/2018/08/09/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个长度为n$ (1 &lt;&#x3D; n &lt;&#x3D; 10^5 $)的数组，所有元素的初始值为0，然后有m$ (1 &lt;&#x3D; m &lt;&#x3D; 5*10^6 $)个操作，更新某段区间的最大值。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>官方题解：如果有两个操作覆盖相同的区间，我们可以保留最大的那个。 对于每个操作$(l, r, v)$，令d等于$\lfloor log_2(r - l + 1) \rfloor$，我们可以用两个操作 $(l, l + 2^d - 1, v)$ 和$(r - 2^d + 1, r, v)$ 替换此操作。这样做之后，每个操作所覆盖的区间长度均为 2 的幂，这意味着长度仅有 $O(logn)$种。剩下的只不过是，按长度递减的顺序枚举操作，将每个操作分成两个相等长度的操作，直到区间长度为一。这样做的时间复杂度为$O(m + nlogn)$，空间复杂度为$O(nlogn)$。</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> X, Y, Z;</span><br><span class="line"><span class="type">int</span> T, Log[N], n, m, mx, l, r, v, d, a[<span class="number">19</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rng61</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X ^= X &lt;&lt; <span class="number">11</span>;</span><br><span class="line">    X ^= X &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    X ^= X &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    X ^= X &gt;&gt; <span class="number">14</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tmp = X ^ Y ^ Z;</span><br><span class="line">    X = Y;</span><br><span class="line">    Y = Z;</span><br><span class="line">    Z = tmp;</span><br><span class="line">    <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;d, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    d &lt; v &amp;&amp; (d = v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="comment">// 2^k &lt;= i &lt; 2^(k+1)，预处理出i对应的k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">        Log[i] = Log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%u%u%u&quot;</span>, &amp;n, &amp;m, &amp;X, &amp;Y, &amp;Z);</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            l = <span class="built_in">rng61</span>() % n + <span class="number">1</span>, r = <span class="built_in">rng61</span>() % n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">            v = <span class="built_in">rng61</span>() % (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">            d = Log[r - l + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 逆用ST表</span></span><br><span class="line">            <span class="built_in">upd</span>(a[d][l], v);</span><br><span class="line">            <span class="built_in">upd</span>(a[d][r - (<span class="number">1</span> &lt;&lt; d) + <span class="number">1</span>], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出满足2^mx &gt; n 的最小mx</span></span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span> &lt;&lt; mx &lt;= n) mx++;</span><br><span class="line">        <span class="comment">// O(nlogn) 从大区间推到小区间，直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mx - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++) &#123;</span><br><span class="line">                <span class="built_in">upd</span>(a[i - <span class="number">1</span>][j], a[i][j]);</span><br><span class="line">                <span class="built_in">upd</span>(a[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))], a[i][j]);</span><br><span class="line">                a[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans ^= <span class="number">1LL</span> * i * a[<span class="number">0</span>][i];</span><br><span class="line">            a[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>思维</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1016E Rest In The Shades</title>
    <url>/2018/08/12/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个光源在x轴下方且平行于x轴的某条线段AB上作匀速直线运动，x轴上有n($$1 &lt;&#x3D; n &lt;&#x3D; 2<em>10^5$$)条会阻挡光线的线段，现在有q($$1 &lt;&#x3D; n &lt;&#x3D; 2</em>10^5$$)个在x轴上方的点，问这q个点没有被光线照射到的时间分别是多少。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>经过观察发现，到达某个点的光假如会被多条线段阻挡，那么这些线段大部分是完整且相邻的，最多只有两条线段是不完整的，因此，我们可以用前缀和来处理完整的线段，然后用二分搜索来处理不完整的线段，求和。接着，由相似三角形的相关定理可计算出在x轴上线段在AB上投影，进而求得答案。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> sum[N];</span><br><span class="line"><span class="type">int</span> n, l, r, q, x, y, vis, idx1, idx2;</span><br><span class="line"><span class="type">double</span> sy, xa, xb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">double</span> l, r, id;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">double</span> l, <span class="type">double</span> r, <span class="type">int</span> id): <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l != rhs.l) <span class="keyword">return</span> l &lt; rhs.l;</span><br><span class="line">        <span class="keyword">if</span>(r != rhs.r) <span class="keyword">return</span> r &lt; rhs.r;</span><br><span class="line">        <span class="keyword">return</span> id &lt; rhs.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;node&gt; se;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;sy, &amp;xa, &amp;xb)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + r - l;</span><br><span class="line">            se.<span class="built_in">insert</span>(<span class="built_in">node</span>(l, r, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> x1 = (y * xa - sy * x) / (y - sy);</span><br><span class="line">            <span class="type">double</span> x2 = (y * xb - sy * x) / (y - sy);</span><br><span class="line">            <span class="keyword">auto</span> it = se.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(x1, <span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">            vis = <span class="number">-1</span>;</span><br><span class="line">            idx1 = (it == se.<span class="built_in">end</span>() ? INF : it-&gt;id);</span><br><span class="line">            <span class="keyword">if</span>(it != se.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                it--;</span><br><span class="line">                <span class="keyword">if</span>(x1 &lt; it-&gt;r) &#123;</span><br><span class="line">                    ans += <span class="built_in">min</span>(it-&gt;r, x2) - x1;</span><br><span class="line">                    vis = it-&gt;id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it = se.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(x2, <span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">if</span>(it != se.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                it--;</span><br><span class="line">                <span class="keyword">if</span>(x2 &lt; it-&gt;r &amp;&amp; vis != it-&gt;id) &#123;</span><br><span class="line">                    ans += x2 - <span class="built_in">max</span>(it-&gt;l, x1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x2 &lt; it-&gt;r) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(it != se.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                        it--;</span><br><span class="line">                        idx2 = it-&gt;id;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        idx2 = -INF;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    idx2 = it-&gt;id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                idx2 = -INF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(idx1 &lt;= idx2) &#123;</span><br><span class="line">                ans += sum[idx2] - sum[idx1<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans *= <span class="number">1.0</span> * (y - sy) / y;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>kuangbin带你飞 专题十一 网络流 题解</title>
    <url>/2018/08/12/1/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/contest/68128">kuangin带你飞专题十一 网络流 传送门</a><br>网络流问题 &#x3D; 建模 + 高效模板</p>
<h1 id="A-POJ-3436-ACM-Computer-Factory"><a href="#A-POJ-3436-ACM-Computer-Factory" class="headerlink" title="A. POJ 3436 ACM Computer Factory"></a>A. POJ 3436 ACM Computer Factory</h1><p>最大流问题，需要拆点、打印路径。</p>
<h1 id="B-POJ-3281-Dining"><a href="#B-POJ-3281-Dining" class="headerlink" title="B. POJ 3281 Dining"></a>B. POJ 3281 Dining</h1><p>最大流问题，需要拆点。<br>经典建模思路：将牛拆点放在中间，然后左边连食物，右边连饮料。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经测试，ISAP比dinic快了不少</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">409</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = N;<span class="comment">//边数的最大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, f, d, start, en, ff, dd, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;f, &amp;d)) &#123;</span><br><span class="line">        start = <span class="number">0</span>, en = f + <span class="number">2</span> * n + d + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            <span class="built_in">addedge</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            <span class="built_in">addedge</span>(f + <span class="number">2</span> * n + i, en, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">addedge</span>(f + i, f + n + i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ff, &amp;dd);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ff; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                <span class="built_in">addedge</span>(t, f + i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; dd; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                <span class="built_in">addedge</span>(f + n + i, f + <span class="number">2</span> * n + t, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">sap</span>(start, en, en + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C-POJ-1087-A-Plug-for-UNIX"><a href="#C-POJ-1087-A-Plug-for-UNIX" class="headerlink" title="C. POJ 1087 A Plug for UNIX"></a>C. POJ 1087 A Plug for UNIX</h1><p>最大流问题，很容易想，但是需要细心，理解好题意，计算好节点个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************************/</span></span><br><span class="line"><span class="comment">/* dinic算法：解决最大流问题。</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(|E| * |V| * |V|)，不过，该算法在实际应用中速度非常快。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_V = <span class="number">509</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to, cap, rev; &#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; G[MAX_V];</span><br><span class="line"><span class="type">int</span> level[MAX_V];</span><br><span class="line"><span class="type">int</span> iter[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap)</span></span>&#123;</span><br><span class="line">    G[from].<span class="built_in">push_back</span>((edge)&#123;to, cap, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(G[to].<span class="built_in">size</span>())&#125;);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>((edge)&#123;from, <span class="number">0</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(G[from].<span class="built_in">size</span>()<span class="number">-1</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="keyword">sizeof</span> level);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    level[s]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> v=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G[v].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            edge &amp;e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&gt;<span class="number">0</span> &amp;&amp; level[e.to]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                level[e.to]=level[v]+<span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> t, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i=iter[v]; i&lt;G[v].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        edge &amp;e=G[v][i];</span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;<span class="number">0</span> &amp;&amp; level[v]&lt;level[e.to])&#123;</span><br><span class="line">            <span class="type">int</span> d=<span class="built_in">dfs</span>(e.to, t, <span class="built_in">min</span>(f, e.cap));</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                e.cap-=d;</span><br><span class="line">                G[e.to][e.rev].cap+=d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_flow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">bfs</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(level[t]&lt;<span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="keyword">sizeof</span> iter);</span><br><span class="line">        <span class="type">int</span> f;</span><br><span class="line">        <span class="keyword">while</span>((f=<span class="built_in">dfs</span>(s, t, INF))&gt;<span class="number">0</span>)</span><br><span class="line">            flow+=f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> start, en, n, m, k, tot;</span><br><span class="line">string s, t, s1, s2;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; ms, mt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(!ms[s]) ms[s] = ++tot;</span><br><span class="line">        <span class="built_in">add_edge</span>(<span class="number">0</span>, ms[s], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    en = <span class="number">400</span> + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(!mt[t]) mt[t] = ++tot;</span><br><span class="line">        <span class="keyword">if</span>(!ms[s]) ms[s] = ++tot;</span><br><span class="line">        <span class="built_in">add_edge</span>(ms[s], mt[t], <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add_edge</span>(mt[t], en, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="keyword">if</span>(!ms[s1]) ms[s1] = ++tot;</span><br><span class="line">        <span class="keyword">if</span>(!ms[s2]) ms[s2] = ++tot;</span><br><span class="line">        <span class="built_in">add_edge</span>(ms[s2], ms[s1], INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = m - <span class="built_in">max_flow</span>(start, en);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-POJ-2195-Going-Home"><a href="#D-POJ-2195-Going-Home" class="headerlink" title="D. POJ 2195 Going Home"></a>D. POJ 2195 Going Home</h1><p>最小费用最大流问题，也可以当成二分图最小权匹配问题来写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* SPFA版最小费用最大流算法(Untested)</span></span><br><span class="line"><span class="comment"> * 最小费用最大流,求最大费用只需要取相反数,结果取相反数即可。</span></span><br><span class="line"><span class="comment"> * 点的总数为 N,点的编号 0 ~ N-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow,cost;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN],tol;</span><br><span class="line"><span class="type">int</span> pre[MAXN],dis[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> N;<span class="comment">//节点总个数,节点编号从 0 ∼ N-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap,<span class="type">int</span> cost)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v;</span><br><span class="line">    edge[tol].cap = cap;</span><br><span class="line">    edge[tol].cost = cost;</span><br><span class="line">    edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];</span><br><span class="line">    head[u] = tol++;</span><br><span class="line">    edge[tol].to = u;</span><br><span class="line">    edge[tol].cap = <span class="number">0</span>;</span><br><span class="line">    edge[tol].cost = -cost;</span><br><span class="line">    edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];</span><br><span class="line">    head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>;i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge</span><br><span class="line">                    [i].cost )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].cost;</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre[t] == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是最大流,cost 存的是最小费用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostMaxflow</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> &amp;cost)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(s,t))&#123;</span><br><span class="line">        <span class="type">int</span> Min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pre[t];i != - <span class="number">1</span>;i = pre[edge[i^<span class="number">1</span>].to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt; edge[i].cap - edge[i].flow)</span><br><span class="line">                Min = edge[i].cap - edge[i].flow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pre[t];i != - <span class="number">1</span>;i = pre[edge[i^<span class="number">1</span>].to])&#123;</span><br><span class="line">            edge[i].flow += Min;</span><br><span class="line">            edge[i^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            cost += edge[i].cost * Min;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += Min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line">vector&lt;pii&gt; vm, vh;</span><br><span class="line"><span class="type">int</span> n, m, start, en, id, id1, cost;</span><br><span class="line"><span class="type">char</span> g[<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ID</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * m + j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n &amp;&amp; !m) <span class="keyword">break</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        en = n * m + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(en + <span class="number">1</span>);</span><br><span class="line">        vm.<span class="built_in">clear</span>();</span><br><span class="line">        vh.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    vm.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(i, j));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">                    vh.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;pii&gt;::iterator it = vm.<span class="built_in">begin</span>(); it != vm.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            pii i = *it;</span><br><span class="line">            id = <span class="built_in">ID</span>(i.x, i.y);</span><br><span class="line">            <span class="built_in">addedge</span>(start, id, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(vector&lt;pii&gt;::iterator it1 = vh.<span class="built_in">begin</span>(); it1 != vh.<span class="built_in">end</span>(); it1++) &#123;</span><br><span class="line">                pii j = *it1;</span><br><span class="line">                id1 = <span class="built_in">ID</span>(j.x, j.y);</span><br><span class="line">                cost = <span class="built_in">abs</span>(i.x - j.x) + <span class="built_in">abs</span>(i.y - j.y);</span><br><span class="line">                <span class="built_in">addedge</span>(id, id1, <span class="number">1</span>, cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;pii&gt;::iterator it = vh.<span class="built_in">begin</span>(); it != vh.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            pii i = *it;</span><br><span class="line">            id = <span class="built_in">ID</span>(i.x, i.y);</span><br><span class="line">            <span class="built_in">addedge</span>(id, en, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">minCostMaxflow</span>(start, en, cost);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-POJ-2516-Minimum-Cost"><a href="#E-POJ-2516-Minimum-Cost" class="headerlink" title="E. POJ 2516 Minimum Cost"></a>E. POJ 2516 Minimum Cost</h1><p>最小费用最大流问题，需要将每个物品分别处理，最后累加。假如直接将所有物品一起建图处理的话，不仅麻烦，而且会超时。<br>套路：把一个问题分成几个子问题来求解，可降低时间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* SPFA版最小费用最大流算法(Tested 1 times)</span></span><br><span class="line"><span class="comment"> * 最小费用最大流,求最大费用只需要取相反数,结果取相反数即可。</span></span><br><span class="line"><span class="comment"> * 点的总数为 N,点的编号 0 ~ N-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow,cost;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN],tol;</span><br><span class="line"><span class="type">int</span> pre[MAXN],dis[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> NN;<span class="comment">//节点总个数,节点编号从 0 ∼ NN-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    NN = n;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap,<span class="type">int</span> cost)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v;</span><br><span class="line">    edge[tol].cap = cap;</span><br><span class="line">    edge[tol].cost = cost;</span><br><span class="line">    edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];</span><br><span class="line">    head[u] = tol++;</span><br><span class="line">    edge[tol].to = u;</span><br><span class="line">    edge[tol].cap = <span class="number">0</span>;</span><br><span class="line">    edge[tol].cost = -cost;</span><br><span class="line">    edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];</span><br><span class="line">    head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; NN;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>;i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge</span><br><span class="line">                    [i].cost )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].cost;</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre[t] == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是最大流,cost 存的是最小费用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostMaxflow</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> &amp;cost)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(s,t))&#123;</span><br><span class="line">        <span class="type">int</span> Min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pre[t];i != - <span class="number">1</span>;i = pre[edge[i^<span class="number">1</span>].to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt; edge[i].cap - edge[i].flow)</span><br><span class="line">                Min = edge[i].cap - edge[i].flow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pre[t];i != - <span class="number">1</span>;i = pre[edge[i^<span class="number">1</span>].to])&#123;</span><br><span class="line">            edge[i].flow += Min;</span><br><span class="line">            edge[i^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            cost += edge[i].cost * Min;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += Min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, need, ans, cost, a[<span class="number">109</span>][<span class="number">109</span>], start, en, b[<span class="number">109</span>][<span class="number">109</span>], d, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        need = <span class="number">0</span>, tot = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a[i] + j);</span><br><span class="line">                need += a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b[i] + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start = <span class="number">0</span>, en = n + m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> o = <span class="number">0</span>; o &lt; k; o++) &#123;</span><br><span class="line">            <span class="built_in">init</span>(en + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="built_in">addedge</span>(start, i + <span class="number">1</span>, b[i][o], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">addedge</span>(m + i + <span class="number">1</span>, en, a[i][o], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">                    <span class="built_in">addedge</span>(j + <span class="number">1</span>, m + i + <span class="number">1</span>, INF, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += <span class="built_in">minCostMaxflow</span>(start, en, cost);</span><br><span class="line">            ans += cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot != need)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="F-POJ-1459-Power-Network"><a href="#F-POJ-1459-Power-Network" class="headerlink" title="F. POJ 1459 Power Network"></a>F. POJ 1459 Power Network</h1><p>最大流问题，题意有点难懂，输入需要点处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">109</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">20409</span>;<span class="comment">//边数的最大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, np, nc, m, start, en, u, v, cap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;np, &amp;nc, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        start = <span class="number">0</span>, en = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; (%d,%d)%d&quot;</span>, &amp;u, &amp;v, &amp;cap);</span><br><span class="line">            <span class="built_in">addedge</span>(u + <span class="number">1</span>, v + <span class="number">1</span>, cap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; np; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; (%d)%d&quot;</span>, &amp;u, &amp;cap);</span><br><span class="line">            <span class="built_in">addedge</span>(start, u + <span class="number">1</span>, cap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nc; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; (%d)%d&quot;</span>, &amp;u, &amp;cap);</span><br><span class="line">            <span class="built_in">addedge</span>(u + <span class="number">1</span>, en, cap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">sap</span>(start, en, en + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-HDU-4280-Island-Transport"><a href="#G-HDU-4280-Island-Transport" class="headerlink" title="G. HDU 4280 Island Transport"></a>G. HDU 4280 Island Transport</h1><p>最大流问题，很裸，但是直接上dinic算法的话，会超时，需要用带优化的ISPA算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">400010</span>;<span class="comment">//边数的最大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> start, en, mifix, mafix, T, n, m, x, u, v, cap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125; </span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        start = <span class="number">-1</span>, mifix = INF, en = <span class="number">-1</span>, mafix = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%*d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x &lt; mifix) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                mifix = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; mafix) &#123;</span><br><span class="line">                en = i;</span><br><span class="line">                mafix = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;cap);</span><br><span class="line">            u--, v--;</span><br><span class="line">            <span class="built_in">addedge</span>(u, v, cap);</span><br><span class="line">            <span class="built_in">addedge</span>(v, u, cap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">sap</span>(start, en, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="H-HDU-4292-Food"><a href="#H-HDU-4292-Food" class="headerlink" title="H. HDU 4292 Food"></a>H. HDU 4292 Food</h1><p>最大流问题，是POJ 3281的升级版，灵活修改一下边权即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1009</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">400010</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, f, d, start, en, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;f, &amp;d)) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        start = <span class="number">0</span>, en = f + <span class="number">2</span> * n + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= f; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            <span class="built_in">addedge</span>(start, i, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            <span class="built_in">addedge</span>(f + <span class="number">2</span> * n + i, en, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">addedge</span>(f + i, f + n + i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= f; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getchar</span>() == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">addedge</span>(j, f + i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= d; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getchar</span>() == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">addedge</span>(f + n + i, f + <span class="number">2</span> * n + j, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">sap</span>(start, en, en + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-HDU-4289-Control"><a href="#I-HDU-4289-Control" class="headerlink" title="I. HDU 4289 Control"></a>I. HDU 4289 Control</h1><p>最小割问题，需要拆点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">409</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">400010</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, start, en, d, u, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;start, &amp;en);</span><br><span class="line">        en += n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">addedge</span>(i, i + n, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">addedge</span>(u + n, v, INF);</span><br><span class="line">            <span class="built_in">addedge</span>(v + n, u, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">sap</span>(start, en, <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="J-UVA-10480-Sabotage"><a href="#J-UVA-10480-Sabotage" class="headerlink" title="J. UVA 10480 Sabotage"></a>J. UVA 10480 Sabotage</h1><p>最小割问题，要求输出割边。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* EK算法：解决最大流问题，使用邻接矩阵，可打印路径(Tested 0 times)</span></span><br><span class="line"><span class="comment"> * 初始化：g[][], start, end, nn</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|V| * |E| * |E|)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> g[MAXN][MAXN];<span class="comment">//存边的容量，没有边的初始化为0</span></span><br><span class="line"><span class="type">int</span> path[MAXN], flow[MAXN], start, en;</span><br><span class="line"><span class="type">int</span> nn;<span class="comment">//点的个数，编号0-nn.nn包括了源点和汇点</span></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i,t;</span><br><span class="line">    <span class="built_in">memset</span>(flow, <span class="number">0</span>, <span class="keyword">sizeof</span> flow);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();<span class="comment">//把清空队列</span></span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="keyword">sizeof</span> path);<span class="comment">//每次搜索前都把路径初始化成-1</span></span><br><span class="line">    path[start] = <span class="number">0</span>;</span><br><span class="line">    flow[start] = INF;<span class="comment">//源点可以有无穷的流流进</span></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t == en) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//枚举所有的点，如果点的编号起始点有变化可以改这里</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= nn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != start &amp;&amp; path[i] == <span class="number">-1</span> &amp;&amp; g[t][i]) &#123;</span><br><span class="line">                flow[i] = <span class="built_in">min</span>(flow[t], g[t][i]);</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                path[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(path[en] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找不到增广路径了</span></span><br><span class="line">    <span class="keyword">return</span> flow[en];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_flow = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> step, now, pre;</span><br><span class="line">    <span class="keyword">while</span>((step = <span class="built_in">bfs</span>()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        max_flow += step;</span><br><span class="line">        now = en;</span><br><span class="line">        <span class="keyword">while</span>(now != start) &#123;</span><br><span class="line">            pre = path[now];</span><br><span class="line">            g[pre][now] -= step;</span><br><span class="line">            g[now][pre] += step;</span><br><span class="line">            now = pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line">pii a[N];</span><br><span class="line"><span class="type">int</span> n, m, w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;w);</span><br><span class="line">            g[a[i].x][a[i].y] = g[a[i].y][a[i].x] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        start = <span class="number">1</span>, en = <span class="number">2</span>, nn = n;</span><br><span class="line">        <span class="built_in">max_flow</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((flow[a[i].x] &amp;&amp; !flow[a[i].y]) || (flow[a[i].y] &amp;&amp; !flow[a[i].x]))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[i].x, a[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="K-HDU-2732-Leapin’-Lizards"><a href="#K-HDU-2732-Leapin’-Lizards" class="headerlink" title="K. HDU 2732 Leapin’ Lizards"></a>K. HDU 2732 Leapin’ Lizards</h1><p>最大流问题，需要拆点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 3+ times)</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1001</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">20009</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[<span class="number">29</span>][<span class="number">29</span>];</span><br><span class="line"><span class="type">int</span> n, m, d, start, en, T, kase;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ID</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        m = <span class="built_in">strlen</span>(g[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        start = <span class="number">0</span>, en = <span class="number">2</span> * n * m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">addedge</span>(<span class="built_in">ID</span>(i, j), n * m + <span class="built_in">ID</span>(i, j), g[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x = -d; x &lt;= d; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = -d; y &lt;= d; y++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!x &amp;&amp; !y) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">abs</span>(x) + <span class="built_in">abs</span>(y) &gt; d) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="type">int</span> nx = i + x, ny = j + y;</span><br><span class="line">                        <span class="keyword">if</span>(nx &lt; <span class="number">1</span> ||  nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; m) &#123;</span><br><span class="line">                            <span class="built_in">addedge</span>(n * m + <span class="built_in">ID</span>(i, j), en, <span class="number">3</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="built_in">addedge</span>(n * m + <span class="built_in">ID</span>(i, j), <span class="built_in">ID</span>(nx, ny), <span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="built_in">addedge</span>(start, <span class="built_in">ID</span>(i, j), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans -= <span class="built_in">sap</span>(start, en, en + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: no lizard was left behind.\n&quot;</span>, ++kase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d lizard was left behind.\n&quot;</span>, ++kase, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d lizards were left behind.\n&quot;</span>, ++kase, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="L-HDU-3338-Kakuro-Extension"><a href="#L-HDU-3338-Kakuro-Extension" class="headerlink" title="L. HDU 3338 Kakuro Extension"></a>L. HDU 3338 Kakuro Extension</h1><p>行列模型的最大流问题，比较神奇。<br>还需要处理一下最小下界流量的限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 6 times)</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|E| * |V| * |V|)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">400010</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="comment">// start起点，end为终点，nodeNum为顶点数，一般为en+1，注意en不为最后一个顶点的情况！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> nodeNum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, lx[<span class="number">109</span>][<span class="number">109</span>], ly[<span class="number">109</span>][<span class="number">109</span>], num[<span class="number">10009</span>], cnt, id[<span class="number">109</span>][<span class="number">109</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">109</span>][<span class="number">109</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(lx, <span class="number">0</span>, <span class="keyword">sizeof</span> lx);</span><br><span class="line">        <span class="built_in">memset</span>(ly, <span class="number">0</span>, <span class="keyword">sizeof</span> ly);</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i][j], <span class="string">&quot;.......&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span> || lx[i][j - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                        lx[i][j] = ++cnt;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        lx[i][j] = cnt;</span><br><span class="line">                    num[cnt]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i][j], <span class="string">&quot;.......&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || lx[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">                        ly[i][j] = ++cnt;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ly[i][j] = cnt;</span><br><span class="line">                    num[cnt]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, en = cnt + <span class="number">1</span>, nodeNum = en + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i][j], <span class="string">&quot;.......&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    id[i][j] = tol;</span><br><span class="line">                    <span class="built_in">addedge</span>(lx[i][j], ly[i][j], <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j][<span class="number">3</span>] != <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j][<span class="number">0</span>] != <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> t = (s[i][j][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">100</span> + (s[i][j][<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span></span><br><span class="line">                        + (s[i][j][<span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="built_in">addedge</span>(ly[i + <span class="number">1</span>][j], en, t - num[ly[i + <span class="number">1</span>][j]]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j][<span class="number">4</span>] != <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> t = (s[i][j][<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">100</span> + (s[i][j][<span class="number">5</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span></span><br><span class="line">                        + (s[i][j][<span class="number">6</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="built_in">addedge</span>(start, lx[i][j + <span class="number">1</span>], t - num[lx[i][j + <span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sap</span>(start, en, nodeNum);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j) <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i][j], <span class="string">&quot;.......&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span> + edge[id[i][j]].flow + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="M-HDU-3605-Escape"><a href="#M-HDU-3605-Escape" class="headerlink" title="M. HDU 3605 Escape"></a>M. HDU 3605 Escape</h1><p>最大流问题，直接建流量为1的图会TLE，需要把同种类型的人看做一个点，然后建流量等于人数的边。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100029</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = MAXN * <span class="number">23</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>) * t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, start, en, d, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        start = <span class="number">0</span>, en = (<span class="number">1</span> &lt;&lt; m) + m;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (<span class="number">1</span> &lt;&lt; m));</span><br><span class="line">        <span class="built_in">init</span>(en + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">                <span class="keyword">if</span>(d) sum += <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; up; i++) &#123;</span><br><span class="line">            <span class="built_in">addedge</span>(start, i, cnt[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="built_in">addedge</span>(i, up + j, cnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">addedge</span>(up + i, en, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">sap</span>(start, en, en + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans == n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="N-HDU-3081-Marriage-Match-II"><a href="#N-HDU-3081-Marriage-Match-II" class="headerlink" title="N. HDU 3081 Marriage Match II"></a>N. HDU 3081 Marriage Match II</h1><p>最大流问题 + 二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">209</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">20409</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM], edget[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v]; head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge[S[i]].cap - edge[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge[S[i]].flow += Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[u] == u ? u : fa[u] = <span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uf</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(u)] = fa[<span class="built_in">find</span>(v)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, k, u, v;</span><br><span class="line"><span class="type">int</span> headt[N];</span><br><span class="line">vi to[N], too[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, en = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            to[i].<span class="built_in">clear</span>();</span><br><span class="line">            too[i].<span class="built_in">clear</span>();</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            to[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">uf</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fa = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j: to[i]) &#123;</span><br><span class="line">                too[fa].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(too[i].<span class="built_in">begin</span>(), too[i].<span class="built_in">end</span>());</span><br><span class="line">            too[i].<span class="built_in">resize</span>(<span class="built_in">unique</span>(too[i].<span class="built_in">begin</span>(), too[i].<span class="built_in">end</span>()) - too[i].<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fa = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j: too[fa]) &#123;</span><br><span class="line">                <span class="built_in">addedge</span>(i, n + j, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tolt = tol;</span><br><span class="line">        <span class="built_in">memcpy</span>(headt, head, <span class="keyword">sizeof</span> head);</span><br><span class="line">        <span class="built_in">memcpy</span>(edget, edge, <span class="keyword">sizeof</span> edge);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> != r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(head, headt, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (en + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">memcpy</span>(edge, edget, <span class="built_in">sizeof</span>(Edge) * (tol + <span class="number">1</span>));</span><br><span class="line">            tol = tolt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">addedge</span>(start, i, mid);</span><br><span class="line">                <span class="built_in">addedge</span>(n + i, en, mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">sap</span>(start, en, en + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(t == n * mid)</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="O-HDU-3416-Marriage-Match-IV"><a href="#O-HDU-3416-Marriage-Match-IV" class="headerlink" title="O. HDU 3416 Marriage Match IV"></a>O. HDU 3416 Marriage Match IV</h1><p>最大流问题 + 最短路问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[<span class="number">2</span>][<span class="number">1009</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, c, next;</span><br><span class="line">    <span class="built_in">Edge</span> () &#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span> (<span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> next): <span class="built_in">v</span>(v), <span class="built_in">c</span>(c), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;edge[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> ty)</span> </span>&#123;</span><br><span class="line">    edge[tot] = Edge&#123;v, c, head[ty][u]&#125;;</span><br><span class="line">    head[ty][u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* dijkstra算法：解决最短路问题(Tested 0 times)</span></span><br><span class="line"><span class="comment"> * 前向心存图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_V=<span class="number">10009</span>;</span><br><span class="line"><span class="type">int</span> d[<span class="number">2</span>][MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> ty)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; que;</span><br><span class="line">    d[ty][s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">pii</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pii p = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = p.second;</span><br><span class="line">        <span class="keyword">if</span>(d[ty][u] &lt; p.first) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[ty][u]; ~i; i = edge[i].next) &#123;</span><br><span class="line">            Edge e = edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[ty][e.v] &gt; d[ty][u] + e.c) &#123;</span><br><span class="line">                d[ty][e.v] = d[ty][u] + e.c;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">pii</span>(d[ty][e.v], e.v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 注意修改MAXN和MAXM成适合的大小，以提高时间效率</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|E| * |V| * |V|)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1009</span>;<span class="comment">//点数的最大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">200009</span>;<span class="comment">//边数的最大值，注意反向边也要算进去，也就是说要乘以2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge1</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge1[MAXM];<span class="comment">//注意是 MAXM</span></span><br><span class="line"><span class="type">int</span> tol;</span><br><span class="line"><span class="type">int</span> head1[MAXN];</span><br><span class="line"><span class="type">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head1,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> rw = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    edge1[tol].to = v; edge1[tol].cap = w; edge1[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge1[tol].next = head1[u]; head1[u] = tol++;</span><br><span class="line">    edge1[tol].to = u; edge1[tol].cap = rw; edge1[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge1[tol].next = head1[v]; head1[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="built_in">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    dep[end] = <span class="number">0</span>;</span><br><span class="line">    Q[rear++] = end;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)&#123;</span><br><span class="line">        <span class="type">int</span> u = Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head1[u]; i != <span class="number">-1</span>; i = edge1[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge1[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sap</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head1,<span class="built_in">sizeof</span>(head1));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = start;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start] &lt; N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == end)&#123;</span><br><span class="line">            <span class="type">int</span> Min = INF;</span><br><span class="line">            <span class="type">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; edge1[S[i]].cap - edge1[S[i]].flow)&#123;</span><br><span class="line">                    Min = edge1[S[i]].cap - edge1[S[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; top;i++)&#123;</span><br><span class="line">                edge1[S[i]].flow += Min;</span><br><span class="line">                edge1[S[i]^<span class="number">1</span>].flow -= Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Min;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge1[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; i != <span class="number">-1</span>; i = edge1[i].next)&#123;</span><br><span class="line">            v = edge1[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge1[i].cap - edge1[i].flow &amp;&amp; dep[v]+<span class="number">1</span> == dep[u])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Min = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head1[u]; i != <span class="number">-1</span>; i = edge1[i].next)</span><br><span class="line">            <span class="keyword">if</span>(edge1[i].cap - edge1[i].flow &amp;&amp; dep[edge1[i].to] &lt; Min)</span><br><span class="line">            &#123;</span><br><span class="line">                Min = dep[edge1[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = Min + <span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u != start)u = edge1[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, u, v, c[N];</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, c + i);</span><br><span class="line">            a[i] = <span class="built_in">pii</span>(u, v);</span><br><span class="line">            <span class="built_in">addedge</span>(u, v, c[i], <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addedge</span>(v, u, c[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">dijkstra</span>(u, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dijkstra</span>(v, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">init1</span>();</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, en = v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[<span class="number">0</span>][a[i].x] + c[i] + d[<span class="number">1</span>][a[i].y] == d[<span class="number">0</span>][v]) &#123;</span><br><span class="line">                <span class="built_in">addedge1</span>(a[i].x, a[i].y, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addedge1</span>(start, u, INF);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sap</span>(start, en, n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1020D The hat</title>
    <url>/2018/08/14/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有n($2 &lt;&#x3D; n &lt;&#x3D; 1e5, n 为偶数$)个人围成一个圈，每个人有一个身上有一个号码，且相邻两人的号码差值为1，现在需要求是否存在一对对侧的人的号码相同，假如存在，输出下标，假如不存在，输出-1。<br>最多询问60次，具体交互规则请参考原题。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先注意到假如对侧两人的差值为奇数，那么一定不存在答案，输出-1。<br>否则，因为差值是从负数渐变到正数的，所以肯定存在答案，二分即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;? %d\n&quot;</span>, id);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, d[N], l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n / <span class="number">2</span>;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="built_in">ask</span>(<span class="number">1</span>) - <span class="built_in">ask</span>(<span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">if</span>(d[<span class="number">1</span>] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! -1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="number">1</span>, r = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span> &amp;&amp; l + <span class="number">1</span> != r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        d[mid] = <span class="built_in">ask</span>(mid) - <span class="built_in">ask</span>(mid + m);</span><br><span class="line">        <span class="keyword">if</span>(d[mid] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>, mid);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((d[l] &lt; <span class="number">0</span> &amp;&amp; d[mid] &lt; <span class="number">0</span>) || (d[l] &gt; <span class="number">0</span> &amp;&amp; d[mid] &gt; <span class="number">0</span>))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    d[l] = <span class="built_in">ask</span>(l) - <span class="built_in">ask</span>(l + m);</span><br><span class="line">    <span class="keyword">if</span>(d[l] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1020E Sergey&#39;s problem</title>
    <url>/2018/08/14/1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个可能有环（但肯定没有自环）的有向图，n($1 &lt;&#x3D; n &lt;&#x3D; 1e6$)个点，m($1 &lt;&#x3D; m &lt;&#x3D; 1e6$)条边，现在需要你选择一个点集，使得这些点之间没有连边，且这些点到点集之外的点的距离不超过2。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先任意选择一点A放到点集里面，则这个点指向的点都不能放到点集里面，我们从原图中删掉这些点，然后再从残余图中找点集，假设这个点集为M。假如点集M中存在一点B有指向A的边，为了处理掉这个冲突，我们删掉A，因为B到A指向的点的距离不超过2，所以保证覆盖了全图。假如不存在，那么我们就将点集M和A合并，也保证了覆盖全图。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[<span class="number">2</span>][N], tot, n, m, u, v;</span><br><span class="line"><span class="type">bool</span> vis[N], used[N];;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nex;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    edge[tot] = node&#123;v, head[id][u]&#125;;</span><br><span class="line">    head[id][u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u &lt;= n &amp;&amp; vis[u]) u++;</span><br><span class="line">    <span class="keyword">if</span>(u == n + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    used[u] = vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[<span class="number">0</span>][u]; ~i; i = edge[i].nex) &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[<span class="number">1</span>][u]; ~i; i = edge[i].nex) &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(used[v]) &#123;</span><br><span class="line">            used[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">addedge</span>(u, v, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addedge</span>(v, u, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        vi ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(used[i])</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)ans.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i], <span class="string">&quot; \n&quot;</span>[ans.<span class="built_in">size</span>() - <span class="number">1</span> == i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>构造</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2243 考研路茫茫――单词情结 题解</title>
    <url>/2018/08/16/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给了n($0 &lt; n &lt; 6$)个模式串，需要求至少包含一个模式串、长度最长为L($ 0 &lt; L &lt; 2^{31} $)的字符串数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注意到是多模式串匹配问题，所以考虑用AC自动机。又因为至少包含一个模式串的问题不太好直接求解，因此我们将其转化为求一个模式串都不包含的问题。我们用模式串建立AC自动机，每个模式串最终走到的节点是不合法的，且假如它的失配指针指向的节点是不合法的话，它也是不合法的，因为它指向的节点是它的一个后缀。然后，假设AC自动机的节点个数为$L$，那么我们就可以建立一个$ L * L $的方案矩阵，这个矩阵的$mat[i][j]$表示$i$到$j$的合法方案数，将这个矩阵求$n$次幂，就得到了走$n$步的方案矩阵。但是由于我们需要求走了$1$ ~ $n$步的方案数，所以需要求和，需要给矩阵最右端增加一列，全置为1，那么第一行最后一列的值减去1就是走了$1$ ~ $n-1$步的方案数。至于字符串总数，也是可以通过构造矩阵求解的，具体构造方法请参考代码。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 矩阵快速幂：根据递推式快速计算第n项(Untested)</span></span><br><span class="line"><span class="comment"> * 矩阵构造、时间复杂度参考白书P201</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义矩阵元素为long long的矩阵：</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ull&gt; vll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vll&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat A, mat B)</span></span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">C</span><span class="params">(A.size(), vll(B[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;	</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">                C[i][j] = (C[i][j] + A[i][k] * B[k][j]);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat A, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">B</span><span class="params">(A.size(), vll(A.size(), <span class="number">0</span>))</span></span>;		</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B.<span class="built_in">size</span>(); i++)</span><br><span class="line">        B[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) B = <span class="built_in">mul</span>(B, A);</span><br><span class="line">        A = <span class="built_in">mul</span>(A, A);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 1 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">39</span>][<span class="number">26</span>], fail[<span class="number">39</span>], end[<span class="number">39</span>], idx, root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">true</span>;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(end[fail[now]] == <span class="literal">true</span>)</span><br><span class="line">                end[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ull <span class="title">cntIllegal</span><span class="params">(ll L)</span> </span>&#123;</span><br><span class="line">        <span class="function">mat <span class="title">a</span><span class="params">(idx + <span class="number">1</span>, vll(idx + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">                <span class="keyword">if</span>(end[next[i][j]] == <span class="literal">false</span>)</span><br><span class="line">                    a[i][next[i][j]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx + <span class="number">1</span>; i++)</span><br><span class="line">            a[i][idx] = <span class="number">1</span>;</span><br><span class="line">        a = <span class="built_in">pow</span>(a, L);</span><br><span class="line">        ull ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx + <span class="number">1</span>; i++)</span><br><span class="line">            ans += a[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll L;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;L)) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">mat <span class="title">a</span><span class="params">(<span class="number">2</span>, vll(<span class="number">2</span>, <span class="number">0</span>))</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>, vll(<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">26</span>, a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a = <span class="built_in">pow</span>(a, L);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, b);</span><br><span class="line">        ull ans = a[<span class="number">0</span>][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ans -= ac.<span class="built_in">cntIllegal</span>(L);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>计数</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1023E Down or Right 题解</title>
    <url>/2018/08/18/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>已知一个n×n$(2 &lt;&#x3D; n &lt;&#x3D; 500)$的迷宫中存在一条(1, 1)到达(n, n)的路径，行走方向只能是向下或向右。现在需要你通过不超过$4*n$次的询问找出这条路径，注意每次询问的两个点曼哈顿距离不能小于$n-1$。<br>具体交互规则请参考原题。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注意到次对角线一定存在一点可同时到达(1, 1)和(n, n)，因此，问题转化成了找(1, 1)到达这一点的路径以及这一点到达(n, n)的路径的问题。<br>具体来说，我们首先固定(n, n)，然后从(1, 1)出发，不断询问下边一点和右边一点能否到达(n, n)，通过$n-1$次询问即可到达次对角线上的一点。同理，我们可以再找出从(n, n)到次对角线上一点的路线。为了保证(1, 1)和(n, n)到达的次对角线的位置是相同的，我们需要让从(1, 1)出发的路线尽可能往下走，然后从(n, n)出发的路线尽可能地往左走。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">509</span>][<span class="number">509</span>], x, y;</span><br><span class="line">pii pre[<span class="number">509</span>][<span class="number">509</span>];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> xx, <span class="type">int</span> yy)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; xx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; yy &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ask</span>(x + <span class="number">1</span>, y, n, n)) &#123;</span><br><span class="line">            x++;</span><br><span class="line">            a[x][y]++;</span><br><span class="line">            pre[x][y] = <span class="built_in">pii</span>(x - <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y++;</span><br><span class="line">            a[x][y]++;</span><br><span class="line">            pre[x][y] = <span class="built_in">pii</span>(x, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span>(!(x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[x][y].x == x) &#123;</span><br><span class="line">            y--;</span><br><span class="line">            ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x--;</span><br><span class="line">            ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    x = n, y = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, x, y - <span class="number">1</span>)) &#123;</span><br><span class="line">            y--;</span><br><span class="line">            a[x][y]++;</span><br><span class="line">            pre[x][y] = <span class="built_in">pii</span>(x, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x--;</span><br><span class="line">            a[x][y]++;</span><br><span class="line">            pre[x][y] = <span class="built_in">pii</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(x == n &amp;&amp; y == n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[x][y].x == x) &#123;</span><br><span class="line">            y++;</span><br><span class="line">            ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x++;</span><br><span class="line">            ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2825 Wireless Password 题解</title>
    <url>/2018/08/18/1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>已知有m个单词，问有多少个长度为n的、且至少含有m个单词中的k个的WIFI密码，注意单词可以重叠。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注意到是多模式串匹配问题，考虑用AC自动机建状态转移图。节点上标记下该节点覆盖了哪些单词，用一个int表示即可，注意要或上fail指针指向节点的标记。然后以dp[i][j][k]表示从单词长度为i、当前节点为j、覆盖单词为k的方案数，转移途径为j的下一个节点。最终答案就是单词长度为n、图上各节点、覆盖单词数不小于k的dp和。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">20090717</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">19</span>];</span><br><span class="line"><span class="type">int</span> n, m, k, dp[<span class="number">26</span>][<span class="number">109</span>][<span class="number">1029</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx, status;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> idx, <span class="type">int</span> status): <span class="built_in">idx</span>(idx), <span class="built_in">status</span>(status)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 3 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">109</span>][<span class="number">26</span>], fail[<span class="number">109</span>], end[<span class="number">109</span>], idx, root; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            end[now] |= end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); k++)</span><br><span class="line">                    dp[i][j][k] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        queue&lt;node&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(node&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">bool</span> vis[<span class="number">259</span>][<span class="number">1029</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            queue&lt;node&gt; nextque;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">            <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                node t = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> o = <span class="number">0</span>; o &lt; <span class="number">26</span>; o++) &#123;</span><br><span class="line">                    <span class="type">int</span> j = t.idx;</span><br><span class="line">                    <span class="type">int</span> k = t.status;</span><br><span class="line">                    <span class="type">int</span> newj = next[j][o];</span><br><span class="line">                    <span class="type">int</span> newk = t.status | end[newj];</span><br><span class="line">                    dp[i][newj][newk] += dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][newj][newk] &gt;= mod)</span><br><span class="line">                        dp[i][newj][newk] -= mod;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[newj][newk]) &#123;</span><br><span class="line">                        vis[newj][newk] = <span class="literal">true</span>;</span><br><span class="line">                        nextque.<span class="built_in">push</span>(&#123;newj, newk&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            que = nextque;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 可以把__builtin_popcount(j)预处理掉，这样更快</span></span><br><span class="line">                <span class="keyword">if</span>(__builtin_popcount(j) &gt;= k) &#123;</span><br><span class="line">                    ans += dp[n][i][j];</span><br><span class="line">                    <span class="keyword">if</span>(ans &gt;= mod)</span><br><span class="line">                        ans -= mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k) &amp;&amp; n) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1025D Recovering BST 题解</title>
    <url>/2018/08/21/0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个升序序列，问能否构造任意相邻节点的gcd都大于1的二叉排序树。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注意到n最大只有700，可考虑$n^3$的做法。令dp[i][j][0]表示$i$ ~ $j$的元素能否构造出以$i - 1$为根的二叉排序树，令dp[i][j][1]表示$i$ ~ $j$的元素能否构造出以$j + 1$为根的二叉排序树。至于转移方程，以dp[i][j][0]为例，它的根为$i - 1$，右儿子可以是下标为$i$ ~ $j$中某个数组元素，我们枚举这个右儿子，不妨设下标为$k$，判断根与它能否连边，以及$i$ ~ $k - 1$能否作为$k$的左子树，$k + 1$ ~ $j$ 能否于作为$k$的右子树。另外需要注意处理好dp边界。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">700</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], dp[N][N][<span class="number">2</span>], n, link[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(__gcd(a[i], a[j]) &gt;= <span class="number">2</span>)</span><br><span class="line">                    link[i][j] = link[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            link[<span class="number">0</span>][i] = link[i][n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            dp[i][i<span class="number">-1</span>][<span class="number">0</span>] = dp[i+<span class="number">1</span>][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = i + len - <span class="number">1</span>; j &lt;= n; i++, j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(link[i<span class="number">-1</span>][k])</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] |= dp[i][k<span class="number">-1</span>][<span class="number">0</span>] &amp; dp[k+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(link[k][j+<span class="number">1</span>])</span><br><span class="line">                        dp[i][j][<span class="number">0</span>] |= dp[i][k<span class="number">-1</span>][<span class="number">0</span>] &amp; dp[k+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dp[<span class="number">1</span>][n][<span class="number">0</span>]?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>回文自动机学习笔记</title>
    <url>/2018/09/04/palindromic-tree-learning/</url>
    <content><![CDATA[<p>回文自动机是一种可以处理回文符问题的优雅高效的数据结构。</p>
<h1 id="URAL-1960-Palindromes-and-Super-Abilities"><a href="#URAL-1960-Palindromes-and-Super-Abilities" class="headerlink" title="URAL 1960 Palindromes and Super Abilities"></a>URAL 1960 Palindromes and Super Abilities</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求各前缀的所有子串中的回文串种类。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>依次插入字符，每插入完一个字符，假如last指针所指的节点是新增的，那么答案加一。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 0 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Palindromic_Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[MAXN][NN] ;<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="type">int</span> fail[MAXN] ;<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="type">int</span> cnt[MAXN] ; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="type">int</span> num[MAXN] ; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="type">int</span> len[MAXN] ;<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="type">int</span> S[MAXN] ;<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="type">int</span> last ;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="type">int</span> n ;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="type">int</span> p ;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span> <span class="params">( <span class="type">int</span> l )</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; NN ; ++ i ) next[p][i] = <span class="number">0</span> ;</span><br><span class="line">        cnt[p] = <span class="number">0</span> ;</span><br><span class="line">        num[p] = <span class="number">0</span> ;</span><br><span class="line">        len[p] = l ;</span><br><span class="line">        <span class="keyword">return</span> p ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">newnode</span> (  <span class="number">0</span> ) ;</span><br><span class="line">        <span class="built_in">newnode</span> ( <span class="number">-1</span> ) ;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        n = <span class="number">0</span> ;</span><br><span class="line">        S[n] = <span class="number">-1</span> ;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_fail</span> <span class="params">( <span class="type">int</span> x )</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span> ( S[n - len[x] - <span class="number">1</span>] != S[n] ) x = fail[x] ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">( <span class="type">int</span> c )</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span> ;</span><br><span class="line">        S[++ n] = c ;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">get_fail</span> ( last ) ;<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> ( !next[cur][c] ) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="type">int</span> now = <span class="built_in">newnode</span> ( len[cur] + <span class="number">2</span> ) ;<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[<span class="built_in">get_fail</span> ( fail[cur] )][c] ;<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now ;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c] ;</span><br><span class="line">        cnt[last] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i ) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.<span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pt.<span class="built_in">add</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(pt.cnt[pt.last] == <span class="number">1</span>)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans, <span class="string">&quot; \n&quot;</span>[i == len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tsinsen-A1280-最长双回文串"><a href="#Tsinsen-A1280-最长双回文串" class="headerlink" title="Tsinsen A1280 最长双回文串"></a>Tsinsen A1280 最长双回文串</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个字符串，在中间某个位置切开，能形成两个回文串，则称这个回文串为双回文串。现在需要求最长双回文串。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令a[i]表示以i结束的最长回文串长度，b[i]表示从i开始的最长回文串长度。<br>每插入一个字符，就更新这两个数组，最后扫一遍，取a[i] + b[i+1]的最大值。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 2 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Palindromic_Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[MAXN][NN] ;<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="type">int</span> fail[MAXN] ;<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="type">int</span> cnt[MAXN] ; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="type">int</span> num[MAXN] ; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="type">int</span> len[MAXN] ;<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="type">int</span> S[MAXN] ;<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="type">int</span> last ;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="type">int</span> n ;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="type">int</span> p ;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span> <span class="params">( <span class="type">int</span> l )</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; NN ; ++ i ) next[p][i] = <span class="number">0</span> ;</span><br><span class="line">        cnt[p] = <span class="number">0</span> ;</span><br><span class="line">        num[p] = <span class="number">0</span> ;</span><br><span class="line">        len[p] = l ;</span><br><span class="line">        <span class="keyword">return</span> p ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">newnode</span> (  <span class="number">0</span> ) ;</span><br><span class="line">        <span class="built_in">newnode</span> ( <span class="number">-1</span> ) ;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        n = <span class="number">0</span> ;</span><br><span class="line">        S[n] = <span class="number">-1</span> ;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_fail</span> <span class="params">( <span class="type">int</span> x )</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span> ( S[n - len[x] - <span class="number">1</span>] != S[n] ) x = fail[x] ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> id, <span class="type">int</span> c )</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span> ;</span><br><span class="line">        S[++ n] = c ;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">get_fail</span> ( last ) ;<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> ( !next[cur][c] ) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="type">int</span> now = <span class="built_in">newnode</span> ( len[cur] + <span class="number">2</span> ) ;<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[<span class="built_in">get_fail</span> ( fail[cur] )][c] ;<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now ;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c] ;</span><br><span class="line">        a[id] = len[last];</span><br><span class="line">        b[id - len[last] + <span class="number">1</span>] = <span class="built_in">max</span>(b[id - len[last] + <span class="number">1</span>], len[last]);</span><br><span class="line">        cnt[last] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i ) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pt.<span class="built_in">add</span>(i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[i] + b[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Tsinsen-A1255-拉拉队排练"><a href="#Tsinsen-A1255-拉拉队排练" class="headerlink" title="Tsinsen A1255 拉拉队排练"></a>Tsinsen A1255 拉拉队排练</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>求前k大奇数长度的回文串的乘积。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先建回文自动机，然后dfs奇根节点，找出奇数长度的回文串的长度和个数，放到容器，排个序贪心取出来即可。注意不能直接递归dfs，会爆栈，需要用stack。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:1024000000,1024000000&quot;</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">19930726</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">26</span>;    <span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Palindromic_Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="type">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="type">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="type">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="type">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="type">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="type">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="type">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_fail</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">get_fail</span>(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="type">int</span> now = <span class="built_in">newnode</span>(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[<span class="built_in">get_fail</span>(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line">pii a[N];</span><br><span class="line">vector&lt;pii&gt; v;</span><br><span class="line">ll sum;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    que.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = pt.next[u][i];</span><br><span class="line">            <span class="keyword">if</span>(t) &#123;</span><br><span class="line">                sum += pt.cnt[t];</span><br><span class="line">                que.<span class="built_in">push</span>(t);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">                v.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(pt.len[t], pt.cnt[t]));</span><br><span class="line">                <span class="comment">//dfs(t);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii a, pii b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) (ans *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pt.<span class="built_in">add</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pt.<span class="built_in">count</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: v) &#123;</span><br><span class="line">            ll num = <span class="built_in">min</span>(<span class="number">1LL</span> * i.y, k);</span><br><span class="line">            (ans *= <span class="built_in">ksm</span>(i.x, num)) %= mod;</span><br><span class="line">            k -= i.y;</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Tsinsen-A1393-Palisection"><a href="#Tsinsen-A1393-Palisection" class="headerlink" title="Tsinsen A1393 Palisection"></a>Tsinsen A1393 Palisection</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>求相交回文串的对数。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>直接求相交回文串的对数的话，不好求。经过思考，发现所有回文串对数以及不相交回文串的对数比较好求，而这两者相减就是答案，得解。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">51123987</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">26</span>;    <span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Palindromic_Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="type">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="type">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="type">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="type">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="type">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="type">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="type">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_fail</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">get_fail</span>(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="type">int</span> now = <span class="built_in">newnode</span>(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[<span class="built_in">get_fail</span>(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">        <span class="keyword">return</span> num[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll sum[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s);</span><br><span class="line">    pt.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        (sum[i+<span class="number">1</span>] = sum[i] + pt.<span class="built_in">add</span>(s[i])) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    (ans = <span class="number">1LL</span> * sum[n] * (sum[n] - <span class="number">1</span>) / <span class="number">2</span>) %= mod;</span><br><span class="line">    <span class="built_in">reverse</span>(s, s + n);</span><br><span class="line">    pt.<span class="built_in">init</span>();</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        t = pt.<span class="built_in">add</span>(s[i]);</span><br><span class="line">        ans -= t * sum[n - i - <span class="number">1</span>];</span><br><span class="line">        (ans += mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Gym-100548G-The-Problem-to-Slow-Down-You"><a href="#Gym-100548G-The-Problem-to-Slow-Down-You" class="headerlink" title="Gym 100548G The Problem to Slow Down You"></a>Gym 100548G The Problem to Slow Down You</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求两个字符串中相同回文串的对数。</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先分别给两个字符串建立回文自动机，然后分别dfs一下奇偶根节点，累加两个回文自动机相同位置的节点的cnt乘积即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">26</span>;    <span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Palindromic_Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="type">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="type">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="type">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="type">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="type">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="type">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="type">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_fail</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">get_fail</span>(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="type">int</span> now = <span class="built_in">newnode</span>(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[<span class="built_in">get_fail</span>(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"><span class="type">int</span> len[<span class="number">2</span>], kase;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u0, <span class="type">int</span> u1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t0 = pt[<span class="number">0</span>].next[u0][i];</span><br><span class="line">        <span class="type">int</span> t1 = pt[<span class="number">1</span>].next[u1][i];</span><br><span class="line">        <span class="keyword">if</span>(t0 &amp;&amp; t1) &#123;</span><br><span class="line">            ans += <span class="number">1LL</span> * pt[<span class="number">0</span>].cnt[t0] * pt[<span class="number">1</span>].cnt[t1];</span><br><span class="line">            <span class="built_in">dfs</span>(t0, t1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">            len[k] = <span class="built_in">strlen</span>(s[k]);</span><br><span class="line">            pt[k].<span class="built_in">init</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len[k]; i++) &#123;</span><br><span class="line">                pt[k].<span class="built_in">add</span>(s[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            pt[k].<span class="built_in">count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>wc项目折腾笔记</title>
    <url>/2018/09/07/word-count/</url>
    <content><![CDATA[<p><a href="https://github.com/hyzgh/wordCount">Github项目地址传送门</a></p>
<h1 id="项目相关要求"><a href="#项目相关要求" class="headerlink" title="项目相关要求"></a>项目相关要求</h1><ul>
<li><p>基本功能</p>
<ul>
<li>统计C语言源文件的字符数（完成）</li>
<li>统计C语言源文件的词的数目（完成）</li>
<li>统计C语言源文件的行数（完成）</li>
</ul>
</li>
<li><p>拓展功能</p>
<ul>
<li>递归处理目录下符合条件的文件（完成）</li>
<li>返回更复杂的数据（代码行 &#x2F; 空行 &#x2F; 注释行）（完成）</li>
<li>支持各种文件的通配符（*,?）（完成）</li>
</ul>
</li>
<li><p>高级功能</p>
<ul>
<li>实现图形界面（待完成）</li>
</ul>
</li>
</ul>
<p>首先，我们需要明确一下“字符”，“词”，“行”，“代码行”，“空行”，“注释行”的定义。<br>字符：一个ASCII字符，包括控制字符和可打印字符。<br>词：一个由空白字符（不仅指空格，还指’\f’,’\v’,’\n’,’\r’这些控制字符）分隔的非空字符串。<br>行：一个由换行符分隔的字符串，可以为空。一行结束的标志是换行符。</p>
<blockquote>
</blockquote>
<p>代码行：本行包括多于一个字符的代码。<br>空行：本行全部是空格或格式控制字符，如果包括代码，则只有不超过一个可显示的字符，例如“{”。<br>注释行：本行不是代码行，并且本行包括注释。</p>
<p>以上代码行、空行、注释行的说明摘自项目说明。</p>
<p>为了消除歧义，特提出以下补充说明：<br>1.项目说明指出了下面第一行是注释行，类似的，第二行和第三行也是项目行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#125; <span class="comment">//注释</span></span><br><span class="line">&#123; <span class="comment">//注释</span></span><br><span class="line">; <span class="comment">//注释</span></span><br></pre></td></tr></table></figure>

<p>2.按照定义，下面这一行是代码行，但不是注释行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>); <span class="comment">//say &quot;Hello, world&quot;</span></span><br></pre></td></tr></table></figure>

<p>3.按照定义，第一行是代码行，但不是注释行。第二行和第三行是注释行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>); <span class="comment">/*say &quot;Hello, world&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                         */</span></span><br></pre></td></tr></table></figure>

<p>4.第二行不是空白行。第一行到第三行都是注释行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The next line is a comment line.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于字符数的统计，每读取一个字符，让<code>chracters</code>加一即可。<br>对于词数的统计，需要一个标记，用于记录前面一个字符是不是空白字符，假如前面一个字符是空白字符且当前字符是可显示字符，那么让<code>words</code>加一。<br>对于行数的统计，每读取到一个换行符，让<code>lines</code>加一即可。<br>对于空白行、代码行、注释行的统计，需要用到一个块注释标记和一些正则表达式，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">string blankLineRegex = <span class="string">&quot;(\\s*)([&#123;&#125;;]?)(\\s*)&quot;</span>;</span><br><span class="line">string lineCommentRegex = <span class="string">&quot;(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)&quot;</span>;</span><br><span class="line">string blockCommentStartFlagRegex = <span class="string">&quot;(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)&quot;</span>;</span><br><span class="line">string blockCommentStartFlag1Regex = <span class="string">&quot;(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)&quot;</span>;</span><br><span class="line">string blockCommentCloseFlagRegex = <span class="string">&quot;(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>每读取一行，首先需要判断当前行是不是位于块注释中，假如是，让注释行加一，否则进行2</li>
<li>使用blankLineRegex这个正则表达式判断当前行是不是空白行，假如是，让空白行加一，否则进行3</li>
<li>使用lineCommentRegex判断当前行是不是行注释，假如是，让注释行加一，否则进行4</li>
<li>使用blockCommentStartFlagRegex判断当前行是不是含有块注释开始的标志且为注释行，假如是，把blockCommentFlag改为true，并将注释行加一，否则进行5</li>
<li>使用blockCommentStartFlag1Regex判断当前行是不是含有块注释开始的标志且为代码行，假如是，把blockCommentFlag改为true，并将代码行加一，否则进行6</li>
<li>假如以上情况都不是，那么说明该行是代码行，让代码行加一，并结束该行的判断</li>
</ol>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>File类：</p>
<ul>
<li>变量：<code>characters, words, lines, blankLines, codeLines, commentLines</code>.</li>
<li>方法：<ul>
<li><code>countBasic</code>：统计字符数、词数、行数。</li>
<li><code>countSpecialLines</code>：统计空白行、代码行、注释行。</li>
<li><code>print</code>：输出统计结果。</li>
</ul>
</li>
</ul>
<p><code>setMode</code>函数：根据输入参数设置模式。<br><code>readFile</code>函数：处理一个文件。<br><code>recursiveReadFiles</code>函数：处理一个目录。</p>
<p>主要流程就是读取命令行参数，然后调用<code>setMode</code>设置参数，接着根据对象是文件还是目录，分别调用<code>readFile</code>或<code>recursiveReadFiles</code>。<br><code>readFile</code>接着又会调用<code>countBasic</code>和<code>countSpecialLines</code>，执行程序的核心部分，进行统计。接着调用print输出结果。</p>
<h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p>1.统计字符、词、行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countBasic</span><span class="params">(FILE *pFile)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">bool</span> spaceFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">fgetc</span>(pFile)) != EOF) &#123;</span><br><span class="line">        characters++;</span><br><span class="line"></span><br><span class="line">        words += (spaceFlag == <span class="literal">true</span> &amp;&amp; <span class="built_in">isgraph</span>(c));</span><br><span class="line">        spaceFlag = <span class="built_in">isspace</span>(c);</span><br><span class="line"></span><br><span class="line">        lines += c == <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.统计空白行、代码行、注释行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 要确定一行是不是空白行，只要通过判断该行的可打印字符个数是否不超过1个即可。另外还要注意，该行不能在块注释中。</span></span><br><span class="line"><span class="comment"> * 要确定一行是不是代码行，只要判断该行的可打印字符个数是否超过1个即可。另外还要注意，改行不在块注释中。</span></span><br><span class="line"><span class="comment"> * 假如一行是注释行，那么该行首先必须不是代码行，其次，需要有注释标志。</span></span><br><span class="line"><span class="comment"> * 根据以上信息，可写出正则表达式进行匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSpecialLines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="type">bool</span> blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">    string blankLineRegex = <span class="string">&quot;(\\s*)([&#123;&#125;;]?)(\\s*)&quot;</span>;</span><br><span class="line">    string lineCommentRegex = <span class="string">&quot;(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)&quot;</span>;</span><br><span class="line">    string blockCommentStartFlagRegex = <span class="string">&quot;(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)&quot;</span>;</span><br><span class="line">    string blockCommentStartFlag1Regex = <span class="string">&quot;(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)&quot;</span>;</span><br><span class="line">    string blockCommentCloseFlagRegex = <span class="string">&quot;(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123; <span class="keyword">if</span>(blockCommentFlag) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, <span class="built_in">regex</span>(blockCommentCloseFlagRegex))) &#123;</span><br><span class="line">                blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, <span class="built_in">regex</span>(blankLineRegex))) &#123;</span><br><span class="line">            blankLines++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, <span class="built_in">regex</span>(lineCommentRegex))) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, <span class="built_in">regex</span>(blockCommentStartFlagRegex))) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">            blockCommentFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, <span class="built_in">regex</span>(blockCommentStartFlag1Regex))) &#123;</span><br><span class="line">            codeLines++;</span><br><span class="line">            blockCommentFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            codeLines++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.根据参数输出统计结果，注意输出顺序是有规律的，依次为字符数 词数 行数 空白行数 代码行数 注释行数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">bool</span>&gt; mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, characters);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">&#x27;w&#x27;</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, words);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">&#x27;l&#x27;</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, lines);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d%6d%6d&quot;</span>, blankLines, codeLines, commentLines);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>首先我制作了几个经典的测试样例以及对应的参考统计结果，另外，为了节省测试时间，我还写了一个脚本来进行自动化测试。<br>假如所有的测试样例都通过了，则会提示ok，如下：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205421076-284872409.png" alt="ok"><br>假如有些样例没有通过，则会提示wrong，并指出错在哪里，如下：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205428881-788451626.png" alt="wrong"><br>我构造的测试样例及测试结果如下：</p>
<ol>
<li>空文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205439689-254256383.png" alt="空文件"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205923166-1878202581.png"><br><strong>这里输出的依次是字符数、词数、行数、空行数、代码行数、注释行数。下面的也一样。</strong><br>之所以这么输出，是模仿了Linux系统下自带的wc命令。一开始我也不太理解wc命令输出的东西哪个是字符数、哪个是单词数，所以阅读了一下文档，找到了输出的规则，理解了输出的含义。<br>所以，我这里也用了这种实现方式，这样做能减少输出冗余信息，减少用户的阅读负担，让用户更快地获得想要的信息。</li>
<li>一个字符的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205912825-488820294.png"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205958319-1399208864.png"></li>
<li>一个单词的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210007243-239773037.png"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210013271-1946409668.png"></li>
<li>一行的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210114455-1151020509.png"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210119963-1429841711.png"></li>
<li>典型的C源文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210126528-40224607.png"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210131462-486603797.png"></li>
<li>另一个典型的C源文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210153931-1158546205.png"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210159342-1826726136.png"></li>
</ol>
<p>除了测试这些样例，我还测试了非法输入的情况，如下：</p>
<ol>
<li>没有输入参数<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210210247-1688868089.png"></li>
<li>参数非法<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210225526-1188622487.png"></li>
<li>文件或目录不存在<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210231620-1867302132.png"></li>
<li>在未输入s参数的情况下查询目录<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210246330-568258736.png"></li>
</ol>
<p>拓展功能的查询更复杂信息和查询目录的测试：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210335631-1210398873.png"></p>
<p>支持各种文件的通配符（*,?）的测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180915090044777-1329710180.png"><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180915090113262-414065472.png"></p>
<h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><p>博主使用了gcov与lcov进行代码覆盖率的测试。经过测试发现，行覆盖率为91.5%，函数覆盖率为100%。<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911234128799-238501992.png"></p>
<h1 id="遇到的困难及解决方法"><a href="#遇到的困难及解决方法" class="headerlink" title="遇到的困难及解决方法"></a>遇到的困难及解决方法</h1><ol>
<li>之前很少用C++写与文件操作相关的代码，所以对于实现-s这个参数的时候无从下手，最后，通过搜索引擎，查阅官方文档和他人的博客，学习到了新知识，顺利地解决了这个问题。</li>
<li>实现-a这个参数，需要统计空行、代码行、注释行。一开始，我的想法是逐个读取字符，进行相关变量的更新，并进行状态转化。但是，这样实现的话，会需要很多的标记，让代码晦涩难懂。而且由于这个状态机的状态很多，状态之间的转化也相当复杂。所以，最后我放弃了这种实现方式，改用正则表达式来实现，这样会简单很多。这启发我，在具体实现前，最好先比较一下各种实现方式的难易程度，再选择一种比较容易的来写。</li>
</ol>
<h1 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h1><table>
<thead>
<tr>
<th>PSP2.1</th>
<th>Personal Software Process Stages</th>
<th>预估耗时（分钟）</th>
<th>实际耗时（分钟）</th>
</tr>
</thead>
<tbody><tr>
<td>Planning</td>
<td>计划</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>· Estimate</td>
<td>· 估计这个任务需要多少时间</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>Development</td>
<td>开发</td>
<td>525</td>
<td>600</td>
</tr>
<tr>
<td>· Analysis</td>
<td>· 需求分析 (包括学习新技术)</td>
<td>75</td>
<td>75</td>
</tr>
<tr>
<td>· Design Spec</td>
<td>· 生成设计文档</td>
<td>25</td>
<td>0</td>
</tr>
<tr>
<td>· Design Review</td>
<td>· 设计复审 (和同事审核设计文档)</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>· Coding Standard</td>
<td>· 代码规范 (为目前的开发制定合适的规范)</td>
<td>25</td>
<td>0</td>
</tr>
<tr>
<td>· Design</td>
<td>· 具体设计</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>· Coding</td>
<td>· 具体编码</td>
<td>325</td>
<td>425</td>
</tr>
<tr>
<td>· Code Review</td>
<td>· 代码复审</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>· Test</td>
<td>· 测试（自我测试，修改代码，提交修改）</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>Reporting</td>
<td>报告</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>· Test Report</td>
<td>· 测试报告</td>
<td>50</td>
<td>50</td>
</tr>
<tr>
<td>· Size Measurement</td>
<td>· 计算工作量</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>· Postmortem &amp; Process Improvement Plan</td>
<td>· 事后总结, 并提出过程改进计划</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>合计</td>
<td></td>
<td>650</td>
<td>750</td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一开始没有认真分析需求，没有想好就开始动手编码实现，中途停停顿顿，浪费了不少时间。从上面的PSP也可以看出，我花了很少时间在“生成设计文档”、“设计复审”、“代码规范”这三个环节上，导致我后面“具体编码”的环节花的时间比预估的时间长了很多。后来，我重新阅读了项目文件，明确了需求，并进行了相关设计，然后就实现得比较顺利了。这启发我，在开始动手编码前，应该先想好思路，并设计好模块，磨刀不误砍柴工嘛。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://magustest.com/2010/09/12/using-gcov-lcov/">C&#x2F;C++代码覆盖工具gcov与lcov入门</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kuangbin带你飞 专题十七 AC自动机 题解</title>
    <url>/2018/08/23/ac-auto-machine-learning/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/contest/70326#overview">kuangin带你飞专题十七 AC自动机 传送门</a><br>AC自动机是著名的多模匹配算法，在ACM中通常会结合计数问题、动态规划问题等一起出现。</p>
<h1 id="A-HDU-2222-Keywords-Search"><a href="#A-HDU-2222-Keywords-Search" class="headerlink" title="A. HDU 2222 Keywords Search"></a>A. HDU 2222 Keywords Search</h1><p>统计字符串出现的个数，AC自动机模板题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Untested)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">26</span>], fail[N], end[N], idx, root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="type">int</span> temp = now;</span><br><span class="line">            <span class="keyword">while</span>(temp != root) &#123;</span><br><span class="line">                ans += end[temp];</span><br><span class="line">                end[temp] = <span class="number">0</span>;</span><br><span class="line">                temp = fail[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"><span class="type">char</span> s[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> ans = ac.<span class="built_in">query</span>(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-HDU-2896-病毒侵袭"><a href="#B-HDU-2896-病毒侵袭" class="headerlink" title="B.HDU 2896 病毒侵袭"></a>B.HDU 2896 病毒侵袭</h1><p>和上道题差不多，但这道题要求输出出现的字符串，修改一下节点保存的信息即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模式串之间可以重叠</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, total;</span><br><span class="line"><span class="type">char</span> s[<span class="number">10009</span>];</span><br><span class="line"><span class="comment">//写AC自动机等树状数据结构一定要注意空间！</span></span><br><span class="line"><span class="comment">//比如这道题，多申请个set&lt;int&gt; se[N] 就会MLE </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acAuto</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">128</span>], fail[N], root, L;</span><br><span class="line">    vi end[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            next[L][i] = <span class="number">-1</span>;</span><br><span class="line">        end[L].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> L++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i]] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i]] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now].<span class="built_in">push_back</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;	<span class="comment">//!</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>)</span><br><span class="line">                next[root][i] = root;	<span class="comment">//</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>)</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; se;</span><br><span class="line">        <span class="type">bool</span> flag[N];</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span> flag);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            now = next[now][s[i]];</span><br><span class="line">            <span class="type">int</span> temp = now;</span><br><span class="line">            <span class="keyword">while</span>(temp != root) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[temp]) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> j: end[temp])</span><br><span class="line">                        se.<span class="built_in">insert</span>(j);</span><br><span class="line">                    flag[temp] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(se.<span class="built_in">size</span>() &gt;= <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">                temp = fail[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(se.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;web %d:&quot;</span>, id);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i: se)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%27c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; L;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,chi = [&quot;</span>,i,fail[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    ac.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(ac.<span class="built_in">query</span>(s ,i))</span><br><span class="line">            total++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total: %d\n&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-HDU-3065-病毒侵袭持续中"><a href="#C-HDU-3065-病毒侵袭持续中" class="headerlink" title="C. HDU 3065 病毒侵袭持续中"></a>C. HDU 3065 病毒侵袭持续中</h1><p>需要统计各字符串出现的次数，使用vector来维护节点上出现的字符串即可。<br>注意是多组样例，初始化要处理好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目有点坑啊，没有说多组样例，WA了一发:(</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">2000009</span>];</span><br><span class="line"><span class="type">char</span> ss[<span class="number">1009</span>][<span class="number">59</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acAuto</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">26</span>], fail[N], root, L;</span><br><span class="line">    vi end[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[L][i] = <span class="number">-1</span>;</span><br><span class="line">        end[L].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> L++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;A&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;A&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now].<span class="built_in">push_back</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>)</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>)</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="type">int</span> cnt[N];</span><br><span class="line">        <span class="type">bool</span> flag[N];</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span> flag);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;se;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            now = <span class="built_in">isupper</span>(s[i]) ? next[now][s[i] - <span class="string">&#x27;A&#x27;</span>] : root;</span><br><span class="line">            <span class="type">int</span> temp = now;</span><br><span class="line">            <span class="keyword">while</span>(temp != root) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> id: end[temp]) &#123;</span><br><span class="line">                    cnt[id]++;</span><br><span class="line">                    <span class="keyword">if</span>(!flag[id]) &#123;</span><br><span class="line">                        se.<span class="built_in">insert</span>(id);</span><br><span class="line">                        flag[id] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = fail[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: se) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>, ss[i], cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss[i]);</span><br><span class="line">            ac.<span class="built_in">insert</span>(ss[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        ac.<span class="built_in">query</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-ZOJ-3430-Detect-the-Virus"><a href="#D-ZOJ-3430-Detect-the-Virus" class="headerlink" title="D. ZOJ 3430 Detect the Virus"></a>D. ZOJ 3430 Detect the Virus</h1><p>题目有点难懂，留坑待填。</p>
<h1 id="E-POJ-2778-DNA-Sequence"><a href="#E-POJ-2778-DNA-Sequence" class="headerlink" title="E. POJ 2778 DNA Sequence"></a>E. POJ 2778 DNA Sequence</h1><p>求不含模式串的字符串总数。<br>该计数问题可用AC自动机+矩阵快速幂解决，很经典。<br><a href="https://hyzgh.github.io/2018/04/21/1/">详细题解传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> shift=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod =    <span class="number">100000</span>;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="type">int</span> n, mm;</span><br><span class="line"><span class="type">char</span> s[<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 矩阵快速幂：根据递推式快速计算第n项</span></span><br><span class="line"><span class="comment"> * 矩阵构造、时间复杂度参考白书P201</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vi&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat A, mat B)</span></span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">C</span><span class="params">(A.size(), vi(B[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;A[<span class="number">0</span>].<span class="built_in">size</span>(); k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;B[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">                C[i][j]=(<span class="number">1LL</span> * C[i][j]+<span class="number">1LL</span> * A[i][k]*B[k][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat A, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">B</span><span class="params">(A.size(), vi(A.size()))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;B.<span class="built_in">size</span>(); i++)</span><br><span class="line">        B[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) B=<span class="built_in">mul</span>(B, A);</span><br><span class="line">        A=<span class="built_in">mul</span>(A, A);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acAuto</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">109</span>][<span class="number">4</span>], fail[<span class="number">109</span>], L, root;</span><br><span class="line">    <span class="type">bool</span> end[<span class="number">109</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">        m[<span class="string">&#x27;T&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">        m[<span class="string">&#x27;G&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            next[L][i] = <span class="number">-1</span>;</span><br><span class="line">        end[L] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> L++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = m[s[i]];</span><br><span class="line">            <span class="keyword">if</span>(next[now][j] == <span class="number">-1</span>)</span><br><span class="line">                next[now][j] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>)</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(end[fail[now]])	<span class="comment">//假如fail转移到的状态不合法，那么该状态也不合法！</span></span><br><span class="line">                end[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMatrix</span><span class="params">(::mat &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">                <span class="keyword">if</span>(end[next[i][j]] == <span class="literal">false</span>)</span><br><span class="line">                    a[i][next[i][j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function">mat <span class="title">a</span><span class="params">(L, vi(L))</span></span>;</span><br><span class="line">        <span class="built_in">buildMatrix</span>(a);</span><br><span class="line">        a = <span class="built_in">pow</span>(a, n);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">            (ans += a[<span class="number">0</span>][j]) %= mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;mm, &amp;n)) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; mm; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">solve</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-HDU-2243-考研路茫茫――单词情结"><a href="#F-HDU-2243-考研路茫茫――单词情结" class="headerlink" title="F. HDU 2243 考研路茫茫――单词情结"></a>F. HDU 2243 考研路茫茫――单词情结</h1><p>求含模式串的字符串总数，注意这道题的字符串长度是可变的，所以矩阵构造需要有所变化。<br>同样是计数问题，还是AC自动机+矩阵快速幂的套路。<br><a href="https://hyzgh.github.io/2018/08/16/0/">详细题解传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 矩阵快速幂：根据递推式快速计算第n项(Untested)</span></span><br><span class="line"><span class="comment"> * 矩阵构造、时间复杂度参考白书P201</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义矩阵元素为long long的矩阵：</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ull&gt; vll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vll&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat A, mat B)</span></span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">C</span><span class="params">(A.size(), vll(B[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;	</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">                C[i][j] = (C[i][j] + A[i][k] * B[k][j]);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat A, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">B</span><span class="params">(A.size(), vll(A.size(), <span class="number">0</span>))</span></span>;		</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B.<span class="built_in">size</span>(); i++)</span><br><span class="line">        B[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) B = <span class="built_in">mul</span>(B, A);</span><br><span class="line">        A = <span class="built_in">mul</span>(A, A);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 1 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">39</span>][<span class="number">26</span>], fail[<span class="number">39</span>], end[<span class="number">39</span>], idx, root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">true</span>;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(end[fail[now]] == <span class="literal">true</span>)</span><br><span class="line">                end[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ull <span class="title">cntIllegal</span><span class="params">(ll L)</span> </span>&#123;</span><br><span class="line">        <span class="function">mat <span class="title">a</span><span class="params">(idx + <span class="number">1</span>, vll(idx + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">                <span class="keyword">if</span>(end[next[i][j]] == <span class="literal">false</span>)</span><br><span class="line">                    a[i][next[i][j]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx + <span class="number">1</span>; i++)</span><br><span class="line">            a[i][idx] = <span class="number">1</span>;</span><br><span class="line">        a = <span class="built_in">pow</span>(a, L);</span><br><span class="line">        ull ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx + <span class="number">1</span>; i++)</span><br><span class="line">            ans += a[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll L;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;L)) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">mat <span class="title">a</span><span class="params">(<span class="number">2</span>, vll(<span class="number">2</span>, <span class="number">0</span>))</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>, vll(<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">26</span>, a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a = <span class="built_in">pow</span>(a, L);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, b);</span><br><span class="line">        ull ans = a[<span class="number">0</span>][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ans -= ac.<span class="built_in">cntIllegal</span>(L);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="G-POJ-1625-Censored"><a href="#G-POJ-1625-Censored" class="headerlink" title="G. POJ 1625 Censored!"></a>G. POJ 1625 Censored!</h1><p>求不含模式串的字符串总数，需要使用大数，但是不能使用矩阵快速幂，因为会MLE。<br>注意到m挺小，所以考虑用DP解决，而且还需要用滚动数组优化一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> chr = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> c, s[<span class="number">59</span>];</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="type">int</span> n, mm, p;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 高精度，支持乘法和加法(Tested 0 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BigInt</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> DLEN = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">90</span>],len;</span><br><span class="line">    <span class="built_in">BigInt</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> v)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            a[len++] = v%mod;</span><br><span class="line">            v /= mod;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> <span class="type">char</span> s[])&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">strlen</span>(s);</span><br><span class="line">        len = L/DLEN;</span><br><span class="line">        <span class="keyword">if</span>(L%DLEN)len++;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = L<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i -= DLEN)&#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> k = i - DLEN + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>)k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = k;j &lt;= i;j++)</span><br><span class="line">                t = t*<span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            a[index++] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> +(<span class="type">const</span> BigInt &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        BigInt res;</span><br><span class="line">        res.len = <span class="built_in">max</span>(len,b.len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= res.len;i++)</span><br><span class="line">            res.a[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; res.len;i++)&#123;</span><br><span class="line">            res.a[i] += ((i &lt; len)?a[i]:<span class="number">0</span>)+((i &lt; b.len)?b.a[i]:<span class="number">0</span>);</span><br><span class="line">            res.a[i+<span class="number">1</span>] += res.a[i]/mod;</span><br><span class="line">            res.a[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.a[res.len] &gt; <span class="number">0</span>)res.len++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> *(<span class="type">const</span> BigInt &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        BigInt res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">            <span class="type">int</span> up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; b.len;j++)&#123;</span><br><span class="line">                <span class="type">int</span> temp = a[i]*b.a[j] + res.a[i+j] + up;</span><br><span class="line">                res.a[i+j] = temp%mod;</span><br><span class="line">                up = temp/mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(up != <span class="number">0</span>)</span><br><span class="line">                res.a[i + b.len] = up;</span><br><span class="line">        &#125;</span><br><span class="line">        res.len = len + b.len; <span class="keyword">while</span>(res.a[res.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp;res.len &gt; <span class="number">1</span>)res.len--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[len<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-2</span>;i &gt;=<span class="number">0</span> ;i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>,a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 矩阵快速幂：根据递推式快速计算第n项(Tested 1 times)</span></span><br><span class="line"><span class="comment"> * 矩阵构造、时间复杂度参考白书P201</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;BigInt&gt; vll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vll&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat A, mat B)</span> </span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">C</span><span class="params">(A.size(), vll(B[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;	<span class="comment">// 假如为long long，vi需要修改为vll</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">                C[i][j] = (C[i][j] + A[i][k] * B[k][j]);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat A, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">B</span><span class="params">(A.size(), vll(A.size(), <span class="number">0</span>))</span></span>;		<span class="comment">// 假如为long long，vi需要修改为vll</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B.<span class="built_in">size</span>(); i++)</span><br><span class="line">        B[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) B = <span class="built_in">mul</span>(B, A);</span><br><span class="line">        A = <span class="built_in">mul</span>(A, A);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 3 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">109</span>][<span class="number">50</span>], fail[<span class="number">109</span>], end[<span class="number">109</span>], idx, root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; chr; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = m[s[i]];</span><br><span class="line">            <span class="keyword">if</span>(next[now][c] == <span class="number">-1</span>)</span><br><span class="line">                next[now][c] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][c];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">true</span>;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; chr; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(end[fail[now]] == <span class="literal">true</span>)</span><br><span class="line">                end[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; chr; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">mat <span class="title">a</span><span class="params">(idx, vll(idx, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; chr; j++)</span><br><span class="line">                <span class="keyword">if</span>(end[next[i][j]] == <span class="literal">false</span>)</span><br><span class="line">                    a[i][next[i][j]] = a[i][next[i][j]] + <span class="number">1</span>;</span><br><span class="line">        <span class="function">mat <span class="title">dp</span><span class="params">(<span class="number">2</span>, vll(idx, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; mm; i++) &#123;</span><br><span class="line">            now ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">                dp[now][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; idx; k++)</span><br><span class="line">                    dp[now][k] = dp[now][k] + dp[now ^ <span class="number">1</span>][j] * a[j][k];</span><br><span class="line">        &#125;</span><br><span class="line">        BigInt ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            ans = ans + dp[now][i];</span><br><span class="line">        ans.<span class="built_in">output</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;mm, &amp;p)) &#123;</span><br><span class="line">        chr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        m.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c = <span class="built_in">getchar</span>();</span><br><span class="line">            m[c] = chr++;</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(p--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="H-HDU-2825-Wireless-Password"><a href="#H-HDU-2825-Wireless-Password" class="headerlink" title="H. HDU 2825 Wireless Password"></a>H. HDU 2825 Wireless Password</h1><p>AC自动机+动态规划<br><a href="https://hyzgh.github.io/2018/08/18/1/">详细题解传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">20090717</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">19</span>];</span><br><span class="line"><span class="type">int</span> n, m, k, dp[<span class="number">26</span>][<span class="number">109</span>][<span class="number">1029</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx, status;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> idx, <span class="type">int</span> status): <span class="built_in">idx</span>(idx), <span class="built_in">status</span>(status)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 3 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">109</span>][<span class="number">26</span>], fail[<span class="number">109</span>], end[<span class="number">109</span>], idx, root; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            end[now] |= end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); k++)</span><br><span class="line">                    dp[i][j][k] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        queue&lt;node&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(node&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">bool</span> vis[<span class="number">259</span>][<span class="number">1029</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            queue&lt;node&gt; nextque;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">            <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                node t = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> o = <span class="number">0</span>; o &lt; <span class="number">26</span>; o++) &#123;</span><br><span class="line">                    <span class="type">int</span> j = t.idx;</span><br><span class="line">                    <span class="type">int</span> k = t.status;</span><br><span class="line">                    <span class="type">int</span> newj = next[j][o];</span><br><span class="line">                    <span class="type">int</span> newk = t.status | end[newj];</span><br><span class="line">                    dp[i][newj][newk] += dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][newj][newk] &gt;= mod)</span><br><span class="line">                        dp[i][newj][newk] -= mod;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[newj][newk]) &#123;</span><br><span class="line">                        vis[newj][newk] = <span class="literal">true</span>;</span><br><span class="line">                        nextque.<span class="built_in">push</span>(&#123;newj, newk&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            que = nextque;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 可以把__builtin_popcount(j)预处理掉，这样更快</span></span><br><span class="line">                <span class="keyword">if</span>(__builtin_popcount(j) &gt;= k) &#123;</span><br><span class="line">                    ans += dp[n][i][j];</span><br><span class="line">                    <span class="keyword">if</span>(ans &gt;= mod)</span><br><span class="line">                        ans -= mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k) &amp;&amp; n) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-HDU-2296-Ring"><a href="#I-HDU-2296-Ring" class="headerlink" title="I. HDU 2296 Ring"></a>I. HDU 2296 Ring</h1><p>AC自动机+动态规划</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">min</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>() &lt; t.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> s &lt; t ? s : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">26</span>], fail[N], end[N], idx, root; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    string c[N];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">59</span>][N];</span><br><span class="line">    string s[<span class="number">59</span>][N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">(string cc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        c[idx] = cc;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            string t; t += s[i];</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>(t);</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] += d;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            end[now] += end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="type">int</span> ma = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; idx; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][u] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> v = next[u][k];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][u] + end[v] &gt; dp[i][v]) &#123;</span><br><span class="line">                        dp[i][v] = dp[i<span class="number">-1</span>][u] + end[v];</span><br><span class="line">                        s[i][v] = s[i<span class="number">-1</span>][u] + c[v];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][u] + end[v] == dp[i][v] &amp;&amp; s[i<span class="number">-1</span>][u] + c[u] &lt; s[i][v]) &#123;</span><br><span class="line">                        s[i][v] = s[i<span class="number">-1</span>][u] + c[v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">                ma = <span class="built_in">max</span>(ma, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ma &lt;= <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                string ans = <span class="string">&quot;zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] == ma) &#123;</span><br><span class="line">                        ans = <span class="built_in">min</span>(ans, s[i][j]);	<span class="comment">//重载了min函数</span></span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, d;</span><br><span class="line"><span class="type">char</span> s[<span class="number">109</span>][<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s[i], d);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="J-HDU-2457-DNA-repair"><a href="#J-HDU-2457-DNA-repair" class="headerlink" title="J. HDU 2457 DNA repair"></a>J. HDU 2457 DNA repair</h1><p>AC自动机+动态规划</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1009</span>][<span class="number">1009</span>];</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="type">int</span> kase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 5 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">4</span>], fail[N], idx, root; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    <span class="type">bool</span> end[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][m[s[i]]] == <span class="number">-1</span>)</span><br><span class="line">                next[now][m[s[i]]] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][m[s[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="literal">false</span>;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!end[fail[now]]) end[now] = end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, INF, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; idx; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][u] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> v = next[u][m[s[i]]];</span><br><span class="line">                <span class="keyword">if</span>(end[v]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    dp[i+<span class="number">1</span>][v] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][v], dp[i][u]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == m[s[i]]) <span class="keyword">continue</span>;</span><br><span class="line">                    v = next[u][j];</span><br><span class="line">                    <span class="keyword">if</span>(end[v]) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][v] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][v], dp[i][u] + <span class="number">1</span>);</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++kase, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dp[len][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">1009</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>; m[<span class="string">&#x27;C&#x27;</span>] = <span class="number">1</span>; m[<span class="string">&#x27;G&#x27;</span>] = <span class="number">2</span>; m[<span class="string">&#x27;T&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        ac.<span class="built_in">query</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="K-ZOJ-3228-Searching-the-String"><a href="#K-ZOJ-3228-Searching-the-String" class="headerlink" title="K. ZOJ 3228 Searching the String"></a>K. ZOJ 3228 Searching the String</h1><p>AC自动机+计数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:102400000,102400000&quot;</span>)    <span class="comment">//手动扩栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N], t[<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> n, ty[N], pos[N], cnt[N][<span class="number">2</span>];    <span class="comment">//改用pos记录位置，避免在ac自动机里面使用end集合，妙</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 6 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">26</span>], fail[N], deep[N], idx, root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">        deep[root] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        cnt[idx][<span class="number">0</span>] = cnt[idx][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[now][s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">newNode</span>();</span><br><span class="line">                deep[next[now][s[i] - <span class="string">&#x27;a&#x27;</span>]] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="type">int</span> last[N];</span><br><span class="line">        <span class="built_in">memset</span>(last, <span class="number">-1</span>, <span class="keyword">sizeof</span> last);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            now = next[now][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="type">int</span> temp = now;</span><br><span class="line">            <span class="keyword">while</span>(temp != root) &#123;</span><br><span class="line">                cnt[temp][<span class="number">0</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(i - last[temp] &gt;= deep[temp]) &#123;</span><br><span class="line">                    cnt[temp][<span class="number">1</span>]++;</span><br><span class="line">                    last[temp] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = fail[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[pos[i]][ty[i]]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;,i,fail[i],end[i]);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d\n&quot;</span>, ++kase);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;ty[i], t);</span><br><span class="line">            pos[i] = ac.<span class="built_in">insert</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="L-HDU-3341-Lost’s-revenge"><a href="#L-HDU-3341-Lost’s-revenge" class="headerlink" title="L. HDU 3341 Lost’s revenge"></a>L. HDU 3341 Lost’s revenge</h1><p>AC自动机+动态规划<br>为了不MLE，动态规划过程中的状态要巧妙设计下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">509</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">509</span>][<span class="number">11</span>*<span class="number">11</span>*<span class="number">11</span>*<span class="number">11</span>+<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 7 times)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">26</span>], fail[N], idx, root, end[N]; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][m[s[i]]] == <span class="number">-1</span>)</span><br><span class="line">                next[now][m[s[i]]] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][m[s[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now]++;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            end[now] += end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bit[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * bit[<span class="number">3</span>] + j * bit[<span class="number">2</span>] + k * bit[<span class="number">1</span>] + l * bit[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            cnt[m[s[i]]]++;</span><br><span class="line">        bit[<span class="number">3</span>] = (cnt[<span class="number">2</span>] + <span class="number">1</span>) * (cnt[<span class="number">1</span>] + <span class="number">1</span>) * (cnt[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">        bit[<span class="number">2</span>] = (cnt[<span class="number">1</span>] + <span class="number">1</span>) * (cnt[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">        bit[<span class="number">1</span>] = cnt[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt[<span class="number">3</span>]; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cnt[<span class="number">2</span>]; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= cnt[<span class="number">1</span>]; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt;= cnt[<span class="number">0</span>]; l++) &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; idx; u++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(dp[u][<span class="built_in">func</span>(i, j, k, l)] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> o = <span class="number">0</span>; o &lt; <span class="number">4</span>; o++) &#123;</span><br><span class="line">                                <span class="type">int</span> v = next[u][o];</span><br><span class="line">                                <span class="keyword">if</span>(o == <span class="number">0</span> &amp;&amp; l == cnt[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                                <span class="keyword">if</span>(o == <span class="number">1</span> &amp;&amp; k == cnt[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                                <span class="keyword">if</span>(o == <span class="number">2</span> &amp;&amp; j == cnt[<span class="number">2</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                                <span class="keyword">if</span>(o == <span class="number">3</span> &amp;&amp; i == cnt[<span class="number">3</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                                <span class="type">int</span> id = <span class="built_in">func</span>(i, j, k, l);</span><br><span class="line">                                dp[v][id + bit[o]] = <span class="built_in">max</span>(dp[v][id + bit[o]], dp[u][id] + end[v]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i][<span class="built_in">func</span>(cnt[<span class="number">3</span>], cnt[<span class="number">2</span>], cnt[<span class="number">1</span>], cnt[<span class="number">0</span>])]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">49</span>];</span><br><span class="line"><span class="type">int</span> n, kase;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>; m[<span class="string">&#x27;C&#x27;</span>] = <span class="number">1</span>; m[<span class="string">&#x27;G&#x27;</span>] = <span class="number">2</span>; m[<span class="string">&#x27;T&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, ++kase);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="M-HDU-3247-Resource-Archiver"><a href="#M-HDU-3247-Resource-Archiver" class="headerlink" title="M. HDU 3247 Resource Archiver"></a>M. HDU 3247 Resource Archiver</h1><p>留坑待填。</p>
<h1 id="N-ZOJ-3494-BCD-Code"><a href="#N-ZOJ-3494-BCD-Code" class="headerlink" title="N. ZOJ 3494 BCD Code"></a>N. ZOJ 3494 BCD Code</h1><p>留坑待填。</p>
<h1 id="O-HDU-4758-Walk-Through-Squares"><a href="#O-HDU-4758-Walk-Through-Squares" class="headerlink" title="O. HDU 4758 Walk Through Squares"></a>O. HDU 4758 Walk Through Squares</h1><p>AC自动机+动态规划</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 8 times)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">26</span>], fail[N], idx, root, end[N]; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s), now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[now][m[s[i]]] == <span class="number">-1</span>)</span><br><span class="line">                next[now][m[s[i]]] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][m[s[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] |= id;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            end[now] |= end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bit[<span class="number">2</span>], dp[<span class="number">209</span>][<span class="number">101</span> * <span class="number">101</span> + <span class="number">9</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bit[<span class="number">1</span>] * i + bit[<span class="number">0</span>] * j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> down, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        bit[<span class="number">1</span>] = right + <span class="number">1</span>;</span><br><span class="line">        bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= down; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; idx; u++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[u][<span class="built_in">get</span>(i, j)][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> o = <span class="number">0</span>; o &lt; <span class="number">2</span>; o++) &#123;</span><br><span class="line">                             <span class="type">int</span> v = next[u][o];</span><br><span class="line">                             <span class="keyword">if</span>(i == down &amp;&amp; o == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                             <span class="keyword">if</span>(j == right &amp;&amp; o == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                             (dp[v][<span class="built_in">get</span>(i + (o == <span class="number">0</span>), j + (o == <span class="number">1</span>))][k | end[v]] += dp[u][<span class="built_in">get</span>(i, j)][k]) %= mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line">            (ans += dp[i][down * bit[<span class="number">1</span>] + right][<span class="number">3</span>]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, mm;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    m[<span class="string">&#x27;D&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="string">&#x27;R&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;mm, &amp;n);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            ac.<span class="built_in">insert</span>(s, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>(n, mm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="P-HDU-4511-小明系列故事――女友的考验"><a href="#P-HDU-4511-小明系列故事――女友的考验" class="headerlink" title="P. HDU 4511 小明系列故事――女友的考验"></a>P. HDU 4511 小明系列故事――女友的考验</h1><p>AC自动机+动态规划</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">509</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, b[<span class="number">9</span>];</span><br><span class="line">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a[<span class="number">59</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"><span class="comment">/* AC自动机：解决多个模式串匹配问题(Tested 9 times)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[N][<span class="number">50</span>], fail[N], idx, root;</span><br><span class="line">    <span class="type">bool</span> end[N]; <span class="comment">// 可以修改下数组大小，以防MLE</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            next[idx][i] = <span class="number">-1</span>;</span><br><span class="line">        end[idx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> b[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            b[i]--;</span><br><span class="line">            <span class="keyword">if</span>(next[now][b[i]] == <span class="number">-1</span>)</span><br><span class="line">                next[now][b[i]] = <span class="built_in">newNode</span>();</span><br><span class="line">            now = next[now][b[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        end[now] = <span class="number">1</span>;	<span class="comment">//根据实际情况可能需要保存不同的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        fail[root] = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[root][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                next[root][i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[next[root][i]] = root;</span><br><span class="line">                que.<span class="built_in">push</span>(next[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> now = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            end[now] |= end[fail[now]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(next[now][i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    next[now][i] = next[fail[now]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fail[next[now][i]] = next[fail[now]][i];</span><br><span class="line">                    que.<span class="built_in">push</span>(next[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">get</span><span class="params">(pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> dp[<span class="number">50</span>][<span class="number">509</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++)</span><br><span class="line">                dp[i][j] = LINF;</span><br><span class="line">        dp[<span class="number">0</span>][next[root][<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt;= LINF - Eps) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> v = next[j][k];</span><br><span class="line">                    <span class="keyword">if</span>(end[v]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[k][v] = <span class="built_in">min</span>(dp[k][v], dp[i][j] + <span class="built_in">get</span>(a[i], a[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> ans = LINF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dp[n<span class="number">-1</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= LINF - Eps)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Can not be reached!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%37c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2c&quot;</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;</span>,i,fail[i],end[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,next[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ac;</span><br><span class="line"><span class="comment">/********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) &amp;&amp; n) &#123;</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + j);</span><br><span class="line">            ac.<span class="built_in">insert</span>(b, k);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        ac.<span class="built_in">query</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>四则运算项目折腾笔记</title>
    <url>/2018/09/30/arithmetic-problems-generator/</url>
    <content><![CDATA[<p><a href="https://github.com/hyzgh/arithmetic-problems-generator">Github项目地址传送门</a></p>
<h1 id="项目相关要求"><a href="#项目相关要求" class="headerlink" title="项目相关要求"></a>项目相关要求</h1><blockquote>
<ol>
<li>(完成)使用 -n 参数控制生成题目的个数。</li>
<li>(完成)使用 -r 参数控制题目中数值（自然数、真分数和真分数分母）的范围。该参数可以设置为1或其他自然数。该参数必须给定，否则程序报错并给出帮助信息。</li>
<li>(完成)生成的题目中计算过程不能产生负数，也就是说算术表达式中如果存在形如e1 − e2的子表达式，那么e1 ≥ e2。</li>
<li>(完成)生成的题目中如果存在形如e1 ÷ e2的子表达式，那么其结果应是真分数。</li>
<li>(完成)每道题目中出现的运算符个数不超过3个。</li>
<li>(完成)程序一次运行生成的题目不能重复，即任何两道题目不能通过有限次交换+和×左右的算术表达式变换为同一道题目。例如，23 + 45 &#x3D; 和45 + 23 &#x3D; 是重复的题目，6 × 8 &#x3D; 和8 × 6 &#x3D; 也是重复的题目。3+(2+1)和1+2+3这两个题目是重复的，由于+是左结合的，1+2+3等价于(1+2)+3，也就是3+(1+2)，也就是3+(2+1)。但是1+2+3和3+2+1是不重复的两道题，因为1+2+3等价于(1+2)+3，而3+2+1等价于(3+2)+1，它们之间不能通过有限次交换变成同一个题目。生成的题目存入执行程序的当前目录下的Exercises.txt文件。</li>
<li>(完成)在生成题目的同时，计算出所有题目的答案，并存入执行程序的当前目录下的Answers.txt文件。</li>
<li>(完成)程序应能支持一万道题目的生成。</li>
<li>(完成)程序支持对给定的题目文件和答案文件，判定答案中的对错并进行数量统计， 统计结果输出到文件Grade.txt。</li>
</ol>
</blockquote>
<h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><p>本次项目的代码遵循了谷歌代码规范(C++)，但由于谷歌代码规范篇幅太多，所以我们目前只遵循了其中的部分规范，具体如下：</p>
<ol>
<li>禁止使用宏</li>
<li>分号以前不加空格</li>
<li>行宽原则上不超过80</li>
<li>一行只定义一个变量</li>
<li>左大括号前保留一个空格</li>
<li>if, else前后都要一个空格</li>
<li>for, while后要有一个空格</li>
<li>return 后面的数值不加 ( )</li>
<li>每个文件应该含有版权信息及作者</li>
<li>左圆括号之后和右圆括号之前无空格</li>
<li>函数参数过多时，每行的参数变量对齐</li>
<li>一目运算符与变量之间不加空格符隔开</li>
<li>禁止使用 using 指示（using-directive） </li>
<li>禁止使用C++的流，而是用printf之类的替代</li>
<li>要么函数名与参数同行，要么所有参数并排分行</li>
<li>换行代码缩进2个空格，并且使用两个空格符取代制表符</li>
<li>二目以上的运算符与变量，常量之间用空格隔开（各类括号除外）</li>
<li>不论控制语句，循环语句后面的循环体有多少行，都必须使用花括号</li>
<li>普通函数，类型（含类与结构体，枚举类型），常量等使用大小写混合，不含下划线</li>
<li>除函数定义的左大括号可置于行首以外，包括函数&#x2F;类&#x2F;结构体&#x2F;枚举声明，各种语句的左大括号必须置于行末，所有右大括号独立成行</li>
</ol>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145059141-655290070.png"></p>
<h1 id="具体设计-关键代码"><a href="#具体设计-关键代码" class="headerlink" title="具体设计&amp;关键代码"></a>具体设计&amp;关键代码</h1><h2 id="ImproperFraction类"><a href="#ImproperFraction类" class="headerlink" title="ImproperFraction类"></a>ImproperFraction类</h2><p>构建一个ImproperFraction的类，然后重载这个类的四种运算 <strong>+-x÷</strong> 以及以及六种逻辑关系**’&lt;’  ‘&#x3D;&#x3D;’  ‘&lt;&#x3D;’  ‘!&#x3D;’  ‘&gt;’  ‘&gt;&#x3D;’**判断，在后续的代码编写之中都是基于这个类进行运算</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImproperFraction</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> :</span><br><span class="line">  <span class="built_in">ImproperFraction</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">ImproperFraction</span> (<span class="type">int</span> Mole, <span class="type">int</span> Deno, <span class="type">int</span> Coef = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> g = std::__gcd (Mole, Deno);</span><br><span class="line">    g = std::<span class="built_in">max</span>(g, <span class="number">1</span>);</span><br><span class="line">    mole = (Mole + Coef * Deno) / g;</span><br><span class="line">    deno = Deno / g;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> + (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="type">int</span> MOLE = mole * rhs.deno + rhs.mole * deno;</span><br><span class="line">    ImproperFraction res = <span class="built_in">ImproperFraction</span> (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> - (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="type">int</span> MOLE = mole * rhs.deno - rhs.mole * deno;</span><br><span class="line">    ImproperFraction res = <span class="built_in">ImproperFraction</span> (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> * (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="type">int</span> MOLE = mole * rhs.mole;</span><br><span class="line">    ImproperFraction res = <span class="built_in">ImproperFraction</span> (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> / (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> DENO = deno * rhs.mole;</span><br><span class="line">    <span class="type">int</span> MOLE = mole * rhs.deno;</span><br><span class="line">    ImproperFraction res = <span class="built_in">ImproperFraction</span> (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mole * rhs.deno &lt; rhs.mole * deno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mole * rhs.deno == rhs.mole * deno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(mole * rhs.deno == rhs.mole * deno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (*<span class="keyword">this</span>) &lt; rhs || (*<span class="keyword">this</span>) == rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !((*<span class="keyword">this</span>) &lt;= rhs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> ImproperFraction &amp; rhs ) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (*<span class="keyword">this</span>) &gt; rhs || (*<span class="keyword">this</span>) == rhs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> :</span><br><span class="line">  <span class="type">int</span> mole = <span class="number">0</span>; <span class="comment">// 分子</span></span><br><span class="line">  <span class="type">int</span> deno = <span class="number">1</span>; <span class="comment">// 分母 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题集的生成"><a href="#题集的生成" class="headerlink" title="题集的生成"></a>题集的生成</h2><h3 id="表达式的生成"><a href="#表达式的生成" class="headerlink" title="表达式的生成"></a>表达式的生成</h3><p>在这里选择的是rand() 随机生成 运算符个数，类型以及每个被运算的数值。</p>
<h3 id="表达式的合法性判断"><a href="#表达式的合法性判断" class="headerlink" title="表达式的合法性判断"></a><strong>表达式的合法性判断</strong></h3><p> 在生成过程之中，有两个要点会导致表达式非法<br>1.运算过程中出现负值<br>2.在÷运算后面出现0</p>
<p><strong>解决办法：</strong>两个特殊判断即可</p>
<h3 id="表达式的去重"><a href="#表达式的去重" class="headerlink" title="表达式的去重"></a><strong>表达式的去重</strong></h3><p>表达式的重复有两种情况:<br>1.完完全全的重复，如出现两个1 + 2 + 3 的表达式<br>2.运算顺序上的重复，如:</p>
<blockquote>
<p>1 + 2 + 3 和 2 + 1 + 3重复<br>2 + 3 x 4 和 4 x 3 + 2重复</p>
</blockquote>
<p><strong>解决办法：</strong><br>对于(1)的情况只需要将生成的表达式保存进C++STL的set之中即可自动去重。<br>对于(2)的情况，则是按照一定规则生成表达式来避免这一情况，规则如下：</p>
<blockquote>
<p>1.默认左边的运算符的优先度高于右边<br>2.第一个数字一定不小于第二个数值<br>因此1 + 2 + 3和2 + 3 x 4不会被生成，而只会生成2 + 1 + 3和4 x 3 + 2</p>
</blockquote>
<h3 id="题集无法生成要求的数量"><a href="#题集无法生成要求的数量" class="headerlink" title="题集无法生成要求的数量"></a><strong>题集无法生成要求的数量</strong></h3><p> 例如：<br>传入的参数是 -n 10000 -r 1 的时候，很明显无法生成10000道题目，因此陷入死循环的生成中</p>
<p><strong>解决办法：</strong><br>设置一个时间戳time，当生成表达式的部分循环了1000000次之后自动跳出循环，终止生成表达式 </p>
<h3 id="答案的生成"><a href="#答案的生成" class="headerlink" title="答案的生成"></a><strong>答案的生成</strong></h3><p> 在表的是合法性判断的时候，会判断最终的数值是否小于0，在这里就已经计算标准答案，保存并打印到answer.txt即可</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">questionSetGenerate</span> <span class="params">(<span class="type">int</span> limit, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">  std::set&lt;std::string&gt;expressions;</span><br><span class="line">  std::vector&lt;std::string&gt;exercise;</span><br><span class="line">  std::vector&lt;ImproperFraction&gt;answer;</span><br><span class="line">  ImproperFraction zero = <span class="built_in">ImproperFraction</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (expressions.<span class="built_in">size</span>() &lt; number &amp;&amp; time &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">    time ++;</span><br><span class="line">    <span class="type">int</span> sz = expressions.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 运算符的个数</span></span><br><span class="line">    <span class="type">int</span> opnumber = <span class="built_in">rand</span>() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    ImproperFraction a[<span class="number">5</span>];</span><br><span class="line">    ImproperFraction res = <span class="built_in">ImproperFraction</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">const</span> ImproperFraction zero = <span class="built_in">ImproperFraction</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 随机生成数值和运算符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= opnumber; i++) &#123;</span><br><span class="line">      a[i] = <span class="built_in">ImproperFraction</span>(<span class="built_in">rand</span>() % (limit * limit), std::<span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">rand</span>() % limit));</span><br><span class="line">      <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        op[i] = oper[<span class="built_in">rand</span>() % <span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string exp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[<span class="number">1</span>]) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span> (a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算答案,并检查中途出现非法情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= opnumber; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">          res = res + a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">          res = res * a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">          res = res - a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (a[i] == zero) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          res = res / a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        exp = exp + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        exp = exp + op[i];</span><br><span class="line">        exp = exp + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = res + a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将分数转化为字符串</span></span><br><span class="line">      <span class="built_in">fractionToString</span>(a[i], exp);</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="built_in">getdeno</span>() &lt; <span class="number">0</span> || res.<span class="built_in">getmole</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      expressions.<span class="built_in">insert</span>(exp);</span><br><span class="line">      <span class="keyword">if</span> (expressions.<span class="built_in">size</span>() &gt; sz) &#123;</span><br><span class="line">        <span class="comment">//保存题集和答案</span></span><br><span class="line">        exercise.<span class="built_in">push_back</span>(<span class="built_in">addbrackets</span>(exp));</span><br><span class="line">        answer.<span class="built_in">push_back</span>(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="答案正确性的检测"><a href="#答案正确性的检测" class="headerlink" title="答案正确性的检测"></a>答案正确性的检测</h2><p>用户通过参数-e exercises.txt -a answers.txt，传进来了题目文件的名称和答案文件的名称。<br>首先，由于文件可能不存在或者没有访问的权限，我们需要对此进行检查，假如有错误，则进行报错，没有异常才进行下一步。<br>第二步，我们需要对exercises.txt文件中的题目计算一遍，然后再和answers.txt文件中的答案进行比较。题目的计算分两步进行，即先将中缀表达式转化为后缀表达式，然后计算后缀表达式的答案。<br>对于这个函数，我们考虑了exercises.txt行数和answers.txt行数不相等的情况，此时我们将以exercises.txt的行数为准，假如answers.txt行数过少，那么将视为错误答案，假如过多，那么将被忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查答案</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkAnswer</span><span class="params">(FILE *exerciseFile, FILE *answerFile)</span> </span>&#123;</span><br><span class="line">  FILE *pFile = <span class="built_in">getPointerToGradeFile</span>();</span><br><span class="line">  <span class="type">int</span> problemID = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> answer[<span class="number">256</span>];</span><br><span class="line">  <span class="type">char</span> exercise[<span class="number">256</span>];</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; wrongID;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; correctID;</span><br><span class="line">  <span class="comment">// 答案的行数可能不等于题目的行数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(answer, <span class="number">256</span>, answerFile)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fgets</span>(exercise, <span class="number">256</span>, exerciseFile)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    problemID++;</span><br><span class="line">    <span class="built_in">removeRedundantPart</span>(answer, exercise);</span><br><span class="line">    <span class="built_in">handleDivideEncoding</span>(exercise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getInfixExpressionAnswer</span>(exercise) == <span class="built_in">stringToImproperFraction</span>(answer)</span><br><span class="line">       ) &#123;</span><br><span class="line">      correctID.<span class="built_in">push_back</span>(problemID);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wrongID.<span class="built_in">push_back</span>(problemID);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(exercise, <span class="number">256</span>, exerciseFile)) &#123;</span><br><span class="line">    problemID++;</span><br><span class="line">    wrongID.<span class="built_in">push_back</span>(problemID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printID</span>(pFile, <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;Correct&quot;</span>), correctID);</span><br><span class="line">  <span class="built_in">printID</span>(pFile, <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;Wrong&quot;</span>), wrongID);</span><br><span class="line">  <span class="built_in">fclose</span>(pFile);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check answer done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="function">std::queue&lt;std::string&gt; <span class="title">transformInfixExprToSuffixExpr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string &amp;InfixExpression)</span> </span>&#123;</span><br><span class="line">  std::stack&lt;<span class="type">char</span>&gt; temp;</span><br><span class="line">  std::queue&lt;std::string&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; InfixExpression.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> cc = InfixExpression[i];</span><br><span class="line">    <span class="keyword">if</span> (cc == <span class="string">&#x27; &#x27;</span>) &#123;  <span class="comment">// 假如遇到空格就跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">// 遇到左括号就直接入栈</span></span><br><span class="line">      temp.<span class="built_in">push</span>(cc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">&#x27;)&#x27;</span>) &#123;  <span class="comment">// 遇到右括号就弹出栈里面的所有运算符，直到遇到左括号</span></span><br><span class="line">      <span class="type">char</span> c;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        c = temp.<span class="built_in">top</span>();</span><br><span class="line">        temp.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">          result.<span class="built_in">push</span>(<span class="built_in">charToString</span>(c));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">&#x27;+&#x27;</span> || cc == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 遇到加号减号也弹出栈顶的所有运算符，直到遇到左括号或者为栈为空</span></span><br><span class="line">      <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = temp.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">          result.<span class="built_in">push</span>(<span class="built_in">charToString</span>(c));</span><br><span class="line">          temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.<span class="built_in">push</span>(cc);  <span class="comment">// 然后将加号入栈</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">&#x27;x&#x27;</span> || cc == <span class="string">&#x27;\xc3&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 假如遇到所有乘号除号，就弹出栈顶的乘号除号，知道遇到加号减号或者左括号或者栈为空</span></span><br><span class="line">      i += cc == <span class="string">&#x27;\xc3&#x27;</span>;</span><br><span class="line">      <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = temp.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">          result.<span class="built_in">push</span>(<span class="built_in">charToString</span>(c));</span><br><span class="line">          temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\xc3&#x27;</span>) &#123;</span><br><span class="line">          result.<span class="built_in">push</span>(<span class="built_in">charToString</span>(c));</span><br><span class="line">          temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.<span class="built_in">push</span>(cc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 假如遇到数字，那就直接输出</span></span><br><span class="line">      std::string s;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; InfixExpression.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = InfixExpression[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">          s += c;</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="built_in">push</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把栈里面剩余的东西输出</span></span><br><span class="line">  <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> c = temp.<span class="built_in">top</span>();</span><br><span class="line">    temp.<span class="built_in">pop</span>();</span><br><span class="line">    result.<span class="built_in">push</span>(<span class="built_in">charToString</span>(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算后缀表达式的答案</span></span><br><span class="line"><span class="function">ImproperFraction <span class="title">getSuffixExpressionAnswer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::queue&lt;std::string&gt; suffixExpression)</span> </span>&#123;</span><br><span class="line">  std::stack&lt;ImproperFraction&gt; sta;</span><br><span class="line">  <span class="keyword">while</span> (!suffixExpression.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::string s = suffixExpression.<span class="built_in">front</span>();</span><br><span class="line">    suffixExpression.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isOperator</span>(s)) &#123;</span><br><span class="line">      <span class="comment">// 假如遇到运算符，就取出栈顶元素进行计算</span></span><br><span class="line">      ImproperFraction a = sta.<span class="built_in">top</span>();</span><br><span class="line">      sta.<span class="built_in">pop</span>();</span><br><span class="line">      ImproperFraction b = sta.<span class="built_in">top</span>();</span><br><span class="line">      sta.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        sta.<span class="built_in">push</span>(a * b);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;\xc3&#x27;</span>) &#123;</span><br><span class="line">        sta.<span class="built_in">push</span>(b / a);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        sta.<span class="built_in">push</span>(a + b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sta.<span class="built_in">push</span>(b - a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 假如遇到数字，就直接进栈</span></span><br><span class="line">      sta.<span class="built_in">push</span>(<span class="built_in">stringToImproperFraction</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sta.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><h2 id="首先是各种参数错误的测试"><a href="#首先是各种参数错误的测试" class="headerlink" title="首先是各种参数错误的测试"></a><strong>首先是各种参数错误的测试</strong></h2><p><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145152174-840362064.png"><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145220286-2085095778.png"><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145231725-1173918739.png"><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145237511-1881695301.png"></p>
<h2 id="接着是传入正确的参数的测试"><a href="#接着是传入正确的参数的测试" class="headerlink" title="接着是传入正确的参数的测试"></a><strong>接着是传入正确的参数的测试</strong></h2><p>生成题集的测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145300636-1176994323.png"><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145309201-925214622.png"></p>
<p>给定的题目文件和答案文件，判定答案中的对错测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145337222-2053419510.png"><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145345693-634194743.png"></p>
<h1 id="效能分析"><a href="#效能分析" class="headerlink" title="效能分析"></a>效能分析</h1><p>本程序主要由生成运算题目和检查答案正确性两个模块，因此效能分析也主要针对这两个模块进行。<br><strong>1. 生成运算题目</strong><br>生成一百万条题目时候的时间占比情况：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145401885-266275327.png"></p>
<p>由上图看出了，占用时间最多的前五个函数为</p>
<ol>
<li>questionSetGenerate</li>
<li>gcd</li>
<li>addbrackets</li>
<li>digToString</li>
<li>ImproperFraction</li>
</ol>
<p>其中，questionSetGenerate是生成运算题目的函数入口，占用时间最长。gcd是在题目运算过程，分数通分时进行调用的，具体实现是辗转相除法。addbrackets是在生成题目的过程给表达式添加括号。digTostring是在生成题目的过程将数字转化为字符串。ImproperFraction是真分数的类名，由于生成的表达式中普遍含有真分数，所以多次调用了它的构造函数。</p>
<p><strong>2. 检查答案正确性</strong><br>检查五十万条题目时的时间占比情况：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145411370-99124462.png"></p>
<p>由上图可以看出，占用时间最多的前五个函数为：</p>
<ol>
<li>gcd</li>
<li>stringToImproperFraction</li>
<li>__deque_buf_size</li>
<li>transformInfixExprToSuffixExpr</li>
<li>_Deque_base</li>
</ol>
<p>其中，gcd用于运算过程的通分，stringToImproperFraction用于将字符串转化为真分数， transformInfixExprToSuffixExpr用于将中缀表达式转化为后缀表达式。另外两个函数是系统函数。</p>
<p>因此，假如要优化效能的话，可以优先在源代码追踪一下上述函数，看能否减少这些函数的调用或者优化其实现方式。</p>
<h1 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h1><table>
<thead>
<tr>
<th>PSP2.1</th>
<th>Personal Software Process Stages</th>
<th>预估耗时（分钟）</th>
<th>实际耗时（分钟）</th>
</tr>
</thead>
<tbody><tr>
<td>Planning</td>
<td>计划</td>
<td>60</td>
<td>50</td>
</tr>
<tr>
<td>· Estimate</td>
<td>· 估计这个任务需要多少时间</td>
<td>60</td>
<td>50</td>
</tr>
<tr>
<td>Development</td>
<td>开发</td>
<td>965</td>
<td>1545</td>
</tr>
<tr>
<td>· Analysis</td>
<td>· 需求分析 (包括学习新技术)</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>· Design Spec</td>
<td>· 生成设计文档</td>
<td>25</td>
<td>35</td>
</tr>
<tr>
<td>· Design Review</td>
<td>· 设计复审 (和同事审核设计文档)</td>
<td>25</td>
<td>35</td>
</tr>
<tr>
<td>· Coding Standard</td>
<td>· 代码规范 (为目前的开发制定合适的规范)</td>
<td>25</td>
<td>65</td>
</tr>
<tr>
<td>· Design</td>
<td>· 具体设计</td>
<td>60</td>
<td>80</td>
</tr>
<tr>
<td>· Coding</td>
<td>· 具体编码</td>
<td>360</td>
<td>415</td>
</tr>
<tr>
<td>· Code Review</td>
<td>· 代码复审</td>
<td>60</td>
<td>150</td>
</tr>
<tr>
<td>· Test</td>
<td>· 测试（自我测试，修改代码，提交修改）</td>
<td>360</td>
<td>665</td>
</tr>
<tr>
<td>Reporting</td>
<td>报告</td>
<td>110</td>
<td>130</td>
</tr>
<tr>
<td>· Test Report</td>
<td>· 测试报告</td>
<td>60</td>
<td>80</td>
</tr>
<tr>
<td>· Size Measurement</td>
<td>· 计算工作量</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>· Postmortem &amp; Process Improvement Plan</td>
<td>· 事后总结, 并提出过程改进计划</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>合计</td>
<td></td>
<td>1135</td>
<td>1725</td>
</tr>
</tbody></table>
<h1 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h1><p><strong>有待改进的地方</strong></p>
<p>   溢出问题：当给定r过大的时候，将会导致最终运算结构的分母溢出，而造成的数据错误<br>   目前方案：检查溢出，将发生了溢出的表达式删除<br>   更佳方案：使用大数的运算，就可以完美避免数据溢出的问题</p>
<p> 生成题目不够友好：当给定数据范围r稍稍有点大的时候，最终答案的分母可能超过一亿<br> 目前方案：不处理<br> 更佳方案: 暂无</p>
<p> 死循环生成题目: 当给定题数过大且给定限制太小时,无法生成要求的题目数量, 导致进入死循环<br> 目前方案: 设置时间戳time,只生成1000000次表达式,再进行合法性判断,但也导致有可能无法生成要求题目数量<br> 更佳方案: 暂无</p>
<h2 id="开发项目中发生的问题"><a href="#开发项目中发生的问题" class="headerlink" title="开发项目中发生的问题"></a><strong>开发项目中发生的问题</strong></h2><ol>
<li>一开始的时候是选择暴力深搜生成题集,再随机选取表达式输出,但是生成的效果来看,题目并不是很随机,例如前两个数字是固定死的,思前想后,觉得还是使用rand()随机生成效果更佳</li>
<li>在最开始设计方案的时候,还是思虑的不够多,以至于后面的代码复审(Debug)工作做了很多,远超过代码编写部分</li>
<li>还有各种人性化的设置,如参数错误提示,程序运行结果显示之类话语并没有想到,但是一个软件,一个项目最终都是面向于人群大众,人性化的设置是必须的</li>
</ol>
<h2 id="团队之中的闪光点"><a href="#团队之中的闪光点" class="headerlink" title="团队之中的闪光点"></a><strong>团队之中的闪光点</strong></h2><ol>
<li>良好的代码风格: 在一开始我们就约束好了团队的代码风格,在后续的代码编写之中我们也能够很好的参照代码风格进行书写,因此在代码复审的时候我们也能够很好的查阅对方的代码</li>
<li>不错的代码能力: 想定思路学习知识之后,可直接进行代码的实现,基本上不会出现一些逻辑错误.后面出现的bug也是因为设计的时候稍稍不够考虑细节,一旦出现bug,都能够立马找到bug和想到相应的修复方案</li>
<li>互帮互助: 在一开始我们就进行了分工,一个人主要负责对给定的题目文件和答案文件进行答案校对、参数组合正确性的检测，另一个人负责了题集的生成部分。并且在最后，一起测试并撰写了博客。<br>通过这次项目，我们实践了结对编程，提高了沟通能力，加强了团队合作的能力。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>后缀自动机学习笔记</title>
    <url>/2018/10/06/sam-learning/</url>
    <content><![CDATA[<p>后缀自动机(SAM)是一种用于处理字符串的高效数据结构，时间复杂度为$O(|S| * CHARSET_SIZE)$。其应用一般与子串有关，比如求解最长公共子串、求解不同子串的个数、求字典序第k小的子串。</p>
<p><a href="https://vjudge.net/contest/47126">题目传送门</a></p>
<h1 id="SPOJ-LCS-Longest-Common-Substring"><a href="#SPOJ-LCS-Longest-Common-Substring" class="headerlink" title="SPOJ LCS Longest Common Substring"></a>SPOJ LCS Longest Common Substring</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求它们的最长公共子串。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于字符串长度上限250000，所以$O(n^2)$的算法是行不通的。<br>我们可以考虑给其中一个字符串建立后缀自动机，该自动机保存了这个字符串的所有子串。接着，我们在这个自动机上跑另一个字符串，假如匹配，就走下一步，假如不匹配，就走失配指针，直到匹配或者回到了根节点。在这个过程中，维护一下匹配的长度，不断取max即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> okd(d) cout &lt;&lt; <span class="string">&quot;ok &quot;</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250009</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, now = <span class="number">1</span>, le = <span class="built_in">strlen</span>(s), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; le; i++) &#123;</span><br><span class="line">            <span class="type">int</span> to = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][to]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, ++cnt);</span><br><span class="line">                now = ch[now][to];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(now &amp;&amp; !ch[now][to]) now = fail[now];</span><br><span class="line">                <span class="keyword">if</span>(now) &#123;</span><br><span class="line">                    cnt = len[now] + <span class="number">1</span>;</span><br><span class="line">                    now = ch[now][to];</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = <span class="number">1</span>;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        sam.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    sam.<span class="built_in">solve</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="SPOJ-LCS2-Longest-Common-Substring-II"><a href="#SPOJ-LCS2-Longest-Common-Substring-II" class="headerlink" title="SPOJ LCS2 Longest Common Substring II"></a>SPOJ LCS2 Longest Common Substring II</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给n($2 &lt;&#x3D; n &lt;&#x3D; 10$)个字符串，求它们的最长公共子串。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这一题在上一题的基础上进行了一定的拓展。我们还是给其中一个字符串建立后缀自动机，然后将其余字符串在自动机上跑一遍。在每个节点上，我们需要维护一个$f$，表示所有字符串到达该结点时的最大匹配长度，初始化为第一个字符串的在该点的$len$。当其余字符串进来匹配的时候，用当前最大匹配长度来更新这个$f$，不断取min。这里需要注意的是，某个结点$u$被访问到，但其后缀链指向的结点$v$可能没被访问到，但是，根据SAM后缀树的性质，$v$结点表示的最大子串是会被完全匹配的。所以，我们将字符串在自动机跑完一遍后，还需要根据拓扑序再反向更新一下。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> okd(d) cout &lt;&lt; <span class="string">&quot;ok &quot;</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], mat[MAXN], f[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            mat[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> le = <span class="built_in">strlen</span>(s), lenn = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; le; i++) &#123;</span><br><span class="line">            <span class="type">int</span> ne = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][ne])</span><br><span class="line">                now = fail[now], lenn = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][ne]) &#123;</span><br><span class="line">                now = ch[now][ne];</span><br><span class="line">                f[now] = <span class="built_in">max</span>(f[now], ++lenn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 这一句非常精髓啊</span></span><br><span class="line">            <span class="keyword">if</span>(f[topo[i]])</span><br><span class="line">                f[fail[topo[i]]] = len[fail[topo[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            mat[i] = <span class="built_in">min</span>(mat[i], f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mat[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sam.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.<span class="built_in">topoSort</span>();</span><br><span class="line">    sam.<span class="built_in">pre</span>();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s)) &#123;</span><br><span class="line">        sam.<span class="built_in">update</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="SPOJ-NSUBSTR-Substrings"><a href="#SPOJ-NSUBSTR-Substrings" class="headerlink" title="SPOJ NSUBSTR 	Substrings"></a>SPOJ NSUBSTR 	Substrings</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>根据子串的长度，可将一个长为$|S|$的字符串的所有子串分到$|S|$个集合中。问在各个集合中，在母串中出现次数最多的子串的出现次数？</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>要统计某一子串出现的次数，需要按照拓扑序逆着更新。当访问到某一节点时，我们把最大长度子串所属集合的答案更新一下，然后传递一下$cntPos$给失配指针所指的结点。我们知道，一个结点表示了多个子串，为什么只更新最大长度子串所属的集合就行了呢？可以这样理解，假设某一节点的最大长度子串为$S[L…R]$，根据SAM的性质，$S[L..(R-1)]$一定不与S[L…R]$在同一结点，且它出现的次数不少于$S[L…R]$，因此，后续访问到该结点时会更新$(R-1)$的答案，而长度更短的同理，也是会被更新到。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250009</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 2 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span> len);</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        <span class="built_in">memset</span>(cntPos, <span class="number">0</span>, <span class="keyword">sizeof</span> cntPos);</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">2</span>;</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = last = sz++;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = sz++; len[n] = len[v] + <span class="number">1</span>;</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans[MAXN];</span><br><span class="line">        <span class="type">int</span> le = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = topo[i];</span><br><span class="line">            ans[len[u]] = <span class="built_in">max</span>(ans[len[u]], cntPos[u]);  <span class="comment">// ?</span></span><br><span class="line">            cntPos[fail[u]] += cntPos[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= le; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s)) &#123;</span><br><span class="line">        sam.<span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sam.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.<span class="built_in">topoSort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sam.<span class="built_in">solve</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="SPOJ-SUBLEX-Lexicographical-Substring-Search"><a href="#SPOJ-SUBLEX-Lexicographical-Substring-Search" class="headerlink" title="SPOJ SUBLEX Lexicographical Substring Search"></a>SPOJ SUBLEX Lexicographical Substring Search</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，求字典序第k小的子串。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>首先给字符串建立SAM，该SAM保存该字符串的所有子串。<br>接着，从根出发，dfs一遍，对各个结点统计从该结点出发的子串数。<br>然后，我们再从根出发，贪心地走字符较小的边。假如一条边到达的结点的子串数大于等于k，那么这条边就可以走。否则，我们减去该结点的子串数，然后找另一条边。一直做下去，直到k等于0了就停止。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 3 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line">pii G[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line"><span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line"><span class="type">int</span> path[MAXN], p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">2</span>;</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = last = sz++;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = sz++; len[n] = len[v] + <span class="number">1</span>;</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cntPath</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path[u]) <span class="keyword">return</span> path[u];</span><br><span class="line">        p[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[u][i]) &#123;</span><br><span class="line">                path[u] += <span class="built_in">cntPath</span>(ch[u][i]);</span><br><span class="line">                G[u][p[u]++] = <span class="built_in">pii</span>(ch[u][i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path[u]++;</span><br><span class="line">        <span class="keyword">return</span> path[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意用递归写法会超时</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findK</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p[u]; i++) &#123;</span><br><span class="line">                <span class="type">int</span> v = G[u][i].x;</span><br><span class="line">                <span class="keyword">if</span>(v &amp;&amp; path[v] &gt;= k) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G[u][i].y + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    k--;</span><br><span class="line">                    u = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    k -= path[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> q, lenn, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss);</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    lenn = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenn; i++)</span><br><span class="line">        sam.<span class="built_in">insert</span>(ss[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    sam.<span class="built_in">cntPath</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        sam.<span class="built_in">findK</span>(<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="SPOJ-COT4-Count-on-a-trie"><a href="#SPOJ-COT4-Count-on-a-trie" class="headerlink" title="SPOJ COT4 Count on a trie"></a>SPOJ COT4 Count on a trie</h1><p>留坑待填。</p>
<h1 id="HDU-4416-Good-Article-Good-sentence"><a href="#HDU-4416-Good-Article-Good-sentence" class="headerlink" title="HDU 4416 Good Article Good sentence"></a>HDU 4416 Good Article Good sentence</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，可以有很多子串，记为集合A。然后再给一些字符串，同样可以有很多子串，记为集合B。现在需要求集合A和集合B的差的大小，即在A集合里出现但不在B集合里出现的元素个数。</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先给第一个字符串建立SAM，然后依次将其余的字符串取更新这个SAM。<br>SAM中的各个结点需要保存一个值f，表示被其余字符串匹配到最大长度。对于某一结点u，f初始化为len[fail[u]]。<br>这里需要注意的是，同多个字符串的最长公共子串问题一样，在匹配完整个字符串后，还需要根据拓扑序逆着更新f一下。<br>最后，所有节点的len - f的和即为答案。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="type">int</span> f[MAXN];</span><br><span class="line">    <span class="type">bool</span> vis[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            f[i] = len[fail[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> up = <span class="built_in">strlen</span>(s), now = <span class="number">1</span>, le = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; up; i++) &#123;</span><br><span class="line">            <span class="type">int</span> v = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][v])</span><br><span class="line">                now = fail[now], le = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][v]) &#123;</span><br><span class="line">                now = ch[now][v];</span><br><span class="line">                vis[now] = <span class="literal">true</span>;</span><br><span class="line">                le++;</span><br><span class="line">                f[now] = <span class="built_in">max</span>(f[now], le);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">                vis[fail[u]] = <span class="literal">true</span>;</span><br><span class="line">                f[fail[u]] = len[fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            ans += len[i] - f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, kase;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, ++kase);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        sam.<span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sam.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.<span class="built_in">pre</span>();</span><br><span class="line">        sam.<span class="built_in">topoSort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            sam.<span class="built_in">update</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.<span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="POJ-3415-Common-Substrings"><a href="#POJ-3415-Common-Substrings" class="headerlink" title="POJ 3415 Common Substrings"></a>POJ 3415 Common Substrings</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求所有长度大于k的公共子串的对数。</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>我们知道，SAM中某个节点代表的是长度连续的数个后缀，不妨设长度为$[L, R]$。在匹配的过程中，长度会落在$[L, R]$之间，我们只需要加上$[k, R]$的这段（可能为空）。<br>另外，还需要按照拓扑序逆着更新一下，这里的更新需要是需要计数的。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span>        <span class="comment">//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>    <span class="comment">//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cfloat&gt;</span>    <span class="comment">//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span>    <span class="comment">//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> okd(d) cout &lt;&lt; <span class="string">&quot;ok &quot;</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">59</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="type">int</span> sum[MAXN], vis[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">topoSort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = topo[i];</span><br><span class="line">            cntPos[fail[u]] += cntPos[u];</span><br><span class="line">            vis[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>, le = <span class="number">0</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, up = <span class="built_in">strlen</span>(s); i &lt; up; i++) &#123;</span><br><span class="line">            <span class="type">int</span> v = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][v])</span><br><span class="line">                now = fail[now], le = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][v]) &#123;</span><br><span class="line">                now = ch[now][v];</span><br><span class="line">                le++;</span><br><span class="line">                vis[now]++;</span><br><span class="line">                <span class="keyword">if</span>(le &gt;= k) &#123;</span><br><span class="line">                    ans += <span class="number">1LL</span> * cntPos[now] * (le - <span class="built_in">max</span>(len[fail[now]] + <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">                sum[fail[u]] += vis[u];</span><br><span class="line">                vis[fail[u]] += vis[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] &gt;= k) &#123;</span><br><span class="line">                ans += <span class="number">1LL</span> * sum[i] * cntPos[i] * (len[i] - <span class="built_in">max</span>(len[fail[i]] + <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k) &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t);</span><br><span class="line">        sam.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s); i &lt; len; i++) &#123;</span><br><span class="line">            sam.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.<span class="built_in">solve</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="HDU-3518-Boring-counting"><a href="#HDU-3518-Boring-counting" class="headerlink" title="HDU 3518 Boring counting"></a>HDU 3518 Boring counting</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>首先给字符串建立SAM，对于各个结点，需要额外维护最长子串首先出现的位置以及最后出现的位置。最后出现的位置需要按照拓扑序逆着来更新。<br>然后扫一遍，根据某个结点代表的最短字符串、最长字符串与最长子串首先出现、最后出现位置，分情况讨论一下即可。<br>一开始没有注意到出现次数大于等于2这个条件，多想了一下。假如要求出现次数大于等于k的话，那么我们可能需要维护的是各个节点的最长子串出现的具体位置，这可能需要就需要用到LCT来维护了。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> okd(d) cout &lt;&lt; <span class="string">&quot;ok &quot;</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 6 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], l[MAXN], r[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(l, <span class="number">-1</span>, <span class="keyword">sizeof</span> l);</span><br><span class="line">        <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="keyword">sizeof</span> r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> po)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        l[u] = r[u] = po;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            l[n] = r[n] = l[o];</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">topoSort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = topo[i];</span><br><span class="line">            r[fail[u]] = <span class="built_in">max</span>(r[fail[u]], r[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] &lt;= r[i] - l[i]) &#123;</span><br><span class="line">                ans += len[i] - len[fail[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="built_in">max</span>(<span class="number">0</span>, r[i] - l[i] - len[fail[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) &amp;&amp; s[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        sam.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, up = <span class="built_in">strlen</span>(s); i &lt; up; i++) &#123;</span><br><span class="line">            sam.<span class="built_in">insert</span>(s[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.<span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="HDU-4622-Reincarnation"><a href="#HDU-4622-Reincarnation" class="headerlink" title="HDU 4622 Reincarnation"></a>HDU 4622 Reincarnation</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，然后有$Q$次询问，求该字符串$[L, R]$本质不同的字符串个数。</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>首先建立SAM，然后对于每次询问，分别处理，维护的是最大匹配长度。<br>然后，扫一遍各个节点，累加最大匹配长度 - 最小字符串 + 1 即可。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ok cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> okd(d) cout &lt;&lt; <span class="string">&quot;ok &quot;</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2009</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 7 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="type">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> v = last, u = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">newnode</span>(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="built_in">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>, le = <span class="number">0</span>, f[MAXN];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="type">int</span> v = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            now = ch[now][v];</span><br><span class="line">            le++;</span><br><span class="line">            f[now] = <span class="built_in">max</span>(f[now], le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(f[u]) &#123;</span><br><span class="line">                f[fail[u]] = len[fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0</span>, f[i] - len[fail[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, T, l, r;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>)!=<span class="literal">NULL</span>) &#123;<span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        sam.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s); i &lt; len; i++) &#123;</span><br><span class="line">            sam.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.<span class="built_in">topoSort</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            sam.<span class="built_in">solve</span>(s, l - <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="HDU-4436-str2int"><a href="#HDU-4436-str2int" class="headerlink" title="HDU 4436 str2int"></a>HDU 4436 str2int</h1><p>留坑待填。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 C++ Single Number I II III</title>
    <url>/2019/01/13/leetcode-single-number/</url>
    <content><![CDATA[<p>在Leetcode上做了Single Number系列的三道题，都是与位运算有关的，感觉都挺巧妙。</p>
<h1 id="Leetcode-136-Single-Number-I"><a href="#Leetcode-136-Single-Number-I" class="headerlink" title="Leetcode 136 Single Number I"></a>Leetcode 136 Single Number I</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有一个数字是出现一次的，其他的数字都恰好出现两次，现在求只出现一次的数是多少。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据异或的性质，答案是所有的数字的异或和。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="Leetcode-137-Single-Number-II"><a href="#Leetcode-137-Single-Number-II" class="headerlink" title="Leetcode 137 Single Number II"></a>Leetcode 137 Single Number II</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有一个数字是出现一次的，其他的数字恰好都出现三次，现在求只出现一次的数是多少。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>显然，假如还是用上一题的做法，直接将数字异或起来，是得不到答案的。为什么上一题的答案直接异或起来就可以，因为出现两次的数字异或后等于出现零次，具体对于某一位来说，它会经过<code>0-&gt;1-&gt;0</code>这么个过程。而对于这道题，假如某个数字出现了三次，那么对于具体某一位来说，它会经过<code>0-&gt;1-&gt;0-&gt;1</code>这个过程。因此，我们应用两个位来表示具体某一位的状态变化，即让它经过<code>00-&gt;10-&gt;01-&gt;00</code>这么个过程。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            ones = (ones ^ i) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ i) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-260-Single-Number-III"><a href="#Leetcode-260-Single-Number-III" class="headerlink" title="Leetcode 260 Single Number III"></a>Leetcode 260 Single Number III</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有两个数字是出现一次的，其他的数字恰好都出现两次，现在求只出现一次的数是哪两个。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>我们先将所有数字异或起来，得到<code>c</code>。设答案为<code>a</code>和<code>b</code>，那么<code>c = a ^ b</code>。</p>
<p>对于这个<code>c</code>的各个位，有的是<code>0</code>，有的是<code>1</code>。值为<code>1</code>的位，意味着只属于<code>a</code>或<code>b</code>。因此，我们可以任意取<code>c</code>中一个值为<code>1</code>的位，将所有数字划分为两个可重集合，这两个集合的数字分别异或起来就是答案。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            sum ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum &amp;= -sum;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &amp; i) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] ^= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[<span class="number">1</span>] ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>位运算</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 C++ Two Sum | 3Sum | 4Sum</title>
    <url>/2019/03/01/leetcode-sum/</url>
    <content><![CDATA[<h1 id="Leetcode-1-Two-Sum"><a href="#Leetcode-1-Two-Sum" class="headerlink" title="Leetcode 1 Two Sum"></a>Leetcode 1 Two Sum</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出两个不同下标的元素，使得它们的值等于某一个值。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>法一：先排序，然后双指针扫一遍。时间复杂度是$O(nlogn)$，空间复杂度是$O(logn)$。</li>
<li>法二：哈希，空间换时间。时间复杂度$O(n)$，空间复杂度是$O(n)$。</li>
</ol>
<p>下面给出法二的代码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(diff);</span><br><span class="line">            <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15 3Sum"></a>Leetcode 15 3Sum</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出所有三个不同下标的元素，使得它们的值等于0。另外要求三元组不能重复。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>先排序，然后利用有序性，将原本需要三层循环的遍历用一层循环 + 双指针来做。时间复杂度是$O(n^2)$。<br>用C++写的话，需要注意vector的size()函数返回的是vector::size_type，一般是unsigned int。<br>因此，假如传进来的vector的元素个数少于2，那么num.size() - 2运算后得到的是一个很大的正数，造成运行错误。<br>所以，我们可以先判断一下nums.size()的大小，假如小于3，那么就直接返回了。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (nums[i] != nums[i<span class="number">-1</span>])) &#123;</span><br><span class="line">                <span class="type">int</span> need = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="type">int</span> lo = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[lo] + nums[hi] == need) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt; &#123;nums[i], nums[lo], nums[hi]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi<span class="number">-1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++, hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; need) &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-18-4Sum"><a href="#Leetcode-18-4Sum" class="headerlink" title="Leetcode 18 4Sum"></a>Leetcode 18 4Sum</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出所有四个不同下标的元素，使得它们的值等于某个值。另外要求四元组不能重复。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先排序，然后利用有序性，将原本需要四层循环的遍历用两层循环 + 双指针来做。时间复杂度是$O(n^3)$。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> lo = j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> hi = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = nums[i] + nums[j] + nums[lo] + nums[hi];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[j], nums[lo], nums[hi]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++, hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 题解 C++ 链表总结</title>
    <url>/2019/03/04/leetcode-linked-list/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>有时候加个冗余头节点会大大降低实现难度，让代码变得更简洁。</li>
<li>做与链表相关的题目一定要在写代码前就想清楚算法的各个步骤，想好要保存哪些指针。否则很容易写乱。</li>
<li>要注意delete掉删除掉的节点，避免内存泄露。</li>
</ol>
<h1 id="Leetcode-2-Add-Two-Numbers"><a href="#Leetcode-2-Add-Two-Numbers" class="headerlink" title="Leetcode 2 Add Two Numbers"></a>Leetcode 2 Add Two Numbers</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>用链表存储十进制数字的各位，现在给这样的两个链表，求和。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于链表头存的是最低位，所以我们可以同时扫描两个链表，模拟一下加法就行了。<br>假如用C++写的话，可以先开一个冗余头指针，方便实现。注意申请或释放内存时，应该要用new和delete而不要用malloc和free，养成良好的编程习惯。<br>假设两个链表的长度分别为n和m，那么时间复杂度和空间复杂度都是$O(n + m)$，显然空间复杂度可以优化到$O(1)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="type">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode 19 Remove Nth Node From End of List"></a>Leetcode 19 Remove Nth Node From End of List</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个链表，要求删除倒数第n个节点。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这道题的边界情况是删除链表首个节点。<br>我们用两个指针指向表头，然后让其中一个指针先走n步，假如走完n步后指向了空指针，说明删除的是表头。假如走完不是空指针，则让另外一个指针开始和它一步一步走，直到前面的指针指到了最后一个节点时，后面的指针刚好指向待删除节点的前一个节点。<br>这样做的时间复杂度是$O(n)$。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *behind = head, *ahead = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ahead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">delete</span>(temp);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ahead-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">            behind = behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = behind-&gt;next;</span><br><span class="line">        behind-&gt;next = behind-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode 21 Merge Two Sorted Lists"></a>Leetcode 21 Merge Two Sorted Lists</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>合并两个有序链表。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接写就行了，时间复杂度为$O(n+m)$，其中n和m为两个链表的长度。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>合并k个有序链表。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>我们需要一种数据结构来较快地插入一个数，取出最小的数，删除最小的数。不难想到优先队列可以满足这些要求。<br>假设k个链表的节点个数和为n，则时间复杂度为$O(nlogk)$。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="type">int</span> idx;</span><br><span class="line">        <span class="built_in">Node</span>(ListNode *p, <span class="type">int</span> idx) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">            <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val &gt; rhs.p-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Node&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i]) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">Node</span>(lists[i], i));</span><br><span class="line">                lists[i] = lists[i]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node node = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (lists[node.idx] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="type">int</span> idx = node.idx;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">Node</span>(lists[idx], idx));</span><br><span class="line">                lists[idx] = lists[idx]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = node.p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode 24 Swap Nodes in Pairs"></a>Leetcode 24 Swap Nodes in Pairs</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>两两交换链表的相邻节点。</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>递归来写，分三种情况，当前节点是空节点，当前节点没有后继，当前节点有后继。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead = head-&gt;next;</span><br><span class="line">        ListNode *nex = head-&gt;next-&gt;next;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(nex);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-25-Reverse-Nodes-in-k-Group"><a href="#Leetcode-25-Reverse-Nodes-in-k-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in k-Group"></a>Leetcode 25 Reverse Nodes in k-Group</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>是Leetcode 24的升级版，需要将链表的每k个节点翻转。</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>用迭代来写，先加个冗余头节点，方便实现。需要记录k节点组的前一个节点p，第一个节点head，最后一个节点tail。然后，我们不断地将p的后一个节点扔到tail的后面即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *p = dummy, *tail = dummy, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count != k &amp;&amp; tail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next != tail) &#123;</span><br><span class="line">                temp = p-&gt;next;</span><br><span class="line">                p-&gt;next = temp-&gt;next;</span><br><span class="line">                </span><br><span class="line">                temp-&gt;next = tail-&gt;next;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>回转链表，注意不是反转链表。</p>
<h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>分三步，首先求出链表长度以及最后一个节点，然后找到回转后的首个节点的前继，最后修改一下它们的指针即可。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *p = head, *lastNode;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            lastNode = p;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k = len - k - <span class="number">1</span>;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode-&gt;next = head;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode 82 Remove Duplicates from Sorted List II"></a>Leetcode 82 Remove Duplicates from Sorted List II</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>删除有序链表中的重复元素。</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>申请个冗余节点会比较好实现点。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *p2 = head;</span><br><span class="line">            <span class="keyword">while</span> (p2-&gt;next &amp;&amp; p2-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != p2) &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != p2) &#123;</span><br><span class="line">                    ListNode *temp = head-&gt;next;</span><br><span class="line">                    <span class="built_in">delete</span>(head);</span><br><span class="line">                    head = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                head= p2-&gt;next;</span><br><span class="line">                <span class="built_in">delete</span>(p2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = head;</span><br><span class="line">                p = p-&gt;next; </span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = dummy-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 83 Remove Duplicates from Sorted List"></a>Leetcode 83 Remove Duplicates from Sorted List</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>删除有序链表中的多余的重复元素，即要保证每个元素最多出现一次。</p>
<h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>直接扫一遍就行了，注意delete掉删掉的节点。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">                ListNode *temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="built_in">delete</span>(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode 86 Partition List"></a>Leetcode 86 Partition List</h1><p>留坑待填。</p>
]]></content>
  </entry>
  <entry>
    <title>git 简明手册 | 学习笔记</title>
    <url>/2019/07/02/git-book/</url>
    <content><![CDATA[<h2 id="迭代记录"><a href="#迭代记录" class="headerlink" title="迭代记录"></a>迭代记录</h2><ul>
<li>190702 首次提交</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>全局配置文件：<code>~/.gitconfig</code></p>
</li>
<li><p>项目配置文件：<code>&lt;project&gt;/.git/config</code></p>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加文件到仓库</span></span><br><span class="line">git add &lt;FILE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把当前所有位置的所有文件都添加到仓库中</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定add具体哪些内容，使用?查看选项的解释</span></span><br><span class="line">git add -p</span><br></pre></td></tr></table></figure>

<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支+远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的分支建立追踪关系，一般是对远程分支建立追踪关系</span></span><br><span class="line">git branch --track [newBranch] [remote/branch]</span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">git branch --track mage origin/mage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间 | 已经弃用</span></span><br><span class="line">git branch --set-upstream [branch] [remote/branch]</span><br></pre></td></tr></table></figure>

<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对当前工作区文件的修改。其中--的作用是表明后面的参数是文件名，而不是分支名。</span></span><br><span class="line">git checkout -- FILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建+切换分支</span></span><br><span class="line">git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在origin/master的基础上，创建一个新分支。</span></span><br><span class="line">git checkout -b &lt;name&gt; origin/master</span><br></pre></td></tr></table></figure>

<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>

<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只克隆仓库的最新一个版本，对于多次提交的仓库可明显提高clone速度</span></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-o指定远程分支名，假如不指定，默认是origin</span></span><br><span class="line">git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>

<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把文件提交到仓库</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以选择部分文件commit</span></span><br><span class="line">git commit &lt;file1&gt; &lt;file2&gt;...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 它一般适用于还未提交到远程仓库的提交，也适用于gerrit，不适用于Github</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不更改评论信息</span></span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure>

<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置提交代码时的用户信息。</span></span><br><span class="line">git config [--global] user.name <span class="string">&quot;Username&quot;</span></span><br><span class="line">git config [--global] user.email <span class="string">&quot;email@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前的git配置。</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件。</span></span><br><span class="line">git config -e [—global]</span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以将FILE现在的状态和最近一次add到仓库的状态进行一次diff。</span></span><br><span class="line">git diff FILE</span><br></pre></td></tr></table></figure>


<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取回分支，但是并不合并。</span></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定取哪个分支，默认情况下会取所有分支。</span></span><br><span class="line">git fetch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程分支到本地某个分支，假如本地分支不存在，则创建。不会切换到该分支。</span></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">git fetch origin :branch2</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">git fetch origin master:branch2</span><br></pre></td></tr></table></figure>


<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看commit日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>


<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>

<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 某些部分可省略。</span></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，取回origin/next分支，再与当前分支合并。</span></span><br><span class="line">git pull origin next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令指定master分支追踪origin/next分支。</span></span><br><span class="line">git branch --set-upstream master origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，本地的当前分支自动与对应的origin主机&quot;追踪分支&quot;进行合并。</span></span><br><span class="line">git pull origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准格式</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地分支推送到远程主机。</span></span><br><span class="line">gut push origin &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支。</span></span><br><span class="line">git push origin --delete &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure>

<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看引用日志，可以回到“未来”。</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有远程主机。</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以参看远程主机的网址。</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主机的详细信息。</span></span><br><span class="line">git remote show &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于删除远程主机。</span></span><br><span class="line">git remote <span class="built_in">rm</span> &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于远程主机的改名。</span></span><br><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将仓库连接到远程服务器。一般是在git init后使用，绑定远程主机。</span></span><br><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 撤销对当前缓存区的修改，相当于`git add`的反操作。</span></span><br><span class="line">git reset -- &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对当前缓存区的修改。</span></span><br><span class="line">git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让HEAD指针指到commit_id代表的状态。顺便一提，HEAD^表示上一个状态，HEAD^^表示上上个状态。</span></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>

<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程分支</span></span><br><span class="line">git revert</span><br></pre></td></tr></table></figure>


<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区。即删除远程文件和本地文件。</span></span><br><span class="line">git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区。即删除远程文件，但不删除本地文件。</span></span><br><span class="line">git <span class="built_in">rm</span> --cached [file]</span><br></pre></td></tr></table></figure>

<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看仓库当前的状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加了tag的commit就会将源码添加到打包，一般用版本号为tag命名</span></span><br><span class="line"><span class="comment"># 在Github上看到的release不是git提供的，而是代码托管网站出于满足开发者发布二进制文件的需求而开发的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>理财入门</title>
    <url>/2019/07/13/financial-management/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理财，同时也是提高自我认知的过程。此博文记录了自己的理财学习之路，希望能对读者有些帮助。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>管理好自己的财产的第一步，是要对自己的支出收入情况有所了解。假如一个人对自己的收支情况一点不了解，就算中了百万彩票，挥金如土，也会很快被挥霍完。而假如一个人对于自己的收支情况了然于胸，量入为出，才能过得很踏实。</p>
<p>在这里，通过一番比较后，我选择了复式记账法，并采用了beancount和fava这两个工具。网上介绍这两个工具的好文章已有不少，这里不再赘述使用方法，而只提一下它的优点。beancount，它是开源的，它可以让你以纯文本的形式记账，并将数据保存在自己的电脑上，保证了数据的可移植性和安全性，无需支付额外费用，使用成本低。另外，利用fava可将数据可视化，可以直观地看到自己的财务情况，非常方便。</p>
<p>很多人之所以不能坚持记账，大多数是因为记账太过繁琐，且记账产生的数据像一潭死水，无法产生实际的指导价值。而用beancount+fava，可以克服这两个缺点。现在大多数网站，比如支付宝和微信支付，都可以导出账单，我们不难写个脚本将其转化成符合beancount语法的文本数据。fava将数据可视化后，含有损益表、资产负债表、试算表、资产、统计等界面，可以很直观地看到自己的收支情况、资产负债情况等。这些东西需要一些财务知识才能理解，我主要通过搜索引擎+看书来学习，这里推荐一本书，书名叫《给创业小白的财报书》，豆瓣评分9.0，值得一读。</p>
<p>我认为实现财务自由最关键的是增加收入以及通过投资来增加净资产。增加净资产，可以通过购买债券、基金、股票、房地产等方式。待所购资产实现增值后，我们的净资产也就增加了。现在我对于存款的处理方式是直接购买基金，因为比较方便。但是购买基金是一种低风险低收益的投资活动，虽然可以实现财富增长，但若想尽快实现财务自由这个目标，依靠此方式是行不通的。所以有必要去学习其他投资方式，这里挖个坑，以后学了再补上。</p>
<p>虽然财务自由听起来很虚幻很遥远，但是我觉得通过一定的努力是能够达到的。当然，每个人对于财务自由的定义会有所不同，我自己的要求比较低，<strong>资产所产生的收益能超过日常开销即算财务自由</strong>。共勉。</p>
]]></content>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 0 计算机系统漫游</title>
    <url>/2019/08/30/CSAPP-learning-note-0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CSAPP（深入理解计算机系统）这本书豆瓣评分接近满分，是学习计算机系统的经典教材之一。这一周开始阅读此书，并计划以后每周写一篇学习笔记。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>数据和信息是两个含义不同的词。数据是“死”的，而信息是“活”的。举个例子，阿拉伯数字8，在不同的情景下，可传递不同的信息。当电梯中可表示第8层，在桌球桌上可表示黑球8，而在聊天中可表示”拜拜”的意思。是什么赋予了它内涵？是情景，也称作上下文。在计算机系统中，数据就是比特串，是一个一个的位，再加上具体的上下文，就成为了信息。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一个C语言程序，需要经过预处理器、编译器、汇编器、链接器的翻译，才能转化成可执行目标程序。</p>
<p>编译是个转化数据的过程。转化前是源代码，是人类可以理解的信息。而转化后，变成了机器语言，变成了人类无法理解的信息，而机器在一定的上下文中，能够理解这些数据。机器语言是机器能够理解的信息。</p>
<p>学习编译系统，可以帮助我们优化程序性能、理解链接时出现的错误、避免安全漏洞等。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>编译后产生的可执行文件在磁盘里。当我们执行该文件时，计算机系统是怎么运作的呢？</p>
<p>假设我们是在shell执行该程序的。键盘是一个外部设备，通过系统I&#x2F;O总线和其他硬件连接在一起。当我们通过键盘输入可执行文件的文件名时，字符串会通过总线被逐一读入CPU中的寄存器并送入内存，且会输出到图形适配器（所以我们才可以在屏幕上看到输入的字符）。当输入回车后，shell就会通过一系列的指令来执行该程序，将程序的文件内容装载进内存，开始子进程，将CPU让给它执行。这个过程中，不同的指令，会让数据在CPU、内存、I&#x2F;O设备间流动，比如输出文字到屏幕、通过网络下载文件等。</p>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>所谓高速缓存，是为了解决CPU从寄存器读取数据与从内存读取数据的速度差异问题。CPU从寄存器读取数据比从内存读取数据要高几个数量级。所以一个自然的想法是提高寄存器的容量，这是一个解决思路，但是因为寄存器的价格要比内存贵得多，大幅提高容量从经济的角度考虑不太现实。另一个解决思路是提高主存的读取速度，这很接近现在大部分计算机系统采用的方法了。根据计算机组成原理的知识，我们知道SRAM的读取性能比DRAM的快得多，且SRAM也分多种，不同的SRAM实现会有不同的性能表现，价格也有差异。因为SRAM的价格还是要比DRAM高，大量采用SRAM作为主存也不现实。因此形成了一种折中的方案，采用DRAM作为主存，SRAM作为CPU的高速缓存。当CPU执行指令时，首先会从寄存器取数据，假如取不到，再到高速缓存取，假如还取不到，才到主存取。通过引进高速缓存，缓解了CPU执行速度与从内存读取数据速度不匹配的问题。</p>
<p>利用局部性原理，可提高高速缓存的命中率，让CPU尽可能快地取到指令去执行，提高整体效率。至于高速缓存中的数据与内存中的数据的映射，则涉及到了计算机组成原理，这里不再深入讲述。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>所谓抽象，在生活中其实随处可见。记得《人类简史》中写到，人类区别于其他生物的重要原因便是想象力丰富。人类之间通过讲述各种故事，塑造各种抽象概念，诸如宗族、城市、国家等概念，让原本互不认识的人有了联系的纽带，共同合作，诞生了各种文明。计算机系统中也有各种抽象概念，诸如文件、虚拟内存、进程。这些抽象，在我看来，是人类设计冯诺依曼计算机的基础，没有这些概念，计算机系统便不知道从何说起。</p>
<p>文件时什么？文件是一些二进制位在I&#x2F;O设备中的抽象。</p>
<p>虚拟内存是什么？虚拟内存是程序的在主存和I&#x2F;O设备中的空间的抽象。</p>
<p>进程是什么？进程是程序在CPU、主存、I&#x2F;O设备活动的抽象。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 1 信息的表示和处理</title>
    <url>/2019/09/08/CSAPP-learning-note-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一周看完了第一章，这一周继续看第二章。本章的内容和信息的表示和处理有关，这部分内容之前修计算机组成原理时有学习到，所以阅读起来比较顺利，预计下周能顺利读完此章。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这一章的内容分为四小节，分别是：</p>
<ul>
<li>信息存储</li>
<li>整数表示</li>
<li>整数运算</li>
<li>浮点数</li>
</ul>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p><a href="https://hyzgh.github.io/2019/08/30/CSAPP-learning-note-0/">上篇笔记</a>谈到了信息，什么是信息？信息是数据+上下文。</p>
<p>在不同的上下文中，数据会有不同的含义。一个字节，既可表示一个字符，也可表示范围在[0, 256)的无符号整数，也可表示范围在[-128, 128)的有符号整数，还可以表示具有8个元素的集合，等等。</p>
<p>大多数机器使用8位的块，称为字节，作为最小的可寻址的内存单位，而不是直接访问内存中单独的位。字长为32位的机器，寻址的最大空间是$2^{32}$字节，而字长为64位的机器，寻址的最大空间就是$2^{64}$字节。什么是字长呢，字长用于指明指针数据的标称大小。</p>
<p>因为一个字节有8个位，用二进制表示起来有点冗长，而用十进制表示法的话，与位模式的互相转化会很麻烦。于是就有了十六进制数来表示位模式，在二进制和十进制取了折中，既方便表示，又不那么难读。</p>
<p>假如我们想要访问跨越多字节的对象，需要建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。对象地址的寻址范围根据字长而定，当字长为$w$时，可寻址空间为$2^{w}$。确定好对象的起始地址，还需要知道它有多少个字节以及如何排列这些字节。假设读取对象为<code>int</code>，有四个字节，且在内存中从低址到高址的内容为<code>0x00000001</code>，采用大端法读取就是$1$，采用小端法读取就是$2^{24}$。大端表示法比较符合人类的习惯，而小端法需要将数据按字节倒序排列。这些数据在机器中的字节排列通常对我们没有影响，但当涉及到网络编程时，就需要关注网络传输数据和机器存储数据的区别了。</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>整数在计算机中有多种表示形式，比如原码、补码、反码等。</p>
<p>而编程语言中遇到的整数类型，比如<code>short</code>, <code>int</code>, <code>long long</code>等，是对整数大小的限制。</p>
<p>而常说的有符号数、无符号数，则是在人类限制整数能否表示负数而产生。我认为有符号数和无符号数的设计其实意义不大，只用一种有符号数来表示整数就足够了。有了无符号数和有符号数，就需要用户去关注无符号数和有符号数的转化，一些隐式转化很容易引起出人意料的隐蔽错误。在Java中，并没有无符号数的概念，而在C语言中，有符号数和无符号数的转化，其实整数在底层的位表示中是不变的，只是C语言在不同的上下文中对它进行了不同的解释。</p>
<p>无符号数，采用简单的原码编码即可。而有符号数，一般采用补码编码，因为相对于源码、反码，它能表示更多一个数，更重要的是，机器中的位表示与整数是一个双射关系，很优雅。</p>
<p>无符号数和有符号数的转化，在理解了机器的位表示始终不变以及补码的相关知识后，我们可以总结出规律。我们这里假设两者的位数都为$w$。将无符号数转化为有符号数，当超过其表示范围时，需要减去$2^w$。将有符号数转化为无符号数时，负数需要加上$2^w$。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记</title>
    <url>/2019/07/31/Go-learning-note/</url>
    <content><![CDATA[<h1 id="常用packages"><a href="#常用packages" class="headerlink" title="常用packages"></a>常用packages</h1><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>Printf</code></p>
<table>
<thead>
<tr>
<th>verb</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>输出值</td>
</tr>
<tr>
<td>%+v</td>
<td>输出键-值</td>
</tr>
<tr>
<td>%#v</td>
<td>输出包名、类型名、键-值</td>
</tr>
<tr>
<td>%T</td>
<td>类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
<tr>
<td>%t</td>
<td>布尔值</td>
</tr>
<tr>
<td>%b</td>
<td>二进制的值</td>
</tr>
<tr>
<td>%c</td>
<td>Unicode编码的字符</td>
</tr>
<tr>
<td>%d</td>
<td>十进制的值</td>
</tr>
<tr>
<td>%o</td>
<td>八进制的值</td>
</tr>
<tr>
<td>%x或%X</td>
<td>十六进制的值</td>
</tr>
<tr>
<td>%U</td>
<td>十六进制表示的Unicode值</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%p</td>
<td>地址</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数，默认精度是小数点后6位</td>
</tr>
<tr>
<td>%e</td>
<td>浮点数，科学计数法，默认精度是小数点后6位</td>
</tr>
<tr>
<td>%g</td>
<td>浮点数，有效数字，尽可能地输出所有位数</td>
</tr>
<tr>
<td>+</td>
<td>添加正负号</td>
</tr>
<tr>
<td>-</td>
<td>设置宽度时默认在左边补全空格，该符号可设置在右边补全空格</td>
</tr>
<tr>
<td>0</td>
<td>用0代替空格进行补全</td>
</tr>
<tr>
<td>#</td>
<td>对于八进制，十六进制等，加上提示符，如八进制为0，十六进制为0x</td>
</tr>
</tbody></table>
<p><code>%f</code> 可指定浮点数的宽度和精度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%f     default width, default precision</span><br><span class="line">%9f    width 9, default precision</span><br><span class="line">%.2f   default width, precision 2</span><br><span class="line">%9.2f  width 9, precision 2</span><br><span class="line">%9.f   width 9, precision 0</span><br></pre></td></tr></table></figure>

<p><code>%g</code> 可指定浮点数的有效数字位数，对于12.345，<code>%.3g</code> 将输出 12.3</p>
<p>若要能对某个自定义类型输出，只要对它定义<code>String() string</code>方法即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d/%g/%q&quot;</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当t是*T类型时，才会调用上面那个函数</span></span><br><span class="line"><span class="comment">// 若要当t是T类型和*T类型都都调用上面那个函数，需要将上面的*T改成T</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br></pre></td></tr></table></figure>



<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>会将内容输出到stderr，且会增加一些信息（如日期时间）。</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>注意只有当结构体内的成员是公开时，才能在Marshal的时候被识别，成为json文件的一部分。</p>
<p>进行Unmarshal时，假如json中有的字段而结构体没有，则这个字段会被忽略，不影响解析。也就是说，可进行json文件的部分解析。同理，假如Marshal时，结构体中的字段不想转到JSON文件中，可以将其tag设置为”-“。</p>
<p>解析时，结构体的某个字段的匹配优先级为tag -&gt; 导出名精确匹配 -&gt; 导出名模糊匹配。</p>
<p>omitempty表示当字段为零值时忽略它，而tag为”-“表示直接忽略它。</p>
<p>UnmarshalText函数和UnmarshalJSON函数的区别是什么？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当不知道json文件的格式时，可这样解析</span></span><br><span class="line">b := []<span class="type">byte</span>(<span class="string">`&#123;&quot;Name&quot;:&quot;Wednesday&quot;,&quot;Age&quot;:6,&quot;Parents&quot;:[&quot;Gomez&quot;,&quot;Morticia&quot;]&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  m := f.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">&quot;is string&quot;</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">&quot;is float64&quot;</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">      fmt.Println(k, <span class="string">&quot;is an array:&quot;</span>)</span><br><span class="line">      <span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">        fmt.Println(i, u)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">&quot;is of a type I don&#x27;t know how to handle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若将结构体的成员设置为指针类型，则若json不存在相应的字段，则为nil</span></span><br><span class="line"><span class="keyword">type</span> IncomingMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">  Cmd *Command</span><br><span class="line">  Msg *Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于流的Encoders和Decoders</span></span><br><span class="line">de := json.NewDecoder(os.Stdin)</span><br><span class="line">enc := json.NewEncoder(os.Stdout)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> v <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := dec.Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> k := <span class="keyword">range</span> v &#123;</span><br><span class="line">    <span class="keyword">if</span> k != <span class="string">&quot;Name&quot;</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(v, k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := enc.Encode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Basic-component"><a href="#Basic-component" class="headerlink" title="Basic component"></a>Basic component</h1><h2 id="package-import"><a href="#package-import" class="headerlink" title="package | import"></a>package | import</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任何go程序都是由package组成，首个非空单词必须是package</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个import</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个import</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><p>形式：形参的标识符在前，类型在后；返回值放在最后面</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样做的主要原因是为了提高易读性，特别是在涉及函数变量（函数指针）的时候</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">int</span>) <span class="type">int</span></span><br><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">int</span>) <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同类型的形参可简写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回值可有多个</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可给返回值命名，且return可简写，注意不要在长函数中简写，因为这样会降低可读性</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="variables-constants-types"><a href="#variables-constants-types" class="headerlink" title="variables | constants | types"></a>variables | constants | types</h2><p>首字母大写的变量称为exported name</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  Address <span class="type">string</span>  <span class="comment">// exported name</span></span><br><span class="line">  cost <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>申明格式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单句</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有赋初值时，可省略类型名</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">d := <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当省略类型名时，编译器会自动推测，推测规则为：</p>
<ul>
<li>右边是变量，则和变量的类型相同</li>
<li>右边是常量，则有可能是int, float64, complex128</li>
</ul>
<p>基础类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="type">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>申明的变量假如没有被显式赋初值，则会被赋<code>zero value</code>，即数值为0，布尔类型为false，字符串为””，指针为nil</p>
<p>申明常量，用<code>const</code>，不能用<code>:=</code>，因为<code>:=</code>是和<code>var</code>关联的，而<code>var</code>代表变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>没有隐式类型转换，必须显式类型转换。</p>
<p>类型断言，用于将空接口转换为普通类型。类型断言又分为安全类型断言和非安全类型断言。</p>
<ul>
<li>&lt;目标类型的值&gt;，&lt;布尔参数&gt; :&#x3D; &lt;表达式&gt;<strong>.</strong>(目标类型)  &#x2F;&#x2F; 安全类型断言</li>
<li>&lt;目标类型的值&gt; :&#x3D; &lt;表达式&gt;<strong>.</strong>(目标类型)  &#x2F;&#x2F; 非安全类型断言</li>
</ul>
<p>在函数体内，变量申明了但不使用会报错。同理，import的package没用的话也会报错。</p>
<p>Go在函数体中定义了一个变量，然后将它的指针返回是合法的，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">// 或者将上面两行简写成return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">    <span class="comment">// 不难发现new(File)和&amp;File&#123;&#125;是等价的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="More-types"><a href="#More-types" class="headerlink" title="More types"></a>More types</h1><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>指针，和C不一样，Go没有指针的算术运算，即不支持<code>p = p + 10</code>这样的语句</p>
<h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>结构体，可将<code>(*p).X</code>写成<code>p.X</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// has type Vertex</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 is implicit</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 and Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// has type *Vertex</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>In Go：</p>
<ul>
<li>Arrays are values. Assigning one array to another copies all the elements.</li>
<li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li>
<li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">    fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    fmt.Println(primes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如想要像C那样只传数组的地址，可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="type">float64</span>)</span></span> (sum <span class="type">float64</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="type">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// Note the explicit address-of operator</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然可以这么写，但不推荐，因为更优雅的方法是使用slices。</p>
<h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>切片，本身不存储实际数据，类似于引用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>切片数组，可以改变指向的范围</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    t := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">    r = t</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>切片，可省略下界或上界</p>
<p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p>
<p><code>len()</code>查看长度，即从下界到上界的个数</p>
<p>切片为<code>nil</code>时，<code>cap</code>和<code>len</code>都为0</p>
<p>使用<code>make</code>来创建一维切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line">    printSlice(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    c := b[:<span class="number">2</span>]</span><br><span class="line">    printSlice(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">    d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    printSlice(<span class="string">&quot;d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="type">string</span>, x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s len=%d cap=%d %v\n&quot;</span>,</span><br><span class="line">        s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>make</code>创建二维切片，第一种方式，该方式允许第二维大小有所变化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可使用<code>append</code>函数向切片添加元素，假如切片容量不足，则容量会翻倍。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以使用<code>append</code>函数向切片中添加切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缩减切片的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">&quot;[0-9]+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ugly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elegant，缩减了切片的cap，释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><code>maps</code>的零值为<code>nil</code>，可通过<code>make</code>创建<code>map</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化时，值的类型名可省略</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入键值对，取键的值，删除键值对（可多次删除，可删除不存在的键）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>map被函数调用，可被修改。</p>
<h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也可以作为值，可以像其他数据类型一样赋值给变量，作为实参等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Function-closures"><a href="#Function-closures" class="headerlink" title="Function closures"></a>Function closures</h2><p>函数闭包，不同变量可以绑定不同的函数闭包，相互之间不影响</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(</span><br><span class="line">            pos(i),</span><br><span class="line">            neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Flow-control-statements"><a href="#Flow-control-statements" class="headerlink" title="Flow control statements"></a>Flow control statements</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>，可以没有<code>()</code>，但一定要有<code>&#123;&#125;</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>if</code>可以像<code>for</code>那样先带个statement。假如申明了变量，则只能在<code>if</code>或后续的<code>else</code>中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can&#x27;t use v here, though</span></span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>，可以没有<code>()</code>，但一定要有<code>&#123;&#125;</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(condition)</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code>, 满足其中一个<code>case</code>即执行其中的语句，不会再执行其他case的语句，可看成自带<code>break</code>。此外，<code>case</code>不一定要接整数常量，它可以不是整数，可以不是常量。但要注意<code>case</code>后接的类型和<code>switch</code>比较的类型相同。</p>
<p><code>switch</code>同样可以像<code>for</code>那样先带个statement，且<code>default</code>的位置可放在首位，因为它总是会在所有条件都不匹配的时候才执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>switch</code>还可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><code>defer</code> 推迟执行，具有LIFO的性质</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;1 &quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;2 &quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;3 &quot;</span>)</span><br><span class="line">    <span class="comment">// 将输出3 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>defer</code>还可以这样写，参数部分的函数是会先执行的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">entering: b</span></span><br><span class="line"><span class="comment">in b</span></span><br><span class="line"><span class="comment">entering: a</span></span><br><span class="line"><span class="comment">in a</span></span><br><span class="line"><span class="comment">leaving: a</span></span><br><span class="line"><span class="comment">leaving: b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Methods-and-interfaces"><a href="#Methods-and-interfaces" class="headerlink" title="Methods and interfaces"></a>Methods and interfaces</h1><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go没有<code>class</code>，但可以给方法（函数）指定适用的类型。<code>method</code>是指定类型的<code>function</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>methord</code>指定的类型可以是基本类型，但所指定的类型必须在本<code>package</code>出现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>methord</code>指定的类型可以是指针，则我们可以修改指针指向的内容，并且不用产生拷贝开销。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口，要求使用接口的类型实现了接口中方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line">    <span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">    <span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现接口中的方法不需要像其他语言那样使用显式的关键字，如<code>implement</code>。</p>
<p>这样做可以让申明和实现分离，不需要特殊处理就可以让他们放在不同的包中。</p>
<p>接口可以看成是一个二元组<code>(value, type)</code>，对于一个<code>value</code>，它会调用接收了<code>type</code>的方法。</p>
<p>假如一个变量是接口类型的，那么它有可能<code>value</code>和<code>type</code>都为<code>nil</code>，这种情况下会RE。而当<code>type</code>不为<code>nil</code>时，它是非空的，但是<code>value</code>可能会空，因此我们需要在实现接口的方法里处理好这种情况。</p>
<p>空接口，用于存储任何类型的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">42</span></span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类型断言，在断言不成立的时候应该用两个变量存储结果，否则会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="type">float64</span>) <span class="comment">// panic</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>type switch</code> 可以依次进行多个类型断言</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Stringer</code> 用于输出自定义类型的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Error</code> 用于输出错误信息的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Reader</code> 用于读取数据的接口</p>
<p><code>func (T) Read(b []byte) (n int, err error)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Images</code> 用于处理图像的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="type">int</span>) color.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><p>Goroutines 轻型线程，它们共享同一地址的内存，需要同步控制</p>
<p><code>go f(x, y, z)</code> 创建一个新Goroutine运行函数<code>f</code></p>
<p>Channels 可用于传递数据的一种数据类型，需要用到运算符<code>&lt;-</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Buffered Channels 可理解为大小的Channel，满了还往里面添加的话会报错</p>
<p>可使用range来取出channel中的所有数据，注意channel要close</p>
<p><code>&lt;-ch</code>实际上会返回两个值，第二个值代表是否还有数据，即<code>false</code> 表示channel close了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>select </code>用于多个channel的选择，哪个channel有数据就执行哪一个，假如同时有数据来了，就随机先执行其中一个</p>
<p><code>select</code>中的<code>default</code>在没有收到任何channel数据的时候执行</p>
<p><code>sync.Mutex</code>  用于互斥</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    c.v[key]++</span><br><span class="line">    c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the current value of the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Diagnostics-诊断"><a href="#Diagnostics-诊断" class="headerlink" title="Diagnostics | 诊断"></a>Diagnostics | 诊断</h1><h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 起手式</span></span><br><span class="line">cpuProfile, _ := os.Create(<span class="string">&quot;cpu_profile&quot;</span>)</span><br><span class="line">pprof.StartCPUProfile(cpuProfile)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>go tool pprof &lt;file&gt;</code></p>
<p><code>web</code> 启动可视化界面</p>
<p><code>top</code> 列出cpu占比最高的函数</p>
<p><code>list &lt;function&gt;</code> 列出指定函数的数据</p>
<h1 id="Go-Command"><a href="#Go-Command" class="headerlink" title="Go Command"></a>Go Command</h1><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p>假如想要玩一下<code>go build</code>命令，注意加上<code>-a</code>重新全部编译，否则会因为有缓存而跳过编译过程。</p>
<p>假如是main，则会编译生成可执行文件。</p>
<p>否则，只会编译，不产生文件，用于验证代码能否编译。</p>
<h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p>假如是main，则会在$GOPATH&#x2F;bin下生成可执行文件。</p>
<p>否则，会在$GOPATH&#x2F;pkg下生成*.a文件。</p>
<h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">go get -u &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h2 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h2><p>删除编译生成的文件等等。</p>
<h1 id="依赖管理工具"><a href="#依赖管理工具" class="headerlink" title="依赖管理工具"></a>依赖管理工具</h1><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化，-v参数代表输出详细信息</span></span><br><span class="line">dep init -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决依赖的BUG</span></span><br><span class="line">dep ensure -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新依赖，假如总是更新失败，先dep ensure -v一下，并选择在网络空闲的时候更新</span></span><br><span class="line">dep ensure -update -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条依赖</span></span><br><span class="line">dep ensure -add github.com/bitly/go-simplejson</span><br></pre></td></tr></table></figure>

<h2 id="Go-Mod"><a href="#Go-Mod" class="headerlink" title="Go Mod"></a>Go Mod</h2><p>拉取速度比Dep要快很多。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，生成go.mod文件</span></span><br><span class="line">go mod init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后即可使用go build或go test拉取依赖</span></span><br><span class="line">go build/test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级所有依赖到最新</span></span><br><span class="line">go get -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将依赖放在项目的vendor中</span></span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>

<p>假如遇到某个依赖有问题，更把那个依赖删掉，然后再<code>go get -u</code>升级所有依赖。</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 2 信息的表示与处理</title>
    <url>/2019/09/15/CSAPP-learning-note-2/</url>
    <content><![CDATA[<p>这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。</p>
<h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>整数运算的分类主要有两个维度，一个是无符号数、有符号数，另一个是加法、乘法。</p>
<p>之前知道编译器会将乘法转化成加减法&#x2F;移位，但始终不知所以然。这次通过阅读CSAPP，深入理解了它的原理，另外知道了还可以将除法转化为加减法&#x2F;移位。</p>
<p>这一节讲得都是规律和证明，这里不再赘述。贴一张图进行总结，以方便以后回忆。</p>
<p><img src="https://s2.ax1x.com/2019/09/16/nRiAaT.png" alt="image-20190915234925595"></p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>阅读完这一节后，对于浮点数的表示、运算、舍入等有了更深入的理解。</p>
<p>其中，有的地方一开始不是很理解，当弄懂后，觉得这些设计很优雅、很聪明。</p>
<p>比如，对于IEEE非规范值得设计不是很理解，为什么要增加复杂性呢。后来，明白了非规格值的设计，使得0的表示很加自然且靠近0的浮点数分布得更均匀。</p>
<p>比如，一开始不太明白为什么要有偶数舍入法，直接四舍五入不行吗。后来，明白了偶数舍入法是对四舍五入的一种改进，避免了舍入所造成的统计误差。</p>
<p>还有浮点的运算，不遵循结合律，这是之前没有注意到但也是十分重要的知识点。</p>
<p><img src="https://s2.ax1x.com/2019/09/16/nRikZV.png" alt="image-20190916000251225"></p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 3 程序的机器级表示</title>
    <url>/2019/09/29/CSAPP-learning-note-3/</url>
    <content><![CDATA[<p>这两周看了第三章的前面五节，对机器指令有了更进一步的认识。</p>
<p><img src="https://s2.ax1x.com/2019/09/29/uGR19e.png" alt="程序的机器级表示 阅读进度"></p>
<h1 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h1><p>Intel处理器系列俗称x86，它有着一段进化之旅。从最初的8086到i386，再到i5和i7。那么它究竟有哪些方面的提升呢？</p>
<ul>
<li>晶体管数量增加。Core i7的1.4G个晶体管，是8086芯片29K个晶体管的4.8万倍。晶体管越多，意味着芯片的电路越复杂，能力越强。</li>
<li>指令集变大，支持更多指令。8087在8086的基础上，建立了浮点模型。</li>
<li>更多的位数。Pentium 4E是Intel对AMD提出的对IA32的64位拓展的实现，我们称之为x86-64。</li>
<li>更多的核数。Core 2是Intel的第一个多核微处理器。</li>
<li>更多的技术。Pentium 4E增加了超线程，允许一个处理器上同时运行两个程序。</li>
</ul>
<p>AMD等产商的大多处理器与Intel处理器兼容，能够运行完全相同的机器级程序。</p>
<h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><p>什么是机器代码呢？我们知道，C语言会经过预处理、编译、汇编、链接这些过程。</p>
<ul>
<li>预编译：拓展源代码，主要处理对象是#include及#define。</li>
<li>编译：产生源文件的汇编代码，拓展名为.s。</li>
<li>汇编：产生二进制目标代码，拓展名为.o。</li>
<li>链接：将多个.o文件转化成一个可执行文件。</li>
</ul>
<p>所谓机器代码，第一种是指.o文件中的代码，第二种是指可执行文件中的代码。它们的区别在于前者还没有填入全局值的地址。</p>
<p>机器代码是一些二进制代码，不具有可读性。汇编代码非常接近机器代码，我们可通过学习汇编代码来认识机器代码。</p>
<h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>Intel的体系结构一直在变化，从16位到32位，再到64位，可能以后还会拓展到128位。</p>
<p>Intel用以下术语来表示不同的数据类型。</p>
<table>
<thead>
<tr>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>一个CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。</p>
<p>我们知道，程序运行时，其数据存放在内存中。CPU需要一些指令来进行内存与寄存器间的数据转移，称为数据转移指令。</p>
<p>我们也知道，程序运行时，在内存中有一个对应的程序栈。CPU有专门指令进行入栈、出栈操作。可否将这些指令去掉呢？可以，存在代替指令。但是这样做，会让机器代码增多，考虑到入栈出栈操作是非常常见的，所以提供专门的指令会缩减机器代码的大小。这也就是在精简指令集上编译出来的机器代码比复杂指令集庞大的原因。</p>
<h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>所谓算术操作，指的是加减乘除等操作。所谓逻辑操作，是指与或移位等操作。</p>
<p>通过学习汇编代码的算术和逻辑操作，对于高级语言的便利性有了更具体的认识。一条C语言简单的算术表达式，转化成汇编代码，会变成多条。对于一些更复杂的循环控制语句，就更复杂了。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 4 程序的机器级表示</title>
    <url>/2019/10/15/CSAPP-learning-note-4/</url>
    <content><![CDATA[<p>这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。</p>
<p>在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。</p>
<p>在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即<code>CMP</code>和<code>TEST</code>，也会设置条件码，但它们不会改变其他寄存器。</p>
<p>那么怎么访问这些条件寄存器呢？CPU中提供了<code>SET</code>指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应<code>SETE</code>指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应<code>SETL</code>，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。</p>
<p>要实现像C语言中的for语句，还需要一类指令<code>JMP</code>。它可以根据条件跳转到其他语句，而不是一直顺序执行。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 4 程序的机器级表示</title>
    <url>/2019/10/15/CSAPP-learning-note-4/</url>
    <content><![CDATA[<p>这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。</p>
<p>在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。</p>
<p>在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即<code>CMP</code>和<code>TEST</code>，也会设置条件码，但它们不会改变其他寄存器。</p>
<p>那么怎么访问这些条件寄存器呢？CPU中提供了<code>SET</code>指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应<code>SETE</code>指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应<code>SETL</code>，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。</p>
<p>要实现像C语言中的for语句，还需要一类指令<code>JMP</code>。它可以根据条件跳转到其他语句，而不是一直顺序执行。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 5 存储器层次结构</title>
    <url>/2019/10/18/CSAPP-learning-note-5/</url>
    <content><![CDATA[<p>这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。</p>
<p><img src="https://s2.ax1x.com/2019/10/18/KeyBvV.png" alt="第六章存储器层次结构"></p>
<h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><p>存储器有着很多的种类，比如CPU的寄存器、高速缓存，主存（内存）的DRAM，机械硬盘、固态硬盘、U盘、SD卡、磁带等。不同的存储器，会用到不同的存储技术。其中寄存器的存储技术从性能上看是最好的，同时价格也最昂贵的，因此寄存器的大小相比于其他存储器，少得可怜，比如一般来说，通用寄存器只有16个，而1个寄存器只能存储64个bit。高速缓存采用的是SRAM，而主存用的是DRAM。SRAM用到了多个晶体管，比DRAM要快得多，会更加稳定，同时成本也更高。一般来说，高速缓存是几M的量级，而主存是以几G的量级，可见两者的价格差异。RAM有一个特点是断电后内容会丢失。</p>
<p>我们常用的U盘、SD卡等，并不是基于RAM，而是基于ROM。所谓ROM，翻译成中文便是只读存储器。个人觉得这个名字有点歧义，容易让人误解成数据不可更改。但实际上，ROM也有多个种类，我们常用的U盘基于EEPROM（电子可擦写只读存储器），是可以进行擦写的。而固态硬盘，基于闪存，它也是可擦写的。以前给手机刷机的时候，常常会听到ROM和固件这两个名词。所谓固件，是指写入到ROM中的程序。</p>
<p>机械硬盘，常常会听到一个参数叫转数。这个参数表示盘片旋转速度的速度。这个参数虽然重要，但却非影响硬盘随机IO时间的最重要因素。磁盘访问数据，由三个部分的时间组成，即寻道时间、旋转时间、传送时间。寻道时间是磁头定位到对应磁道的时间，这个时间平均占比是最大的，通常可占到整体时间的1&#x2F;2以上，所以我们可以用两倍寻道时间来估计总时间。磁头定位到对应磁道，有专门的寻道算法，比如电梯算法。</p>
<p>固态硬盘，是近些年流行起来的存储器。其性能、价格皆介于主存和机械硬盘之间。由于固态硬盘采用了闪存，避免了机械硬盘缓慢的寻道和旋转，所以速度更快，特别是在随机IO的表现上。</p>
<p>根据历史趋势，存储器将会访问速度越来越快，越来越大，且会越来越便宜。但是，由于CPU的性能提升要比SRAM、DRAM、磁盘的速度快，所以两者的差距在增大，这将成为计算机的瓶颈。也因此，各级缓存的必要性就体现出来了，利用局部性原理，我们可以减弱这种差距。</p>
<h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性分为空间局部性及时间局部性。空间局部性指的是某个位置的数据被访问后，其附近的数据将可能被访问。时间局部性指的是某个位置的数据被访问后，这个位置还将可能被再次访问。</p>
<p>以前对于这个概念的认识有点模糊，对其带来的性能差异没有明确的认知。我们下面通过一个程序来看一下空间局部性带来的影响。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum1</span><span class="params">(<span class="type">int</span> a[N][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> a[N][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;    </span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当N &#x3D; 20000时，在我的机器上，sum1执行的时间为2.1s，而sum2执行的时间为5.6s，两者差距两倍多。</p>
<p>sum1之所以性能表现比sum2优秀，是因为它访问数据时的步长为1，让计算机能更好地利用空间局部性原理。</p>
<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>计算机的存储器层次结构从快到慢分为寄存器、L1高速缓存、L2高速缓存、L3高速缓存、主存、本地二级磁盘（本地磁盘）、远程二级存储（分布式文件系统、Web服务器）等。通过这样的层次结构，在大小、访问速度、价格等因素之间取得了折衷，让计算机的价格合理、访问速度较快、存储空间较大。</p>
<p>缓存无处不在，其目的是降低不同存储器之间速度差异带来的影响。计算机各级存储器之间，上层是下层的缓存。浏览器访问网页时，在本地磁盘有缓存，能提高用户打开同一网页的速度。Web服务器被访问的时候，本地磁盘也有缓存，能提高不同用户访问同一网页的速度。磁盘也有缓存，用于缓存磁盘扇区，提高计算机访问磁盘的速度。代理服务器，也可用来做缓存，能降低网络延迟。业务上，redis用作MySQL的缓存，是用内存来缓存磁盘的内容，缓解了随机I&#x2F;O带来的性能问题。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 6 异常控制流</title>
    <url>/2019/10/21/CSAPP-learning-note-6/</url>
    <content><![CDATA[<p>最近看了CSAPP的第八章——异常控制流。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。异常有不同的种类，有中断、陷阱、故障、终止。</p>
<p>中断，是在CPU执行某条指令的时候，其他部件异步产生的，比如定时器芯片、磁盘控制器、网络适配器等。CPU检测到中断后，会把当前指令执行完，然后转去执行异常处理程序，接着再返回来执行下一条指令。</p>
<p>陷阱，是有意的异常，最常见的陷阱是系统调用。系统调用，是指从用户模式转为内核模式，以执行一些特殊的指令，比如操作I&#x2F;O设备。执行完系统调用后，会返回来执行下一条指令。</p>
<p>故障，是指执行指令的时候遇到了意外，比如遇到了缺页、访问了未定义的虚拟内存区域等。根据故障的不同，异常处理程序执行完后可能会返回执行当前指令，也有可能会终止程序。在写程序时常常遇到的<code>Floating point exception</code>和<code>Segmentation fault</code>就属于故障，且在Linux中的处理是程序被终止。</p>
<p>终止，是指遇到了致命的硬件错误，必须结束程序。</p>
<p>因为异常种类繁多，所以计算机中有一张异常表，用来记录不同的异常及对应的异常处理程序。在CPU中，有一个特殊的寄存器——异常表基址寄存器，用来存放异常表在内存中的基址。当CPU遇到一种异常的时候，会拿到一个异常号。CPU拿着这个异常号及寄存器中的基址，便可以找到对应的异常处理程序了。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程，是执行中的程序实例，是操作系统对于程序的一种抽象。这种抽象，使得看起来进程是独占cpu和内存的。为了实现这种抽象，需要操作系统保存好进程的上下文，进行进程调度。</p>
<p>进程的上下文，是指进程执行的状态，包括CPU中的状态、用户模式中的状态、内核模式中的状态。具体来说，cpu中的状态，包括各种寄存器，比如通用寄存器，用来保存指令执行用到的数据，还有程序计数器，用来指明程序执行的进度。用户模式下的状态，包括用户栈等。内核模式中的状态，包括内核栈、进程已打开文件的信息的文件表、有关当前进程的信息的进程表等。</p>
<p>什么时候会触发进程调度呢？主要有两种情况。一种是进程执行了系统调用，阻塞住了，比如读写文件、sleep等。另一种是中断，包括IO操作完成以及时钟中断等。</p>
<h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><ul>
<li><code>PS</code>：列出当前系统中的进程。</li>
<li><code>TOP</code>：打印出关于当前进程资源使用的进程。</li>
<li><code>PMAP</code>：显示进程的内存映射。</li>
<li><code>STRACE</code>：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。<code>-static</code>是个实用的参数。</li>
<li><code>/proc</code>：一个虚拟文件系统，以ASCII文件格式输出大量内核数据结构的内容。</li>
</ul>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>图片文件格式 学习笔记</title>
    <url>/2019/12/07/null/</url>
    <content><![CDATA[<p>在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。</p>
<p>一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过<code>ImageMagick</code>这个程序来解析图片文件。</p>
<p>分辨率，比如1920x1080，是指图片的一行具有1920个像素，一列具有1080个像素。</p>
<p>色彩空间，是指描述一个像素点的方式。比如RGB，是指一个像素点用red, green, blue各8bit一共24bit来描述。而YUV，是指Y表示亮度，U和V一起表示色调和饱和度。</p>
<p>在互联网上最常见的大概是jpeg类的文件。jpeg文件之所以适合在互联网上传播，是因为它的压缩比较高，且能在压缩和图片还原度上保持平衡，使得一张图片既有小巧的体积，又能在肉眼级别上有良好的清晰度。</p>
<p>但是jpeg文件并不适合保存图标等图像内容，因为它不具有alpha通道，不能用来表示透明的背景。一般会用png来保存图标。由于png是无损压缩存储图片的，所以会比jpeg文件要大一些，也适合对于图像质量要求较高的情况。</p>
<p>bmp文件，它也是无损不压缩的，所以会比较大，比较少见。</p>
<p>git文件，可以存储动图，但是由于它只用了8bit来描述一个像素点，所以可用的色彩并不多，色彩丰富度低。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>文件格式</tag>
      </tags>
  </entry>
  <entry>
    <title>perl 学习笔记</title>
    <url>/2019/12/18/null/</url>
    <content><![CDATA[<p>Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。</p>
<p>Perl的强大之处，在于它具有sed和awk的全部功能，以及众多语言的语法特性，以及非常强大的正则表达式，等等。</p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h1><p>Perl的Hello, World：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;print(&quot;Hello, World\n&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在安装了perl的计算机上，直接执行上述代码，即可输出<code>Hello, World</code>。</p>
<p>也可以将perl代码写在文件，以重复执行，具体可以这样写：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 &quot;Hello, World&quot;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将上述代码保存成<code>learn.pl</code>后，加下执行权限，然后执行<code>./learn.pl</code>，可输出<code>Hello, World</code>。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Perl的正式表达式非常强大，是常用编程语言里最顶尖的之一。下面来看几个例子。</p>
<h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p><code>echo box.svc.content | perl -p -e &#39;s/\.+/\//g&#39;</code></p>
<p>将会输出<code>box/svc/content</code>。</p>
<p>解析：</p>
<p><code>-p</code>参数会将结果输出出来。</p>
<p>这里用到了一个常用的<strong>替换</strong>句型，<code>s/old/new/parameters</code>，表示将<code>old</code>替换成<code>new</code>。</p>
<p><code>s/\.+/\//g</code>的<code>s</code>表示替换，<code>\.+</code>表示至少一个<code>.</code>，<code>\/</code>表示一个<code>/</code>，<code>g</code>表示全局匹配。</p>
<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"></span><br><span class="line">$string = <span class="string">&#x27;welcome to w3cschool site.&#x27;</span>;</span><br><span class="line">$string =~ <span class="regexp">tr/a-z/A-z/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$string\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码将会输出<code>WELCOME TO W3CSCHOOL SITE.</code>。</p>
<p>这里用到了一个常用的<strong>转化</strong>句型，<code>tr/old/new/parameters</code>。表示将<code>old</code>转化成<code>new</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.w3cschool.cn/perl/perl-regular-expressions.html">Perl 正则表达式 - W3Cschool</a></p>
]]></content>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Lang GC 学习笔记</title>
    <url>/2020/01/11/go-garbage-collector-learning-note/</url>
    <content><![CDATA[<p>GC的具体实现一直在改变，但是其模型是相对稳定的。</p>
<p>collection的三个阶段：</p>
<ul>
<li>Mark Setup - STW</li>
<li>Marking - Concurrent</li>
<li>Mark Termination - STW</li>
</ul>
<p>Mark Setup：当进行gc时，为了保证数据完整性，需要设置Write Barrier，这要求将所有的goroutine停止，正常情况下这个时间平均为10-30ms。但是当goroutine停止不下时，会让这个时间变长。调度器目前停止goroutine的时机是在goroutine执行函数调用的时候，因为这样做才能保证安全。假如某个goroutine一直在执行循环，而不执行函数调用，它就无法被停止，这不仅会耽误gc第一个阶段的完成，还会造成其他goroutine停止着。将在Go1.14引入 <a href="https://github.com/golang/go/issues/24543">preemptive</a> techniques 尝试对此进行优化。</p>
<p>Marking - Concurrent：当设置好Write Barrier后，collector会拿走25%可用的CPU，用于mark操作。mark操作，会遍历所有goroutine的栈，寻找指针指向的heap内存，将仍在使用的内存标记一下。这个时候，goroutine是可以并发执行的。在mark的过程，其他正在运行的goroutine可以分配内存，这可能导致内存不够用，这时候需要Mark Assits。Mark Assits，是指短暂停止正在运行的goroutine，让它们来帮忙mark，加快mark的进度。当然，这会影响这些goroutine的执行，collector的目标是尽可能减少Mark Assits的需要。</p>
<p>Mark Termination - STW：Mark完成后，需要关闭Write Barrier，进行多项清理工作，设定下次collection的目标。在进行这些工作前，仍要求所有的goroutine停止。这些工作平均持续60~90ms。虽然也可以设计成边Termination边正常运行一些gorutine的模式，但是设计者认为这样得到的收益很小，而增加的复杂性较高，所以选择了这种STW的实现方式。当Termination工作完成后，回到正常状态。</p>
<p>在collection完成后，会进行sweeping。</p>
<p>sweep是指将那些没有标记为使用的heap内存回收，它不是发生在一次collection中，而是被均摊到每次分配内存的时候。</p>
<p>以上所有行为只有在GC开始且正在进行的时候发生，GC Percentage对collection有很大影响。GC Pencentage，默认是100%。将GC Pencentage设置为100%，意味着下次GC会在heap达到当前GC的mark live内存的2倍时进行。</p>
<p>GC trace可用于追踪collection。<code>GODEBUG=gctrace=1 ./app</code>可查看GC信息，输出到<code>stderr</code>。</p>
<p>GC trace：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过设置环境变量查看GC trace</span></span><br><span class="line">GODEBUG=gctrace=1 ./app</span><br><span class="line"></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8-&gt;11-&gt;6 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8-&gt;14-&gt;8 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC trace含义</span></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">// General</span><br><span class="line">gc 1404     : The 1404 GC run since the program started</span><br><span class="line">@6.068s     : Six seconds since the program started</span><br><span class="line">11%         : Eleven percent of the available CPU so far has been spent <span class="keyword">in</span> GC</span><br><span class="line"></span><br><span class="line">// Wall-Clock</span><br><span class="line">0.058ms     : STW        : Mark Start       - Write Barrier on</span><br><span class="line">1.2ms       : Concurrent : Marking</span><br><span class="line">0.083ms     : STW        : Mark Termination - Write Barrier off and clean up</span><br><span class="line"></span><br><span class="line">// CPU Time</span><br><span class="line">0.70ms      : STW        : Mark Start</span><br><span class="line">2.5ms       : Concurrent : Mark - Assist Time (GC performed <span class="keyword">in</span> line with allocation)</span><br><span class="line">1.5ms       : Concurrent : Mark - Background GC time</span><br><span class="line">0ms         : Concurrent : Mark - Idle GC time</span><br><span class="line">0.99ms      : STW        : Mark Term</span><br><span class="line"></span><br><span class="line">// Memory</span><br><span class="line">7MB         : Heap memory in-use before the Marking started</span><br><span class="line">11MB        : Heap memory in-use after the Marking finished</span><br><span class="line">6MB         : Heap memory marked as live after the Marking finished</span><br><span class="line">10MB        : Collection goal <span class="keyword">for</span> heap memory in-use after Marking finished</span><br><span class="line"></span><br><span class="line">// Threads</span><br><span class="line">12P         : Number of logical processors or threads used to run Goroutines</span><br></pre></td></tr></table></figure>

<p>（全文完）</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Lang slice 学习笔记</title>
    <url>/2020/01/27/go-slice-learning-note/</url>
    <content><![CDATA[<h1 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h1><p>切片，本身不存储实际数据。切片的数据结构，也被称为slice header，包含指向首元素的指针、切片长度、切片容量：</p>
<p><img src="https://s2.ax1x.com/2020/01/27/1uWu2n.png" alt="img"></p>
<p>当将切片作为实参时，只会传递slice header。这个传递是值传递，这意味着：</p>
<ul>
<li>假如在函数里面对slice的元素作赋值操作，由于有指针指着元素，所以原有slice指向的元素也会被改变。</li>
<li>假如在函数里面reslice，并不会影响原slice。</li>
</ul>
<p>假如想要改变原有slice，有两种写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种，将返回值赋值给原slice，这种方式也就是append的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubtractOneFromLength</span><span class="params">(slice []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSlice := SubtractOneFromLength(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，用slice指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrSubtractOneFromLength</span><span class="params">(slicePtr *[]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    slice := *slicePtr</span><br><span class="line">    *slicePtr = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这引发了另一个需要注意的点，对于slice的方法，假如需要reslice，要用slice指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> path []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *path)</span></span> TruncateAtFinalSlash() &#123;</span><br><span class="line">    i := bytes.LastIndex(*p, []<span class="type">byte</span>(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        *p = (*p)[<span class="number">0</span>:i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pathName := path(<span class="string">&quot;/usr/bin/tso&quot;</span>) <span class="comment">// Conversion from string to path.</span></span><br><span class="line">    pathName.TruncateAtFinalSlash()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, pathName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片，可以改变指向的范围，这是成本很低的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片，可以切片，即<code>s := s[[begin]:[end]]</code>，其中begin和end可以省略。当end超过实际cap时，会panic。</p>
<p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p>
<p><code>len()</code>查看长度，即从下界到上界的个数</p>
<p>切片的零值为<code>nil</code>，此时<code>cap</code>和<code>len</code>都为0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span>  <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>



<h1 id="切片的append"><a href="#切片的append" class="headerlink" title="切片的append"></a>切片的append</h1><p>可使用<code>append</code>函数向切片添加元素，对nil切片进行<code>append</code>是正确的。</p>
<p>当append超过切片容量时，会将容量翻倍，且利用内置函数copy进行数据的拷贝，该函数在切片重叠的情况下也可以保证正确拷贝。注意只有被append的slice的指针会指向这块新的区域，基于这个slice的其他slice并不会更新指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>append</code>函数向切片中添加切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>



<h1 id="切片的内存管理"><a href="#切片的内存管理" class="headerlink" title="切片的内存管理"></a>切片的内存管理</h1><p>注意只要有一个slice使用着底层slice，即使这个上层slice只包含了很少的元素，底层slice的内存也不会被释放掉。这时候假如为了释放不必要的内存占用，需要将上层slice指向的数据拷贝到新的区域：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">&quot;[0-9]+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个文件的字节都被加载进去了，且不释放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝到c，释放多余的占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h1><p>使用<code>make</code>来创建一维切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  <span class="comment">// len(a) == cap(a) == 5</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b) == 0, cap(b) == 5</span></span><br></pre></td></tr></table></figure>

<p>使用<code>make</code>创建二维切片</p>
<p>第一种方式，该方式允许第二维大小有所变化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, dy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h1><p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="切片的技巧"><a href="#切片的技巧" class="headerlink" title="切片的技巧"></a>切片的技巧</h1><p>优雅地往slice插入一个value：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert inserts the value into the slice at the specified index,</span></span><br><span class="line"><span class="comment">// which must be in range.</span></span><br><span class="line"><span class="comment">// The slice must have room for the new element.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(slice []<span class="type">int</span>, index, value <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// Grow the slice by one element.</span></span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)+<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// Use copy to move the upper part of the slice out of the way and open a hole.</span></span><br><span class="line">    <span class="built_in">copy</span>(slice[index+<span class="number">1</span>:], slice[index:])</span><br><span class="line">    <span class="comment">// Store the new value.</span></span><br><span class="line">    slice[index] = value</span><br><span class="line">    <span class="comment">// Return the result.</span></span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优雅地合并两个切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>&#125;</span><br><span class="line">b := []<span class="type">string</span>&#123;<span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>, <span class="string">&quot;Pete&quot;</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a, b...) <span class="comment">// equivalent to &quot;append(a, b[0], b[1], b[2])&quot;</span></span><br><span class="line"><span class="comment">// a == []string&#123;&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;&#125;</span></span><br></pre></td></tr></table></figure>



<p>优雅地copy：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">b = <span class="built_in">append</span>([]T(<span class="literal">nil</span>), a...)</span><br></pre></td></tr></table></figure>



<p>cut，优雅地删除掉slice中的某一个区间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通版，对于元素为指针或者结构中含有指针，会存在内存泄漏，因为被删掉的元素仍属于slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级版，将指针设为nil，减少了内存泄漏，但是还是有元素属于slice</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:], a[j:])</span><br><span class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ &#123;</span><br><span class="line">    a[k] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</span><br></pre></td></tr></table></figure>



<p>filter：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(a []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> keep(x) &#123;</span><br><span class="line">            a[n] = x</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a[:n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>reverse:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    opp := <span class="built_in">len</span>(a)<span class="number">-1</span>-i</span><br><span class="line">    a[i], a[opp] = a[opp], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>shuffling:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">    j := rand.Intn(i + <span class="number">1</span>)</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接用math/rand.Shuffle</span></span><br><span class="line"><span class="comment">// 使用了Fisher–Yates算法</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 每日一题01 Single Number</title>
    <url>/2020/04/01/leetcode-exercise-per-day-1-Single-Number/</url>
    <content><![CDATA[<p>最近Leetcode举办了一个为期一个月的活动，每天会推出一道题目。最近这段时间正好有空，所以打算跟着参加一下，顺便写一下题解。使用的语言为C++。</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote>
<p> 题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3283/">Single Number</a></p>
</blockquote>
<p>给一个非空的数组，其中有1个元素出现了1次，其他的都出现2次。时间要求为线性，不允许使用额外内存，求出现1次的元素。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目保证数组非空，所以不需要特殊处理。</p>
<p>两个相同的数异或等于0，因此我们可以将数组所有元素异或起来，最后得到的值即为出现1次的元素。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 每日一题2 Happy Number</title>
    <url>/2020/04/02/leetcode-exercise-per-day-2-Happy-Number/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote>
<p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3284/">Happy Number</a></p>
</blockquote>
<p>给一个数字，判断它是不是Happy Number。假如一个数是Happy Number，则可以通过不断取各数位的平方和得到1。而假如不是Happy Number，则会陷入循环，不会得到1。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题的关键在于怎么知道发生了循环，并在发生循环的时候及时结束。弗洛伊德判圈法(Floyd Cycle detection algorithm)是可以在O(1)的空间复杂度和O(n)的时间复杂度内，判断是否发生循环的一种算法，其中n是循环的次数。其思想是维护两个指针，令它们一开始都指向最开始的位置，然后进行<code>do while</code>循环，让其中一个指针一次走两步，另一个一次走一步，直到两者相等，就可以判定存在圈。</p>
<p>这道题一定存在循环，Happy Number在找到圈的时候，指向的数为1，而非Happy Number指向的数非1，得解。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow, fast;</span><br><span class="line">        slow = fast = n;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = <span class="built_in">getSum</span>(slow);</span><br><span class="line">            fast = <span class="built_in">getSum</span>(fast);</span><br><span class="line">            fast = <span class="built_in">getSum</span>(fast);</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (d) &#123;</span><br><span class="line">            <span class="type">int</span> mod = d % <span class="number">10</span>;</span><br><span class="line">            d /= <span class="number">10</span>;</span><br><span class="line">            sum += mod * mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 每日一题3 Maximum Subarray</title>
    <url>/2020/04/04/leetcode-exercise-per-day-3-Maximum-Subarray/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote>
<p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3285/">Maximum Subarray</a></p>
</blockquote>
<p>给一个数组，求该数组的最大子数组和。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>解法1：从左到右遍历一次，累加，若sum比现有的答案大，则更新。若sum为负数，则放弃这一段的元素，置为0。时间复杂度为O(n)，空间复杂度为O(1)。</p>
<p>解法2：分治法。若我们将一个数组从中间分隔成两个数组，则它的答案是max(左数组的答案, 右数组的答案, 左数组的最大后缀和+右数组的最大前缀和+中间元素)。时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>解法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = LONG_LONG_MIN;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; ans)</span><br><span class="line">                ans = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxSubArrayCore</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArrayCore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid - <span class="number">1</span>, sum = <span class="number">0</span>; i &gt;= l; i--) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftMax + rightMax + nums[mid],</span><br><span class="line">                <span class="built_in">max</span>(<span class="built_in">maxSubArrayCore</span>(nums, l, mid), <span class="built_in">maxSubArrayCore</span>(nums, mid + <span class="number">1</span>, r)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 每日一题4 Move Zeroes</title>
    <url>/2020/04/04/leetcode-exercise-per-day-4-Move-Zeroes/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote>
<p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3286/">Move Zeroes</a></p>
</blockquote>
<p>给一个数组，通过交换将所有非零元素放置在前面，将所有零元素放置在后面。</p>
<p>要求In-place，即不能使用额外的空间存放数组元素。</p>
<p>另外还要求交换次数最少。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>为了满足题目要求，我们可以使用双指针法，找到一个零元素，以及在它后面的非零元素，将两者交换，不断重复这个过程。</p>
<p>假如不需要交换次数最少，有种更简洁的写法，即两次for循环，第一个for循环将非零元素放在数组前面，第二次for循环将非零元素放在数组后面。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pZero = <span class="built_in">findNextZeroIndex</span>(nums, <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pNonZero = <span class="built_in">findNextNonZeroIndex</span>(nums, pZero);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pZero &lt; nums.<span class="built_in">size</span>() &amp;&amp; pNonZero &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[pNonZero], nums[pZero]);</span><br><span class="line">            pZero = <span class="built_in">findNextZeroIndex</span>(nums, pZero);</span><br><span class="line">            pNonZero = <span class="built_in">findNextNonZeroIndex</span>(nums, pZero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNextZeroIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> pZero)</span> </span>&#123;</span><br><span class="line">        pZero++;</span><br><span class="line">        <span class="keyword">while</span> (pZero &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[pZero] != <span class="number">0</span>) &#123;</span><br><span class="line">            pZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pZero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNextNonZeroIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> pNonZero)</span> </span>&#123;</span><br><span class="line">        pNonZero++;</span><br><span class="line">        <span class="keyword">while</span> (pNonZero &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[pNonZero] == <span class="number">0</span>) &#123;</span><br><span class="line">            pNonZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNonZero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 每日一题5 Best Time to Buy and Sell Stock II</title>
    <url>/2020/04/05/leetcode-exercise-per-day-5-Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，表示每天的股票股价。可以进行无数次交易，但同一时刻只能持有一股的股票。求最大收益。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假如股价在未来是涨的，那么就应该购买。假如是跌的，就不购买。</p>
<p>因此，我们扫描一遍数组，维护当前最低的股价，假如遇到较高的股价，就卖出，并更新最低股价。时间复杂度为O(n)，空间复杂度为O(1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mi = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - mi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += prices[i] - mi;</span><br><span class="line">                mi = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 每日一题6 Group Anagrams</title>
    <url>/2020/04/06/leetcode-exercise-per-day-6-Group-Anagrams/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，起元素为只包含英文小写字母的单词。</p>
<p>要求分组输出使用了相同字符构造的单词，比如tea和eat就是同类单词。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将所有的单词遍历一遍，将同类单词放到同一个位置中去，关键是这个映射要怎么实现。对于一个长度为m的单词，我们可以用O(m)的时间遍历出各字符的使用次数。接着，我们将其转化成字符串，对于某个字符，其出现次数可以编码成cnt + char，然后按照英文字母表顺序连接起来。比如，teaa编码成2a1e1t。</p>
<p>上面的编码使用了一个优化，即对于出现次数的0的字母，不编码到字符串中。</p>
<p>假如追求极致，还可以对编码继续优化。</p>
<ul>
<li>对于出现次数为1的字母，可以不写上cnt。比如teaa可以写成2aet。</li>
<li>当cnt很大时，可以使用整形来表示。比如250，使用char来表示需要3个字节，使用整形只要1个字节。</li>
</ul>
<p>编码是个很有趣的知识点，上面的编码方式似乎都有专门的名称，以后有空的话专门写篇博客总结一下，这里留个坑:)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; v;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: strs) &#123;</span><br><span class="line">            m[<span class="built_in">hashWord</span>(i)].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it: m) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">hashWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            hash += <span class="built_in">string</span>(cnt[i], <span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>《微习惯》读书笔记</title>
    <url>/2020/05/10/Mini-Habits-reading-note/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/26877306/">豆瓣链接</a></p>
<p>本书主要写了微习惯是什么，以及通过微习惯来培养好习惯的依据和规则。</p>
<h1 id="第一章-微习惯是什么"><a href="#第一章-微习惯是什么" class="headerlink" title="第一章 微习惯是什么"></a>第一章 微习惯是什么</h1><p>小决心优于大决心。许多人拥有大决心，但是却不去执行，效果是零。有小决心的人，更容易执行某件事情，虽然单次的收益比较小，但远大于不执行。日积月累，小决心产生的收益会很大。</p>
<p>拥有大决心而不执行，原因是大脑觉得这次行动很难，因此会选择逃避。拥有小决心，就不太会存在这个问题。小决心是为了让大脑接受这次行动。通常来讲，在开始后，会想花更多的时间在上面。</p>
<p>微习惯就是将较大的行动拆分成容易执行的小行动。比如，每天写3000字可以改成每天写50字，每天锻炼1小时可以改成每天锻炼5分钟。</p>
<p>养成一个习惯，需要的天数会受各种因素影响。我们假如想要养成一个习惯，不必在意需要的天数，因为重要的是坚持。当连续做某件事情时，大脑的抵触情绪会越来越低，会自然地养成习惯。当有某天没有坚持习惯时，不用气馁，一天的堕落从整个过程上看并不会影响习惯的养成，我们需要做的是克服心理上的自暴自弃。</p>
<h1 id="第二章-大脑的工作原理"><a href="#第二章-大脑的工作原理" class="headerlink" title="第二章 大脑的工作原理"></a>第二章 大脑的工作原理</h1><p>可以将大脑粗分为潜意识部分和意识部分。从大脑的角度看，改变习惯的两个关键点是重复和回报。如果有回报，大脑会更愿意重复一件事情。重复是潜意识大脑使用的语言，潜意识大脑喜欢效率，这是我们能养成习惯的原因。</p>
<p>大脑是变化缓慢、状态稳定的，因此习惯的养成过程是缓慢的，习惯的保持是稳定的。</p>
<p>习惯改变涉及到大脑的两个部分：前额皮层和基底神经节。前额皮层是大脑的意识部分，是管理者，负责让大脑其他部分喜欢上自己想要的东西，用于习惯的执行。基底神经节是大脑的潜意识部分，没有思想，只会一味重复，能够探测都模式，用于新习惯的重复和养成。</p>
<h1 id="第三章-动力VS意志力"><a href="#第三章-动力VS意志力" class="headerlink" title="第三章 动力VS意志力"></a>第三章 动力VS意志力</h1><p>动力越高，做某件事情所需的意志力就越少。假如动力是满分，那么几乎不需要意志力就会去做某件事情。而假如动力为零，那么就需要很强的意志力才能去做某件事情。</p>
<p>有些人会使用“激发动力”策略来养成习惯。虽然动力确实有利于执行某件事情，但是它存在诸多问题。第一，动力难以永久保持高昂，容易导致习惯在养成的过程中断。第二，动力的影响因素多，不稳定。第三，不会每次都愿意激发动力。第四，根据热情递减原则，动力会减少，假如只依靠动力，那么会动力不足。</p>
<p>当连续执行某个行动后，我们会注意到心中不再充满动力。这可能是更稳定和自动的基底神经节正在夺取控制权，我们应该做的是利用微习惯继续执行下去，渡过这个艰难期，迎来新习惯。</p>
<p>动力并不是行动的唯一基础，我们还可以依靠意志力、习惯等。动力是好东西，只是不可靠。假如我们可以借助意志力，那么动力会变得更加可靠。如果先采取行动，动力会被迅速地激发。</p>
<p>使用意志力来采取行动远比努力激发动力靠谱。第一，意志力很可靠。第二，意志力可以被强化。第三，意志力策略可以通过计划执行。</p>
<p>意志力的工作原理是什么？意志力是有阈值的，并不是取之不尽用之不竭的。引起意志力损耗的五大主要因素有努力程度、感知程度、消极情绪、主观疲劳和血糖水平。抵抗诱惑，做决定等行为都会引起意志力的损耗。</p>
<p>我们需要克服这五大障碍，合理使用意志力，养成习惯。</p>
<h1 id="第四章-微习惯策略"><a href="#第四章-微习惯策略" class="headerlink" title="第四章 微习惯策略"></a>第四章 微习惯策略</h1><p>微习惯策略就是强迫自己每天实施1到4个“小得到不可思议”的计划好的行动。这些运动小得到不会失败，小到不会因为特殊情况就被自己轻易放弃。它们有双重作用——激励自己继续做下去，并会成为微习惯。</p>
<p>以微习惯方式运用意志力，可以有效地减少意志力的损耗。因为微习惯的努力程度要求小、感知难度小、消极情绪低、主观疲劳小、血糖水平降低少。</p>
<p>微习惯能更科学地拓宽我们的舒适区。因为大脑是抗拒改变的，因此大幅度的改变会让大脑抗议，而微习惯因其微小而成之。</p>
<h1 id="第五章-微习惯的独特之处"><a href="#第五章-微习惯的独特之处" class="headerlink" title="第五章 微习惯的独特之处"></a>第五章 微习惯的独特之处</h1><p>微习惯能与现有习惯一较高下。大脑会抗拒大幅度改变，但是微习惯很小，被抗拒的程度会很小。</p>
<p>有些人在养成习惯的时候，会给自己设置一个期限。但是这是不科学的，因为习惯的形成因习惯、个体而定。微习惯策略没有截止时间，因为我们不知道需要多少时间，但是我们要寻找养成习惯的信号。</p>
<p>自我效能感是指对自己影响事件结果的能力的信念。微习惯能提升自我效能感。</p>
<p>微习惯能给我们更多的自主权，潜意识会恐惧控制，而微习惯通过将行动微小化，让潜意识意识到自己的控制权仍在，从而接受微小的变化。</p>
<p>微习惯能帮助自己远离恐惧、怀疑、胆怯或犹豫。行动是克服这些消极情绪的最佳武器，而微习惯能帮助自己行动。</p>
<p>正念是指对自己思维和行动有着清醒认识。正念是目标清晰地活着和敷衍地活着之间的区别。微习惯能让自己意识到在做什么，能培养自己的正念。</p>
<h1 id="第六章-彻底改变只需八步"><a href="#第六章-彻底改变只需八步" class="headerlink" title="第六章 彻底改变只需八步"></a>第六章 彻底改变只需八步</h1><ol>
<li>选择适合你的微习惯和计划<ul>
<li>不超过四个</li>
<li>微习惯要小到即使精疲力尽也可以执行</li>
<li>写下来</li>
</ul>
</li>
<li>挖掘每个微习惯的内在价值<ul>
<li>不断问自己为什么要养成这个习惯，寻找依据</li>
</ul>
</li>
<li>明确习惯依据，将其纳入日程<ul>
<li>根据时间制定</li>
<li>根据行为方式制定</li>
<li>非具体习惯</li>
</ul>
</li>
<li>创建奖励机制，以奖励提升成就感<ul>
<li>奖励，关联美好事物，比如npy、大声微笑、唱歌、吃东西、休息一下等</li>
<li>奖励时间点：在取得一定里程碑时，给自己奖励。在坚持不下去时，给自己奖励</li>
<li>奖励能提升意志力</li>
</ul>
</li>
<li>记录与追踪完成情况<ul>
<li>研究表明，把想法写在纸上时，会让其在大脑中更加突出，而打字就不具备同样的效应</li>
<li>可以采用纸质日历、电子数据等方式来追踪，关注自己在意的数据，比如完成天数&#x2F;总天数</li>
</ul>
</li>
<li>微量开始，超额完成<ul>
<li>强化意志力</li>
<li>当下就取得进步</li>
<li>不耗尽意志力</li>
</ul>
</li>
<li>服从计划安排，摆脱高期待值<ul>
<li>我们常常在执行的过程会超额完成目标，可以记录这些数据</li>
<li>要把期待值和精力放在坚持目标上，而不要对任务量抱有较高的期待</li>
</ul>
</li>
<li>留意习惯养成的标志<ul>
<li>没有抵触情绪，做起来容易，不做反而更难</li>
<li>认同身份，比如我常运动，我喜欢阅读</li>
<li>行动无需考虑，不再担心，常态化</li>
<li>很无聊，好的习惯并不会让人兴奋，它们只是对我们有好处而已</li>
</ul>
</li>
</ol>
<h1 id="第七章-微习惯策略的八大规则"><a href="#第七章-微习惯策略的八大规则" class="headerlink" title="第七章 微习惯策略的八大规则"></a>第七章 微习惯策略的八大规则</h1><ol>
<li>绝不要自欺欺人。不要偷偷要求自己做得更多，要真正的微习惯</li>
<li>满意每一个进步。要满意，但别满足</li>
<li>经常回报自己，尤其在完成微习惯之后</li>
<li>保持头脑清醒。不管情绪是兴奋的，还是低落的，都要记住，要完成微习惯</li>
<li>感到强烈抵触时，后退并缩小目标。缩小目标，有利于降低意志力损耗，有利于行动的执行，开始执行要优于不执行，执行的过程会带来动力，形成正反馈</li>
<li>提醒自己这件事很轻松、很有趣。大脑喜欢轻松、有趣的事情</li>
<li>绝不要小看微步骤。不积跬步无以至千里</li>
<li>用多余精力超额完成任务，而不是制定更大目标</li>
</ol>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《刻意练习》读书笔记</title>
    <url>/2020/06/19/PEAK-Secrets-from-the-New-Science-of-Expertise-reding-note/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/26895993/">《刻意练习》</a>这本书的前半部分讲述了刻意练习是什么，为什么管用，以及杰出人物如何运用它来发展杰出的能力，后半部分讲述了如何运用刻意练习。</p>
<h1 id="文前页"><a href="#文前页" class="headerlink" title="文前页"></a>文前页</h1><p>提高生活技能、工作能力，都离不开大量的练习。</p>
<p>练习不是不断的重复，正确的练习需要好导师、有目标、有反馈等。</p>
<p>一万小时定律并不严谨，它存在以下几个问题：</p>
<ul>
<li>不同专业领域的技能习得时间与练习时间并不存在一个一万小时的最低阈值。</li>
<li>成功与练习时间并不完全成正比，天赋虽然在其中不起决定性作用，但也会是一大影响因子。</li>
<li>练习的成果并不与时间呈正相关，它也取决于练习方法。</li>
</ul>
<p>刻意练习的核心观点是，那些处于中上水平的人们，拥有一种较强的记忆能力：长时记忆。长时记忆正是区分卓越者与一般人的一个重要能力，它才是刻意练习的指向与本质。</p>
<p>通过怎样刻意练习才能够获得优秀的长时记忆呢？刻意练习的任务难度要适中，能收到反馈，有足够的次数重复练习，学习者能够纠正自己的错误。</p>
<p>长时记忆的培养要点：</p>
<ul>
<li>赋予意义，精细编码：能非常快地明白自己领域的单词与术语，在存储信息的时候，可以有意识地采取元认知的各项加工策略。</li>
<li>提取结构或模式：往往需要将专业领域的知识、提取结构或者模式以更好的方式存储。</li>
<li>加快速度、增加连接：在编码和提取过程方面很快，增加长时记忆与工作记忆之间的各种通路。</li>
</ul>
<h1 id="引言-天才存在吗"><a href="#引言-天才存在吗" class="headerlink" title="引言 天才存在吗"></a>引言 天才存在吗</h1><p>基因确实会在很多方面影响我们，但是，要想成为人们口中的天才，通常需要通过大量的、正确的练习。</p>
<h1 id="第一章-有目的的练习"><a href="#第一章-有目的的练习" class="headerlink" title="第一章 有目的的练习"></a>第一章 有目的的练习</h1><p>一个工作20年的老师并不一定比工作5年的老师有经验，通过有目的的练习，后者可以超越前者。</p>
<p>有目的的练习，有以下几个特点：</p>
<ul>
<li>具有定义明确的特定目标</li>
<li>保持专注</li>
<li>包含反馈</li>
<li>走出舒适区</li>
</ul>
<p>当遇到瓶颈时，应该鼓励自己尽力克服它，并尝试各种不同的办法，不达目的不罢休。</p>
<p>当实在坚持不下去的时候，可以加强自己的动机，或者降低要求（降低意志力损耗）。</p>
<p>在练习的过程中，要学会总结出背后的模式，在更高的层次上去掌握它。</p>
<h1 id="第二章-大脑的适应能力"><a href="#第二章-大脑的适应能力" class="headerlink" title="第二章 大脑的适应能力"></a>第二章 大脑的适应能力</h1><p>大脑的适应能力很强，不要给自己设限。实际上，人类身体各部位适应能力都很强。据称，最多次数的俯卧撑是46001个，最多次数的引体向上是4654个。</p>
<p>人类的身体有一种偏爱稳定性的倾向。因此，改变是缓慢痛苦的，但身体会适应这个过程，最终重新达成平衡，变得稳定。</p>
<p>经常性的训练会让大脑受到训练挑战的区域发生改变，大脑通过自身重新布线的方式来适应这些挑战。</p>
<p>三个重要细节：</p>
<ul>
<li>年轻的大脑适应能力更强</li>
<li>训练发展大脑中的某些部位，可能会对其他部位产生负面影响</li>
<li>由训练引起的认知和生理变化需要继续保持训练</li>
</ul>
<h1 id="第三章-心理表征"><a href="#第三章-心理表征" class="headerlink" title="第三章 心理表征"></a>第三章 心理表征</h1><p>研究表明，国际象棋大师在记忆有意义的棋盘时表现得新手好得多，但是在记忆无意义的棋盘时并不比新手好多少。同理，人们记忆有意义句子的能力，要比记忆无意义句子的能力强得多。之所以有这种现象，是因为心理表征在起作用。</p>
<p>国际大师心理表征的强大之处，在于他可以对棋盘进行有效地编码，记住棋子的位置和它们之间的相互关系，记住在这种局面下有效的招法，另外，还能将注意力集中在单个棋子上，并且在心理上“移动”它们，以观察对棋局的影响。简单地说，心理表征使得大师即可看到一片森林，也可以观察一棵树。</p>
<p>心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或其他任何事物相对应的心理结构，或具体，或抽象。</p>
<p>刻意练习包括创建心理表征。由于各个行业或领域之间心理表征的细节具有极大差异，我们难以给出一个十分清晰的顶层定义，但基本上，这些表征是信息预先存在的模式（比如事实、图片、规则、关系等等），这些模式保存在长时记忆中，可以用于有效且快速地顺应某些类型的局面。</p>
<p>心理表征的作用：</p>
<ul>
<li>有助于找出规律，进而预测未来，进行无意识决策等。比如攀援运动员可以快速选择石头。</li>
<li>有助于解释信息。比如一名资深足球球迷在阅读一篇足球赛的文章时，会理解得更好并记住得更多。</li>
<li>有助于组织信息。比如专业医生能够考虑大量的事实，根据心理表征做出诊断。</li>
<li>有助于制订计划。比如外科医生在第一次拿起手术刀之前，就会想象整个手术该怎么样进行，以及如何应对手术过程中出现某些意料之外的事情和潜在的风险时，应该怎么办。</li>
<li>有助于高效学习。比如专业音乐家在练习某件新作品时，对好的演奏有清晰的认识，进而指导自己的练习。并且，它们可以更好地认识自己犯下的错误。</li>
</ul>
<p>刻意练习的主要目的在于创建有效的心理表征。</p>
<h1 id="第四章-黄金标准"><a href="#第四章-黄金标准" class="headerlink" title="第四章 黄金标准"></a>第四章 黄金标准</h1><p>可以进行刻意练习的行业或领域的特点：</p>
<ol>
<li>对于绩效的衡量，总是存在客观的方面。比如象棋比赛的输赢，唱歌比赛的专家评价等。</li>
<li>这些行业或领域往往具有足够的竞争性，以至于从业人员有强烈的动机来训练和提高。</li>
<li>这些行业或领域通常都是已经形成规模，相关的技能已得到数十年甚至数世纪的培养。</li>
<li>这些行业或领域中，有一些从业人员还担任导师和教练，发展出一整套训练方法。</li>
</ol>
<p>刻意练习与有目的的练习，在两个重要方面上存在差别：</p>
<ol>
<li>它需要一个已经得到合理发展的行业或领域，也就是说，最杰出的从业者已达到一定程度的表现水平，使他们与其他刚刚进入的从业者明显地区分开来。</li>
<li>它需要一位能够布置练习作业的导师，以帮助学生提高他的水平。</li>
</ol>
<p>刻意练习的特点：</p>
<ul>
<li>刻意练习发展的技能，是已经拥有一整套行之有效的训练方法的技能。</li>
<li>刻意练习发生在舒适圈之外。</li>
<li>刻意练习包含得到良好定义的特定目标。</li>
<li>刻意练习是有目的的，需要人们完全的关注和有意识的行动。</li>
<li>刻意练习包含反馈，以及为应对那些反馈而就行调整的努力。反馈可以是来自他人或自己。</li>
<li>刻意练习既产生有效的心理表征，又依靠有效的心理表征。</li>
</ul>
<p>如何运用刻意练习：</p>
<ul>
<li>寻找行业中最优秀的人，推测他们为何如此优秀，向他们学习训练方法。</li>
<li>最佳方法是寻找一位优秀的导师，让他帮忙制定训练计划，给予自己指导和反馈。</li>
</ul>
<h1 id="第五章-在工作中运用刻意练习原则"><a href="#第五章-在工作中运用刻意练习原则" class="headerlink" title="第五章 在工作中运用刻意练习原则"></a>第五章 在工作中运用刻意练习原则</h1><p>美国的王牌飞行员计划告诉我们，可以想办法来辩认某个领域或行业中的杰出人物，然后训练其他那些表现不太出色的人，并且尽可能使后者达到前者的水平。</p>
<p>辨认并拒绝两种错误思想：</p>
<ul>
<li>认为某人的能力通常受到基因特征的限制。正确的做法是摆正心态。</li>
<li>如果足够长时间地做某件事情，一定会更擅长。正确的做法是找到不足，挖掘进步的点，寻找正确的训练方法。</li>
</ul>
<p>知识和技能是存在区别的。传统的教学方法总是强调传授更多的知识，而不是培养技能。</p>
<p>包含某些互动因子的方法，比如费曼学习法，有更好的效果。</p>
<h1 id="第六章-在生活中运用刻意练习原则"><a href="#第六章-在生活中运用刻意练习原则" class="headerlink" title="第六章 在生活中运用刻意练习原则"></a>第六章 在生活中运用刻意练习原则</h1><ul>
<li>找位好导师，导师的水平比自己高，并且最好是一对一指导。好的导师，他的教学和辅导应该足够高效，可以帮助自己更快地建立心理表征。</li>
<li>如果练习的时候在走神，或者很放松，或者只是为了好玩，那么可能不会进步。不专注，练习是没效果的，专注和投入至关重要。好的练习，应该在练习后会让自己感到大脑被掏空。</li>
<li>假如没有导师，自己也可以帮助自己更好地练习。在练习过程，应该思考优秀的人会怎么做，优秀的标准是怎么样的，自己与优秀的差距在哪里，最好是能通过每次练习得到反馈，看到自己的进步。</li>
<li>用三个F建立有效的心理表征：focus, feedback, fix.</li>
<li>当觉得自己停滞不前时，可以尝试不同的方式挑战自己、攻克特定的弱点等。</li>
<li>保持动机也许是每个投入到有目的的训练或者刻意练习中的人最终要面对的最大问题。保持动机可以从两个角度入手。<ul>
<li>弱化停下脚步的理由。最有效的方式是留出固定的时间来练习，不受所有其他事情所干扰。</li>
<li>增强继续前行的倾向。鼓励自己，精心设置目标，看到自己的进步。</li>
</ul>
</li>
</ul>
<h1 id="第七章-成为杰出人物的路线图"><a href="#第七章-成为杰出人物的路线图" class="headerlink" title="第七章 成为杰出人物的路线图"></a>第七章 成为杰出人物的路线图</h1><p>成为杰出人物通常有四个阶段：</p>
<ol>
<li>产生兴趣</li>
<li>变得认真。一开始，需要父母和导师以多种方式鼓励孩子，让他充满动力。在最后，孩子开始体会刻意练习带来的回报，变得越来越能够自我激励。</li>
<li>全力投入。学生通常会寻找最好的导师来指导自己的练习。在这个阶段，动机完全靠学生自己来保持，但家人依然能够发挥重要的支持作用。为了得到优秀的训练资源，通常要求家庭有一定的经济条件。</li>
<li>开拓创新。这些人所在的贡献，彻底改变了他们所在的领域或行业。他们是引领整个时代的人进入全新世界的开拓者。创新，离不开刻意练习，它需要大量的刻意练习作为基础。</li>
</ol>
<h1 id="第八章-怎样解释天生才华"><a href="#第八章-怎样解释天生才华" class="headerlink" title="第八章 怎样解释天生才华"></a>第八章 怎样解释天生才华</h1><p>杰出人物通过年复一年的刻意练习，在漫长而艰苦的过程中一步一步改进，终于练就了他们杰出的能力，没有捷径可走。</p>
<p>作者通过帕格尼尼、莫扎特等人的例子，表达了天才也需要大量的刻意练习。</p>
<p>莫扎特的父亲是一个不得志的音乐家，希望将莫扎特培养成杰出的音乐家。他在莫扎特很小的时候，就让他练习各种乐器，投入了很大的精力。莫扎特也付出了大量时间去练习，才得以成为“神童”，成为杰出的音乐家。在现代，得益于日益进步的训练资源，网上存在不少“神童”的视频，比成年人还要强。</p>
<p>“自闭症奇才”的能力通常在非常特定的领域或行业中出现。他们更有可能比不具备奇才的普通自闭症孩子更加注重细节，而且更倾向于反复的行为。当某件事情引起他的注意时，他们会将注意力全部集中在那件事上面，因此，他们很可能是通过大量的刻意练习培养出来的才能。</p>
<p>有些人会认为自己缺乏某方面的才华，比如五音不全、不擅长数学等。研究表明，这是可以通常刻意练习改进的。</p>
<p>智商高的人确实在一开始可能会有更好的表现，但是想变得真正杰出，训练时间比智商更重要。研究表明，国际象棋大师的智商并不比普通人高。也就是说，真正起决定性因素的是训练，而不是智商。</p>
<p>人的基因确实会对我们有各种影响，这目前还不明确。而且，基因我们也无法改变。唯一能做的，只是通过后天的努力来达成自己的目标。</p>
<h1 id="第九章-用刻意练习创造全新的世界"><a href="#第九章-用刻意练习创造全新的世界" class="headerlink" title="第九章 用刻意练习创造全新的世界"></a>第九章 用刻意练习创造全新的世界</h1><p>作者主要阐述了刻意练习的作用和影响。</p>
<p>作者还提到了要给各行各业的人建立心理表征，以帮助他们更好地训练。以我的理解，这里的心理表征，是一种大局观，知道杰出的人物和自己的差距在哪里，知道自己的技能树是怎么样的，知道有哪些方式可以有效提高自己的技能。当存在有效的心理表征后，就应该不断通过自身的努力来提高、完善和改进自己。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 学习笔记 7 虚拟内存</title>
    <url>/2020/08/29/CSAPP-learning-note-7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没看CSAPP这本书了。最近在学习redis的AOF重写过程，发现对于涉及的一些概念有些模糊，比如fork、页表、虚拟内存、物理内存等。而且，最近在工作中也经常遇到和内存相关的问题，在利用top命令来排查内存问题的过程中，发现手册里提到的一些内存的概念，自己都不甚清晰。</p>
<p>于是很有必要重新捡起这本书看看，梳理一下书中第9章虚拟内存的相关知识，巩固一下基础。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>操作系统的内存是由许多进程共享的，假如进程之间内存没有独立开来，那么很有可能导致进程崩溃。</p>
<p>虚拟内存是现代系统提供的一种对主存的抽象概念，用于将进程间的内存空间相互独立开来。</p>
<blockquote>
<p> 现代操作系统都使用的是按需页面调度的方式。</p>
</blockquote>
<p>从top的manual中可以查看Linux的多种内存类型的定义。</p>
<blockquote>
<p>physical memory: a limited resource where code and data must reside when executed or referenced.</p>
<p>optional swap file: where modified (dirty) memory can be saved and later retrieved if too many demands are made on physical memory.</p>
<p>virtual memory: a  nearly  unlimited resource.</p>
</blockquote>
<p>其中，虚拟内存是近似无限大的，它的意义在于：</p>
<blockquote>
<ol>
<li>abstraction, free from physical memory addresses&#x2F;limits</li>
<li>isolation, every process in a separate address space</li>
<li>sharing, a single mapping can serve multiple needs</li>
<li>flexibility, assign a virtual address to a file</li>
</ol>
</blockquote>
<p>对于第一点和第二点，就是CSAPP中提到的进程内存之间抽象和隔离。</p>
<p>第三点和第四点是什么意思呢？</p>
<p>另外，手册中也提到了不管是哪种内存类型，都是以页面的方式进行管理，通常是4KB。当然，在某些场景可以将页面设置得大一些，称为big pgae.</p>
<p>对于每一个page，在Linux中，都可以划分到某一类中。具体类别如下：</p>
<p><img src="/../../../../Documents/notebook/img/image-20201129171849191.png" alt="image-20201129171849191"></p>
<p>对于物理内存和虚拟内存，可以划分到这四类中任意一个。而对于swap file的内存，只能划分到#1和#3.</p>
<p>Anonymous和File-backed有什么区别：</p>
<blockquote>
<p><strong>File</strong>-<strong>backed</strong> mapping maps an area of the process’s virtual memory to <strong>files</strong>; i.e. reading those areas of memory causes the <strong>file</strong> to be read. It is the default mapping type. <strong>Anonymous</strong> mapping maps an area of the process’s virtual memory not <strong>backed</strong> by any <strong>file</strong>. The contents are initialized to zero.</p>
</blockquote>
<p>top可以显示的关于内存的各种指标，参考手册如下：</p>
<pre><code>      %MEM - simply RES divided by total physical memory
      CODE - the `pgms&#39; portion of quadrant 3
      DATA - the entire quadrant 1 portion of VIRT plus all
             explicit mmap file-backed pages of quadrant 3
      RES  - anything occupying physical memory which, beginning with
             Linux-4.5, is the sum of the following three fields:
             RSan - quadrant 1 pages, which include any
                    former quadrant 3 pages if modified
             RSfd - quadrant 3 and quadrant 4 pages
             RSsh - quadrant 2 pages
      RSlk - subset of RES which cannot be swapped out (any quadrant)
      SHR  - subset of RES (excludes 1, includes all 2 &amp; 4, some 3)
      SWAP - potentially any quadrant except 4
      USED - simply the sum of RES and SWAP
      VIRT - everything in-use and/or reserved (all quadrants)
</code></pre>
<p>使用Go写一个简单的hello, world程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行后，通过top的mem视图可以观察该进程的内存情况：</p>
<p><img src="/../../../../Documents/notebook/img/image-20201205114259481.png" alt="image-20201205114259481"></p>
<p>这里的VIRT, RES, CODE, DATA, SHR的单位是KiB。</p>
<p>VIRT：虚拟内存占用大概是700MiB。（感觉有点反直觉）</p>
<p>RES：实际的物理内存占用大概是1.8MiB。</p>
<p>CODE：代码占用的内存是584KiB。</p>
<p>DATA：运行栈和堆的数据大概是102MiB。</p>
<p>SHR：共享内存大概是1MiB。</p>
<p>我感觉实际的内存占用都有点大，能更细粒度地观察内存花在哪里的吗？分析一下。</p>
<p>怎么分析该进程的内存情况呢？</p>
<p>怎么理解这四种内存页呢？mmap这个函数的定义是什么？</p>
<p>top如何保存视图？</p>
<p>（未完待续）</p>
]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>生活记录-拔智齿</title>
    <url>/2020/09/13/life-record-wisdom-tooth/</url>
    <content><![CDATA[<p>前段时间去体检的时候，医生建议我把左边的下智齿给拔了，原因是长得不好，牙齿间有较大空隙，会藏食物，不好清理。其实之前去洁牙的时候有拍片，也建议我把它拔了，但是由于某些原因没有拔。一是因为除了清理比较麻烦外，暂时没有造成实际的影响（比如疼痛）。二是因为在深圳广州拔牙很贵，那时不确定学校的医保给不给报销，就拖到了现在。</p>
<p>前些天深圳的社保卡刚办理好，于是打算去把这颗智齿拔了，防止它藏食物所造成的潜在口腔疾病风险。</p>
<p>在出发前，查了一些资料，以及从同事那里获取了一些信息。得知拔阻生齿是可以走医保统筹报销以及商业保险的，但是实际上并不是所有拔牙都可以这样。事后推测同事应该是因为是手术才可以走医保统筹报销。正常的话，拔牙只能走医保个人账户以及商业保险。</p>
<p>在深圳，医保根据缴纳比例的不同，分成一二三档。对于不同档的参保者，有不同的医保待遇。通过查询公司的文档，我得知公司给我缴纳的是一档医保。</p>
<p>通过查询资料，学习了一下针对深圳一档参保者的知识点，摘抄如下：</p>
<ul>
<li>需要到定点医疗机构就医才能享受医疗保险待遇。</li>
<li>走统筹报销的，由市社会保险机构与定点医疗机构或定点零售药店按协议约定结算。</li>
<li>走个人账户支付的，由本市定点医疗机构或定点零售药店从参保人的个人账户中划扣，个人账户不足支付的，应当由参保人现金支付。</li>
<li>在非本市定点医疗机构发生的医疗费用，由参保人先行支付后向市社会保险机构申请报销，市社会保险机构按本办法的规定予以审核，符合条件的予以支付。参保人先行支付医疗费用的，应在费用发生或出院之日起十二个月内申请报销，逾期不予报销。</li>
<li>参保单位、参保人中断缴交医疗保险费的，自中断缴交的次月1日起，停止享受医疗保险统筹基金支付的医疗保险待遇，但其个人账户余额可继续使用。<strong>注意不要断保。</strong></li>
<li>基本医疗保险药品、诊疗项目、服务设施标准的目录按照国家及广东省公布的目录执行。可参考：<a href="http://www.nhsa.gov.cn/art/2019/8/20/art_37_1666.html">《国家基本医疗保险、工伤保险和生育保险药品目录》</a>。<strong>一般也不需要特别关注这个目录，假如能走统筹报销的话，支持的时候自然也会走报销。假如想要省钱的话，可以在就医时，告诉医生尽量用目录里的药物。另外在去药店买药时，也可以查一查这个目录，在这个目录再去买，否则网上买可能实惠些。</strong></li>
<li>基本医疗保险一档参保人个人账户用于支付参保人门诊基本医疗费用、地方补充医疗费用、在定点零售药店凭本市市内定点医疗机构医生开具的处方购买医疗保险目录范围内药品的费用，个人账户不足支付部分由个人自付。基本医疗保险一档参保人连续参保满一年，在同一医疗保险年度内个人自付的门诊基本医疗费用和地方补充医疗费用超过本市上年度在岗职工平均工资5%的，超过部分由基本医疗保险大病统筹基金或地方补充医疗保险基金按规定支付70%，参保人年满70周岁以上的支付80%。</li>
<li>基本医疗保险一档参保人个人账户积累额超过本市上年度在岗职工平均工资5%的，超过部分可以用于买药、给家人用等。</li>
<li>基本医疗保险一档参保人在本市定点社康中心发生的基本医疗费用和地方补充医疗费用，70%由其个人账户支付，30%由基本医疗保险大病统筹基金、地方补充医疗保险基金按规定支付。但不包括<strong>口腔科治疗费用</strong>、康复理疗费用、大型医疗设备检查治疗费用等。</li>
<li>基本医疗保险一档参保人在本市定点医疗机构门诊做大型医疗设备检查和治疗所发生的基本医疗费用、地方补充医疗费用，80%由基本医疗保险大病统筹基金、地方补充医疗保险基金按规定支付。</li>
<li>统筹基金、地方补充医疗保险基金存在支付限额，连续参保时间越久，限额越高。连续三个月断保需要重新计算，<strong>因此注意不要断保。</strong></li>
</ul>
<p>我这次选择了去北京大学深圳医院的口腔科拔牙，在深圳，这家医院的实力是最顶尖的之一。口腔科下也细分了许多科室，需要注意不要挂错科室了。拔牙需要挂牙槽外科。因为新冠病毒的原因，需要在医护人员的引导下填写一张表单。中途等号的时候有点担心需要做完新冠病毒检测才能拔牙，时间可能不够。实际上并不需要做检测就可以拔牙了。</p>
<p>就诊医生有点迟到，但是我来得比较早，很快就排到我了。医生肉眼检查了一下我的智齿，发现看得不是很清楚，并且我也无法提供拍片的照片，因此建议我先去拍片。于是我听从医生的吩咐，排了较长的队拍了个片。回来后医生很快就根据拍片单做出判断，跟我说明下面的左右各一颗智齿都需要拔掉，因为继续长的话会顶到其他牙齿，建议这次只拔一颗。我选择了拔左下角的那颗智齿。医生很专业，给我的左下角口腔打上麻醉，然后上电钻、钳子等各种工具，行云流水地一顿操作，感觉不到十分钟就拔完了。结束时，医生还让我看了眼自己的牙齿，挺大的完整两瓣，含着血丝。不知道能不能带走纪念，本来想问问的，但是口腔上了麻醉说话有点困难，就没问了。最后，医生问我有没有布洛芬、头孢这些药，那时候我不知道这是啥药，当然回答没有。他给我开了一些药，然后我记了下注意事项后就去付款了。感觉自己对于常见的药物并不熟悉，家里也没有备药的习惯，以后有空可以了解一下常用的药。另外做得不好的一点是，忘了询问医生药要吃多久了，以后就医的时候要问清楚用药持续时间。</p>
<p>接下来到了手术付款时间，花了大概1300元，不能走统筹，全部走了个人医保账户。第一次用医保，当时也不是很清楚个人账户和统筹账户的区别，后来查资料发现，统筹才是医保报销，个人医保是个人支付的。</p>
<p>虽然是走的个人支付，但是好在公司有商业保险，能报销90%，最后相当于自己花了100多拔了一颗智齿。感觉商业保险还是很有用的，有空可以给家人看看有什么保险可以购买，提高家庭的抗风险能力。</p>
<p>接下来还有另外一颗智齿要拔，由于医保账户的余额不是很够，假如现在拔的话需要走现金支付，考虑到医保一般用不完，所以有点亏。于是打算医保余额足够了，再去拔另外一颗智齿吧。</p>
<p>北京大学深圳医院虽然离自己住的地方有点远，并且挂号困难，但是还是值得的，因为它拥有很专业的医生。专业度这点是非常珍贵的，假如经验不足，那么可能需要花费更多的时间、做出不合适的判断、甚至在手术过程造成失误等。这一点我深有感触，由于拔完牙后还需要再去拆线，这次给我拆线的是一个实习生，给我的感觉是拆得有点艰难，耗费的时间比拔牙还要久&#x3D; &#x3D;、</p>
<p>这次拔牙，还学到了一个生活经验，即有疑问可以找有关部门咨询，这样获取信息的效率很高。比如我对于拔牙不能走统筹保险这一点比较疑惑，通过网上一顿搜索都没有找到合理的解释，最后在网上发现可以打社保局的电话（12333）咨询，于是就打电话问问。最终得到了满意的答复，解答了心中的疑惑，发现去医院做门诊一般是需要个人账户支付的，除非门诊一年累计支付超过了一定额度，才能走70%的统筹报销。其实生活中是有许多部门很有用的，包括社保局、监管部门、工信部、公安局等，有空可以多了解一下他们的职责，以便在需要的时候用上。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.gd.gov.cn/zwgk/wjk/zcfgk/content/post_2530804.html">深圳市社会医疗保险办法</a></li>
</ul>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang源码学习1 源码编译</title>
    <url>/2020/11/25/golang-source-code-learning-1-compile-source-code/</url>
    <content><![CDATA[<p>前些天在工作中用Go写出了一个内存泄露的bug，原因是没有认真阅读文档，使用姿势不对。根据官方文档纠正使用姿势后，解决掉了这个bug。但是，对于为什么会内存泄露我还不是很明白，于是打算对源码研究一番，就有了这篇博文。</p>
<p>我的电脑操作系统是Linux，之前安装Go的方式是根据<a href="https://golang.org/dl/">官网教程</a>下载的二进制，在<code>$GOROOT</code>有编译好的二进制文件，也有源代码。通常在写项目代码时，会跳转标准库的函数说明，就是跳转到这里的源代码。这里的源代码用来参考还好，但是不适合折腾。我选择了从github拷贝最新的源代码来阅读。一是不会影响正常项目的编译，二是能拉取到最新的源代码，三是可以看到整个项目各个大佬的commit。</p>
<p>下载源代码，直接<code>git clone</code>即可。</p>
<p>下载了源代码后，开始尝试阅读源码。发现一个问题，IDE会对一些Go标准库的函数标红，提示没有这个函数的引用。经过查看commit，发现这个函数是新增加的，而自己IDE使用的sdk还是老旧的、之前下载的二进制文件。为了让GoLand认识这些新函数，需要使用这份新的源码编译。</p>
<p>对源码的编译。我参考了<a href="https://golang.org/doc/install/source">Installing Go from source</a>，这里不再赘述。</p>
<p>学习Golang的源码，就是跟顶尖程序员学习编程，是一件蛮有意义的事情。后面会写一些Golang源码学习相关的博文。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
