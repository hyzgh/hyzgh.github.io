<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[perl å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F12%2F18%2Fnull%2F</url>
    <content type="text"><![CDATA[Perlæ˜¯ä¸€é—¨è§£é‡Šå‹è¯­è¨€ï¼Œå…·æœ‰åŠ¨æ€è¯­è¨€çš„ç‰¹æ€§ï¼Œå¯ä»¥å†™å¾—å¾ˆéšæ€§ã€‚ç¼ºç‚¹æ˜¯ç”±äºè¯­æ³•çµæ´»å¯¼è‡´éš¾ä»¥ç»´æŠ¤ï¼Œè¿™å’ŒGo Langå½¢æˆäº†å¼ºçƒˆçš„å¯¹æ¯”ã€‚Go Langå¾ˆé€‚åˆç”¨æ¥å›¢é˜Ÿåä½œå¼€å‘ï¼Œå› ä¸ºå®ƒå†™æ³•å¾ˆå•ä¸€å›ºå®šã€‚Perlï¼Œæ›´åƒæ˜¯é»‘å®¢çš„å·¥å…·ã€‚ Perlçš„å¼ºå¤§ä¹‹å¤„ï¼Œåœ¨äºå®ƒå…·æœ‰sedå’Œawkçš„å…¨éƒ¨åŠŸèƒ½ï¼Œä»¥åŠä¼—å¤šè¯­è¨€çš„è¯­æ³•ç‰¹æ€§ï¼Œä»¥åŠéå¸¸å¼ºå¤§çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œç­‰ç­‰ã€‚ Hello, WorldPerlçš„Hello, Worldï¼š 1perl -e 'print("Hello, World\n")' åœ¨å®‰è£…äº†perlçš„è®¡ç®—æœºä¸Šï¼Œç›´æ¥æ‰§è¡Œä¸Šè¿°ä»£ç ï¼Œå³å¯è¾“å‡ºHello, Worldã€‚ ä¹Ÿå¯ä»¥å°†perlä»£ç å†™åœ¨æ–‡ä»¶ï¼Œä»¥é‡å¤æ‰§è¡Œï¼Œå…·ä½“å¯ä»¥è¿™æ ·å†™ï¼š 1234#!/usr/bin/perl# è¾“å‡º "Hello, World"print("Hello, World\n"); å°†ä¸Šè¿°ä»£ç ä¿å­˜æˆlearn.plåï¼ŒåŠ ä¸‹æ‰§è¡Œæƒé™ï¼Œç„¶åæ‰§è¡Œ./learn.plï¼Œå¯è¾“å‡ºHello, Worldã€‚ æ­£åˆ™è¡¨è¾¾å¼Perlçš„æ­£å¼è¡¨è¾¾å¼éå¸¸å¼ºå¤§ï¼Œæ˜¯å¸¸ç”¨ç¼–ç¨‹è¯­è¨€é‡Œæœ€é¡¶å°–çš„ä¹‹ä¸€ã€‚ä¸‹é¢æ¥çœ‹å‡ ä¸ªä¾‹å­ã€‚ ä¾‹å­1echo box.svc.content | perl -p -e &#39;s/\.+/\//g&#39; å°†ä¼šè¾“å‡ºbox/svc/contentã€‚ è§£æï¼š -på‚æ•°ä¼šå°†ç»“æœè¾“å‡ºå‡ºæ¥ã€‚ è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªå¸¸ç”¨çš„æ›¿æ¢å¥å‹ï¼Œs/old/new/parametersï¼Œè¡¨ç¤ºå°†oldæ›¿æ¢æˆnewã€‚ s/\.+/\//gçš„sè¡¨ç¤ºæ›¿æ¢ï¼Œ\.+è¡¨ç¤ºè‡³å°‘ä¸€ä¸ª.ï¼Œ\/è¡¨ç¤ºä¸€ä¸ª/ï¼Œgè¡¨ç¤ºå…¨å±€åŒ¹é…ã€‚ ä¾‹å­2123456#!/usr/bin/perl $string = 'welcome to w3cschool site.';$string =~ tr/a-z/A-z/;print "$string\n"; ä¸Šé¢çš„ä»£ç å°†ä¼šè¾“å‡ºWELCOME TO W3CSCHOOL SITE.ã€‚ è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªå¸¸ç”¨çš„è½¬åŒ–å¥å‹ï¼Œtr/old/new/parametersã€‚è¡¨ç¤ºå°†oldè½¬åŒ–æˆnewã€‚ å‚è€ƒPerl æ­£åˆ™è¡¨è¾¾å¼ - W3Cschool]]></content>
      <tags>
        <tag>ç¼–ç¨‹è¯­è¨€</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›¾ç‰‡æ–‡ä»¶æ ¼å¼ å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F12%2F07%2Fnull%2F</url>
    <content type="text"><![CDATA[åœ¨äº’è”ç½‘ä¸­ï¼Œå¸¸è§çš„å›¾ç‰‡æ–‡ä»¶æ ¼å¼æœ‰jpeg, png, bmp, gifç­‰ã€‚ ä¸€å‰¯å›¾ç‰‡ï¼Œå…·æœ‰å¾ˆå¤šçš„å±æ€§ï¼Œæ¯”å¦‚åˆ†è¾¨ç‡ï¼Œè‰²å½©ç©ºé—´ç­‰ã€‚å¯ä»¥é€šè¿‡ImageMagickè¿™ä¸ªç¨‹åºæ¥è§£æå›¾ç‰‡æ–‡ä»¶ã€‚ åˆ†è¾¨ç‡ï¼Œæ¯”å¦‚1920x1080ï¼Œæ˜¯æŒ‡å›¾ç‰‡çš„ä¸€è¡Œå…·æœ‰1920ä¸ªåƒç´ ï¼Œä¸€åˆ—å…·æœ‰1080ä¸ªåƒç´ ã€‚ è‰²å½©ç©ºé—´ï¼Œæ˜¯æŒ‡æè¿°ä¸€ä¸ªåƒç´ ç‚¹çš„æ–¹å¼ã€‚æ¯”å¦‚RGBï¼Œæ˜¯æŒ‡ä¸€ä¸ªåƒç´ ç‚¹ç”¨red, green, blueå„8bitä¸€å…±24bitæ¥æè¿°ã€‚è€ŒYUVï¼Œæ˜¯æŒ‡Yè¡¨ç¤ºäº®åº¦ï¼ŒUå’ŒVä¸€èµ·è¡¨ç¤ºè‰²è°ƒå’Œé¥±å’Œåº¦ã€‚ åœ¨äº’è”ç½‘ä¸Šæœ€å¸¸è§çš„å¤§æ¦‚æ˜¯jpegç±»çš„æ–‡ä»¶ã€‚jpegæ–‡ä»¶ä¹‹æ‰€ä»¥é€‚åˆåœ¨äº’è”ç½‘ä¸Šä¼ æ’­ï¼Œæ˜¯å› ä¸ºå®ƒçš„å‹ç¼©æ¯”è¾ƒé«˜ï¼Œä¸”èƒ½åœ¨å‹ç¼©å’Œå›¾ç‰‡è¿˜åŸåº¦ä¸Šä¿æŒå¹³è¡¡ï¼Œä½¿å¾—ä¸€å¼ å›¾ç‰‡æ—¢æœ‰å°å·§çš„ä½“ç§¯ï¼Œåˆèƒ½åœ¨è‚‰çœ¼çº§åˆ«ä¸Šæœ‰è‰¯å¥½çš„æ¸…æ™°åº¦ã€‚ ä½†æ˜¯jpegæ–‡ä»¶å¹¶ä¸é€‚åˆä¿å­˜å›¾æ ‡ç­‰å›¾åƒå†…å®¹ï¼Œå› ä¸ºå®ƒä¸å…·æœ‰alphaé€šé“ï¼Œä¸èƒ½ç”¨æ¥è¡¨ç¤ºé€æ˜çš„èƒŒæ™¯ã€‚ä¸€èˆ¬ä¼šç”¨pngæ¥ä¿å­˜å›¾æ ‡ã€‚ç”±äºpngæ˜¯æ— æŸå‹ç¼©å­˜å‚¨å›¾ç‰‡çš„ï¼Œæ‰€ä»¥ä¼šæ¯”jpegæ–‡ä»¶è¦å¤§ä¸€äº›ï¼Œä¹Ÿé€‚åˆå¯¹äºå›¾åƒè´¨é‡è¦æ±‚è¾ƒé«˜çš„æƒ…å†µã€‚ bmpæ–‡ä»¶ï¼Œå®ƒä¹Ÿæ˜¯æ— æŸä¸å‹ç¼©çš„ï¼Œæ‰€ä»¥ä¼šæ¯”è¾ƒå¤§ï¼Œæ¯”è¾ƒå°‘è§ã€‚ gitæ–‡ä»¶ï¼Œå¯ä»¥å­˜å‚¨åŠ¨å›¾ï¼Œä½†æ˜¯ç”±äºå®ƒåªç”¨äº†8bitæ¥æè¿°ä¸€ä¸ªåƒç´ ç‚¹ï¼Œæ‰€ä»¥å¯ç”¨çš„è‰²å½©å¹¶ä¸å¤šï¼Œè‰²å½©ä¸°å¯Œåº¦ä½ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>æ–‡ä»¶æ ¼å¼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 6]]></title>
    <url>%2F2019%2F10%2F21%2FCSAPP-learning-note-6%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘çœ‹äº†CSAPPçš„ç¬¬å…«ç« â€”â€”å¼‚å¸¸æ§åˆ¶æµã€‚ å¼‚å¸¸åœ¨è®¡ç®—æœºä¸­ï¼Œå‡å¦‚æ²¡æœ‰å¼‚å¸¸ï¼Œé‚£ä¹ˆæŒ‡ä»¤æ˜¯é¡ºåºæ‰§è¡Œçš„ã€‚å½“é‡åˆ°å¼‚å¸¸æ—¶ï¼Œä¼šæ‰§è¡Œå¼‚å¸¸å¤„ç†ç¨‹åºã€‚å¼‚å¸¸æœ‰ä¸åŒçš„ç§ç±»ï¼Œæœ‰ä¸­æ–­ã€é™·é˜±ã€æ•…éšœã€ç»ˆæ­¢ã€‚ ä¸­æ–­ï¼Œæ˜¯åœ¨CPUæ‰§è¡ŒæŸæ¡æŒ‡ä»¤çš„æ—¶å€™ï¼Œå…¶ä»–éƒ¨ä»¶å¼‚æ­¥äº§ç”Ÿçš„ï¼Œæ¯”å¦‚å®šæ—¶å™¨èŠ¯ç‰‡ã€ç£ç›˜æ§åˆ¶å™¨ã€ç½‘ç»œé€‚é…å™¨ç­‰ã€‚CPUæ£€æµ‹åˆ°ä¸­æ–­åï¼Œä¼šæŠŠå½“å‰æŒ‡ä»¤æ‰§è¡Œå®Œï¼Œç„¶åè½¬å»æ‰§è¡Œå¼‚å¸¸å¤„ç†ç¨‹åºï¼Œæ¥ç€å†è¿”å›æ¥æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ é™·é˜±ï¼Œæ˜¯æœ‰æ„çš„å¼‚å¸¸ï¼Œæœ€å¸¸è§çš„é™·é˜±æ˜¯ç³»ç»Ÿè°ƒç”¨ã€‚ç³»ç»Ÿè°ƒç”¨ï¼Œæ˜¯æŒ‡ä»ç”¨æˆ·æ¨¡å¼è½¬ä¸ºå†…æ ¸æ¨¡å¼ï¼Œä»¥æ‰§è¡Œä¸€äº›ç‰¹æ®Šçš„æŒ‡ä»¤ï¼Œæ¯”å¦‚æ“ä½œI/Oè®¾å¤‡ã€‚æ‰§è¡Œå®Œç³»ç»Ÿè°ƒç”¨åï¼Œä¼šè¿”å›æ¥æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ æ•…éšœï¼Œæ˜¯æŒ‡æ‰§è¡ŒæŒ‡ä»¤çš„æ—¶å€™é‡åˆ°äº†æ„å¤–ï¼Œæ¯”å¦‚é‡åˆ°äº†ç¼ºé¡µã€è®¿é—®äº†æœªå®šä¹‰çš„è™šæ‹Ÿå†…å­˜åŒºåŸŸç­‰ã€‚æ ¹æ®æ•…éšœçš„ä¸åŒï¼Œå¼‚å¸¸å¤„ç†ç¨‹åºæ‰§è¡Œå®Œåå¯èƒ½ä¼šè¿”å›æ‰§è¡Œå½“å‰æŒ‡ä»¤ï¼Œä¹Ÿæœ‰å¯èƒ½ä¼šç»ˆæ­¢ç¨‹åºã€‚åœ¨å†™ç¨‹åºæ—¶å¸¸å¸¸é‡åˆ°çš„Floating point exceptionå’ŒSegmentation faultå°±å±äºæ•…éšœï¼Œä¸”åœ¨Linuxä¸­çš„å¤„ç†æ˜¯ç¨‹åºè¢«ç»ˆæ­¢ã€‚ ç»ˆæ­¢ï¼Œæ˜¯æŒ‡é‡åˆ°äº†è‡´å‘½çš„ç¡¬ä»¶é”™è¯¯ï¼Œå¿…é¡»ç»“æŸç¨‹åºã€‚ å› ä¸ºå¼‚å¸¸ç§ç±»ç¹å¤šï¼Œæ‰€ä»¥è®¡ç®—æœºä¸­æœ‰ä¸€å¼ å¼‚å¸¸è¡¨ï¼Œç”¨æ¥è®°å½•ä¸åŒçš„å¼‚å¸¸åŠå¯¹åº”çš„å¼‚å¸¸å¤„ç†ç¨‹åºã€‚åœ¨CPUä¸­ï¼Œæœ‰ä¸€ä¸ªç‰¹æ®Šçš„å¯„å­˜å™¨â€”â€”å¼‚å¸¸è¡¨åŸºå€å¯„å­˜å™¨ï¼Œç”¨æ¥å­˜æ”¾å¼‚å¸¸è¡¨åœ¨å†…å­˜ä¸­çš„åŸºå€ã€‚å½“CPUé‡åˆ°ä¸€ç§å¼‚å¸¸çš„æ—¶å€™ï¼Œä¼šæ‹¿åˆ°ä¸€ä¸ªå¼‚å¸¸å·ã€‚CPUæ‹¿ç€è¿™ä¸ªå¼‚å¸¸å·åŠå¯„å­˜å™¨ä¸­çš„åŸºå€ï¼Œä¾¿å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„å¼‚å¸¸å¤„ç†ç¨‹åºäº†ã€‚ è¿›ç¨‹è¿›ç¨‹ï¼Œæ˜¯æ‰§è¡Œä¸­çš„ç¨‹åºå®ä¾‹ï¼Œæ˜¯æ“ä½œç³»ç»Ÿå¯¹äºç¨‹åºçš„ä¸€ç§æŠ½è±¡ã€‚è¿™ç§æŠ½è±¡ï¼Œä½¿å¾—çœ‹èµ·æ¥è¿›ç¨‹æ˜¯ç‹¬å cpuå’Œå†…å­˜çš„ã€‚ä¸ºäº†å®ç°è¿™ç§æŠ½è±¡ï¼Œéœ€è¦æ“ä½œç³»ç»Ÿä¿å­˜å¥½è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œè¿›è¡Œè¿›ç¨‹è°ƒåº¦ã€‚ è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œæ˜¯æŒ‡è¿›ç¨‹æ‰§è¡Œçš„çŠ¶æ€ï¼ŒåŒ…æ‹¬CPUä¸­çš„çŠ¶æ€ã€ç”¨æˆ·æ¨¡å¼ä¸­çš„çŠ¶æ€ã€å†…æ ¸æ¨¡å¼ä¸­çš„çŠ¶æ€ã€‚å…·ä½“æ¥è¯´ï¼Œcpuä¸­çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬å„ç§å¯„å­˜å™¨ï¼Œæ¯”å¦‚é€šç”¨å¯„å­˜å™¨ï¼Œç”¨æ¥ä¿å­˜æŒ‡ä»¤æ‰§è¡Œç”¨åˆ°çš„æ•°æ®ï¼Œè¿˜æœ‰ç¨‹åºè®¡æ•°å™¨ï¼Œç”¨æ¥æŒ‡æ˜ç¨‹åºæ‰§è¡Œçš„è¿›åº¦ã€‚ç”¨æˆ·æ¨¡å¼ä¸‹çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬ç”¨æˆ·æ ˆç­‰ã€‚å†…æ ¸æ¨¡å¼ä¸­çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬å†…æ ¸æ ˆã€è¿›ç¨‹å·²æ‰“å¼€æ–‡ä»¶çš„ä¿¡æ¯çš„æ–‡ä»¶è¡¨ã€æœ‰å…³å½“å‰è¿›ç¨‹çš„ä¿¡æ¯çš„è¿›ç¨‹è¡¨ç­‰ã€‚ ä»€ä¹ˆæ—¶å€™ä¼šè§¦å‘è¿›ç¨‹è°ƒåº¦å‘¢ï¼Ÿä¸»è¦æœ‰ä¸¤ç§æƒ…å†µã€‚ä¸€ç§æ˜¯è¿›ç¨‹æ‰§è¡Œäº†ç³»ç»Ÿè°ƒç”¨ï¼Œé˜»å¡ä½äº†ï¼Œæ¯”å¦‚è¯»å†™æ–‡ä»¶ã€sleepç­‰ã€‚å¦ä¸€ç§æ˜¯ä¸­æ–­ï¼ŒåŒ…æ‹¬IOæ“ä½œå®Œæˆä»¥åŠæ—¶é’Ÿä¸­æ–­ç­‰ã€‚ æ“ä½œè¿›ç¨‹çš„å·¥å…· PSï¼šåˆ—å‡ºå½“å‰ç³»ç»Ÿä¸­çš„è¿›ç¨‹ã€‚ TOPï¼šæ‰“å°å‡ºå…³äºå½“å‰è¿›ç¨‹èµ„æºä½¿ç”¨çš„è¿›ç¨‹ã€‚ PMAPï¼šæ˜¾ç¤ºè¿›ç¨‹çš„å†…å­˜æ˜ å°„ã€‚ STRACEï¼šæ‰“å°ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„ç¨‹åºå’Œå®ƒçš„å­è¿›ç¨‹è°ƒç”¨çš„æ¯ä¸ªç³»ç»Ÿè°ƒç”¨çš„è½¨è¿¹ã€‚-staticæ˜¯ä¸ªå®ç”¨çš„å‚æ•°ã€‚ /procï¼šä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼Œä»¥ASCIIæ–‡ä»¶æ ¼å¼è¾“å‡ºå¤§é‡å†…æ ¸æ•°æ®ç»“æ„çš„å†…å®¹ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 5]]></title>
    <url>%2F2019%2F10%2F18%2FCSAPP-learning-note-5%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨çœ‹äº†CSAPPç¬¬å…­ç« å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„çš„å‰ä¸‰èŠ‚ï¼Œä¸‹é¢æ˜¯æ€ç»´ç¬”è®°ã€‚ å­˜å‚¨æŠ€æœ¯å­˜å‚¨å™¨æœ‰ç€å¾ˆå¤šçš„ç§ç±»ï¼Œæ¯”å¦‚CPUçš„å¯„å­˜å™¨ã€é«˜é€Ÿç¼“å­˜ï¼Œä¸»å­˜ï¼ˆå†…å­˜ï¼‰çš„DRAMï¼Œæœºæ¢°ç¡¬ç›˜ã€å›ºæ€ç¡¬ç›˜ã€Uç›˜ã€SDå¡ã€ç£å¸¦ç­‰ã€‚ä¸åŒçš„å­˜å‚¨å™¨ï¼Œä¼šç”¨åˆ°ä¸åŒçš„å­˜å‚¨æŠ€æœ¯ã€‚å…¶ä¸­å¯„å­˜å™¨çš„å­˜å‚¨æŠ€æœ¯ä»æ€§èƒ½ä¸Šçœ‹æ˜¯æœ€å¥½çš„ï¼ŒåŒæ—¶ä»·æ ¼ä¹Ÿæœ€æ˜‚è´µçš„ï¼Œå› æ­¤å¯„å­˜å™¨çš„å¤§å°ç›¸æ¯”äºå…¶ä»–å­˜å‚¨å™¨ï¼Œå°‘å¾—å¯æ€œï¼Œæ¯”å¦‚ä¸€èˆ¬æ¥è¯´ï¼Œé€šç”¨å¯„å­˜å™¨åªæœ‰16ä¸ªï¼Œè€Œ1ä¸ªå¯„å­˜å™¨åªèƒ½å­˜å‚¨64ä¸ªbitã€‚é«˜é€Ÿç¼“å­˜é‡‡ç”¨çš„æ˜¯SRAMï¼Œè€Œä¸»å­˜ç”¨çš„æ˜¯DRAMã€‚SRAMç”¨åˆ°äº†å¤šä¸ªæ™¶ä½“ç®¡ï¼Œæ¯”DRAMè¦å¿«å¾—å¤šï¼Œä¼šæ›´åŠ ç¨³å®šï¼ŒåŒæ—¶æˆæœ¬ä¹Ÿæ›´é«˜ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œé«˜é€Ÿç¼“å­˜æ˜¯å‡ Mçš„é‡çº§ï¼Œè€Œä¸»å­˜æ˜¯ä»¥å‡ Gçš„é‡çº§ï¼Œå¯è§ä¸¤è€…çš„ä»·æ ¼å·®å¼‚ã€‚RAMæœ‰ä¸€ä¸ªç‰¹ç‚¹æ˜¯æ–­ç”µåå†…å®¹ä¼šä¸¢å¤±ã€‚ æˆ‘ä»¬å¸¸ç”¨çš„Uç›˜ã€SDå¡ç­‰ï¼Œå¹¶ä¸æ˜¯åŸºäºRAMï¼Œè€Œæ˜¯åŸºäºROMã€‚æ‰€è°“ROMï¼Œç¿»è¯‘æˆä¸­æ–‡ä¾¿æ˜¯åªè¯»å­˜å‚¨å™¨ã€‚ä¸ªäººè§‰å¾—è¿™ä¸ªåå­—æœ‰ç‚¹æ­§ä¹‰ï¼Œå®¹æ˜“è®©äººè¯¯è§£æˆæ•°æ®ä¸å¯æ›´æ”¹ã€‚ä½†å®é™…ä¸Šï¼ŒROMä¹Ÿæœ‰å¤šä¸ªç§ç±»ï¼Œæˆ‘ä»¬å¸¸ç”¨çš„Uç›˜åŸºäºEEPROMï¼ˆç”µå­å¯æ“¦å†™åªè¯»å­˜å‚¨å™¨ï¼‰ï¼Œæ˜¯å¯ä»¥è¿›è¡Œæ“¦å†™çš„ã€‚è€Œå›ºæ€ç¡¬ç›˜ï¼ŒåŸºäºé—ªå­˜ï¼Œå®ƒä¹Ÿæ˜¯å¯æ“¦å†™çš„ã€‚ä»¥å‰ç»™æ‰‹æœºåˆ·æœºçš„æ—¶å€™ï¼Œå¸¸å¸¸ä¼šå¬åˆ°ROMå’Œå›ºä»¶è¿™ä¸¤ä¸ªåè¯ã€‚æ‰€è°“å›ºä»¶ï¼Œæ˜¯æŒ‡å†™å…¥åˆ°ROMä¸­çš„ç¨‹åºã€‚ æœºæ¢°ç¡¬ç›˜ï¼Œå¸¸å¸¸ä¼šå¬åˆ°ä¸€ä¸ªå‚æ•°å«è½¬æ•°ã€‚è¿™ä¸ªå‚æ•°è¡¨ç¤ºç›˜ç‰‡æ—‹è½¬é€Ÿåº¦çš„é€Ÿåº¦ã€‚è¿™ä¸ªå‚æ•°è™½ç„¶é‡è¦ï¼Œä½†å´éå½±å“ç¡¬ç›˜éšæœºIOæ—¶é—´çš„æœ€é‡è¦å› ç´ ã€‚ç£ç›˜è®¿é—®æ•°æ®ï¼Œç”±ä¸‰ä¸ªéƒ¨åˆ†çš„æ—¶é—´ç»„æˆï¼Œå³å¯»é“æ—¶é—´ã€æ—‹è½¬æ—¶é—´ã€ä¼ é€æ—¶é—´ã€‚å¯»é“æ—¶é—´æ˜¯ç£å¤´å®šä½åˆ°å¯¹åº”ç£é“çš„æ—¶é—´ï¼Œè¿™ä¸ªæ—¶é—´å¹³å‡å æ¯”æ˜¯æœ€å¤§çš„ï¼Œé€šå¸¸å¯å åˆ°æ•´ä½“æ—¶é—´çš„1/2ä»¥ä¸Šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ä¸¤å€å¯»é“æ—¶é—´æ¥ä¼°è®¡æ€»æ—¶é—´ã€‚ç£å¤´å®šä½åˆ°å¯¹åº”ç£é“ï¼Œæœ‰ä¸“é—¨çš„å¯»é“ç®—æ³•ï¼Œæ¯”å¦‚ç”µæ¢¯ç®—æ³•ã€‚ å›ºæ€ç¡¬ç›˜ï¼Œæ˜¯è¿‘äº›å¹´æµè¡Œèµ·æ¥çš„å­˜å‚¨å™¨ã€‚å…¶æ€§èƒ½ã€ä»·æ ¼çš†ä»‹äºä¸»å­˜å’Œæœºæ¢°ç¡¬ç›˜ä¹‹é—´ã€‚ç”±äºå›ºæ€ç¡¬ç›˜é‡‡ç”¨äº†é—ªå­˜ï¼Œé¿å…äº†æœºæ¢°ç¡¬ç›˜ç¼“æ…¢çš„å¯»é“å’Œæ—‹è½¬ï¼Œæ‰€ä»¥é€Ÿåº¦æ›´å¿«ï¼Œç‰¹åˆ«æ˜¯åœ¨éšæœºIOçš„è¡¨ç°ä¸Šã€‚ æ ¹æ®å†å²è¶‹åŠ¿ï¼Œå­˜å‚¨å™¨å°†ä¼šè®¿é—®é€Ÿåº¦è¶Šæ¥è¶Šå¿«ï¼Œè¶Šæ¥è¶Šå¤§ï¼Œä¸”ä¼šè¶Šæ¥è¶Šä¾¿å®œã€‚ä½†æ˜¯ï¼Œç”±äºCPUçš„æ€§èƒ½æå‡è¦æ¯”SRAMã€DRAMã€ç£ç›˜çš„é€Ÿåº¦å¿«ï¼Œæ‰€ä»¥ä¸¤è€…çš„å·®è·åœ¨å¢å¤§ï¼Œè¿™å°†æˆä¸ºè®¡ç®—æœºçš„ç“¶é¢ˆã€‚ä¹Ÿå› æ­¤ï¼Œå„çº§ç¼“å­˜çš„å¿…è¦æ€§å°±ä½“ç°å‡ºæ¥äº†ï¼Œåˆ©ç”¨å±€éƒ¨æ€§åŸç†ï¼Œæˆ‘ä»¬å¯ä»¥å‡å¼±è¿™ç§å·®è·ã€‚ å±€éƒ¨æ€§å±€éƒ¨æ€§åˆ†ä¸ºç©ºé—´å±€éƒ¨æ€§åŠæ—¶é—´å±€éƒ¨æ€§ã€‚ç©ºé—´å±€éƒ¨æ€§æŒ‡çš„æ˜¯æŸä¸ªä½ç½®çš„æ•°æ®è¢«è®¿é—®åï¼Œå…¶é™„è¿‘çš„æ•°æ®å°†å¯èƒ½è¢«è®¿é—®ã€‚æ—¶é—´å±€éƒ¨æ€§æŒ‡çš„æ˜¯æŸä¸ªä½ç½®çš„æ•°æ®è¢«è®¿é—®åï¼Œè¿™ä¸ªä½ç½®è¿˜å°†å¯èƒ½è¢«å†æ¬¡è®¿é—®ã€‚ ä»¥å‰å¯¹äºè¿™ä¸ªæ¦‚å¿µçš„è®¤è¯†æœ‰ç‚¹æ¨¡ç³Šï¼Œå¯¹å…¶å¸¦æ¥çš„æ€§èƒ½å·®å¼‚æ²¡æœ‰æ˜ç¡®çš„è®¤çŸ¥ã€‚æˆ‘ä»¬ä¸‹é¢é€šè¿‡ä¸€ä¸ªç¨‹åºæ¥çœ‹ä¸€ä¸‹ç©ºé—´å±€éƒ¨æ€§å¸¦æ¥çš„å½±å“ã€‚ 12345678910111213141516171819int sum1(int a[N][N]) &#123; int i, j, sum = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; sum += a[i][j]; &#125; &#125; return sum;&#125;int sum2(int a[N][N]) &#123; int i, j, sum = 0; for (int j = 0; j &lt; N; j++) &#123; for (int i = 0; i &lt; N; i++) &#123; sum += a[i][j]; &#125; &#125; return sum;&#125; å½“N = 20000æ—¶ï¼Œåœ¨æˆ‘çš„æœºå™¨ä¸Šï¼Œsum1æ‰§è¡Œçš„æ—¶é—´ä¸º2.1sï¼Œè€Œsum2æ‰§è¡Œçš„æ—¶é—´ä¸º5.6sï¼Œä¸¤è€…å·®è·ä¸¤å€å¤šã€‚ sum1ä¹‹æ‰€ä»¥æ€§èƒ½è¡¨ç°æ¯”sum2ä¼˜ç§€ï¼Œæ˜¯å› ä¸ºå®ƒè®¿é—®æ•°æ®æ—¶çš„æ­¥é•¿ä¸º1ï¼Œè®©è®¡ç®—æœºèƒ½æ›´å¥½åœ°åˆ©ç”¨ç©ºé—´å±€éƒ¨æ€§åŸç†ã€‚ å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„è®¡ç®—æœºçš„å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„ä»å¿«åˆ°æ…¢åˆ†ä¸ºå¯„å­˜å™¨ã€L1é«˜é€Ÿç¼“å­˜ã€L2é«˜é€Ÿç¼“å­˜ã€L3é«˜é€Ÿç¼“å­˜ã€ä¸»å­˜ã€æœ¬åœ°äºŒçº§ç£ç›˜ï¼ˆæœ¬åœ°ç£ç›˜ï¼‰ã€è¿œç¨‹äºŒçº§å­˜å‚¨ï¼ˆåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿã€WebæœåŠ¡å™¨ï¼‰ç­‰ã€‚é€šè¿‡è¿™æ ·çš„å±‚æ¬¡ç»“æ„ï¼Œåœ¨å¤§å°ã€è®¿é—®é€Ÿåº¦ã€ä»·æ ¼ç­‰å› ç´ ä¹‹é—´å–å¾—äº†æŠ˜è¡·ï¼Œè®©è®¡ç®—æœºçš„ä»·æ ¼åˆç†ã€è®¿é—®é€Ÿåº¦è¾ƒå¿«ã€å­˜å‚¨ç©ºé—´è¾ƒå¤§ã€‚ ç¼“å­˜æ— å¤„ä¸åœ¨ï¼Œå…¶ç›®çš„æ˜¯é™ä½ä¸åŒå­˜å‚¨å™¨ä¹‹é—´é€Ÿåº¦å·®å¼‚å¸¦æ¥çš„å½±å“ã€‚è®¡ç®—æœºå„çº§å­˜å‚¨å™¨ä¹‹é—´ï¼Œä¸Šå±‚æ˜¯ä¸‹å±‚çš„ç¼“å­˜ã€‚æµè§ˆå™¨è®¿é—®ç½‘é¡µæ—¶ï¼Œåœ¨æœ¬åœ°ç£ç›˜æœ‰ç¼“å­˜ï¼Œèƒ½æé«˜ç”¨æˆ·æ‰“å¼€åŒä¸€ç½‘é¡µçš„é€Ÿåº¦ã€‚WebæœåŠ¡å™¨è¢«è®¿é—®çš„æ—¶å€™ï¼Œæœ¬åœ°ç£ç›˜ä¹Ÿæœ‰ç¼“å­˜ï¼Œèƒ½æé«˜ä¸åŒç”¨æˆ·è®¿é—®åŒä¸€ç½‘é¡µçš„é€Ÿåº¦ã€‚ç£ç›˜ä¹Ÿæœ‰ç¼“å­˜ï¼Œç”¨äºç¼“å­˜ç£ç›˜æ‰‡åŒºï¼Œæé«˜è®¡ç®—æœºè®¿é—®ç£ç›˜çš„é€Ÿåº¦ã€‚ä»£ç†æœåŠ¡å™¨ï¼Œä¹Ÿå¯ç”¨æ¥åšç¼“å­˜ï¼Œèƒ½é™ä½ç½‘ç»œå»¶è¿Ÿã€‚ä¸šåŠ¡ä¸Šï¼Œredisç”¨ä½œMySQLçš„ç¼“å­˜ï¼Œæ˜¯ç”¨å†…å­˜æ¥ç¼“å­˜ç£ç›˜çš„å†…å®¹ï¼Œç¼“è§£äº†éšæœºI/Oå¸¦æ¥çš„æ€§èƒ½é—®é¢˜ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 4]]></title>
    <url>%2F2019%2F10%2F15%2FCSAPP-learning-note-4%2F</url>
    <content type="text"><![CDATA[è¿™ä¸¤å‘¨çœ‹å¾—æ¯”è¾ƒå°‘ï¼Œè¿›åº¦ç¼“æ…¢ï¼Œåªçœ‹äº†ç¬¬ä¸‰ç« å…³äºæ§åˆ¶çš„ä¸€å°èŠ‚å†…å®¹ï¼Œä¸‹é¢ç®€å•å†™ä¸€å†™ã€‚ åœ¨CPUä¸­ï¼Œç»´æŠ¤ç€ä¸€ç»„å•ä¸ªä½çš„æ¡ä»¶ç å¯„å­˜å™¨ï¼Œç”¨äºæè¿°ç®—æœ¯æˆ–é€»è¾‘æ“ä½œçš„å±æ€§ï¼Œå¯ä»¥é€šè¿‡æ£€æµ‹è¿™äº›å¯„å­˜å™¨æ¥æ‰§è¡Œæ¡ä»¶åˆ†æ”¯æŒ‡ä»¤ï¼Œæœ€å¸¸ç”¨çš„æ¡ä»¶ç æœ‰è¿›ä½æ ‡å¿—ã€é›¶æ ‡å¿—ã€ç¬¦å·æ ‡å¿—ã€æº¢å‡ºæ ‡å¿—ã€‚ åœ¨CPUæ‰§è¡Œæ‰€æœ‰ç®—æœ¯å’Œé€»è¾‘è¿ç®—æ—¶ï¼Œéƒ½ä¼šè®¾ç½®æ¡ä»¶ç ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰ä¸¤ç±»æŒ‡ä»¤ï¼Œå³CMPå’ŒTESTï¼Œä¹Ÿä¼šè®¾ç½®æ¡ä»¶ç ï¼Œä½†å®ƒä»¬ä¸ä¼šæ”¹å˜å…¶ä»–å¯„å­˜å™¨ã€‚ é‚£ä¹ˆæ€ä¹ˆè®¿é—®è¿™äº›æ¡ä»¶å¯„å­˜å™¨å‘¢ï¼ŸCPUä¸­æä¾›äº†SETæŒ‡ä»¤ï¼Œå¯¹è¿™äº›æ ‡å¿—ä½è¿›è¡Œäº†å°è£…ï¼Œå¯ä»¥æ›´æ–¹ä¾¿åœ°è·å–å¸¸è§çš„æ¯”è¾ƒç»“æœã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæœ€ç®€å•çš„æƒ…å†µï¼Œæ˜¯åˆ¤æ–­ç»“æœæ˜¯å¦ä¸ºé›¶ï¼Œå¯¹åº”SETEæŒ‡ä»¤ï¼Œå®ƒä¼šè¯»å–é›¶æ ‡å¿—å¯„å­˜å™¨ã€‚è€Œæ¯”è¾ƒå¤æ‚çš„æƒ…å†µï¼Œåˆ¤æ–­æœ‰ç¬¦å·æ•°çš„å°äºæ¯”è¾ƒï¼Œå¯¹åº”SETLï¼Œå®ƒä¼šè¯»å–ç¬¦å·æ ‡å¿—å¯„å­˜å™¨å’Œæº¢å‡ºæ ‡å¿—å¯„å­˜å™¨ï¼Œç„¶åå–å®ƒä»¬çš„å¼‚æˆ–å€¼ã€‚ è¦å®ç°åƒCè¯­è¨€ä¸­çš„forè¯­å¥ï¼Œè¿˜éœ€è¦ä¸€ç±»æŒ‡ä»¤JMPã€‚å®ƒå¯ä»¥æ ¹æ®æ¡ä»¶è·³è½¬åˆ°å…¶ä»–è¯­å¥ï¼Œè€Œä¸æ˜¯ä¸€ç›´é¡ºåºæ‰§è¡Œã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 3]]></title>
    <url>%2F2019%2F09%2F29%2FCSAPP-learning-note-3%2F</url>
    <content type="text"><![CDATA[è¿™ä¸¤å‘¨çœ‹äº†ç¬¬ä¸‰ç« çš„å‰é¢äº”èŠ‚ï¼Œå¯¹æœºå™¨æŒ‡ä»¤æœ‰äº†æ›´è¿›ä¸€æ­¥çš„è®¤è¯†ã€‚ å†å²è§‚ç‚¹Intelå¤„ç†å™¨ç³»åˆ—ä¿—ç§°x86ï¼Œå®ƒæœ‰ç€ä¸€æ®µè¿›åŒ–ä¹‹æ—…ã€‚ä»æœ€åˆçš„8086åˆ°i386ï¼Œå†åˆ°i5å’Œi7ã€‚é‚£ä¹ˆå®ƒç©¶ç«Ÿæœ‰å“ªäº›æ–¹é¢çš„æå‡å‘¢ï¼Ÿ æ™¶ä½“ç®¡æ•°é‡å¢åŠ ã€‚Core i7çš„1.4Gä¸ªæ™¶ä½“ç®¡ï¼Œæ˜¯8086èŠ¯ç‰‡29Kä¸ªæ™¶ä½“ç®¡çš„4.8ä¸‡å€ã€‚æ™¶ä½“ç®¡è¶Šå¤šï¼Œæ„å‘³ç€èŠ¯ç‰‡çš„ç”µè·¯è¶Šå¤æ‚ï¼Œèƒ½åŠ›è¶Šå¼ºã€‚ æŒ‡ä»¤é›†å˜å¤§ï¼Œæ”¯æŒæ›´å¤šæŒ‡ä»¤ã€‚8087åœ¨8086çš„åŸºç¡€ä¸Šï¼Œå»ºç«‹äº†æµ®ç‚¹æ¨¡å‹ã€‚ æ›´å¤šçš„ä½æ•°ã€‚Pentium 4Eæ˜¯Intelå¯¹AMDæå‡ºçš„å¯¹IA32çš„64ä½æ‹“å±•çš„å®ç°ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºx86-64ã€‚ æ›´å¤šçš„æ ¸æ•°ã€‚Core 2æ˜¯Intelçš„ç¬¬ä¸€ä¸ªå¤šæ ¸å¾®å¤„ç†å™¨ã€‚ æ›´å¤šçš„æŠ€æœ¯ã€‚Pentium 4Eå¢åŠ äº†è¶…çº¿ç¨‹ï¼Œå…è®¸ä¸€ä¸ªå¤„ç†å™¨ä¸ŠåŒæ—¶è¿è¡Œä¸¤ä¸ªç¨‹åºã€‚ AMDç­‰äº§å•†çš„å¤§å¤šå¤„ç†å™¨ä¸Intelå¤„ç†å™¨å…¼å®¹ï¼Œèƒ½å¤Ÿè¿è¡Œå®Œå…¨ç›¸åŒçš„æœºå™¨çº§ç¨‹åºã€‚ ç¨‹åºç¼–ç ä»€ä¹ˆæ˜¯æœºå™¨ä»£ç å‘¢ï¼Ÿæˆ‘ä»¬çŸ¥é“ï¼ŒCè¯­è¨€ä¼šç»è¿‡é¢„å¤„ç†ã€ç¼–è¯‘ã€æ±‡ç¼–ã€é“¾æ¥è¿™äº›è¿‡ç¨‹ã€‚ é¢„ç¼–è¯‘ï¼šæ‹“å±•æºä»£ç ï¼Œä¸»è¦å¤„ç†å¯¹è±¡æ˜¯#includeåŠ#defineã€‚ ç¼–è¯‘ï¼šäº§ç”Ÿæºæ–‡ä»¶çš„æ±‡ç¼–ä»£ç ï¼Œæ‹“å±•åä¸º.sã€‚ æ±‡ç¼–ï¼šäº§ç”ŸäºŒè¿›åˆ¶ç›®æ ‡ä»£ç ï¼Œæ‹“å±•åä¸º.oã€‚ é“¾æ¥ï¼šå°†å¤šä¸ª.oæ–‡ä»¶è½¬åŒ–æˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ã€‚ æ‰€è°“æœºå™¨ä»£ç ï¼Œç¬¬ä¸€ç§æ˜¯æŒ‡.oæ–‡ä»¶ä¸­çš„ä»£ç ï¼Œç¬¬äºŒç§æ˜¯æŒ‡å¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„ä»£ç ã€‚å®ƒä»¬çš„åŒºåˆ«åœ¨äºå‰è€…è¿˜æ²¡æœ‰å¡«å…¥å…¨å±€å€¼çš„åœ°å€ã€‚ æœºå™¨ä»£ç æ˜¯ä¸€äº›äºŒè¿›åˆ¶ä»£ç ï¼Œä¸å…·æœ‰å¯è¯»æ€§ã€‚æ±‡ç¼–ä»£ç éå¸¸æ¥è¿‘æœºå™¨ä»£ç ï¼Œæˆ‘ä»¬å¯é€šè¿‡å­¦ä¹ æ±‡ç¼–ä»£ç æ¥è®¤è¯†æœºå™¨ä»£ç ã€‚ æ•°æ®æ ¼å¼Intelçš„ä½“ç³»ç»“æ„ä¸€ç›´åœ¨å˜åŒ–ï¼Œä»16ä½åˆ°32ä½ï¼Œå†åˆ°64ä½ï¼Œå¯èƒ½ä»¥åè¿˜ä¼šæ‹“å±•åˆ°128ä½ã€‚ Intelç”¨ä»¥ä¸‹æœ¯è¯­æ¥è¡¨ç¤ºä¸åŒçš„æ•°æ®ç±»å‹ã€‚ Intelæ•°æ®ç±»å‹ æ±‡ç¼–ä»£ç åç¼€ å¤§å°ï¼ˆå­—èŠ‚ï¼‰ å­—èŠ‚ b 1 å­— w 2 åŒå­— l 4 å››å­— q 8 å•ç²¾åº¦ s 4 åŒç²¾åº¦ l 8 è®¿é—®ä¿¡æ¯ä¸€ä¸ªCPUåŒ…å«ä¸€ç»„16ä¸ªå­˜å‚¨64ä½å€¼çš„é€šç”¨ç›®çš„å¯„å­˜å™¨ï¼Œè¿™äº›å¯„å­˜å™¨ç”¨æ¥å­˜å‚¨æ•´æ•°æ•°æ®å’ŒæŒ‡é’ˆã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œç¨‹åºè¿è¡Œæ—¶ï¼Œå…¶æ•°æ®å­˜æ”¾åœ¨å†…å­˜ä¸­ã€‚CPUéœ€è¦ä¸€äº›æŒ‡ä»¤æ¥è¿›è¡Œå†…å­˜ä¸å¯„å­˜å™¨é—´çš„æ•°æ®è½¬ç§»ï¼Œç§°ä¸ºæ•°æ®è½¬ç§»æŒ‡ä»¤ã€‚ æˆ‘ä»¬ä¹ŸçŸ¥é“ï¼Œç¨‹åºè¿è¡Œæ—¶ï¼Œåœ¨å†…å­˜ä¸­æœ‰ä¸€ä¸ªå¯¹åº”çš„ç¨‹åºæ ˆã€‚CPUæœ‰ä¸“é—¨æŒ‡ä»¤è¿›è¡Œå…¥æ ˆã€å‡ºæ ˆæ“ä½œã€‚å¯å¦å°†è¿™äº›æŒ‡ä»¤å»æ‰å‘¢ï¼Ÿå¯ä»¥ï¼Œå­˜åœ¨ä»£æ›¿æŒ‡ä»¤ã€‚ä½†æ˜¯è¿™æ ·åšï¼Œä¼šè®©æœºå™¨ä»£ç å¢å¤šï¼Œè€ƒè™‘åˆ°å…¥æ ˆå‡ºæ ˆæ“ä½œæ˜¯éå¸¸å¸¸è§çš„ï¼Œæ‰€ä»¥æä¾›ä¸“é—¨çš„æŒ‡ä»¤ä¼šç¼©å‡æœºå™¨ä»£ç çš„å¤§å°ã€‚è¿™ä¹Ÿå°±æ˜¯åœ¨ç²¾ç®€æŒ‡ä»¤é›†ä¸Šç¼–è¯‘å‡ºæ¥çš„æœºå™¨ä»£ç æ¯”å¤æ‚æŒ‡ä»¤é›†åºå¤§çš„åŸå› ã€‚ ç®—æœ¯å’Œé€»è¾‘æ“ä½œæ‰€è°“ç®—æœ¯æ“ä½œï¼ŒæŒ‡çš„æ˜¯åŠ å‡ä¹˜é™¤ç­‰æ“ä½œã€‚æ‰€è°“é€»è¾‘æ“ä½œï¼Œæ˜¯æŒ‡ä¸æˆ–ç§»ä½ç­‰æ“ä½œã€‚ é€šè¿‡å­¦ä¹ æ±‡ç¼–ä»£ç çš„ç®—æœ¯å’Œé€»è¾‘æ“ä½œï¼Œå¯¹äºé«˜çº§è¯­è¨€çš„ä¾¿åˆ©æ€§æœ‰äº†æ›´å…·ä½“çš„è®¤è¯†ã€‚ä¸€æ¡Cè¯­è¨€ç®€å•çš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œè½¬åŒ–æˆæ±‡ç¼–ä»£ç ï¼Œä¼šå˜æˆå¤šæ¡ã€‚å¯¹äºä¸€äº›æ›´å¤æ‚çš„å¾ªç¯æ§åˆ¶è¯­å¥ï¼Œå°±æ›´å¤æ‚äº†ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½¯ä»¶å·¥ç¨‹å¸ˆçš„è‡ªæˆ‘ä¿®å…» week4]]></title>
    <url>%2F2019%2F09%2F23%2Fsoftwafe-engineer-week4%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨çš„ä¸»è¦æ”¶è·æœ‰ï¼š åˆ·Leetcodeï¼Œåšäº†13é“å·¦å³çš„é¢˜ç›®ã€‚ å¤ä¹ ã€Šå‰‘æŒ‡Offerã€‹ï¼Œçœ‹äº†å¤§æ¦‚50%ã€‚ å¤ä¹ ã€ŠRedisè®¾è®¡ä¸å®ç°ã€‹ï¼Œçœ‹äº†å¤§æ¦‚13%ã€‚ å¤ä¹ ã€Šæ•°æ®ç»“æ„ã€‹ï¼Œçœ‹äº†å¤§æ¦‚25%ã€‚ å­¦ä¹ C++ï¼Œé˜…è¯»ã€ŠEffective C++ã€‹ï¼Œå­¦ä¹ äº†ä¸‰ä¸ªæ¡æ¬¾ã€‚ å­¦ä¹ è®¾è®¡æ¨¡å¼ï¼Œæ–°å­¦äº†è£…é¥°è€…æ¨¡å¼ã€‚ å­¦ä¹ MySQLï¼Œå¤ä¹ äº†ä¸“æ ï¼Œç»§ç»­é˜…è¯»äº†ã€Šé«˜æ€§èƒ½MySQLã€‹çš„ç´¢å¼•éƒ¨åˆ†ã€‚ å­¦ä¹ Gitï¼Œgithugé—¯äº†æ•°å…³ï¼Œå­¦åˆ°äº†ä¸€äº›å‘½ä»¤çš„æ–°ç”¨æ³•ã€‚ é˜…è¯»CSAPPï¼Œå¼€å§‹é˜…è¯»ç¬¬ä¸‰ç« ï¼ˆç¨‹åºçš„æœºå™¨çº§è¡¨ç¤ºï¼‰ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>æˆé•¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½¯ä»¶å·¥ç¨‹å¸ˆçš„è‡ªæˆ‘ä¿®å…» week3]]></title>
    <url>%2F2019%2F09%2F16%2Fsoftwafe-engineer-week3%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨çš„ä¸»è¦æ”¶è·æœ‰ï¼š åˆ·Leetcodeï¼Œåšäº†14é“å·¦å³ã€‚æ¯å‘¨åšçš„é¢˜ç›®è¶Šæ¥è¶Šå¤šï¼Œæ¯ä¸€é“é¢˜èŠ±è´¹çš„æ—¶é—´å¹³å‡åŠå°æ—¶ï¼Œè¿™ä¸ªèŠ‚å¥è¿˜è¡Œã€‚å¯¹äºeasyçš„é¢˜ç›®ï¼Œå°ç›®æ ‡æ˜¯10åˆ†é’Ÿå†…èƒ½æƒ³å‡ºæœ€ä¼˜è§£æ³•å¹¶å†™å®Œã€‚å¯¹äºmediumçš„é¢˜ç›®ï¼Œå°ç›®æ ‡æ˜¯20åˆ†é’Ÿå†…èƒ½æœ‰è¾ƒå¥½çš„æ€è·¯å¹¶å†™å®Œã€‚å¯¹äºhardçš„é¢˜ç›®ï¼Œå°ç›®æ ‡æ˜¯30åˆ†é’Ÿå†…æœ‰ä¸€èˆ¬çš„æ€è·¯å¹¶å†™å®Œã€‚é¢è¯•çš„æ—¶å€™ï¼Œå¯¹äºæœ‰ä¸€å®šéš¾åº¦çš„é¢˜ç›®ï¼Œå¹¶ä¸ä¸€å®šè¦ä¸€ä¸‹å­æƒ³å‡ºæœ€ä¼˜è§£ï¼Œæœ‰æ—¶å€™ç›´æ¥æƒ³å‡ºæœ€ä¼˜è§£åè€Œæ˜¯æœ‰å¼Šç«¯çš„ï¼ˆå³éœ€è¦è€—è´¹æ›´å¤šçš„æ—¶é—´å»æ€è€ƒè§£æ³•å’Œå†™ä»£ç ï¼Œé¢ä¸´æƒ³ä¸å‡ºæ¥çš„é£é™©ï¼Œä¸”å³ä½¿æƒ³å‡ºæ¥ä¹Ÿå®¹æ˜“ç»™äººç•™ä¸‹ä¹‹å‰åšè¿‡è¿™é“é¢˜çš„å°è±¡ï¼‰ã€‚å†™æœ‰ä¸€å®šéš¾åº¦çš„é¢è¯•é¢˜æ—¶ï¼Œå¯è¡Œçš„åšæ³•æ˜¯æœ‰æ€è·¯åä¸ç®¡æš´åŠ›è¿˜æ˜¯ä¼˜é›…ï¼Œç›´æ¥å‘Šè¯‰é¢è¯•å®˜ï¼Œä¿æŒä¸é¢è¯•å®˜çš„æ²Ÿé€šï¼Œç„¶åå†å°è¯•ä¸€æ­¥æ­¥ä¼˜åŒ–ï¼Œåšä¸€ä¸ªæ¸è¿›çš„å¤„ç†ã€‚ é˜…è¯»ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹ï¼Œçœ‹å®Œç¬¬äºŒç« çš„å‰©ä½™ç¯‡å¹…ï¼Œå¹¶å†™äº†ä¸€ç¯‡åšæ–‡ã€‚CSAPPç¡®å®æ˜¯æœ¬å¥½ä¹¦ï¼Œè¯»æ¥å¾ˆæœ‰æ”¶è·ï¼Œå¹¶ä¸”è¶Šè¯»è¶Šæœ‰è¶£ï¼Œæ„Ÿè§‰è‡ªå·±çš„â€œå†…åŠŸâ€è¶Šæ¥è¶Šæ·±åšäº†~ å¤ä¹ ã€Šå‰‘æŒ‡Offerã€‹ï¼Œçœ‹å®Œäº†å¤§æ¦‚80é¡µã€‚è¿™æ˜¯ç¬¬äºŒæ¬¡é˜…è¯»ã€Šå‰‘æŒ‡Offerã€‹ï¼Œå‘ç°äº†ä¹‹å‰æ²¡æœ‰æ³¨æ„åˆ°çš„ä¸€äº›ç»†èŠ‚ã€‚ å­¦ä¹ è‹±è¯­ï¼Œçœ‹å®Œäº†3ä¸ªè§†é¢‘ã€‚è‹±è¯­èƒ½åŠ›ï¼Œ æ˜¯ä¸€ä¸ªè½¯ä»¶å·¥ç¨‹å¸ˆéå¸¸é‡è¦çš„è½¯æŠ€èƒ½ï¼Œå’Œæ¯å¤©çš„å·¥ä½œæ¯æ¯ç›¸å…³ï¼Œä¸ç®¡æ˜¯é˜…è¯»æ–‡æ¡£ï¼Œè¿˜æ˜¯å†™ä»£ç ç­‰ã€‚å­¦ä¹ è‹±è¯­æ˜¯ä»¶éœ€è¦æŒä¹…åšæŒçš„äº‹æƒ…ï¼Œä½†æ˜¯ç°åœ¨é‡‡ç”¨çš„æ–¹å¼æ˜¯è¢«åŠ¨å­¦ä¹ ï¼Œå­¦ä¹ æ•ˆæœä¸æ˜¯æœ€ä¼˜çš„ï¼Œä¸”å®¹æ˜“å­¤å†›å¥‹æˆ˜å¯¼è‡´åŠé€”è€ŒåºŸï¼Œæ‰€ä»¥æœ€å¥½æ˜¯èƒ½æ‰¾ä¸ªè¯­ä¼´ä¸€èµ·ç»ƒä¹ ~ å‚åŠ ä¸¤åœºå…¬å¸çš„ç¬”è¯•é¢˜ã€‚æ„Ÿè§‰è´¨é‡éƒ½ä¸€èˆ¬ï¼Œæ²¡æœ‰ä»€ä¹ˆè¯šæ„~ é˜…è¯»ã€ŠHTTPæƒå¨æŒ‡å—ã€‹ï¼Œæ¨è¿›ä¸€ç« ã€‚é€šè¿‡è¿™å‘¨çš„å­¦ä¹ ï¼Œå¯¹äºwebæœåŠ¡å™¨çš„å·¥ä½œå†…å®¹æœ‰äº†æ›´æ·±å…¥çš„ç†è§£ã€‚ å¼€å§‹é˜…è¯»ã€ŠEffective C++ã€‹ã€‚è¿™å‘¨æ²¡è¿˜é˜…è¯»å¤šå°‘å†…å®¹ï¼Œä½†ä¹Ÿæ„Ÿè§‰åˆ°äº†æ­¤ä¹¦å¾ˆå¼ºï¼Œå€¼å¾—ä¸€å­¦ã€‚ã€ŠC++ Primerã€‹è¿™æœ¬ä¹¦ä¹‹å‰çœ‹äº†ä¸€å¤§åŠï¼Œä½†è¿˜æœ‰ä¸€äº›å…³é”®å†…å®¹è¿˜æ²¡çœ‹ï¼Œæ¯”å¦‚æ¨¡æ¿ç¼–ç¨‹ç­‰ã€‚æ‰€ä»¥ç°åœ¨çœ‹ã€ŠEffective C++ã€‹æ—¶éš¾å…ä¼šé‡åˆ°ä¸€äº›ä¸æ‡‚çš„è¯­æ³•ç‚¹ï¼Œè§£å†³æ–¹æ³•æ˜¯çœ‹åˆ°ä¸æ‡‚çš„å†å»ç¿»C++çš„ä¹¦ç±å­¦ä¹ ã€‚ä¸å»ºè®®Googleï¼Œå› ä¸ºä¼šå­¦å¾—ä¸å¤Ÿç³»ç»Ÿã€‚ å­¦ä¹ MySQLï¼Œå¤ä¹ ä¸“æ ã€‚ä¹‹å‰é€šè¿‡æå®¢æ—¶é—´ä¸Šçš„ä¸“æ ä¸€ç« ä¸€ç« åœ°é˜…è¯»ï¼Œå­¦äº†åé¢å°±å¿˜äº†å‰é¢ï¼Œè¿˜æ²¡æœ‰å¤ä¹ è¿‡ã€‚è¿™æ¬¡ï¼Œé€šè¿‡ç”»æ€ç»´å¯¼å›¾ï¼Œé¡ºä¾¿å¤ä¹ äº†ä¹‹å‰å­¦ä¹ çš„å†…å®¹ï¼Œæ„Ÿè§‰æ•ˆæœå¾ˆå¥½ã€‚ å­¦ä¹ è®¾è®¡æ¨¡å¼ï¼Œæ–°å­¦äº†è§‚å¯Ÿè€…æ¨¡å¼ã€‚]]></content>
      <tags>
        <tag>æˆé•¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 2]]></title>
    <url>%2F2019%2F09%2F15%2FCSAPP-learning-note-2%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨çœ‹äº†ç¬¬äºŒç« çš„å‰©ä½™ç¯‡å¹…ï¼Œå…³äºæ•´æ•°è¿ç®—ä»¥åŠæµ®ç‚¹æ•°ã€‚ç›®å‰è¿˜æœªå®Œå…¨æå®šï¼Œæœ‰å¾ˆå¤šä¹ é¢˜å¾…å†™ã€‚ æ•´æ•°è¿ç®—æ•´æ•°è¿ç®—çš„åˆ†ç±»ä¸»è¦æœ‰ä¸¤ä¸ªç»´åº¦ï¼Œä¸€ä¸ªæ˜¯æ— ç¬¦å·æ•°ã€æœ‰ç¬¦å·æ•°ï¼Œå¦ä¸€ä¸ªæ˜¯åŠ æ³•ã€ä¹˜æ³•ã€‚ ä¹‹å‰çŸ¥é“ç¼–è¯‘å™¨ä¼šå°†ä¹˜æ³•è½¬åŒ–æˆåŠ å‡æ³•/ç§»ä½ï¼Œä½†å§‹ç»ˆä¸çŸ¥æ‰€ä»¥ç„¶ã€‚è¿™æ¬¡é€šè¿‡é˜…è¯»CSAPPï¼Œæ·±å…¥ç†è§£äº†å®ƒçš„åŸç†ï¼Œå¦å¤–çŸ¥é“äº†è¿˜å¯ä»¥å°†é™¤æ³•è½¬åŒ–ä¸ºåŠ å‡æ³•/ç§»ä½ã€‚ è¿™ä¸€èŠ‚è®²å¾—éƒ½æ˜¯è§„å¾‹å’Œè¯æ˜ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚è´´ä¸€å¼ å›¾è¿›è¡Œæ€»ç»“ï¼Œä»¥æ–¹ä¾¿ä»¥åå›å¿†ã€‚ æµ®ç‚¹æ•°é˜…è¯»å®Œè¿™ä¸€èŠ‚åï¼Œå¯¹äºæµ®ç‚¹æ•°çš„è¡¨ç¤ºã€è¿ç®—ã€èˆå…¥ç­‰æœ‰äº†æ›´æ·±å…¥çš„ç†è§£ã€‚ å…¶ä¸­ï¼Œæœ‰çš„åœ°æ–¹ä¸€å¼€å§‹ä¸æ˜¯å¾ˆç†è§£ï¼Œå½“å¼„æ‡‚åï¼Œè§‰å¾—è¿™äº›è®¾è®¡å¾ˆä¼˜é›…ã€å¾ˆèªæ˜ã€‚ æ¯”å¦‚ï¼Œå¯¹äºIEEEéè§„èŒƒå€¼å¾—è®¾è®¡ä¸æ˜¯å¾ˆç†è§£ï¼Œä¸ºä»€ä¹ˆè¦å¢åŠ å¤æ‚æ€§å‘¢ã€‚åæ¥ï¼Œæ˜ç™½äº†éè§„æ ¼å€¼çš„è®¾è®¡ï¼Œä½¿å¾—0çš„è¡¨ç¤ºå¾ˆåŠ è‡ªç„¶ä¸”é è¿‘0çš„æµ®ç‚¹æ•°åˆ†å¸ƒå¾—æ›´å‡åŒ€ã€‚ æ¯”å¦‚ï¼Œä¸€å¼€å§‹ä¸å¤ªæ˜ç™½ä¸ºä»€ä¹ˆè¦æœ‰å¶æ•°èˆå…¥æ³•ï¼Œç›´æ¥å››èˆäº”å…¥ä¸è¡Œå—ã€‚åæ¥ï¼Œæ˜ç™½äº†å¶æ•°èˆå…¥æ³•æ˜¯å¯¹å››èˆäº”å…¥çš„ä¸€ç§æ”¹è¿›ï¼Œé¿å…äº†èˆå…¥æ‰€é€ æˆçš„ç»Ÿè®¡è¯¯å·®ã€‚ è¿˜æœ‰æµ®ç‚¹çš„è¿ç®—ï¼Œä¸éµå¾ªç»“åˆå¾‹ï¼Œè¿™æ˜¯ä¹‹å‰æ²¡æœ‰æ³¨æ„åˆ°ä½†ä¹Ÿæ˜¯ååˆ†é‡è¦çš„çŸ¥è¯†ç‚¹ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½¯ä»¶å·¥ç¨‹å¸ˆçš„è‡ªæˆ‘ä¿®å…» week2]]></title>
    <url>%2F2019%2F09%2F08%2Fsoftwafe-engineer-week2%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨çš„ä¸»è¦æ”¶è·ï¼š åˆ·Leetcodeï¼Œåšäº†7é“é¢˜ã€‚æ•°é‡æ˜¯ä¸Šä¸€å‘¨çš„ä¸¤å€ï¼Œåšé¢˜ä¹Ÿè¶Šæ¥è¶Šæœ‰æ„Ÿè§‰äº†ã€‚ä»¥åå¯ä»¥æ¯å‘¨åˆ·ä¸¤ä¸ªcontestï¼Œä¿æŒæ¯å‘¨8é“é¢˜è¿™æ ·çš„èŠ‚å¥ã€‚ å­¦ä¹ kafkaï¼Œå­¦å®Œä¸“æ çš„â€œå®¢æˆ·ç«¯å®è·µåŠåŸç†å‰–æâ€ã€‚åœ¨ç»§ç»­å­¦ä¹ æ¥ä¸‹æ¥çš„ç« èŠ‚å‰ï¼Œå…ˆå¤ä¹ ä¸€ä¸‹å­¦è¿‡çš„å†…å®¹ï¼Œåšå¥½æ€»ç»“ã€‚æ…¢ç‚¹ï¼Œå†æ…¢ç‚¹ã€‚ é˜…è¯»ã€Šé«˜æ€§èƒ½MySQLã€‹ï¼Œå­¦ä¹ äº†ç´¢å¼•çš„ç« èŠ‚ã€‚å¯¹ç´¢å¼•çš„ç§ç±»ã€å®ç°ã€æ€§è´¨ã€ç”¨æ³•ç­‰æœ‰äº†æ›´è¿›ä¸€æ­¥çš„è®¤è¯†ã€‚ é˜…è¯»ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹ï¼Œå­¦ä¹ äº†ç¬¬äºŒç« çš„å‰åŠéƒ¨åˆ†ã€‚ä¿¡æ¯å­˜å‚¨ã€æ•´æ•°çš„è¡¨ç¤ºä¸è½¬åŒ–è¿™éƒ¨åˆ†å…¶å®ä¹‹å‰å¤šå¤šå°‘å°‘æ¥è§¦è¿‡ï¼Œç°åœ¨é˜…è¯»CSAPPï¼Œåˆå¼ºåŒ–äº†ä¸€éã€‚çŸ¥è¯†å°±æ˜¯éœ€è¦ä¸æ–­åœ°å¼ºåŒ–ï¼Œæœ€é«˜å¢ƒç•Œå¤§æ¦‚æ˜¯è½å¶é£èŠ±çš†å¯ä¼¤äººâ€”â€”å¯¹äºä»»æ„çš„çŸ¥è¯†ç‚¹éƒ½å¯ä»¥è”æƒ³åˆ°ä¸€æ•´ç‰‡çš„çŸ¥è¯†æ£®æ—ï¼Œå¯ä»¥ç»™åˆ«äººè®²ä¸Šä¸€æ•´å¤©~ è½¬æ­£ç­”è¾©ã€‚è¿™ä¸€å‘¨èŠ±äº†ä¸å°‘æ—¶é—´åœ¨å‡†å¤‡è½¬æ­£ç­”è¾©ä¸Šï¼Œæœ€ç»ˆçš„ç­”è¾©è¡¨ç°è‡ªå·±ä¹Ÿè§‰å¾—è¿˜è¡Œã€‚è¿™æ¬¡ç­”è¾©ï¼Œè®©æˆ‘æ„è¯†åˆ°äº†è‡ªå·±è®¾è®¡èƒ½åŠ›çš„ç¼ºå¤±ï¼Œå³åªå±€é™äºå·²æœ‰çš„è§£å†³æ–¹æ¡ˆï¼Œè€Œå¯¹äºæ›´å¥½çš„è§£å†³æ–¹æ¡ˆç¼ºå°‘æ€è·¯ã€‚ä¸€ä¸ªé«˜çº§çš„è½¯ä»¶å·¥ç¨‹å¸ˆï¼Œå¯¹äºæ¥å£ã€æ¨¡å—ã€æ¶æ„ã€æ–¹æ¡ˆç­‰æ•´ä½“æ€§çš„è®¾è®¡ä¹Ÿéœ€è¦æ˜¯ä¼˜ç§€çš„ã€‚å‡å¦‚å°†è½¯ä»¶å·¥ç¨‹å¸ˆæ¯”å–»æˆå»ºç­‘å¸ˆï¼Œé‚£ä¹ˆå­¦ä¹ ä¸€ç§å…·ä½“çš„æŠ€æœ¯ï¼Œæ¯”å¦‚MySQL, kafkaç­‰ï¼Œç›¸å½“äºæ˜¯äº†è§£ä¸€ç§å»ºç­‘å·¥å…·ã€å»ºç­‘ææ–™ï¼Œè€Œè®¾è®¡èƒ½åŠ›ï¼Œåˆ™ç›¸å½“äºæ˜¯å­¦ä¹ å¦‚ä½•ç”»å‡ºæ•´æ ‹å¤§å¦çš„è®¾è®¡å›¾ã€‚ä¸¤è€…ç¼ºä¸€ä¸å¯ï¼Œä¸å¯åé¢‡å…¶ä¸€ã€‚]]></content>
      <tags>
        <tag>æˆé•¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 1]]></title>
    <url>%2F2019%2F09%2F08%2FCSAPP-learning-note-1%2F</url>
    <content type="text"><![CDATA[å‰è¨€ä¸Šä¸€å‘¨çœ‹å®Œäº†ç¬¬ä¸€ç« ï¼Œè¿™ä¸€å‘¨ç»§ç»­çœ‹ç¬¬äºŒç« ã€‚æœ¬ç« çš„å†…å®¹å’Œä¿¡æ¯çš„è¡¨ç¤ºå’Œå¤„ç†æœ‰å…³ï¼Œè¿™éƒ¨åˆ†å†…å®¹ä¹‹å‰ä¿®è®¡ç®—æœºç»„æˆåŸç†æ—¶æœ‰å­¦ä¹ åˆ°ï¼Œæ‰€ä»¥é˜…è¯»èµ·æ¥æ¯”è¾ƒé¡ºåˆ©ï¼Œé¢„è®¡ä¸‹å‘¨èƒ½é¡ºåˆ©è¯»å®Œæ­¤ç« ã€‚ æ­£æ–‡è¿™ä¸€ç« çš„å†…å®¹åˆ†ä¸ºå››å°èŠ‚ï¼Œåˆ†åˆ«æ˜¯ï¼š ä¿¡æ¯å­˜å‚¨ æ•´æ•°è¡¨ç¤º æ•´æ•°è¿ç®— æµ®ç‚¹æ•° ä¿¡æ¯å­˜å‚¨ä¸Šç¯‡ç¬”è®°è°ˆåˆ°äº†ä¿¡æ¯ï¼Œä»€ä¹ˆæ˜¯ä¿¡æ¯ï¼Ÿä¿¡æ¯æ˜¯æ•°æ®+ä¸Šä¸‹æ–‡ã€‚ åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæ•°æ®ä¼šæœ‰ä¸åŒçš„å«ä¹‰ã€‚ä¸€ä¸ªå­—èŠ‚ï¼Œæ—¢å¯è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ï¼Œä¹Ÿå¯è¡¨ç¤ºèŒƒå›´åœ¨[0, 256)çš„æ— ç¬¦å·æ•´æ•°ï¼Œä¹Ÿå¯è¡¨ç¤ºèŒƒå›´åœ¨[-128, 128)çš„æœ‰ç¬¦å·æ•´æ•°ï¼Œè¿˜å¯ä»¥è¡¨ç¤ºå…·æœ‰8ä¸ªå…ƒç´ çš„é›†åˆï¼Œç­‰ç­‰ã€‚ å¤§å¤šæ•°æœºå™¨ä½¿ç”¨8ä½çš„å—ï¼Œç§°ä¸ºå­—èŠ‚ï¼Œä½œä¸ºæœ€å°çš„å¯å¯»å€çš„å†…å­˜å•ä½ï¼Œè€Œä¸æ˜¯ç›´æ¥è®¿é—®å†…å­˜ä¸­å•ç‹¬çš„ä½ã€‚å­—é•¿ä¸º32ä½çš„æœºå™¨ï¼Œå¯»å€çš„æœ€å¤§ç©ºé—´æ˜¯$2^{32}$å­—èŠ‚ï¼Œè€Œå­—é•¿ä¸º64ä½çš„æœºå™¨ï¼Œå¯»å€çš„æœ€å¤§ç©ºé—´å°±æ˜¯$2^{64}$å­—èŠ‚ã€‚ä»€ä¹ˆæ˜¯å­—é•¿å‘¢ï¼Œå­—é•¿ç”¨äºæŒ‡æ˜æŒ‡é’ˆæ•°æ®çš„æ ‡ç§°å¤§å°ã€‚ å› ä¸ºä¸€ä¸ªå­—èŠ‚æœ‰8ä¸ªä½ï¼Œç”¨äºŒè¿›åˆ¶è¡¨ç¤ºèµ·æ¥æœ‰ç‚¹å†—é•¿ï¼Œè€Œç”¨åè¿›åˆ¶è¡¨ç¤ºæ³•çš„è¯ï¼Œä¸ä½æ¨¡å¼çš„äº’ç›¸è½¬åŒ–ä¼šå¾ˆéº»çƒ¦ã€‚äºæ˜¯å°±æœ‰äº†åå…­è¿›åˆ¶æ•°æ¥è¡¨ç¤ºä½æ¨¡å¼ï¼Œåœ¨äºŒè¿›åˆ¶å’Œåè¿›åˆ¶å–äº†æŠ˜ä¸­ï¼Œæ—¢æ–¹ä¾¿è¡¨ç¤ºï¼Œåˆä¸é‚£ä¹ˆéš¾è¯»ã€‚ å‡å¦‚æˆ‘ä»¬æƒ³è¦è®¿é—®è·¨è¶Šå¤šå­—èŠ‚çš„å¯¹è±¡ï¼Œéœ€è¦å»ºç«‹ä¸¤ä¸ªè§„åˆ™ï¼šè¿™ä¸ªå¯¹è±¡çš„åœ°å€æ˜¯ä»€ä¹ˆï¼Œä»¥åŠåœ¨å†…å­˜ä¸­å¦‚ä½•æ’åˆ—è¿™äº›å­—èŠ‚ã€‚å¯¹è±¡åœ°å€çš„å¯»å€èŒƒå›´æ ¹æ®å­—é•¿è€Œå®šï¼Œå½“å­—é•¿ä¸º$w$æ—¶ï¼Œå¯å¯»å€ç©ºé—´ä¸º$2^{w}$ã€‚ç¡®å®šå¥½å¯¹è±¡çš„èµ·å§‹åœ°å€ï¼Œè¿˜éœ€è¦çŸ¥é“å®ƒæœ‰å¤šå°‘ä¸ªå­—èŠ‚ä»¥åŠå¦‚ä½•æ’åˆ—è¿™äº›å­—èŠ‚ã€‚å‡è®¾è¯»å–å¯¹è±¡ä¸ºintï¼Œæœ‰å››ä¸ªå­—èŠ‚ï¼Œä¸”åœ¨å†…å­˜ä¸­ä»ä½å€åˆ°é«˜å€çš„å†…å®¹ä¸º0x00000001ï¼Œé‡‡ç”¨å¤§ç«¯æ³•è¯»å–å°±æ˜¯$1$ï¼Œé‡‡ç”¨å°ç«¯æ³•è¯»å–å°±æ˜¯$2^{24}$ã€‚å¤§ç«¯è¡¨ç¤ºæ³•æ¯”è¾ƒç¬¦åˆäººç±»çš„ä¹ æƒ¯ï¼Œè€Œå°ç«¯æ³•éœ€è¦å°†æ•°æ®æŒ‰å­—èŠ‚å€’åºæ’åˆ—ã€‚è¿™äº›æ•°æ®åœ¨æœºå™¨ä¸­çš„å­—èŠ‚æ’åˆ—é€šå¸¸å¯¹æˆ‘ä»¬æ²¡æœ‰å½±å“ï¼Œä½†å½“æ¶‰åŠåˆ°ç½‘ç»œç¼–ç¨‹æ—¶ï¼Œå°±éœ€è¦å…³æ³¨ç½‘ç»œä¼ è¾“æ•°æ®å’Œæœºå™¨å­˜å‚¨æ•°æ®çš„åŒºåˆ«äº†ã€‚ æ•´æ•°è¡¨ç¤ºæ•´æ•°åœ¨è®¡ç®—æœºä¸­æœ‰å¤šç§è¡¨ç¤ºå½¢å¼ï¼Œæ¯”å¦‚åŸç ã€è¡¥ç ã€åç ç­‰ã€‚ è€Œç¼–ç¨‹è¯­è¨€ä¸­é‡åˆ°çš„æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚short, int, long longç­‰ï¼Œæ˜¯å¯¹æ•´æ•°å¤§å°çš„é™åˆ¶ã€‚ è€Œå¸¸è¯´çš„æœ‰ç¬¦å·æ•°ã€æ— ç¬¦å·æ•°ï¼Œåˆ™æ˜¯åœ¨äººç±»é™åˆ¶æ•´æ•°èƒ½å¦è¡¨ç¤ºè´Ÿæ•°è€Œäº§ç”Ÿã€‚æˆ‘è®¤ä¸ºæœ‰ç¬¦å·æ•°å’Œæ— ç¬¦å·æ•°çš„è®¾è®¡å…¶å®æ„ä¹‰ä¸å¤§ï¼Œåªç”¨ä¸€ç§æœ‰ç¬¦å·æ•°æ¥è¡¨ç¤ºæ•´æ•°å°±è¶³å¤Ÿäº†ã€‚æœ‰äº†æ— ç¬¦å·æ•°å’Œæœ‰ç¬¦å·æ•°ï¼Œå°±éœ€è¦ç”¨æˆ·å»å…³æ³¨æ— ç¬¦å·æ•°å’Œæœ‰ç¬¦å·æ•°çš„è½¬åŒ–ï¼Œä¸€äº›éšå¼è½¬åŒ–å¾ˆå®¹æ˜“å¼•èµ·å‡ºäººæ„æ–™çš„éšè”½é”™è¯¯ã€‚åœ¨Javaä¸­ï¼Œå¹¶æ²¡æœ‰æ— ç¬¦å·æ•°çš„æ¦‚å¿µï¼Œè€Œåœ¨Cè¯­è¨€ä¸­ï¼Œæœ‰ç¬¦å·æ•°å’Œæ— ç¬¦å·æ•°çš„è½¬åŒ–ï¼Œå…¶å®æ•´æ•°åœ¨åº•å±‚çš„ä½è¡¨ç¤ºä¸­æ˜¯ä¸å˜çš„ï¼Œåªæ˜¯Cè¯­è¨€åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­å¯¹å®ƒè¿›è¡Œäº†ä¸åŒçš„è§£é‡Šã€‚ æ— ç¬¦å·æ•°ï¼Œé‡‡ç”¨ç®€å•çš„åŸç ç¼–ç å³å¯ã€‚è€Œæœ‰ç¬¦å·æ•°ï¼Œä¸€èˆ¬é‡‡ç”¨è¡¥ç ç¼–ç ï¼Œå› ä¸ºç›¸å¯¹äºæºç ã€åç ï¼Œå®ƒèƒ½è¡¨ç¤ºæ›´å¤šä¸€ä¸ªæ•°ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œæœºå™¨ä¸­çš„ä½è¡¨ç¤ºä¸æ•´æ•°æ˜¯ä¸€ä¸ªåŒå°„å…³ç³»ï¼Œå¾ˆä¼˜é›…ã€‚ æ— ç¬¦å·æ•°å’Œæœ‰ç¬¦å·æ•°çš„è½¬åŒ–ï¼Œåœ¨ç†è§£äº†æœºå™¨çš„ä½è¡¨ç¤ºå§‹ç»ˆä¸å˜ä»¥åŠè¡¥ç çš„ç›¸å…³çŸ¥è¯†åï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡ºè§„å¾‹ã€‚æˆ‘ä»¬è¿™é‡Œå‡è®¾ä¸¤è€…çš„ä½æ•°éƒ½ä¸º$w$ã€‚å°†æ— ç¬¦å·æ•°è½¬åŒ–ä¸ºæœ‰ç¬¦å·æ•°ï¼Œå½“è¶…è¿‡å…¶è¡¨ç¤ºèŒƒå›´æ—¶ï¼Œéœ€è¦å‡å»$2^w$ã€‚å°†æœ‰ç¬¦å·æ•°è½¬åŒ–ä¸ºæ— ç¬¦å·æ•°æ—¶ï¼Œè´Ÿæ•°éœ€è¦åŠ ä¸Š$2^w$ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½¯ä»¶å·¥ç¨‹å¸ˆçš„è‡ªæˆ‘ä¿®å…» week1]]></title>
    <url>%2F2019%2F09%2F02%2Fsoftwafe-engineer-week1%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨çš„ä¸»è¦æ”¶è·ï¼š å­¦ä¹ ã€Šé«˜æ€§èƒ½MySQLã€‹ï¼Œæ¨è¿›äº†å¤§æ¦‚25é¡µã€‚å­¦åˆ°äº†MySQLçš„å¤šç§æ•°æ®ç±»å‹ï¼ŒåŒ…æ‹¬æ•´æ•°ç±»å‹ã€å®æ•°ç±»å‹ã€å­—ç¬¦ä¸²ç±»å‹ã€æ—¥æœŸå’Œæ—¶é—´ç±»å‹ã€ä½æ•°æ®ç±»å‹ç­‰ç­‰ã€‚æ•°æ®ç±»å‹æ˜¯æ•°æ®åº“ç®¡ç†ç³»ç»Ÿç”¨äºå­˜å‚¨æ•°æ®çš„æŠ½è±¡ï¼Œç†è§£å¥½äº†è¿™äº›æŠ½è±¡ï¼Œä»¥åå°±èƒ½ç”¨å¾—æ›´é¡ºæ‰‹äº†ã€‚ å­¦ä¹ gitï¼ŒæŠ•å…¥äº†50åˆ†é’Ÿå·¦å³ã€‚ä¸»è¦å­¦ä¹ äº†å¹³æ—¶ç”¨å¾—æ¯”è¾ƒå°‘çš„ä¸¤ä¸ªå‘½ä»¤git config å’Œgit logã€‚ é˜…è¯»ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹ï¼Œ æ¨è¿›äº†å¤§æ¦‚40é¡µå·¦å³ï¼Œå¹¶å†™äº†ä¸€ç¯‡å­¦ä¹ ç¬”è®°ã€‚ä¸Šå‘¨å‘ç°é˜…è¯»å¤§éƒ¨å¤´çš„å­¦ä¹ æ•ˆæœä¸é”™ï¼Œæ‰€ä»¥è¿™å‘¨åˆæ‰¾äº†æœ¬å¤§éƒ¨å¤´æ¥çœ‹ã€‚å¯¹äºè¿™æœ¬ä¹¦è“ç™½ç›¸é—´çš„å°åˆ·å¾ˆå–œæ¬¢ï¼Œç›®å‰è¯»èµ·æ¥è¿˜æ²¡é‡åˆ°å¤§çš„é˜»åŠ›ï¼Œè€Œä¸”æ”¶è·è‰¯å¤šï¼Œæ‰“ç®—ç»§ç»­é˜…è¯»ä¸‹å»ã€‚ åˆ·Leetcodeï¼Œåšäº†ä¸‰é“é¢˜ã€‚å¥½ä¹…æ²¡åšé¢˜äº†ï¼Œæœ‰ç‚¹ç”Ÿç–ã€‚ æŠ˜è…¾åšå®¢ï¼Œæ¢ç´¢å¢åŠ è¯„è®ºæ¨¡å—ã€‚ä¸Šå‘¨æåˆ°è¦ç»™åšå®¢è¡¥ä¸Šè¯„è®ºåŠŸèƒ½ï¼Œäºæ˜¯è¿™å‘¨å°±æŠ˜è…¾äº†ä¸€ä¸‹ã€‚æˆ‘çš„åšå®¢ä¸»é¢˜ç”¨çš„æ˜¯Nextï¼Œå®ƒçš„é…ç½®æ–‡ä»¶é‡Œé¢æ˜¾å¼æ”¯æŒçš„è¯„è®ºæ’ä»¶æœ‰valine, disqusç­‰ã€‚è¯•äº†ä¸€ä¸‹valineï¼Œè¯„è®ºæ•°æ®æ‰˜ç®¡åœ¨ç¬¬ä¸‰æ–¹å…¬å¸ï¼Œä¸å¤ªæ–¹ä¾¿ï¼Œå¦å¤–è¯„è®ºé€šçŸ¥åŠŸèƒ½åšå¾—ä¸å®Œå–„ï¼Œåˆ«äººè¯„è®ºäº†æˆ‘ä¸èƒ½å¾ˆæ–¹ä¾¿åœ°çŸ¥é“ï¼Œè¿™å°±å¾ˆå¼±ã€‚è€Œä¸”è¯„è®ºè€…å¯ä»¥é€‰æ‹©åŒ¿åæˆ–è€…é€‰æ‹©ç•™ä¸‹é‚®ç®±è¯„è®ºï¼Œå‡å¦‚ç•™ä¸‹äº†é‚®ç®±ï¼Œå°±ä¼šå°è¯•é€šè¿‡ç¬¬ä¸‰æ–¹è·å–å¤´åƒä¿¡æ¯ï¼Œè¿™å°±å¸¦æ¥äº†å®‰å…¨æ€§çš„é—®é¢˜ï¼Œä¸€ä¸ªäººå®Œå…¨å¯ä»¥é€šè¿‡ä»–äººçš„é‚®ç®±æ¥å†’å……ä»–äººã€‚åŸºäºä»¥ä¸Šçš„é—®é¢˜ï¼Œæ”¾å¼ƒäº†ä½¿ç”¨valineçš„å¿µå¤´ï¼Œæ‰“ç®—ä¸‹å‘¨æŠ˜è…¾ä¸€ä¸‹disqusã€‚ é˜…è¯»æŠ€æœ¯æ–‡ç«  CSä¸“ä¸šå­¦ç”Ÿéœ€çŸ¥ï¼ˆè‹±ï¼‰ å­¦ä¹ è‹±è¯­ï¼ŒæŠ•å…¥äº†50åˆ†é’Ÿå·¦å³ã€‚ä»åœ¨ç»ƒä¹ å£è¯­ï¼Œæ…¢æ…¢æ¥å§ã€‚]]></content>
      <tags>
        <tag>æˆé•¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP å­¦ä¹ ç¬”è®° 0]]></title>
    <url>%2F2019%2F08%2F30%2FCSAPP-learning-note-0%2F</url>
    <content type="text"><![CDATA[å‰è¨€CSAPPï¼ˆæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿï¼‰è¿™æœ¬ä¹¦è±†ç“£è¯„åˆ†æ¥è¿‘æ»¡åˆ†ï¼Œæ˜¯å­¦ä¹ è®¡ç®—æœºç³»ç»Ÿçš„ç»å…¸æ•™æä¹‹ä¸€ã€‚è¿™ä¸€å‘¨å¼€å§‹é˜…è¯»æ­¤ä¹¦ï¼Œå¹¶è®¡åˆ’ä»¥åæ¯å‘¨å†™ä¸€ç¯‡å­¦ä¹ ç¬”è®°ã€‚ æ­£æ–‡ä¿¡æ¯æ•°æ®å’Œä¿¡æ¯æ˜¯ä¸¤ä¸ªå«ä¹‰ä¸åŒçš„è¯ã€‚æ•°æ®æ˜¯â€œæ­»â€çš„ï¼Œè€Œä¿¡æ¯æ˜¯â€œæ´»â€çš„ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œé˜¿æ‹‰ä¼¯æ•°å­—8ï¼Œåœ¨ä¸åŒçš„æƒ…æ™¯ä¸‹ï¼Œå¯ä¼ é€’ä¸åŒçš„ä¿¡æ¯ã€‚å½“ç”µæ¢¯ä¸­å¯è¡¨ç¤ºç¬¬8å±‚ï¼Œåœ¨æ¡Œçƒæ¡Œä¸Šå¯è¡¨ç¤ºé»‘çƒ8ï¼Œè€Œåœ¨èŠå¤©ä¸­å¯è¡¨ç¤ºâ€æ‹œæ‹œâ€çš„æ„æ€ã€‚æ˜¯ä»€ä¹ˆèµ‹äºˆäº†å®ƒå†…æ¶µï¼Ÿæ˜¯æƒ…æ™¯ï¼Œä¹Ÿç§°ä½œä¸Šä¸‹æ–‡ã€‚åœ¨è®¡ç®—æœºç³»ç»Ÿä¸­ï¼Œæ•°æ®å°±æ˜¯æ¯”ç‰¹ä¸²ï¼Œæ˜¯ä¸€ä¸ªä¸€ä¸ªçš„ä½ï¼Œå†åŠ ä¸Šå…·ä½“çš„ä¸Šä¸‹æ–‡ï¼Œå°±æˆä¸ºäº†ä¿¡æ¯ã€‚åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­ï¼Œä¸€ä¸ªåŒæ ·çš„å­—èŠ‚åºåˆ—å¯èƒ½è¡¨ç¤ºä¸€ä¸ªæ•´æ•°ã€æµ®ç‚¹æ•°ã€å­—ç¬¦ä¸²æˆ–è€…æœºå™¨æŒ‡ä»¤ã€‚ ç¼–è¯‘ä¸€ä¸ªCè¯­è¨€ç¨‹åºï¼Œéœ€è¦ç»è¿‡é¢„å¤„ç†å™¨ã€ç¼–è¯‘å™¨ã€æ±‡ç¼–å™¨ã€é“¾æ¥å™¨çš„ç¿»è¯‘ï¼Œæ‰èƒ½è½¬åŒ–æˆå¯æ‰§è¡Œç›®æ ‡ç¨‹åºã€‚ ç¼–è¯‘æ˜¯ä¸ªè½¬åŒ–æ•°æ®çš„è¿‡ç¨‹ã€‚è½¬åŒ–å‰æ˜¯æºä»£ç ï¼Œæ˜¯äººç±»å¯ä»¥ç†è§£çš„ä¿¡æ¯ã€‚è€Œè½¬åŒ–åï¼Œå˜æˆäº†æœºå™¨è¯­è¨€ï¼Œå˜æˆäº†äººç±»æ— æ³•ç†è§£çš„ä¿¡æ¯ï¼Œè€Œæœºå™¨åœ¨ä¸€å®šçš„ä¸Šä¸‹æ–‡ä¸­ï¼Œèƒ½å¤Ÿç†è§£è¿™äº›æ•°æ®ã€‚æœºå™¨è¯­è¨€æ˜¯æœºå™¨èƒ½å¤Ÿç†è§£çš„ä¿¡æ¯ã€‚ å­¦ä¹ ç¼–è¯‘ç³»ç»Ÿï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬ä¼˜åŒ–ç¨‹åºæ€§èƒ½ã€ç†è§£é“¾æ¥æ—¶å‡ºç°çš„é”™è¯¯ã€é¿å…å®‰å…¨æ¼æ´ç­‰ã€‚ æŒ‡ä»¤ç¼–è¯‘åäº§ç”Ÿçš„å¯æ‰§è¡Œæ–‡ä»¶åœ¨ç£ç›˜é‡Œã€‚å½“æˆ‘ä»¬æ‰§è¡Œè¯¥æ–‡ä»¶æ—¶ï¼Œè®¡ç®—æœºç³»ç»Ÿæ˜¯æ€ä¹ˆè¿ä½œçš„å‘¢ï¼Ÿ å‡è®¾æˆ‘ä»¬æ˜¯åœ¨shellæ‰§è¡Œè¯¥ç¨‹åºçš„ã€‚é”®ç›˜æ˜¯ä¸€ä¸ªå¤–éƒ¨è®¾å¤‡ï¼Œé€šè¿‡ç³»ç»ŸI/Oæ€»çº¿å’Œå…¶ä»–ç¡¬ä»¶è¿æ¥åœ¨ä¸€èµ·ã€‚å½“æˆ‘ä»¬é€šè¿‡é”®ç›˜è¾“å…¥å¯æ‰§è¡Œæ–‡ä»¶çš„æ–‡ä»¶åæ—¶ï¼Œå­—ç¬¦ä¸²ä¼šé€šè¿‡æ€»çº¿è¢«é€ä¸€è¯»å…¥CPUä¸­çš„å¯„å­˜å™¨å¹¶é€å…¥å†…å­˜ï¼Œä¸”ä¼šè¾“å‡ºåˆ°å›¾å½¢é€‚é…å™¨ï¼ˆæ‰€ä»¥æˆ‘ä»¬æ‰å¯ä»¥åœ¨å±å¹•ä¸Šçœ‹åˆ°è¾“å…¥çš„å­—ç¬¦ï¼‰ã€‚å½“è¾“å…¥å›è½¦åï¼Œshellå°±ä¼šé€šè¿‡ä¸€ç³»åˆ—çš„æŒ‡ä»¤æ¥æ‰§è¡Œè¯¥ç¨‹åºï¼Œå°†ç¨‹åºçš„æ–‡ä»¶å†…å®¹è£…è½½è¿›å†…å­˜ï¼Œå¼€å§‹å­è¿›ç¨‹ï¼Œå°†CPUè®©ç»™å®ƒæ‰§è¡Œã€‚è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œä¸åŒçš„æŒ‡ä»¤ï¼Œä¼šè®©æ•°æ®åœ¨CPUã€å†…å­˜ã€I/Oè®¾å¤‡é—´æµåŠ¨ï¼Œæ¯”å¦‚è¾“å‡ºæ–‡å­—åˆ°å±å¹•ã€é€šè¿‡ç½‘ç»œä¸‹è½½æ–‡ä»¶ç­‰ã€‚ é«˜é€Ÿç¼“å­˜æ‰€è°“é«˜é€Ÿç¼“å­˜ï¼Œæ˜¯ä¸ºäº†è§£å†³CPUä»å¯„å­˜å™¨è¯»å–æ•°æ®ä¸ä»å†…å­˜è¯»å–æ•°æ®çš„é€Ÿåº¦å·®å¼‚é—®é¢˜ã€‚CPUä»å¯„å­˜å™¨è¯»å–æ•°æ®æ¯”ä»å†…å­˜è¯»å–æ•°æ®è¦é«˜å‡ ä¸ªæ•°é‡çº§ã€‚æ‰€ä»¥ä¸€ä¸ªè‡ªç„¶çš„æƒ³æ³•æ˜¯æé«˜å¯„å­˜å™¨çš„å®¹é‡ï¼Œè¿™æ˜¯ä¸€ä¸ªè§£å†³æ€è·¯ï¼Œä½†æ˜¯å› ä¸ºå¯„å­˜å™¨çš„ä»·æ ¼è¦æ¯”å†…å­˜è´µå¾—å¤šï¼Œå¤§å¹…æé«˜å®¹é‡ä»ç»æµçš„è§’åº¦è€ƒè™‘ä¸å¤ªç°å®ã€‚å¦ä¸€ä¸ªè§£å†³æ€è·¯æ˜¯æé«˜ä¸»å­˜çš„è¯»å–é€Ÿåº¦ï¼Œè¿™å¾ˆæ¥è¿‘ç°åœ¨å¤§éƒ¨åˆ†è®¡ç®—æœºç³»ç»Ÿé‡‡ç”¨çš„æ–¹æ³•äº†ã€‚æ ¹æ®è®¡ç®—æœºç»„æˆåŸç†çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬çŸ¥é“SRAMçš„è¯»å–æ€§èƒ½æ¯”DRAMçš„å¿«å¾—å¤šï¼Œä¸”SRAMä¹Ÿåˆ†å¤šç§ï¼Œä¸åŒçš„SRAMå®ç°ä¼šæœ‰ä¸åŒçš„æ€§èƒ½è¡¨ç°ï¼Œä»·æ ¼ä¹Ÿæœ‰å·®å¼‚ã€‚å› ä¸ºSRAMçš„ä»·æ ¼è¿˜æ˜¯è¦æ¯”DRAMé«˜ï¼Œå¤§é‡é‡‡ç”¨SRAMä½œä¸ºä¸»å­˜ä¹Ÿä¸ç°å®ã€‚å› æ­¤å½¢æˆäº†ä¸€ç§æŠ˜ä¸­çš„æ–¹æ¡ˆï¼Œé‡‡ç”¨DRAMä½œä¸ºä¸»å­˜ï¼ŒSRAMä½œä¸ºCPUçš„é«˜é€Ÿç¼“å­˜ã€‚å½“CPUæ‰§è¡ŒæŒ‡ä»¤æ—¶ï¼Œé¦–å…ˆä¼šä»å¯„å­˜å™¨å–æ•°æ®ï¼Œå‡å¦‚å–ä¸åˆ°ï¼Œå†åˆ°é«˜é€Ÿç¼“å­˜å–ï¼Œå‡å¦‚è¿˜å–ä¸åˆ°ï¼Œæ‰åˆ°ä¸»å­˜å–ã€‚é€šè¿‡å¼•è¿›é«˜é€Ÿç¼“å­˜ï¼Œç¼“è§£äº†CPUæ‰§è¡Œé€Ÿåº¦ä¸ä»å†…å­˜è¯»å–æ•°æ®é€Ÿåº¦ä¸åŒ¹é…çš„é—®é¢˜ã€‚ åˆ©ç”¨å±€éƒ¨æ€§åŸç†ï¼Œå¯æé«˜é«˜é€Ÿç¼“å­˜çš„å‘½ä¸­ç‡ï¼Œè®©CPUå°½å¯èƒ½å¿«åœ°å–åˆ°æŒ‡ä»¤å»æ‰§è¡Œï¼Œæé«˜æ•´ä½“æ•ˆç‡ã€‚è‡³äºé«˜é€Ÿç¼“å­˜ä¸­çš„æ•°æ®ä¸å†…å­˜ä¸­çš„æ•°æ®çš„æ˜ å°„ï¼Œåˆ™æ¶‰åŠåˆ°äº†è®¡ç®—æœºç»„æˆåŸç†ï¼Œè¿™é‡Œä¸å†æ·±å…¥è®²è¿°ã€‚ æŠ½è±¡æ‰€è°“æŠ½è±¡ï¼Œåœ¨ç”Ÿæ´»ä¸­å…¶å®éšå¤„å¯è§ã€‚è®°å¾—ã€Šäººç±»ç®€å²ã€‹ä¸­å†™åˆ°ï¼Œäººç±»åŒºåˆ«äºå…¶ä»–ç”Ÿç‰©çš„é‡è¦åŸå› ä¾¿æ˜¯æƒ³è±¡åŠ›ä¸°å¯Œã€‚äººç±»ä¹‹é—´é€šè¿‡è®²è¿°å„ç§æ•…äº‹ï¼Œå¡‘é€ å„ç§æŠ½è±¡æ¦‚å¿µï¼Œè¯¸å¦‚å®—æ—ã€åŸå¸‚ã€å›½å®¶ç­‰æ¦‚å¿µï¼Œè®©åŸæœ¬äº’ä¸è®¤è¯†çš„äººæœ‰äº†è”ç³»çš„çº½å¸¦ï¼Œå…±åŒåˆä½œï¼Œè¯ç”Ÿäº†å„ç§æ–‡æ˜ã€‚è®¡ç®—æœºç³»ç»Ÿä¸­ä¹Ÿæœ‰å„ç§æŠ½è±¡æ¦‚å¿µï¼Œè¯¸å¦‚æ–‡ä»¶ã€è™šæ‹Ÿå†…å­˜ã€è¿›ç¨‹ã€‚è¿™äº›æŠ½è±¡ï¼Œåœ¨æˆ‘çœ‹æ¥ï¼Œæ˜¯äººç±»è®¾è®¡å†¯è¯ºä¾æ›¼è®¡ç®—æœºçš„åŸºç¡€ï¼Œæ²¡æœ‰è¿™äº›æ¦‚å¿µï¼Œè®¡ç®—æœºç³»ç»Ÿä¾¿ä¸çŸ¥é“ä»ä½•è¯´èµ·ã€‚ æ–‡ä»¶æ—¶ä»€ä¹ˆï¼Ÿæ–‡ä»¶æ˜¯ä¸€äº›äºŒè¿›åˆ¶ä½åœ¨I/Oè®¾å¤‡ä¸­çš„æŠ½è±¡ã€‚ è™šæ‹Ÿå†…å­˜æ˜¯ä»€ä¹ˆï¼Ÿè™šæ‹Ÿå†…å­˜æ˜¯ç¨‹åºçš„åœ¨ä¸»å­˜å’ŒI/Oè®¾å¤‡ä¸­çš„ç©ºé—´çš„æŠ½è±¡ã€‚ è¿›ç¨‹æ˜¯ä»€ä¹ˆï¼Ÿè¿›ç¨‹æ˜¯ç¨‹åºåœ¨CPUã€ä¸»å­˜ã€I/Oè®¾å¤‡æ´»åŠ¨çš„æŠ½è±¡ã€‚ ï¼ˆå…¨æ–‡å®Œï¼‰]]></content>
      <tags>
        <tag>è®¡ç®—æœºç³»ç»Ÿ</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½¯ä»¶å·¥ç¨‹å¸ˆçš„è‡ªæˆ‘ä¿®å…» week0]]></title>
    <url>%2F2019%2F08%2F24%2Fsoftwafe-engineer-week0%2F</url>
    <content type="text"><![CDATA[å‰è¨€æŠŠæ¯å‘¨çš„æ”¶è·è®°å½•ä¸‹æ¥ï¼Œä¼šæ˜¯ä»¶å¾ˆæœ‰æ„ä¹‰çš„äº‹æƒ…ï¼Œäºæ˜¯å°±æœ‰äº†è¿™ä¸ªç³»åˆ—çš„åšæ–‡ã€‚ ä¸€ä¸ªä¼˜ç§€çš„è½¯ä»¶å·¥ç¨‹å¸ˆï¼Œå¿…é¡»æŒç»­æé«˜è‡ªå·±ä¸“ä¸šæ°´å¹³ï¼Œä¸æ–­å¥å…¨çŸ¥è¯†ä½“ç³»ã€‚æ¯ä¸€å‘¨ï¼Œæˆ–æ˜¯åˆ·ä¸€ä¸¤é“ç®—æ³•é¢˜ï¼Œæˆ–æ˜¯å•ƒå‡ åé¡µå¤§éƒ¨å¤´ï¼Œæˆ–æ˜¯åœ¨å¼€æºç¤¾åŒºæå‡ ä¸ªPRï¼Œæˆ–æ˜¯é˜…è¯»å‡ ç¯‡æŠ€æœ¯åšæ–‡ï¼Œæˆ–æ˜¯è¾“å‡ºå‡ ç¯‡æŠ€æœ¯åšæ–‡ï¼Œéƒ½å¦‚æ¶“æ¶“ç»†æµæ±‡å…¥å¤§æ²³ï¼Œä¸€ç‚¹ç‚¹æ±‡èšæˆä¸€è‚¡å¼ºå¤§çš„åˆåŠ›ï¼Œæ¨åŠ¨è‡ªå·±å˜å¾—å¾ˆå¼º(ç§ƒ)~ æ­£æ–‡è¿™ä¸€å‘¨çš„ä¸»è¦æ”¶è·ï¼š åœ¨Githubç»™gopdfï¼ˆä¸€ä¸ªç”¨Goå†™çš„å¯ä»¥ç”Ÿæˆpdfçš„åº“ï¼‰æäº†ä¸¤ä¸ªPRï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯ä¼˜åŒ–äº†æ—¶é—´å¤æ‚åº¦ï¼Œå°†$O(n^2)$é™æˆäº†$O(n)$ï¼Œå¦ä¸€ä¸ªæ˜¯ä¿®å¤äº†ä¸€ä¸ªissueä¸­çš„bugã€‚ é˜…è¯»äº†ã€Šé«˜æ€§èƒ½MySQLã€‹ï¼Œæ¨è¿›äº†å¤§æ¦‚20é¡µï¼Œæ”¶è·é¢‡ä¸°ã€‚ä¹‹å‰é¢è¯•çš„æ—¶å€™é‡åˆ°äº†è®¸å¤šä¸æ‡‚çš„MySQLçŸ¥è¯†ï¼Œçœ‹ç½‘ä¸Šçš„åšæ–‡éƒ½å†™å¾—ä¸æ€ä¹ˆæ ·ï¼Œä¸å¤Ÿç³»ç»Ÿã€‚è¿™æœ¬ä¹¦å¯ä»¥å¸®åŠ©å»ºç«‹MySQLçš„çŸ¥è¯†ä½“ç³»ï¼Œå¯¹äºéDBAæ¥è¯´ï¼Œå¯ä»¥æœ‰é€‰æ‹©åœ°è¯»ï¼Œæœ‰çš„åº”è¯¥ç•¥è¯»ï¼Œè€Œæœ‰çš„éœ€è¦ç²¾è¯»ï¼Œä½†å¯¹DBAæ¥è¯´ï¼Œå°±éœ€è¦çœ‹å¾—æ›´ç”¨å·¥äº›ã€‚ é˜…è¯»äº†ã€ŠHead Firstè®¾è®¡æ¨¡å¼ã€‹ï¼Œå­¦ä¹ äº†ä¸€ç§æ–°çš„è®¾è®¡æ¨¡å¼ã€‚ç°åœ¨å·¥ä½œä¸­ä¸»è¦ç”¨Goå¼€å‘ï¼ŒGoä¸æ˜¯ä¸€é—¨åƒJavaé‚£æ ·çš„é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œä½†è¿™å¹¶ä¸æ„å‘³ç€ä¸å¿…è¦çœ‹è¿™æœ¬ä¹¦ã€‚å› ä¸ºå­¦ä¹ è®¾è®¡æ¨¡å¼ï¼Œå°±åƒå­¦ä¹ ç®—æ³•ä¸€æ ·ï¼Œå¯èƒ½åœ¨å®é™…å¼€å‘ä¸­ç”¨åˆ°ä¸å¤šï¼Œä½†éƒ½å¯¹æé«˜ç¼–ç¨‹çš„å¢ƒç•Œå¤§æœ‰è£¨ç›Šã€‚ å­¦ä¹ kafkaï¼Œæ¨è¿›äº†ä¸“æ çš„å‡ èŠ‚ã€‚kafkaï¼Œä½œä¸ºæœ€çƒ­é—¨çš„æ¶ˆæ¯å¼•æ“ç³»ç»Ÿä¹‹ä¸€ï¼Œä¸å­¦å¾ˆäºã€‚ç›®å‰çœ‹çš„ä¸“æ æ˜¯æå®¢æ—¶é—´ä¸Šçš„â€œKafkaæ ¸å¿ƒæŠ€æœ¯ä¸å®æˆ˜â€ï¼Œæ„Ÿè§‰å­¦ä¹ æ–¹å¼æœ‰ç‚¹å•ä¸€ï¼Œå‡å¦‚æœ‰åˆé€‚å­¦ä¹ é€”å¾„ï¼Œæ¬¢è¿åˆ†äº«ç»™æˆ‘~ç°åœ¨åšå®¢è¿˜æ²¡æœ‰è¯„è®ºåŠŸèƒ½ï¼Œæœ‰æ—¶é—´æä¸€ä¸‹~ å­¦ä¹ dockerï¼Œå­¦ä¼šäº†åŸºæœ¬æ“ä½œã€‚è¿™é‡Œæ¨èä¸€ç¯‡é˜®ä¸€å³°å†™çš„åšæ–‡ï¼Œå†™å¾—å¾ˆæ£’ã€‚Dockerå¾ˆå¥½ç©ï¼Œç°åœ¨åªæ˜¯åˆšå…¥é—¨ï¼Œæœ‰æ—¶é—´å¯ä»¥å†æ·±å…¥äº†è§£ä¸€ä¸‹ã€‚ å­¦ä¹ è‹±è¯­ï¼ŒæŠ•å…¥äº†å¤§æ¦‚50åˆ†é’Ÿã€‚ç°åœ¨ä¸»è¦æ˜¯åƒæé«˜å£è¯­èƒ½åŠ›ï¼Œç”¨çš„è‹±è¯­æµåˆ©è¯´è¿™ä¸ªAppç»ƒä¹ ã€‚è¿™ä¸ªAppä¼šå¯¹ç”¨æˆ·çš„å‘éŸ³è¿›è¡Œè¯„åˆ†ï¼Œè‡ªå·±åŸºæœ¬ä¸Šæ˜¯åœ¨80åˆ†æ³¢åŠ¨ã€‚ä¸€äº›æ„Ÿè§‰å¾ˆç®€å•çš„è¯ï¼Œä½†å°±æ˜¯å‘ä¸å¯¹éŸ³ï¼Œæœ‰å¾ˆå¤§çš„æå‡ç©ºé—´ï¼Œå“ˆå“ˆğŸ˜… å¸Œæœ›ä¸‹ä¸€å‘¨æœ‰å¤šç‚¹å†…å®¹å¯ä»¥å†™ï¼Œå…±å‹‰~]]></content>
      <tags>
        <tag>æˆé•¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F07%2F31%2FGo-learning-note%2F</url>
    <content type="text"><![CDATA[å¸¸ç”¨packagesfmtPrintf verb æè¿° %v è¾“å‡ºå€¼ %+v è¾“å‡ºé”®-å€¼ %#v è¾“å‡ºåŒ…åã€ç±»å‹åã€é”®-å€¼ %T ç±»å‹ %% ç™¾åˆ†å· %t å¸ƒå°”å€¼ %b äºŒè¿›åˆ¶çš„å€¼ %c Unicodeç¼–ç çš„å­—ç¬¦ %d åè¿›åˆ¶çš„å€¼ %o å…«è¿›åˆ¶çš„å€¼ %xæˆ–%X åå…­è¿›åˆ¶çš„å€¼ %U åå…­è¿›åˆ¶è¡¨ç¤ºçš„Unicodeå€¼ %s å­—ç¬¦ä¸² %p åœ°å€ %f æµ®ç‚¹æ•°ï¼Œé»˜è®¤ç²¾åº¦æ˜¯å°æ•°ç‚¹å6ä½ %e æµ®ç‚¹æ•°ï¼Œç§‘å­¦è®¡æ•°æ³•ï¼Œé»˜è®¤ç²¾åº¦æ˜¯å°æ•°ç‚¹å6ä½ %g æµ®ç‚¹æ•°ï¼Œæœ‰æ•ˆæ•°å­—ï¼Œå°½å¯èƒ½åœ°è¾“å‡ºæ‰€æœ‰ä½æ•° + æ·»åŠ æ­£è´Ÿå· - è®¾ç½®å®½åº¦æ—¶é»˜è®¤åœ¨å·¦è¾¹è¡¥å…¨ç©ºæ ¼ï¼Œè¯¥ç¬¦å·å¯è®¾ç½®åœ¨å³è¾¹è¡¥å…¨ç©ºæ ¼ 0 ç”¨0ä»£æ›¿ç©ºæ ¼è¿›è¡Œè¡¥å…¨ # å¯¹äºå…«è¿›åˆ¶ï¼Œåå…­è¿›åˆ¶ç­‰ï¼ŒåŠ ä¸Šæç¤ºç¬¦ï¼Œå¦‚å…«è¿›åˆ¶ä¸º0ï¼Œåå…­è¿›åˆ¶ä¸º0x %f å¯æŒ‡å®šæµ®ç‚¹æ•°çš„å®½åº¦å’Œç²¾åº¦ 12345%f default width, default precision%9f width 9, default precision%.2f default width, precision 2%9.2f width 9, precision 2%9.f width 9, precision 0 %g å¯æŒ‡å®šæµ®ç‚¹æ•°çš„æœ‰æ•ˆæ•°å­—ä½æ•°ï¼Œå¯¹äº12.345ï¼Œ%.3g å°†è¾“å‡º 12.3 è‹¥è¦èƒ½å¯¹æŸä¸ªè‡ªå®šä¹‰ç±»å‹è¾“å‡ºï¼Œåªè¦å¯¹å®ƒå®šä¹‰String() stringæ–¹æ³•å³å¯ï¼š 123456func (t *T) String() string &#123; return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)&#125;// åªæœ‰å½“tæ˜¯*Tç±»å‹æ—¶ï¼Œæ‰ä¼šè°ƒç”¨ä¸Šé¢é‚£ä¸ªå‡½æ•°// è‹¥è¦å½“tæ˜¯Tç±»å‹å’Œ*Tç±»å‹éƒ½éƒ½è°ƒç”¨ä¸Šé¢é‚£ä¸ªå‡½æ•°ï¼Œéœ€è¦å°†ä¸Šé¢çš„*Tæ”¹æˆTfmt.Printf("%v\n", t) logä¼šå°†å†…å®¹è¾“å‡ºåˆ°stderrï¼Œä¸”ä¼šå¢åŠ ä¸€äº›ä¿¡æ¯ï¼ˆå¦‚æ—¥æœŸæ—¶é—´ï¼‰ã€‚ jsonæ³¨æ„åªæœ‰å½“ç»“æ„ä½“å†…çš„æˆå‘˜æ˜¯å…¬å¼€æ—¶ï¼Œæ‰èƒ½åœ¨Marshalçš„æ—¶å€™è¢«è¯†åˆ«ï¼Œæˆä¸ºjsonæ–‡ä»¶çš„ä¸€éƒ¨åˆ†ã€‚ è¿›è¡ŒUnmarshalæ—¶ï¼Œå‡å¦‚jsonä¸­æœ‰çš„å­—æ®µè€Œç»“æ„ä½“æ²¡æœ‰ï¼Œåˆ™è¿™ä¸ªå­—æ®µä¼šè¢«å¿½ç•¥ï¼Œä¸å½±å“è§£æã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯è¿›è¡Œjsonæ–‡ä»¶çš„éƒ¨åˆ†è§£æã€‚åŒç†ï¼Œå‡å¦‚Marshalæ—¶ï¼Œç»“æ„ä½“ä¸­çš„å­—æ®µä¸æƒ³è½¬åˆ°JSONæ–‡ä»¶ä¸­ï¼Œå¯ä»¥å°†å…¶tagè®¾ç½®ä¸ºâ€-â€œã€‚ è§£ææ—¶ï¼Œç»“æ„ä½“çš„æŸä¸ªå­—æ®µçš„åŒ¹é…ä¼˜å…ˆçº§ä¸ºtag -&gt; å¯¼å‡ºåç²¾ç¡®åŒ¹é… -&gt; å¯¼å‡ºåæ¨¡ç³ŠåŒ¹é…ã€‚ omitemptyè¡¨ç¤ºå½“å­—æ®µä¸ºé›¶å€¼æ—¶å¿½ç•¥å®ƒï¼Œè€Œtagä¸ºâ€-â€œè¡¨ç¤ºç›´æ¥å¿½ç•¥å®ƒã€‚ UnmarshalTextå‡½æ•°å’ŒUnmarshalJSONå‡½æ•°çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// å½“ä¸çŸ¥é“jsonæ–‡ä»¶çš„æ ¼å¼æ—¶ï¼Œå¯è¿™æ ·è§£æb := []byte(`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`)var f interface&#123;&#125;err := json.Unmarshal(b, &amp;f)if err == nil &#123; m := f.(map[string]interface&#123;&#125;) for k, v := range m &#123; switch vv := v.(type) &#123; case string: fmt.Println(k, "is string", vv) case float64: fmt.Println(k, "is float64", vv) case []interface&#123;&#125;: fmt.Println(k, "is an array:") for i, u := range vv &#123; fmt.Println(i, u) &#125; default: fmt.Println(k, "is of a type I don't know how to handle") &#125; &#125;&#125;// è‹¥å°†ç»“æ„ä½“çš„æˆå‘˜è®¾ç½®ä¸ºæŒ‡é’ˆç±»å‹ï¼Œåˆ™è‹¥jsonä¸å­˜åœ¨ç›¸åº”çš„å­—æ®µï¼Œåˆ™ä¸ºniltype IncomingMessage struct &#123; Cmd *Command Msg *Message&#125;// å¯¹äºæµçš„Encoderså’ŒDecodersde := json.NewDecoder(os.Stdin)enc := json.NewEncoder(os.Stdout)for &#123; var v map[string]interface&#123;&#125; if err := dec.Decode(&amp;v); err != nil &#123; log.Println(err) return &#125; for k := range v &#123; if k != "Name" &#123; delete(v, k) &#125; &#125; if err := enc.Encode(&amp;v); err != nil &#123; log.Println(err) &#125;&#125; Basic componentpackage | import1234567891011// ä»»ä½•goç¨‹åºéƒ½æ˜¯ç”±packageç»„æˆï¼Œé¦–ä¸ªéç©ºå•è¯å¿…é¡»æ˜¯packagepackage main// å•ä¸ªimportimport "os"// å¤šä¸ªimportimport ( "fmt" "math") functionså½¢å¼ï¼šå½¢å‚çš„æ ‡è¯†ç¬¦åœ¨å‰ï¼Œç±»å‹åœ¨åï¼›è¿”å›å€¼æ”¾åœ¨æœ€åé¢ 123func add(x int, y int) int &#123; return x + y&#125; è¿™æ ·åšçš„ä¸»è¦åŸå› æ˜¯ä¸ºäº†æé«˜æ˜“è¯»æ€§ï¼Œç‰¹åˆ«æ˜¯åœ¨æ¶‰åŠå‡½æ•°å˜é‡ï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰çš„æ—¶å€™ 12f func(func(int,int) int, int) intf func(func(int,int) int, int) func(int, int) int åŒç±»å‹çš„å½¢å‚å¯ç®€å†™ 123func add(x, y int) int &#123; return x + y&#125; è¿”å›å€¼å¯æœ‰å¤šä¸ª 12345678func swap(x, y string) (string, string) &#123; return y, x&#125;func main() &#123; a, b := swap("hello", "world") fmt.Println(a, b)&#125; å¯ç»™è¿”å›å€¼å‘½åï¼Œä¸”returnå¯ç®€å†™ï¼Œæ³¨æ„ä¸è¦åœ¨é•¿å‡½æ•°ä¸­ç®€å†™ï¼Œå› ä¸ºè¿™æ ·ä¼šé™ä½å¯è¯»æ€§ 12345func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125; variables | constants | typesé¦–å­—æ¯å¤§å†™çš„å˜é‡ç§°ä¸ºexported name 1234type A struct &#123; Address string // exported name cost int&#125; ç”³æ˜æ ¼å¼ 12345678910111213// å•å¥var c, python, java bool// æœ‰èµ‹åˆå€¼æ—¶ï¼Œå¯çœç•¥ç±»å‹åvar c, python, java = true, false, "no!"d := 3// å—var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i)) å½“çœç•¥ç±»å‹åæ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨æµ‹ï¼Œæ¨æµ‹è§„åˆ™ä¸ºï¼š å³è¾¹æ˜¯å˜é‡ï¼Œåˆ™å’Œå˜é‡çš„ç±»å‹ç›¸åŒ å³è¾¹æ˜¯å¸¸é‡ï¼Œåˆ™æœ‰å¯èƒ½æ˜¯int, float64, complex128 åŸºç¡€ç±»å‹ 123456789101112131415boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // alias for uint8rune // alias for int32 // represents a Unicode code pointfloat32 float64complex64 complex128 ç”³æ˜çš„å˜é‡å‡å¦‚æ²¡æœ‰è¢«æ˜¾å¼èµ‹åˆå€¼ï¼Œåˆ™ä¼šè¢«èµ‹zero valueï¼Œå³æ•°å€¼ä¸º0ï¼Œå¸ƒå°”ç±»å‹ä¸ºfalseï¼Œå­—ç¬¦ä¸²ä¸ºâ€â€ï¼ŒæŒ‡é’ˆä¸ºnil ç”³æ˜å¸¸é‡ï¼Œç”¨constï¼Œä¸èƒ½ç”¨:=ï¼Œå› ä¸º:=æ˜¯å’Œvarå…³è”çš„ï¼Œè€Œvarä»£è¡¨å˜é‡ã€‚ 1234func main() &#123; const World = "ä¸–ç•Œ" fmt.Println("Hello", World)&#125; æ²¡æœ‰éšå¼ç±»å‹è½¬æ¢ï¼Œå¿…é¡»æ˜¾å¼ç±»å‹è½¬æ¢ã€‚ ç±»å‹æ–­è¨€ï¼Œç”¨äºå°†ç©ºæ¥å£è½¬æ¢ä¸ºæ™®é€šç±»å‹ã€‚ç±»å‹æ–­è¨€åˆåˆ†ä¸ºå®‰å…¨ç±»å‹æ–­è¨€å’Œéå®‰å…¨ç±»å‹æ–­è¨€ã€‚ &lt;ç›®æ ‡ç±»å‹çš„å€¼&gt;ï¼Œ&lt;å¸ƒå°”å‚æ•°&gt; := &lt;è¡¨è¾¾å¼&gt;.(ç›®æ ‡ç±»å‹) // å®‰å…¨ç±»å‹æ–­è¨€ &lt;ç›®æ ‡ç±»å‹çš„å€¼&gt; := &lt;è¡¨è¾¾å¼&gt;.(ç›®æ ‡ç±»å‹) // éå®‰å…¨ç±»å‹æ–­è¨€ åœ¨å‡½æ•°ä½“å†…ï¼Œå˜é‡ç”³æ˜äº†ä½†ä¸ä½¿ç”¨ä¼šæŠ¥é”™ã€‚åŒç†ï¼Œimportçš„packageæ²¡ç”¨çš„è¯ä¹Ÿä¼šæŠ¥é”™ã€‚ Goåœ¨å‡½æ•°ä½“ä¸­å®šä¹‰äº†ä¸€ä¸ªå˜é‡ï¼Œç„¶åå°†å®ƒçš„æŒ‡é’ˆè¿”å›æ˜¯åˆæ³•çš„ï¼Œæ¯”å¦‚ï¼š 123456789func NewFile(fd int, name string) *File &#123; if fd &lt; 0 &#123; return nil &#125; f := File&#123;fd, name, nil, 0&#125; return &amp;f // æˆ–è€…å°†ä¸Šé¢ä¸¤è¡Œç®€å†™æˆreturn &amp;File&#123;fd: fd, name: name&#125; // ä¸éš¾å‘ç°new(File)å’Œ&amp;File&#123;&#125;æ˜¯ç­‰ä»·çš„&#125; More typesPointersæŒ‡é’ˆï¼Œå’ŒCä¸ä¸€æ ·ï¼ŒGoæ²¡æœ‰æŒ‡é’ˆçš„ç®—æœ¯è¿ç®—ï¼Œå³ä¸æ”¯æŒp = p + 10è¿™æ ·çš„è¯­å¥ Structsç»“æ„ä½“ï¼Œå¯å°†(*p).Xå†™æˆp.X 1234567891011type Vertex struct &#123; X int Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // has type Vertex v2 = Vertex&#123;X: 1&#125; // Y:0 is implicit v3 = Vertex&#123;&#125; // X:0 and Y:0 p = &amp;Vertex&#123;1, 2&#125; // has type *Vertex) ArraysIn Goï¼š Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct. 12345678910func main() &#123; var a [2]string a[0] = "Hello" a[1] = "World" fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(primes)&#125; å‡å¦‚æƒ³è¦åƒCé‚£æ ·åªä¼ æ•°ç»„çš„åœ°å€ï¼Œå¯ä»¥è¿™æ ·å†™ï¼š 123456789func Sum(a *[3]float64) (sum float64) &#123; for _, v := range *a &#123; sum += v &#125; return&#125;array := [...]float64&#123;7.0, 8.5, 9.1&#125;x := Sum(&amp;array) // Note the explicit address-of operator è™½ç„¶å¯ä»¥è¿™ä¹ˆå†™ï¼Œä½†ä¸æ¨èï¼Œå› ä¸ºæ›´ä¼˜é›…çš„æ–¹æ³•æ˜¯ä½¿ç”¨slicesã€‚ Slicesåˆ‡ç‰‡ï¼Œæœ¬èº«ä¸å­˜å‚¨å®é™…æ•°æ®ï¼Œç±»ä¼¼äºå¼•ç”¨ 123456func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; var s []int = primes[1:4] fmt.Println(s)&#125; åˆ‡ç‰‡æ•°ç»„ï¼Œå¯ä»¥æ”¹å˜æŒ‡å‘çš„èŒƒå›´ 123456789101112func main() &#123; r := []bool&#123;true, true, true, false, false, false&#125; t := []bool&#123;true, true, true, false, false, false&#125; fmt.Println(r) r = r[1:2] fmt.Println(r) r = r[0:3] fmt.Println(r) # è¾“å‡º[true true false]ï¼Œå³æœ€å¼€å§‹çš„[1,4] r = t fmt.Println(r)&#125; åˆ‡ç‰‡ï¼Œå¯çœç•¥ä¸‹ç•Œæˆ–ä¸Šç•Œ cap() æŸ¥çœ‹å®¹é‡ï¼Œå³ä»ä¸‹ç•Œåˆ°æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ çš„ä¸ªæ•° len()æŸ¥çœ‹é•¿åº¦ï¼Œå³ä»ä¸‹ç•Œåˆ°ä¸Šç•Œçš„ä¸ªæ•° åˆ‡ç‰‡ä¸ºnilæ—¶ï¼Œcapå’Œlenéƒ½ä¸º0 ä½¿ç”¨makeæ¥åˆ›å»ºä¸€ç»´åˆ‡ç‰‡ 123456789101112131415161718func main() &#123; a := make([]int, 5) printSlice("a", a) b := make([]int, 0, 5) // len(b)=0, cap(b)=5 printSlice("b", b) c := b[:2] printSlice("c", c) d := c[2:5] printSlice("d", d)&#125;func printSlice(s string, x []int) &#123; fmt.Printf("%s len=%d cap=%d %v\n", s, len(x), cap(x), x)&#125; ä½¿ç”¨makeåˆ›å»ºäºŒç»´åˆ‡ç‰‡ï¼Œç¬¬ä¸€ç§æ–¹å¼ï¼Œè¯¥æ–¹å¼å…è®¸ç¬¬äºŒç»´å¤§å°æœ‰æ‰€å˜åŒ–ï¼š 12345// åˆ›å»ºä¸€ä¸ªä½æ•°ä¸º[dx][dy]çš„åˆ‡ç‰‡a := make([][]uint8, dx)for i := range a &#123; a[i] = make([]uint8, dy)&#125; ç¬¬äºŒç§æ–¹å¼ï¼Œä¸å…è®¸ç¬¬äºŒç»´å¤§å°æœ‰æ‰€å˜åŒ–ï¼Œå› ä¸ºæ”¹å˜äº†å°±ä¼šæœ‰å¯èƒ½è¦†ç›–ï¼š 12345678// Allocate the top-level slice, the same as before.picture := make([][]uint8, YSize) // One row per unit of y.// Allocate one large slice to hold all the pixels.pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.// Loop over the rows, slicing each row from the front of the remaining pixels slice.for i := range picture &#123; picture[i], pixels = pixels[:XSize], pixels[XSize:]&#125; å¯ä½¿ç”¨appendå‡½æ•°å‘åˆ‡ç‰‡æ·»åŠ å…ƒç´ ï¼Œå‡å¦‚åˆ‡ç‰‡å®¹é‡ä¸è¶³ï¼Œåˆ™å®¹é‡ä¼šç¿»å€ã€‚ 12345func main() &#123; var s []int s = append(s, 2, 3, 4) fmt.Println(s)&#125; è¿˜å¯ä»¥ä½¿ç”¨appendå‡½æ•°å‘åˆ‡ç‰‡ä¸­æ·»åŠ åˆ‡ç‰‡ï¼š 1234x := []int&#123;1,2,3&#125;y := []int&#123;4,5,6&#125;x = append(x, y...)fmt.Println(x) å¯ä½¿ç”¨rangeéå†åˆ‡ç‰‡ï¼Œæ¯æ¬¡å¾ªç¯ä¼šæœ‰ä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªæ˜¯å…ƒç´ çš„ä¸‹æ ‡ï¼Œä¸€ä¸ªæ˜¯å…ƒç´ çš„å€¼ã€‚å¯ä½¿ç”¨_å¿½ç•¥å…¶ä¸­ä¸€ä¸ªã€‚ 1234567891011func main() &#123; pow := []int&#123;4, 1, 5&#125; for _, value := range pow &#123; fmt.Printf("%d\n", value) &#125; // åªæœ‰ä¸€ä¸ªå€¼åªä¼šå¾—åˆ°ä¸‹æ ‡ for idx := range pow &#123; fmt.Printf("%d\n", pow[idx]) &#125;&#125; ç¼©å‡åˆ‡ç‰‡çš„å¤§å°ï¼š 12345678910111213141516var digitRegexp = regexp.MustCompile("[0-9]+")// uglyfunc FindDigits(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) return digitRegexp.Find(b)&#125;// elegantï¼Œç¼©å‡äº†åˆ‡ç‰‡çš„capï¼Œé‡Šæ”¾å†…å­˜func CopyDigits(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c&#125; Mapsmapsçš„é›¶å€¼ä¸ºnilï¼Œå¯é€šè¿‡makeåˆ›å»ºmapã€‚ 12345678910type Vertex struct &#123; Lat, Long float64&#125;func main() &#123; m := make(map[string]Vertex) m["Bell Labs"] = Vertex&#123; 40.68433, -74.39967, &#125; fmt.Println(m["Bell Labs"])&#125; åˆå§‹åŒ– 12345678var m = map[string]Vertex&#123; "Bell Labs": Vertex&#123; 40.68433, -74.39967, &#125;, "Google": Vertex&#123; 37.42202, -122.08408, &#125;,&#125; åˆå§‹åŒ–æ—¶ï¼Œå€¼çš„ç±»å‹åå¯çœç•¥ 1234var m = map[string]Vertex&#123; "Bell Labs": &#123;40.68433, -74.39967&#125;, "Google": &#123;37.42202, -122.08408&#125;,&#125; æ’å…¥é”®å€¼å¯¹ï¼Œå–é”®çš„å€¼ï¼Œåˆ é™¤é”®å€¼å¯¹ï¼ˆå¯å¤šæ¬¡åˆ é™¤ï¼Œå¯åˆ é™¤ä¸å­˜åœ¨çš„é”®ï¼‰ 123456789101112131415func main() &#123; m := make(map[string]int) m["Answer"] = 42 fmt.Println("The value:", m["Answer"]) m["Answer"] = 48 fmt.Println("The value:", m["Answer"]) delete(m, "Answer") fmt.Println("The value:", m["Answer"]) v, ok := m["Answer"] fmt.Println("The value:", v, "Present?", ok)&#125; mapè¢«å‡½æ•°è°ƒç”¨ï¼Œå¯è¢«ä¿®æ”¹ã€‚ Function valueså‡½æ•°ä¹Ÿå¯ä»¥ä½œä¸ºå€¼ï¼Œå¯ä»¥åƒå…¶ä»–æ•°æ®ç±»å‹ä¸€æ ·èµ‹å€¼ç»™å˜é‡ï¼Œä½œä¸ºå®å‚ç­‰ã€‚ 12345678910111213func compute(fn func(float64, float64) float64) float64 &#123; return fn(3, 4)&#125;func main() &#123; hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y) &#125; fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))&#125; Function closureså‡½æ•°é—­åŒ…ï¼Œä¸åŒå˜é‡å¯ä»¥ç»‘å®šä¸åŒçš„å‡½æ•°é—­åŒ…ï¼Œç›¸äº’ä¹‹é—´ä¸å½±å“ 1234567891011121314151617func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; Flow control statementsififï¼Œå¯ä»¥æ²¡æœ‰()ï¼Œä½†ä¸€å®šè¦æœ‰{} 123if x &lt; 0 &#123; return sqrt(-x) + "i"&#125; ifå¯ä»¥åƒforé‚£æ ·å…ˆå¸¦ä¸ªstatementã€‚å‡å¦‚ç”³æ˜äº†å˜é‡ï¼Œåˆ™åªèƒ½åœ¨ifæˆ–åç»­çš„elseä¸­ä½¿ç”¨ã€‚ 123456789func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf("%g &gt;= %g\n", v, lim) &#125; // can't use v here, though return lim&#125; forforï¼Œå¯ä»¥æ²¡æœ‰()ï¼Œä½†ä¸€å®šè¦æœ‰{} 123456789101112131415for i := 0; i &lt; 10; i++ &#123; sum += i&#125;// ç›¸å½“äºwhile(condition)i := 0for i &lt; 10 &#123; DoSomething(); i++;&#125;// ç›¸å½“äºwhile(true)for &#123; DoSomething();&#125; switchswitch, æ»¡è¶³å…¶ä¸­ä¸€ä¸ªcaseå³æ‰§è¡Œå…¶ä¸­çš„è¯­å¥ï¼Œä¸ä¼šå†æ‰§è¡Œå…¶ä»–caseçš„è¯­å¥ï¼Œå¯çœ‹æˆè‡ªå¸¦breakã€‚æ­¤å¤–ï¼Œcaseä¸ä¸€å®šè¦æ¥æ•´æ•°å¸¸é‡ï¼Œå®ƒå¯ä»¥ä¸æ˜¯æ•´æ•°ï¼Œå¯ä»¥ä¸æ˜¯å¸¸é‡ã€‚ä½†è¦æ³¨æ„caseåæ¥çš„ç±»å‹å’Œswitchæ¯”è¾ƒçš„ç±»å‹ç›¸åŒã€‚ switchåŒæ ·å¯ä»¥åƒforé‚£æ ·å…ˆå¸¦ä¸ªstatementï¼Œä¸”defaultçš„ä½ç½®å¯æ”¾åœ¨é¦–ä½ï¼Œå› ä¸ºå®ƒæ€»æ˜¯ä¼šåœ¨æ‰€æœ‰æ¡ä»¶éƒ½ä¸åŒ¹é…çš„æ—¶å€™æ‰æ‰§è¡Œã€‚ 12345678910111213func main() &#123; fmt.Print("Go runs on ") switch os := runtime.GOOS; os &#123; default: // freebsd, openbsd, // plan9, windows... fmt.Printf("%s.\n", os) case "darwin": fmt.Println("OS X.") case "linux": fmt.Println("Linux.") &#125;&#125; switchè¿˜å¯ä»¥è¿™æ ·å†™ï¼š 1234567891011func unhex(c byte) byte &#123; switch &#123; case '0' &lt;= c &amp;&amp; c &lt;= '9': return c - '0' case 'a' &lt;= c &amp;&amp; c &lt;= 'f': return c - 'a' + 10 case 'A' &lt;= c &amp;&amp; c &lt;= 'F': return c - 'A' + 10 &#125; return 0&#125; deferdefer æ¨è¿Ÿæ‰§è¡Œï¼Œå…·æœ‰LIFOçš„æ€§è´¨ 123456func main() &#123; defer fmt.Printf("1 ") defer fmt.Printf("2 ") fmt.Printf("3 ") // å°†è¾“å‡º3 2 1&#125; deferè¿˜å¯ä»¥è¿™æ ·å†™ï¼Œå‚æ•°éƒ¨åˆ†çš„å‡½æ•°æ˜¯ä¼šå…ˆæ‰§è¡Œçš„ï¼š 12345678910111213141516171819202122232425262728293031func trace(s string) string &#123; fmt.Println("entering:", s) return s&#125;func un(s string) &#123; fmt.Println("leaving:", s)&#125;func a() &#123; defer un(trace("a")) fmt.Println("in a")&#125;func b() &#123; defer un(trace("b")) fmt.Println("in b") a()&#125;func main() &#123; b()&#125;/* è¾“å‡ºï¼šentering: bin bentering: ain aleaving: aleaving: b*/ Methods and interfacesMethodsGoæ²¡æœ‰classï¼Œä½†å¯ä»¥ç»™æ–¹æ³•ï¼ˆå‡½æ•°ï¼‰æŒ‡å®šé€‚ç”¨çš„ç±»å‹ã€‚methodæ˜¯æŒ‡å®šç±»å‹çš„functionã€‚ 123456789101112type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125; methordæŒ‡å®šçš„ç±»å‹å¯ä»¥æ˜¯åŸºæœ¬ç±»å‹ï¼Œä½†æ‰€æŒ‡å®šçš„ç±»å‹å¿…é¡»åœ¨æœ¬packageå‡ºç°ã€‚ 12345678910111213type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125; methordæŒ‡å®šçš„ç±»å‹å¯ä»¥æ˜¯æŒ‡é’ˆï¼Œåˆ™æˆ‘ä»¬å¯ä»¥ä¿®æ”¹æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ï¼Œå¹¶ä¸”ä¸ç”¨äº§ç”Ÿæ‹·è´å¼€é”€ã€‚ 123456789101112131415161718type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(10) fmt.Println(v.Abs())&#125; Interfacesæ¥å£ï¼Œè¦æ±‚ä½¿ç”¨æ¥å£çš„ç±»å‹å®ç°äº†æ¥å£ä¸­æ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; å®ç°æ¥å£ä¸­çš„æ–¹æ³•ä¸éœ€è¦åƒå…¶ä»–è¯­è¨€é‚£æ ·ä½¿ç”¨æ˜¾å¼çš„å…³é”®å­—ï¼Œå¦‚implementã€‚ è¿™æ ·åšå¯ä»¥è®©ç”³æ˜å’Œå®ç°åˆ†ç¦»ï¼Œä¸éœ€è¦ç‰¹æ®Šå¤„ç†å°±å¯ä»¥è®©ä»–ä»¬æ”¾åœ¨ä¸åŒçš„åŒ…ä¸­ã€‚ æ¥å£å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªäºŒå…ƒç»„(value, type)ï¼Œå¯¹äºä¸€ä¸ªvalueï¼Œå®ƒä¼šè°ƒç”¨æ¥æ”¶äº†typeçš„æ–¹æ³•ã€‚ å‡å¦‚ä¸€ä¸ªå˜é‡æ˜¯æ¥å£ç±»å‹çš„ï¼Œé‚£ä¹ˆå®ƒæœ‰å¯èƒ½valueå’Œtypeéƒ½ä¸ºnilï¼Œè¿™ç§æƒ…å†µä¸‹ä¼šREã€‚è€Œå½“typeä¸ä¸ºnilæ—¶ï¼Œå®ƒæ˜¯éç©ºçš„ï¼Œä½†æ˜¯valueå¯èƒ½ä¼šç©ºï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨å®ç°æ¥å£çš„æ–¹æ³•é‡Œå¤„ç†å¥½è¿™ç§æƒ…å†µã€‚ ç©ºæ¥å£ï¼Œç”¨äºå­˜å‚¨ä»»ä½•ç±»å‹çš„æ•°æ® 1234567891011121314func main() &#123; var i interface&#123;&#125; describe(i) i = 42 describe(i) i = "hello" describe(i)&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf("(%v, %T)\n", i, i)&#125; ç±»å‹æ–­è¨€ï¼Œåœ¨æ–­è¨€ä¸æˆç«‹çš„æ—¶å€™åº”è¯¥ç”¨ä¸¤ä¸ªå˜é‡å­˜å‚¨ç»“æœï¼Œå¦åˆ™ä¼šæŠ¥é”™ 123456789101112131415func main() &#123; var i interface&#123;&#125; = "hello" s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f)&#125; type switch å¯ä»¥ä¾æ¬¡è¿›è¡Œå¤šä¸ªç±»å‹æ–­è¨€ 12345678910111213141516func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf("Twice %v is %v\n", v, v*2) case string: fmt.Printf("%q is %v bytes long\n", v, len(v)) default: fmt.Printf("I don't know about type %T!\n", v) &#125;&#125;func main() &#123; do(21) do("hello") do(true)&#125; Stringer ç”¨äºè¾“å‡ºè‡ªå®šä¹‰ç±»å‹çš„æ¥å£ 123type Stringer interface &#123; String() string&#125; 1234567891011121314type Person struct &#123; Name string Age int&#125;func (p Person) String() string &#123; return fmt.Sprintf("%v (%v years)", p.Name, p.Age)&#125;func main() &#123; a := Person&#123;"Arthur Dent", 42&#125; z := Person&#123;"Zaphod Beeblebrox", 9001&#125; fmt.Println(a, z)&#125; Error ç”¨äºè¾“å‡ºé”™è¯¯ä¿¡æ¯çš„æ¥å£ 123type error interface &#123; Error() string&#125; 12345678910111213141516171819202122type MyError struct &#123; When time.Time What string&#125;func (e *MyError) Error() string &#123; return fmt.Sprintf("at %v, %s", e.When, e.What)&#125;func run() error &#123; return &amp;MyError&#123; time.Now(), "it didn't work", &#125;&#125;func main() &#123; if err := run(); err != nil &#123; fmt.Println(err) &#125;&#125; Reader ç”¨äºè¯»å–æ•°æ®çš„æ¥å£ func (T) Read(b []byte) (n int, err error) 12345678910111213func main() &#123; r := strings.NewReader("Hello, Reader!") b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf("n = %v err = %v b = %v\n", n, err, b) fmt.Printf("b[:n] = %q\n", b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125; Images ç”¨äºå¤„ç†å›¾åƒçš„æ¥å£ 12345type Image interface &#123; ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color&#125; ConcurrencyGoroutines è½»å‹çº¿ç¨‹ï¼Œå®ƒä»¬å…±äº«åŒä¸€åœ°å€çš„å†…å­˜ï¼Œéœ€è¦åŒæ­¥æ§åˆ¶ go f(x, y, z) åˆ›å»ºä¸€ä¸ªæ–°Goroutineè¿è¡Œå‡½æ•°f Channels å¯ç”¨äºä¼ é€’æ•°æ®çš„ä¸€ç§æ•°æ®ç±»å‹ï¼Œéœ€è¦ç”¨åˆ°è¿ç®—ç¬¦&lt;- 123456789101112131415161718func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // send sum to c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y)&#125; Buffered Channels å¯ç†è§£ä¸ºå¤§å°çš„Channelï¼Œæ»¡äº†è¿˜å¾€é‡Œé¢æ·»åŠ çš„è¯ä¼šæŠ¥é”™ å¯ä½¿ç”¨rangeæ¥å–å‡ºchannelä¸­çš„æ‰€æœ‰æ•°æ®ï¼Œæ³¨æ„channelè¦close &lt;-chå®é™…ä¸Šä¼šè¿”å›ä¸¤ä¸ªå€¼ï¼Œç¬¬äºŒä¸ªå€¼ä»£è¡¨æ˜¯å¦è¿˜æœ‰æ•°æ®ï¼Œå³false è¡¨ç¤ºchannel closeäº† 12345678910111213141516func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x+y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125; selectç”¨äºå¤šä¸ªchannelçš„é€‰æ‹©ï¼Œå“ªä¸ªchannelæœ‰æ•°æ®å°±æ‰§è¡Œå“ªä¸€ä¸ªï¼Œå‡å¦‚åŒæ—¶æœ‰æ•°æ®æ¥äº†ï¼Œå°±éšæœºå…ˆæ‰§è¡Œå…¶ä¸­ä¸€ä¸ª selectä¸­çš„defaultåœ¨æ²¡æœ‰æ”¶åˆ°ä»»ä½•channelæ•°æ®çš„æ—¶å€™æ‰§è¡Œ sync.Mutex ç”¨äºäº’æ–¥ 12345678910111213141516171819202122232425262728293031323334353637import ( "fmt" "sync" "time")// SafeCounter is safe to use concurrently.type SafeCounter struct &#123; v map[string]int mux sync.Mutex&#125;// Inc increments the counter for the given key.func (c *SafeCounter) Inc(key string) &#123; c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mux.Unlock()&#125;// Value returns the current value of the counter for the given key.func (c *SafeCounter) Value(key string) int &#123; c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mux.Unlock() return c.v[key]&#125;func main() &#123; c := SafeCounter&#123;v: make(map[string]int)&#125; for i := 0; i &lt; 1000; i++ &#123; go c.Inc("somekey") &#125; time.Sleep(time.Second) fmt.Println(c.Value("somekey"))&#125; Diagnostics | è¯Šæ–­pprof1234// èµ·æ‰‹å¼cpuProfile, _ := os.Create("cpu_profile")pprof.StartCPUProfile(cpuProfile)defer pprof.StopCPUProfile() go tool pprof &lt;file&gt; web å¯åŠ¨å¯è§†åŒ–ç•Œé¢ top åˆ—å‡ºcpuå æ¯”æœ€é«˜çš„å‡½æ•° list &lt;function&gt; åˆ—å‡ºæŒ‡å®šå‡½æ•°çš„æ•°æ® Go Commandgo buildå‡å¦‚æƒ³è¦ç©ä¸€ä¸‹go buildå‘½ä»¤ï¼Œæ³¨æ„åŠ ä¸Š-aé‡æ–°å…¨éƒ¨ç¼–è¯‘ï¼Œå¦åˆ™ä¼šå› ä¸ºæœ‰ç¼“å­˜è€Œè·³è¿‡ç¼–è¯‘è¿‡ç¨‹ã€‚ å‡å¦‚æ˜¯mainï¼Œåˆ™ä¼šç¼–è¯‘ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚ å¦åˆ™ï¼Œåªä¼šç¼–è¯‘ï¼Œä¸äº§ç”Ÿæ–‡ä»¶ï¼Œç”¨äºéªŒè¯ä»£ç èƒ½å¦ç¼–è¯‘ã€‚ go installå‡å¦‚æ˜¯mainï¼Œåˆ™ä¼šåœ¨$GOPATH/binä¸‹ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚ å¦åˆ™ï¼Œä¼šåœ¨$GOPATH/pkgä¸‹ç”Ÿæˆ*.aæ–‡ä»¶ã€‚ go get12# å‡çº§åŒ…go get -u &lt;package&gt; go cleanåˆ é™¤ç¼–è¯‘ç”Ÿæˆçš„æ–‡ä»¶ç­‰ç­‰ã€‚ ä¾èµ–ç®¡ç†å·¥å…·Dep1234567891011# åˆå§‹åŒ–ï¼Œ-vå‚æ•°ä»£è¡¨è¾“å‡ºè¯¦ç»†ä¿¡æ¯dep init -v# è§£å†³ä¾èµ–çš„BUGdep ensure -v# æ›´æ–°ä¾èµ–ï¼Œå‡å¦‚æ€»æ˜¯æ›´æ–°å¤±è´¥ï¼Œå…ˆdep ensure -vä¸€ä¸‹ï¼Œå¹¶é€‰æ‹©åœ¨ç½‘ç»œç©ºé—²çš„æ—¶å€™æ›´æ–°dep ensure -update -v# æ·»åŠ ä¸€æ¡ä¾èµ–dep ensure -add github.com/bitly/go-simplejson Go Modæ‹‰å–é€Ÿåº¦æ¯”Depè¦å¿«å¾ˆå¤šã€‚ 1234567891011121314# è®¾ç½®ç¯å¢ƒå˜é‡export GO111MODULE=on# åˆå§‹åŒ–ï¼Œç”Ÿæˆgo.modæ–‡ä»¶go mod init# ä¹‹åå³å¯ä½¿ç”¨go buildæˆ–go testæ‹‰å–ä¾èµ–go build/test# å‡çº§æ‰€æœ‰ä¾èµ–åˆ°æœ€æ–°go get -u# å°†ä¾èµ–æ”¾åœ¨é¡¹ç›®çš„vendorä¸­go mod vendor å‡å¦‚é‡åˆ°æŸä¸ªä¾èµ–æœ‰é—®é¢˜ï¼Œæ›´æŠŠé‚£ä¸ªä¾èµ–åˆ æ‰ï¼Œç„¶åå†go get -uå‡çº§æ‰€æœ‰ä¾èµ–ã€‚]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç†è´¢å…¥é—¨]]></title>
    <url>%2F2019%2F07%2F13%2Ffinancial-management%2F</url>
    <content type="text"><![CDATA[èƒŒæ™¯å‰æ®µæ—¶é—´å¼€å§‹äº†å®ä¹ ï¼Œå¹¶æ‹¿åˆ°äº†äººç”Ÿçš„ç¬¬ä¸€æ¡¶é‡‘ã€‚ä¸ºäº†èƒ½å¤ŸæŒæ¡å¥½è‡ªå·±çš„è´¢åŠ¡æƒ…å†µï¼Œä»¥åŠæ€€ç€å°½å¿«å®ç°è´¢åŠ¡è‡ªç”±çš„ç›®æ ‡ï¼Œå¼€å§‹äº†è‡ªå·±ç†è´¢çŸ¥è¯†å­¦ä¹ ä¹‹è·¯ã€‚å­¦ä¹ ç†è´¢ï¼ŒåŒæ—¶ä¹Ÿæ˜¯æé«˜è‡ªæˆ‘è®¤çŸ¥çš„è¿‡ç¨‹ã€‚æ­¤åšæ–‡è®°å½•äº†è‡ªå·±çš„ç†è´¢å­¦ä¹ ä¹‹è·¯ï¼Œå¸Œæœ›èƒ½å¯¹è¯»è€…æœ‰äº›å¸®åŠ©ã€‚ æ­£æ–‡ç®¡ç†å¥½è‡ªå·±çš„è´¢äº§çš„ç¬¬ä¸€æ­¥ï¼Œæ˜¯è¦å¯¹è‡ªå·±çš„æ”¯å‡ºæ”¶å…¥æƒ…å†µæœ‰æ‰€äº†è§£ã€‚å‡å¦‚ä¸€ä¸ªäººå¯¹è‡ªå·±çš„æ”¶æ”¯æƒ…å†µä¸€ç‚¹ä¸äº†è§£ï¼Œå°±ç®—ä¸­äº†ç™¾ä¸‡å½©ç¥¨ï¼ŒæŒ¥é‡‘å¦‚åœŸï¼Œä¹Ÿä¼šå¾ˆå¿«è¢«æŒ¥éœå®Œã€‚è€Œå‡å¦‚ä¸€ä¸ªäººå¯¹äºè‡ªå·±çš„æ”¶æ”¯æƒ…å†µäº†ç„¶äºèƒ¸ï¼Œé‡å…¥ä¸ºå‡ºï¼Œæ‰èƒ½è¿‡å¾—å¾ˆè¸å®ã€‚ åœ¨è¿™é‡Œï¼Œé€šè¿‡ä¸€ç•ªæ¯”è¾ƒåï¼Œæˆ‘é€‰æ‹©äº†å¤å¼è®°è´¦æ³•ï¼Œå¹¶é‡‡ç”¨äº†beancountå’Œfavaè¿™ä¸¤ä¸ªå·¥å…·ã€‚ç½‘ä¸Šä»‹ç»è¿™ä¸¤ä¸ªå·¥å…·çš„å¥½æ–‡ç« å·²æœ‰ä¸å°‘ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ä½¿ç”¨æ–¹æ³•ï¼Œè€Œåªæä¸€ä¸‹å®ƒçš„ä¼˜ç‚¹ã€‚beancountï¼Œå®ƒæ˜¯å¼€æºçš„ï¼Œå®ƒå¯ä»¥è®©ä½ ä»¥çº¯æ–‡æœ¬çš„å½¢å¼è®°è´¦ï¼Œå¹¶å°†æ•°æ®ä¿å­˜åœ¨è‡ªå·±çš„ç”µè„‘ä¸Šï¼Œä¿è¯äº†æ•°æ®çš„å¯ç§»æ¤æ€§å’Œå®‰å…¨æ€§ï¼Œæ— éœ€æ”¯ä»˜é¢å¤–è´¹ç”¨ï¼Œä½¿ç”¨æˆæœ¬ä½ã€‚å¦å¤–ï¼Œåˆ©ç”¨favaå¯å°†æ•°æ®å¯è§†åŒ–ï¼Œå¯ä»¥ç›´è§‚åœ°çœ‹åˆ°è‡ªå·±çš„è´¢åŠ¡æƒ…å†µï¼Œéå¸¸æ–¹ä¾¿ã€‚ å¾ˆå¤šäººä¹‹æ‰€ä»¥ä¸èƒ½åšæŒè®°è´¦ï¼Œå¤§å¤šæ•°æ˜¯å› ä¸ºè®°è´¦å¤ªè¿‡ç¹çï¼Œä¸”è®°è´¦äº§ç”Ÿçš„æ•°æ®åƒä¸€æ½­æ­»æ°´ï¼Œæ— æ³•äº§ç”Ÿå®é™…çš„æŒ‡å¯¼ä»·å€¼ã€‚è€Œç”¨beancount+favaï¼Œå¯ä»¥å…‹æœè¿™ä¸¤ä¸ªç¼ºç‚¹ã€‚ç°åœ¨å¤§å¤šæ•°ç½‘ç«™ï¼Œæ¯”å¦‚æ”¯ä»˜å®å’Œå¾®ä¿¡æ”¯ä»˜ï¼Œéƒ½å¯ä»¥å¯¼å‡ºè´¦å•ï¼Œæˆ‘ä»¬ä¸éš¾å†™ä¸ªè„šæœ¬å°†å…¶è½¬åŒ–æˆç¬¦åˆbeancountè¯­æ³•çš„æ–‡æœ¬æ•°æ®ã€‚favaå°†æ•°æ®å¯è§†åŒ–åï¼Œå«æœ‰æŸç›Šè¡¨ã€èµ„äº§è´Ÿå€ºè¡¨ã€è¯•ç®—è¡¨ã€èµ„äº§ã€ç»Ÿè®¡ç­‰ç•Œé¢ï¼Œå¯ä»¥å¾ˆç›´è§‚åœ°çœ‹åˆ°è‡ªå·±çš„æ”¶æ”¯æƒ…å†µã€èµ„äº§è´Ÿå€ºæƒ…å†µç­‰ã€‚è¿™äº›ä¸œè¥¿éœ€è¦ä¸€äº›è´¢åŠ¡çŸ¥è¯†æ‰èƒ½ç†è§£ï¼Œæˆ‘ä¸»è¦é€šè¿‡æœç´¢å¼•æ“+çœ‹ä¹¦æ¥å­¦ä¹ ï¼Œè¿™é‡Œæ¨èä¸€æœ¬ä¹¦ï¼Œä¹¦åå«ã€Šç»™åˆ›ä¸šå°ç™½çš„è´¢æŠ¥ä¹¦ã€‹ï¼Œè±†ç“£è¯„åˆ†9.0ï¼Œå€¼å¾—ä¸€è¯»ã€‚ æˆ‘è®¤ä¸ºå®ç°è´¢åŠ¡è‡ªç”±æœ€å…³é”®çš„æ˜¯å¢åŠ æ”¶å…¥ä»¥åŠé€šè¿‡æŠ•èµ„æ¥å¢åŠ å‡€èµ„äº§ã€‚å¢åŠ å‡€èµ„äº§ï¼Œå¯ä»¥é€šè¿‡è´­ä¹°å€ºåˆ¸ã€åŸºé‡‘ã€è‚¡ç¥¨ã€æˆ¿åœ°äº§ç­‰æ–¹å¼ã€‚å¾…æ‰€è´­èµ„äº§å®ç°å¢å€¼åï¼Œæˆ‘ä»¬çš„å‡€èµ„äº§ä¹Ÿå°±å¢åŠ äº†ã€‚ç°åœ¨æˆ‘å¯¹äºå­˜æ¬¾çš„å¤„ç†æ–¹å¼æ˜¯ç›´æ¥è´­ä¹°åŸºé‡‘ï¼Œå› ä¸ºæ¯”è¾ƒæ–¹ä¾¿ã€‚ä½†æ˜¯è´­ä¹°åŸºé‡‘æ˜¯ä¸€ç§ä½é£é™©ä½æ”¶ç›Šçš„æŠ•èµ„æ´»åŠ¨ï¼Œè™½ç„¶å¯ä»¥å®ç°è´¢å¯Œå¢é•¿ï¼Œä½†è‹¥æƒ³å°½å¿«å®ç°è´¢åŠ¡è‡ªç”±è¿™ä¸ªç›®æ ‡ï¼Œä¾é æ­¤æ–¹å¼æ˜¯è¡Œä¸é€šçš„ã€‚æ‰€ä»¥æœ‰å¿…è¦å»å­¦ä¹ å…¶ä»–æŠ•èµ„æ–¹å¼ï¼Œè¿™é‡ŒæŒ–ä¸ªå‘ï¼Œä»¥åå­¦äº†å†è¡¥ä¸Šã€‚ è™½ç„¶è´¢åŠ¡è‡ªç”±å¬èµ·æ¥å¾ˆè™šå¹»å¾ˆé¥è¿œï¼Œä½†æ˜¯æˆ‘è§‰å¾—é€šè¿‡ä¸€å®šçš„åŠªåŠ›æ˜¯èƒ½å¤Ÿè¾¾åˆ°çš„ã€‚å½“ç„¶ï¼Œæ¯ä¸ªäººå¯¹äºè´¢åŠ¡è‡ªç”±çš„å®šä¹‰ä¼šæœ‰æ‰€ä¸åŒï¼Œæˆ‘è‡ªå·±çš„è¦æ±‚æ¯”è¾ƒä½ï¼Œèµ„äº§æ‰€äº§ç”Ÿçš„æ”¶ç›Šèƒ½è¶…è¿‡æ—¥å¸¸å¼€é”€å³ç®—è´¢åŠ¡è‡ªç”±ã€‚å…±å‹‰ã€‚]]></content>
      <tags>
        <tag>ç†è´¢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git ç®€æ˜æ‰‹å†Œ | å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F07%2F02%2Fgit-book%2F</url>
    <content type="text"><![CDATA[è¿­ä»£è®°å½• 190702 é¦–æ¬¡æäº¤ æ–‡ä»¶ å…¨å±€é…ç½®æ–‡ä»¶ï¼š~/.gitconfig é¡¹ç›®é…ç½®æ–‡ä»¶ï¼š&lt;project&gt;/.git/config å‘½ä»¤git add12345678# æ·»åŠ æ–‡ä»¶åˆ°ä»“åº“git add &lt;FILE&gt;# æŠŠå½“å‰æ‰€æœ‰ä½ç½®çš„æ‰€æœ‰æ–‡ä»¶éƒ½æ·»åŠ åˆ°ä»“åº“ä¸­git add .# å…è®¸æŒ‡å®šaddå…·ä½“å“ªäº›å†…å®¹ï¼Œä½¿ç”¨?æŸ¥çœ‹é€‰é¡¹çš„è§£é‡Šgit add -p git branch12345678910111213141516171819202122232425# æŸ¥çœ‹æœ¬åœ°åˆ†æ”¯git branch# æŸ¥çœ‹è¿œç¨‹åˆ†æ”¯git branch -r# æŸ¥çœ‹æœ¬åœ°åˆ†æ”¯+è¿œç¨‹åˆ†æ”¯git branch -a# åˆ›å»ºåˆ†æ”¯git branch &lt;name&gt;# åˆ é™¤åˆ†æ”¯git branch -d &lt;name&gt;# åˆ é™¤è¿œç¨‹åˆ†æ”¯git branch -dr [remote/branch]# æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œä¸æŒ‡å®šçš„åˆ†æ”¯å»ºç«‹è¿½è¸ªå…³ç³»ï¼Œä¸€èˆ¬æ˜¯å¯¹è¿œç¨‹åˆ†æ”¯å»ºç«‹è¿½è¸ªå…³ç³»git branch --track [newBranch] [remote/branch]# eggit branch --track mage origin/mage# å»ºç«‹è¿½è¸ªå…³ç³»ï¼Œåœ¨ç°æœ‰åˆ†æ”¯ä¸æŒ‡å®šçš„è¿œç¨‹åˆ†æ”¯ä¹‹é—´ | å·²ç»å¼ƒç”¨git branch --set-upstream [branch] [remote/branch] git checkout1234567891011121314# åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªåˆ†æ”¯git checkout -# æ’¤é”€å¯¹å½“å‰å·¥ä½œåŒºæ–‡ä»¶çš„ä¿®æ”¹ã€‚å…¶ä¸­--çš„ä½œç”¨æ˜¯è¡¨æ˜åé¢çš„å‚æ•°æ˜¯æ–‡ä»¶åï¼Œè€Œä¸æ˜¯åˆ†æ”¯åã€‚git checkout -- FILE# åˆ‡æ¢åˆ†æ”¯git checkout &lt;name&gt;# åˆ›å»º+åˆ‡æ¢åˆ†æ”¯git checkout -b &lt;name&gt;# åœ¨origin/masterçš„åŸºç¡€ä¸Šï¼Œåˆ›å»ºä¸€ä¸ªæ–°åˆ†æ”¯ã€‚git checkout -b &lt;name&gt; origin/master git cherry-pick12# é€‰æ‹©ä¸€ä¸ªcommitï¼Œåˆå¹¶è¿›å½“å‰åˆ†æ”¯git cherry-pick [commit] git clone12345# åªå…‹éš†ä»“åº“çš„æœ€æ–°ä¸€ä¸ªç‰ˆæœ¬ï¼Œå¯¹äºå¤šæ¬¡æäº¤çš„ä»“åº“å¯æ˜æ˜¾æé«˜cloneé€Ÿåº¦git clone --depth=1 ä»“åº“åœ°å€# ä½¿ç”¨-oæŒ‡å®šè¿œç¨‹åˆ†æ”¯åï¼Œå‡å¦‚ä¸æŒ‡å®šï¼Œé»˜è®¤æ˜¯origingit clone -o jQuery https://github.com/jquery/jquery.git git commit123456789101112# æŠŠæ–‡ä»¶æäº¤åˆ°ä»“åº“git commit# å¯ä»¥é€‰æ‹©éƒ¨åˆ†æ–‡ä»¶commitgit commit &lt;file1&gt; &lt;file2&gt;...# ä½¿ç”¨ä¸€æ¬¡æ–°çš„commitï¼Œæ›¿ä»£ä¸Šä¸€æ¬¡æäº¤# å®ƒä¸€èˆ¬é€‚ç”¨äºè¿˜æœªæäº¤åˆ°è¿œç¨‹ä»“åº“çš„æäº¤ï¼Œä¹Ÿé€‚ç”¨äºgerritï¼Œä¸é€‚ç”¨äºGithubgit commit --amend# ä¸æ›´æ”¹è¯„è®ºä¿¡æ¯git commit --amend --no-edit git config123456789# è®¾ç½®æäº¤ä»£ç æ—¶çš„ç”¨æˆ·ä¿¡æ¯ã€‚git config [--global] user.name "Username"git config [--global] user.email "email@example.com"# æ˜¾ç¤ºå½“å‰çš„gité…ç½®ã€‚git config --list# ç¼–è¾‘Gité…ç½®æ–‡ä»¶ã€‚git config -e [â€”global] git diff12# å¯ä»¥å°†FILEç°åœ¨çš„çŠ¶æ€å’Œæœ€è¿‘ä¸€æ¬¡addåˆ°ä»“åº“çš„çŠ¶æ€è¿›è¡Œä¸€æ¬¡diffã€‚git diff FILE git fetch123456789101112# å–å›åˆ†æ”¯ï¼Œä½†æ˜¯å¹¶ä¸åˆå¹¶ã€‚git fetch &lt;è¿œç¨‹ä¸»æœºå&gt; &lt;åˆ†æ”¯å&gt; # æŒ‡å®šå–å“ªä¸ªåˆ†æ”¯ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¼šå–æ‰€æœ‰åˆ†æ”¯ã€‚git fetch &lt;åˆ†æ”¯å&gt;# å–å›è¿œç¨‹åˆ†æ”¯åˆ°æœ¬åœ°æŸä¸ªåˆ†æ”¯ï¼Œå‡å¦‚æœ¬åœ°åˆ†æ”¯ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºã€‚ä¸ä¼šåˆ‡æ¢åˆ°è¯¥åˆ†æ”¯ã€‚git fetch &lt;è¿œç¨‹ä¸»æœºå&gt; &lt;è¿œç¨‹åˆ†æ”¯å&gt;:&lt;æœ¬åœ°åˆ†æ”¯å&gt;git fetch origin :branch2# ç­‰ä»·äºgit fetch origin master:branch2 git init12# åˆå§‹åŒ–ä»“åº“git init git log12# æŸ¥çœ‹commitæ—¥å¿—git log git merge12# åˆå¹¶æŒ‡å®šåˆ†æ”¯åˆ°å½“å‰åˆ†æ”¯git merge [branch] git mv12# æ”¹åæ–‡ä»¶ï¼Œå¹¶ä¸”å°†è¿™ä¸ªæ”¹åæ”¾å…¥æš‚å­˜åŒºgit mv [file-original] [file-renamed] git pull1234567891011121314# æŸäº›éƒ¨åˆ†å¯çœç•¥ã€‚git pull &lt;è¿œç¨‹ä¸»æœºå&gt; &lt;è¿œç¨‹åˆ†æ”¯å&gt;:&lt;æœ¬åœ°åˆ†æ”¯å&gt;# ä¸Šé¢å‘½ä»¤è¡¨ç¤ºï¼Œå–å›origin/nextåˆ†æ”¯ï¼Œå†ä¸å½“å‰åˆ†æ”¯åˆå¹¶ã€‚git pull origin next# ä¸Šé¢å‘½ä»¤æŒ‡å®šmasteråˆ†æ”¯è¿½è¸ªorigin/nextåˆ†æ”¯ã€‚git branch --set-upstream master origin/next# ä¸Šé¢å‘½ä»¤è¡¨ç¤ºï¼Œæœ¬åœ°çš„å½“å‰åˆ†æ”¯è‡ªåŠ¨ä¸å¯¹åº”çš„originä¸»æœº"è¿½è¸ªåˆ†æ”¯"è¿›è¡Œåˆå¹¶ã€‚git pull origin# ä¸Šé¢å‘½ä»¤è¡¨ç¤ºï¼Œå½“å‰åˆ†æ”¯è‡ªåŠ¨ä¸å”¯ä¸€ä¸€ä¸ªè¿½è¸ªåˆ†æ”¯è¿›è¡Œåˆå¹¶ã€‚git pull git push1234567891011121314# æ ‡å‡†æ ¼å¼git push &lt;è¿œç¨‹ä¸»æœºå&gt; &lt;æœ¬åœ°åˆ†æ”¯å&gt;:&lt;è¿œç¨‹åˆ†æ”¯å&gt;# ä¸Šé¢å‘½ä»¤å°†æœ¬åœ°çš„masteråˆ†æ”¯æ¨é€åˆ°originä¸»æœºï¼ŒåŒæ—¶æŒ‡å®šoriginä¸ºé»˜è®¤ä¸»æœºï¼Œåé¢å°±å¯ä»¥ä¸åŠ ä»»ä½•å‚æ•°ä½¿ç”¨git pushäº†ã€‚git push -u origin master# å°†æœ¬åœ°åˆ†æ”¯æ¨é€åˆ°è¿œç¨‹ä¸»æœºã€‚gut push origin &lt;æœ¬åœ°åˆ†æ”¯å&gt;# åˆ é™¤è¿œç¨‹åˆ†æ”¯ã€‚git push origin --delete &lt;name&gt;# æäº¤æ‰€æœ‰taggit push [remote] --tags git rebase12 git reflog12# æŸ¥çœ‹å¼•ç”¨æ—¥å¿—ï¼Œå¯ä»¥å›åˆ°â€œæœªæ¥â€ã€‚git reflog git remote1234567891011121314151617# åˆ—å‡ºæ‰€æœ‰è¿œç¨‹ä¸»æœºã€‚git remote# å¯ä»¥å‚çœ‹è¿œç¨‹ä¸»æœºçš„ç½‘å€ã€‚git remote -v# æŸ¥çœ‹ä¸»æœºçš„è¯¦ç»†ä¿¡æ¯ã€‚git remote show &lt;ä¸»æœºå&gt;# ç”¨äºåˆ é™¤è¿œç¨‹ä¸»æœºã€‚git remote rm &lt;ä¸»æœºå&gt;# ç”¨äºè¿œç¨‹ä¸»æœºçš„æ”¹åã€‚git remote rename &lt;åŸä¸»æœºå&gt; &lt;æ–°ä¸»æœºå&gt;# å°†ä»“åº“è¿æ¥åˆ°è¿œç¨‹æœåŠ¡å™¨ã€‚ä¸€èˆ¬æ˜¯åœ¨git initåä½¿ç”¨ï¼Œç»‘å®šè¿œç¨‹ä¸»æœºã€‚git remote add origin &lt;server&gt; git reset12345678# æ’¤é”€å¯¹å½“å‰ç¼“å­˜åŒºçš„ä¿®æ”¹ï¼Œç›¸å½“äº`git add`çš„åæ“ä½œã€‚git reset -- &lt;file&gt;# æ’¤é”€å¯¹å½“å‰ç¼“å­˜åŒºçš„ä¿®æ”¹ã€‚git reset HEAD &lt;file&gt;# è®©HEADæŒ‡é’ˆæŒ‡åˆ°commit_idä»£è¡¨çš„çŠ¶æ€ã€‚é¡ºä¾¿ä¸€æï¼ŒHEAD^è¡¨ç¤ºä¸Šä¸€ä¸ªçŠ¶æ€ï¼ŒHEAD^^è¡¨ç¤ºä¸Šä¸Šä¸ªçŠ¶æ€ã€‚git reset --hard commit_id git revert12# è¿œç¨‹åˆ†æ”¯git revert git rm12345# åˆ é™¤å·¥ä½œåŒºæ–‡ä»¶ï¼Œå¹¶ä¸”å°†è¿™æ¬¡åˆ é™¤æ”¾å…¥æš‚å­˜åŒºã€‚å³åˆ é™¤è¿œç¨‹æ–‡ä»¶å’Œæœ¬åœ°æ–‡ä»¶ã€‚git rm [file1] [file2] ...# åœæ­¢è¿½è¸ªæŒ‡å®šæ–‡ä»¶ï¼Œä½†è¯¥æ–‡ä»¶ä¼šä¿ç•™åœ¨å·¥ä½œåŒºã€‚å³åˆ é™¤è¿œç¨‹æ–‡ä»¶ï¼Œä½†ä¸åˆ é™¤æœ¬åœ°æ–‡ä»¶ã€‚git rm --cached [file] git status12# æŸ¥çœ‹ä»“åº“å½“å‰çš„çŠ¶æ€git status git tag1234567891011121314# æ·»åŠ äº†tagçš„commitå°±ä¼šå°†æºç æ·»åŠ åˆ°æ‰“åŒ…ï¼Œä¸€èˆ¬ç”¨ç‰ˆæœ¬å·ä¸ºtagå‘½å# åœ¨Githubä¸Šçœ‹åˆ°çš„releaseä¸æ˜¯gitæä¾›çš„ï¼Œè€Œæ˜¯ä»£ç æ‰˜ç®¡ç½‘ç«™å‡ºäºæ»¡è¶³å¼€å‘è€…å‘å¸ƒäºŒè¿›åˆ¶æ–‡ä»¶çš„éœ€æ±‚è€Œå¼€å‘çš„# åˆ—å‡ºæ‰€æœ‰taggit tag# æ–°å»ºä¸€ä¸ªtagåœ¨å½“å‰commitgit tag [tag]# æ–°å»ºä¸€ä¸ªtagåœ¨æŒ‡å®šcommitgit tag [tag] [commit]# åˆ é™¤æœ¬åœ°taggit tag -d [tag]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode é¢˜è§£ C++ é“¾è¡¨æ€»ç»“]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-linked-list%2F</url>
    <content type="text"><![CDATA[æ€»ç»“ æœ‰æ—¶å€™åŠ ä¸ªå†—ä½™å¤´èŠ‚ç‚¹ä¼šå¤§å¤§é™ä½å®ç°éš¾åº¦ï¼Œè®©ä»£ç å˜å¾—æ›´ç®€æ´ã€‚ åšä¸é“¾è¡¨ç›¸å…³çš„é¢˜ç›®ä¸€å®šè¦åœ¨å†™ä»£ç å‰å°±æƒ³æ¸…æ¥šç®—æ³•çš„å„ä¸ªæ­¥éª¤ï¼Œæƒ³å¥½è¦ä¿å­˜å“ªäº›æŒ‡é’ˆã€‚å¦åˆ™å¾ˆå®¹æ˜“å†™ä¹±ã€‚ è¦æ³¨æ„deleteæ‰åˆ é™¤æ‰çš„èŠ‚ç‚¹ï¼Œé¿å…å†…å­˜æ³„éœ²ã€‚ Leetcode 2 Add Two Numbersé¢˜æ„ç”¨é“¾è¡¨å­˜å‚¨åè¿›åˆ¶æ•°å­—çš„å„ä½ï¼Œç°åœ¨ç»™è¿™æ ·çš„ä¸¤ä¸ªé“¾è¡¨ï¼Œæ±‚å’Œã€‚ åˆ†æç”±äºé“¾è¡¨å¤´å­˜çš„æ˜¯æœ€ä½ä½ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åŒæ—¶æ‰«æä¸¤ä¸ªé“¾è¡¨ï¼Œæ¨¡æ‹Ÿä¸€ä¸‹åŠ æ³•å°±è¡Œäº†ã€‚å‡å¦‚ç”¨C++å†™çš„è¯ï¼Œå¯ä»¥å…ˆå¼€ä¸€ä¸ªå†—ä½™å¤´æŒ‡é’ˆï¼Œæ–¹ä¾¿å®ç°ã€‚æ³¨æ„ç”³è¯·æˆ–é‡Šæ”¾å†…å­˜æ—¶ï¼Œåº”è¯¥è¦ç”¨newå’Œdeleteè€Œä¸è¦ç”¨mallocå’Œfreeï¼Œå…»æˆè‰¯å¥½çš„ç¼–ç¨‹ä¹ æƒ¯ã€‚å‡è®¾ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦åˆ†åˆ«ä¸ºnå’Œmï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯$O(n + m)$ï¼Œæ˜¾ç„¶ç©ºé—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ°$O(1)$ã€‚ ä»£ç 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *dummy = new ListNode(0); ListNode *p = dummy; int carry = 0; while (l1 || l2) &#123; int x = l1 ? l1-&gt;val : 0; int y = l2 ? l2-&gt;val : 0; int sum = x + y + carry; carry = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; &#125; if (carry) p-&gt;next = new ListNode(1); p = dummy-&gt;next; delete dummy; return p; &#125;&#125;; Leetcode 19 Remove Nth Node From End of Listé¢˜æ„ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œè¦æ±‚åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ã€‚ åˆ†æè¿™é“é¢˜çš„è¾¹ç•Œæƒ…å†µæ˜¯åˆ é™¤é“¾è¡¨é¦–ä¸ªèŠ‚ç‚¹ã€‚æˆ‘ä»¬ç”¨ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘è¡¨å¤´ï¼Œç„¶åè®©å…¶ä¸­ä¸€ä¸ªæŒ‡é’ˆå…ˆèµ°næ­¥ï¼Œå‡å¦‚èµ°å®Œnæ­¥åæŒ‡å‘äº†ç©ºæŒ‡é’ˆï¼Œè¯´æ˜åˆ é™¤çš„æ˜¯è¡¨å¤´ã€‚å‡å¦‚èµ°å®Œä¸æ˜¯ç©ºæŒ‡é’ˆï¼Œåˆ™è®©å¦å¤–ä¸€ä¸ªæŒ‡é’ˆå¼€å§‹å’Œå®ƒä¸€æ­¥ä¸€æ­¥èµ°ï¼Œç›´åˆ°å‰é¢çš„æŒ‡é’ˆæŒ‡åˆ°äº†æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œåé¢çš„æŒ‡é’ˆåˆšå¥½æŒ‡å‘å¾…åˆ é™¤èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ã€‚ ä»£ç 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int k) &#123; if (head == nullptr || k &lt;= 0) return nullptr; ListNode *behind = head, *ahead = head; for (int i = 0; i &lt; k; i++) &#123; ahead = ahead-&gt;next; &#125; if (ahead == nullptr) &#123; ListNode *temp = head; head = head-&gt;next; delete(temp); return head; &#125; while (ahead-&gt;next != nullptr) &#123; ahead = ahead-&gt;next; behind = behind-&gt;next; &#125; ListNode *temp = behind-&gt;next; behind-&gt;next = behind-&gt;next-&gt;next; delete(temp); return head; &#125;&#125;; Leetcode 21 Merge Two Sorted Listsé¢˜æ„åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ã€‚ åˆ†æç›´æ¥å†™å°±è¡Œäº†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(n+m)$ï¼Œå…¶ä¸­nå’Œmä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ã€‚ ä»£ç 1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummy = new ListNode(0); ListNode *p = dummy; while(l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; p-&gt;next = l1 ? l1 : l2; p = dummy-&gt;next; delete(dummy); return p; &#125;&#125;; Leetcode 23 Merge k Sorted Listsé¢˜æ„åˆå¹¶kä¸ªæœ‰åºé“¾è¡¨ã€‚ åˆ†ææˆ‘ä»¬éœ€è¦ä¸€ç§æ•°æ®ç»“æ„æ¥è¾ƒå¿«åœ°æ’å…¥ä¸€ä¸ªæ•°ï¼Œå–å‡ºæœ€å°çš„æ•°ï¼Œåˆ é™¤æœ€å°çš„æ•°ã€‚ä¸éš¾æƒ³åˆ°ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥æ»¡è¶³è¿™äº›è¦æ±‚ã€‚å‡è®¾kä¸ªé“¾è¡¨çš„èŠ‚ç‚¹ä¸ªæ•°å’Œä¸ºnï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¸º$O(nlogk)$ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;private: struct Node &#123; ListNode *p; int idx; Node(ListNode *p, int idx) &#123; this-&gt;p = p; this-&gt;idx = idx; &#125; bool operator &lt; (const Node &amp;rhs) const &#123; return p-&gt;val &gt; rhs.p-&gt;val; &#125; &#125;;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; priority_queue&lt;Node&gt; que; for (int i = 0; i &lt; lists.size(); i++) &#123; if (lists[i]) &#123; que.push(Node(lists[i], i)); lists[i] = lists[i]-&gt;next; &#125; &#125; ListNode *dummy = new ListNode(0); ListNode *p = dummy; while(!que.empty()) &#123; Node node = que.top(); que.pop(); if (lists[node.idx] != nullptr) &#123; int idx = node.idx; que.push(Node(lists[idx], idx)); lists[idx] = lists[idx]-&gt;next; &#125; p-&gt;next = node.p; p = p-&gt;next; &#125; p = dummy-&gt;next; delete(dummy); return p; &#125;&#125;; Leetcode 24 Swap Nodes in Pairsé¢˜æ„ä¸¤ä¸¤äº¤æ¢é“¾è¡¨çš„ç›¸é‚»èŠ‚ç‚¹ã€‚ åˆ†æé€’å½’æ¥å†™ï¼Œåˆ†ä¸‰ç§æƒ…å†µï¼Œå½“å‰èŠ‚ç‚¹æ˜¯ç©ºèŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹æ²¡æœ‰åç»§ï¼Œå½“å‰èŠ‚ç‚¹æœ‰åç»§ã€‚ ä»£ç 12345678910111213141516class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (head == nullptr) &#123; return nullptr; &#125; if (head-&gt;next == nullptr) &#123; return head; &#125; ListNode *newHead = head-&gt;next; ListNode *nex = head-&gt;next-&gt;next; newHead-&gt;next = head; head-&gt;next = swapPairs(nex); return newHead; &#125;&#125;; Leetcode 25 Reverse Nodes in k-Groupé¢˜æ„æ˜¯Leetcode 24çš„å‡çº§ç‰ˆï¼Œéœ€è¦å°†é“¾è¡¨çš„æ¯kä¸ªèŠ‚ç‚¹ç¿»è½¬ã€‚ åˆ†æç”¨è¿­ä»£æ¥å†™ï¼Œå…ˆåŠ ä¸ªå†—ä½™å¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿å®ç°ã€‚éœ€è¦è®°å½•kèŠ‚ç‚¹ç»„çš„å‰ä¸€ä¸ªèŠ‚ç‚¹pï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹headï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹tailã€‚ç„¶åï¼Œæˆ‘ä»¬ä¸æ–­åœ°å°†pçš„åä¸€ä¸ªèŠ‚ç‚¹æ‰”åˆ°tailçš„åé¢å³å¯ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (head == nullptr || head-&gt;next == nullptr || k &lt; 2) return head; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *p = dummy, *tail = dummy, *temp = nullptr; while (true) &#123; int count = 0; while (count != k &amp;&amp; tail != nullptr) &#123; tail = tail-&gt;next; count++; &#125; if (tail == nullptr) &#123; break; &#125; head = p-&gt;next; while (p-&gt;next != tail) &#123; temp = p-&gt;next; p-&gt;next = temp-&gt;next; temp-&gt;next = tail-&gt;next; tail-&gt;next = temp; &#125; p = tail = head; &#125; p = dummy-&gt;next; delete(dummy); return p; &#125;&#125;; Leetcode 61 Rotate Listé¢˜æ„å›è½¬é“¾è¡¨ï¼Œæ³¨æ„ä¸æ˜¯åè½¬é“¾è¡¨ã€‚ åˆ†æåˆ†ä¸‰æ­¥ï¼Œé¦–å…ˆæ±‚å‡ºé“¾è¡¨é•¿åº¦ä»¥åŠæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åæ‰¾åˆ°å›è½¬åçš„é¦–ä¸ªèŠ‚ç‚¹çš„å‰ç»§ï¼Œæœ€åä¿®æ”¹ä¸€ä¸‹å®ƒä»¬çš„æŒ‡é’ˆå³å¯ã€‚ ä»£ç 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if (head == nullptr) return nullptr; ListNode *p = head, *lastNode; int len = 1; while (p-&gt;next) &#123; len++; p = p-&gt;next; lastNode = p; &#125; k %= len; if (k == 0) return head; k = len - k - 1; ListNode *pre = head; while (k--) &#123; pre = pre-&gt;next; &#125; lastNode-&gt;next = head; head = pre-&gt;next; pre-&gt;next = nullptr; return head; &#125;&#125;; Leetcode 82 Remove Duplicates from Sorted List IIé¢˜æ„åˆ é™¤æœ‰åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ã€‚ åˆ†æç”³è¯·ä¸ªå†—ä½™èŠ‚ç‚¹ä¼šæ¯”è¾ƒå¥½å®ç°ç‚¹ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *dummy = new ListNode(0); ListNode *p = dummy; while (head) &#123; ListNode *p2 = head; while (p2-&gt;next &amp;&amp; p2-&gt;next-&gt;val == head-&gt;val) &#123; p2 = p2-&gt;next; &#125; if (head != p2) &#123; while (head != p2) &#123; ListNode *temp = head-&gt;next; delete(head); head = temp; &#125; head= p2-&gt;next; delete(p2); &#125; else &#123; p-&gt;next = head; p = p-&gt;next; head = head-&gt;next; p-&gt;next = nullptr; &#125; &#125; ListNode *temp = dummy-&gt;next; delete(dummy); return temp; &#125;&#125;; Leetcode 83 Remove Duplicates from Sorted Listé¢˜æ„åˆ é™¤æœ‰åºé“¾è¡¨ä¸­çš„å¤šä½™çš„é‡å¤å…ƒç´ ï¼Œå³è¦ä¿è¯æ¯ä¸ªå…ƒç´ æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚ åˆ†æç›´æ¥æ‰«ä¸€éå°±è¡Œäº†ï¼Œæ³¨æ„deleteæ‰åˆ æ‰çš„èŠ‚ç‚¹ã€‚ ä»£ç 12345678910111213141516class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *cur = head; while (cur &amp;&amp; cur-&gt;next) &#123; if (cur-&gt;next-&gt;val == cur-&gt;val) &#123; ListNode *temp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete(temp); &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return head; &#125;&#125;; Leetcode 86 Partition Listç•™å‘å¾…å¡«ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode é¢˜è§£ C++ Two Sum | 3Sum | 4Sum]]></title>
    <url>%2F2019%2F03%2F01%2Fleetcode-sum%2F</url>
    <content type="text"><![CDATA[Leetcode 1 Two Sumé¢˜æ„ç»™ä¸€ä¸ªvectorï¼Œä»ä¸­æ‰¾å‡ºä¸¤ä¸ªä¸åŒä¸‹æ ‡çš„å…ƒç´ ï¼Œä½¿å¾—å®ƒä»¬çš„å€¼ç­‰äºæŸä¸€ä¸ªå€¼ã€‚ åˆ†æ æ³•ä¸€ï¼šå…ˆæ’åºï¼Œç„¶ååŒæŒ‡é’ˆæ‰«ä¸€éã€‚æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlogn)$ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯$O(logn)$ã€‚ æ³•äºŒï¼šå“ˆå¸Œï¼Œç©ºé—´æ¢æ—¶é—´ã€‚æ—¶é—´å¤æ‚åº¦$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯$O(n)$ã€‚ ä¸‹é¢ç»™å‡ºæ³•äºŒçš„ä»£ç ã€‚ ä»£ç 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); i++) &#123; int diff = target - nums[i]; auto it = m.find(diff); if (it != m.end()) &#123; vector&lt;int&gt; ans; ans.push_back(it-&gt;second); ans.push_back(i); return ans; &#125; m[nums[i]] = i; &#125; return vector&lt;int&gt;(-1, -1); &#125;&#125;; Leetcode 15 3Sumé¢˜æ„ç»™ä¸€ä¸ªvectorï¼Œä»ä¸­æ‰¾å‡ºæ‰€æœ‰ä¸‰ä¸ªä¸åŒä¸‹æ ‡çš„å…ƒç´ ï¼Œä½¿å¾—å®ƒä»¬çš„å€¼ç­‰äº0ã€‚å¦å¤–è¦æ±‚ä¸‰å…ƒç»„ä¸èƒ½é‡å¤ã€‚ åˆ†æå…ˆæ’åºï¼Œç„¶ååˆ©ç”¨æœ‰åºæ€§ï¼Œå°†åŸæœ¬éœ€è¦ä¸‰å±‚å¾ªç¯çš„éå†ç”¨ä¸€å±‚å¾ªç¯ + åŒæŒ‡é’ˆæ¥åšã€‚æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ã€‚ç”¨C++å†™çš„è¯ï¼Œéœ€è¦æ³¨æ„vectorçš„size()å‡½æ•°è¿”å›çš„æ˜¯vector::size_typeï¼Œä¸€èˆ¬æ˜¯unsigned intã€‚å› æ­¤ï¼Œå‡å¦‚ä¼ è¿›æ¥çš„vectorçš„å…ƒç´ ä¸ªæ•°å°‘äº2ï¼Œé‚£ä¹ˆnum.size() - 2è¿ç®—åå¾—åˆ°çš„æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ­£æ•°ï¼Œé€ æˆè¿è¡Œé”™è¯¯ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆåˆ¤æ–­ä¸€ä¸‹nums.size()çš„å¤§å°ï¼Œå‡å¦‚å°äº3ï¼Œé‚£ä¹ˆå°±ç›´æ¥è¿”å›äº†ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if (nums.size() &lt; 3) return ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (i == 0 || (nums[i] != nums[i-1])) &#123; int need = 0 - nums[i]; int lo = i + 1; int hi = nums.size() - 1; while (lo &lt; hi) &#123; if (nums[lo] + nums[hi] == need) &#123; ans.push_back(vector&lt;int&gt; &#123;nums[i], nums[lo], nums[hi]&#125;); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+1]) &#123; lo++; &#125; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi-1]) &#123; hi--; &#125; lo++, hi--; &#125; else if (nums[lo] + nums[hi] &lt; need) &#123; lo++; &#125; else &#123; hi--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; Leetcode 18 4Sumé¢˜æ„ç»™ä¸€ä¸ªvectorï¼Œä»ä¸­æ‰¾å‡ºæ‰€æœ‰å››ä¸ªä¸åŒä¸‹æ ‡çš„å…ƒç´ ï¼Œä½¿å¾—å®ƒä»¬çš„å€¼ç­‰äºæŸä¸ªå€¼ã€‚å¦å¤–è¦æ±‚å››å…ƒç»„ä¸èƒ½é‡å¤ã€‚ åˆ†æå…ˆæ’åºï¼Œç„¶ååˆ©ç”¨æœ‰åºæ€§ï¼Œå°†åŸæœ¬éœ€è¦å››å±‚å¾ªç¯çš„éå†ç”¨ä¸¤å±‚å¾ªç¯ + åŒæŒ‡é’ˆæ¥åšã€‚æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^3)$ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i &lt; n - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int lo = j + 1; int hi = n - 1; while (lo &lt; hi) &#123; int sum = nums[i] + nums[j] + nums[lo] + nums[hi]; if (sum == target) &#123; ans.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[lo], nums[hi]&#125;); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) &#123; lo++; &#125; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) &#123; hi--; &#125; lo++, hi--; &#125; else if (sum &gt; target) &#123; hi--; &#125; else &#123; lo++; &#125; &#125; &#125; &#125; return ans; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode é¢˜è§£ C++ Single Number I II III]]></title>
    <url>%2F2019%2F01%2F13%2Fleetcode-single-number%2F</url>
    <content type="text"><![CDATA[åœ¨Leetcodeä¸Šåšäº†Single Numberç³»åˆ—çš„ä¸‰é“é¢˜ï¼Œéƒ½æ˜¯ä¸ä½è¿ç®—æœ‰å…³çš„ï¼Œæ„Ÿè§‰éƒ½æŒºå·§å¦™ã€‚ Leetcode 136 Single Number Ié¢˜æ„ä¸€ç»„æ•°ä¸­åªæœ‰ä¸€ä¸ªæ•°å­—æ˜¯å‡ºç°ä¸€æ¬¡çš„ï¼Œå…¶ä»–çš„æ•°å­—éƒ½æ°å¥½å‡ºç°ä¸¤æ¬¡ï¼Œç°åœ¨æ±‚åªå‡ºç°ä¸€æ¬¡çš„æ•°æ˜¯å¤šå°‘ã€‚ åˆ†ææ ¹æ®å¼‚æˆ–çš„æ€§è´¨ï¼Œç­”æ¡ˆæ˜¯æ‰€æœ‰çš„æ•°å­—çš„å¼‚æˆ–å’Œã€‚ ä»£ç 12345678class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); i++) nums[0] ^= nums[i]; return nums[0]; &#125;&#125;; Leetcode 137 Single Number IIé¢˜æ„ä¸€ç»„æ•°ä¸­åªæœ‰ä¸€ä¸ªæ•°å­—æ˜¯å‡ºç°ä¸€æ¬¡çš„ï¼Œå…¶ä»–çš„æ•°å­—æ°å¥½éƒ½å‡ºç°ä¸‰æ¬¡ï¼Œç°åœ¨æ±‚åªå‡ºç°ä¸€æ¬¡çš„æ•°æ˜¯å¤šå°‘ã€‚ åˆ†ææ˜¾ç„¶ï¼Œå‡å¦‚è¿˜æ˜¯ç”¨ä¸Šä¸€é¢˜çš„åšæ³•ï¼Œç›´æ¥å°†æ•°å­—å¼‚æˆ–èµ·æ¥ï¼Œæ˜¯å¾—ä¸åˆ°ç­”æ¡ˆçš„ã€‚ä¸ºä»€ä¹ˆä¸Šä¸€é¢˜çš„ç­”æ¡ˆç›´æ¥å¼‚æˆ–èµ·æ¥å°±å¯ä»¥ï¼Œå› ä¸ºå‡ºç°ä¸¤æ¬¡çš„æ•°å­—å¼‚æˆ–åç­‰äºå‡ºç°é›¶æ¬¡ï¼Œå…·ä½“å¯¹äºæŸä¸€ä½æ¥è¯´ï¼Œå®ƒä¼šç»è¿‡0-&gt;1-&gt;0è¿™ä¹ˆä¸ªè¿‡ç¨‹ã€‚è€Œå¯¹äºè¿™é“é¢˜ï¼Œå‡å¦‚æŸä¸ªæ•°å­—å‡ºç°äº†ä¸‰æ¬¡ï¼Œé‚£ä¹ˆå¯¹äºå…·ä½“æŸä¸€ä½æ¥è¯´ï¼Œå®ƒä¼šç»è¿‡0-&gt;1-&gt;0-&gt;1è¿™ä¸ªè¿‡ç¨‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”ç”¨ä¸¤ä¸ªä½æ¥è¡¨ç¤ºå…·ä½“æŸä¸€ä½çš„çŠ¶æ€å˜åŒ–ï¼Œå³è®©å®ƒç»è¿‡00-&gt;10-&gt;01-&gt;00è¿™ä¹ˆä¸ªè¿‡ç¨‹ã€‚ ä»£ç 123456789101112class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ones = 0; int twos = 0; for (auto i: nums) &#123; ones = (ones ^ i) &amp; ~twos; twos = (twos ^ i) &amp; ~ones; &#125; return ones; &#125;&#125;; Leetcode 260 Single Number IIIé¢˜æ„ä¸€ç»„æ•°ä¸­åªæœ‰ä¸¤ä¸ªæ•°å­—æ˜¯å‡ºç°ä¸€æ¬¡çš„ï¼Œå…¶ä»–çš„æ•°å­—æ°å¥½éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œç°åœ¨æ±‚åªå‡ºç°ä¸€æ¬¡çš„æ•°æ˜¯å“ªä¸¤ä¸ªã€‚ åˆ†ææˆ‘ä»¬å…ˆå°†æ‰€æœ‰æ•°å­—å¼‚æˆ–èµ·æ¥ï¼Œå¾—åˆ°cã€‚è®¾ç­”æ¡ˆä¸ºaå’Œbï¼Œé‚£ä¹ˆc = a ^ bã€‚ å¯¹äºè¿™ä¸ªcçš„å„ä¸ªä½ï¼Œæœ‰çš„æ˜¯0ï¼Œæœ‰çš„æ˜¯1ã€‚å€¼ä¸º1çš„ä½ï¼Œæ„å‘³ç€åªå±äºaæˆ–bã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„å–cä¸­ä¸€ä¸ªå€¼ä¸º1çš„ä½ï¼Œå°†æ‰€æœ‰æ•°å­—åˆ’åˆ†ä¸ºä¸¤ä¸ªå¯é‡é›†åˆï¼Œè¿™ä¸¤ä¸ªé›†åˆçš„æ•°å­—åˆ†åˆ«å¼‚æˆ–èµ·æ¥å°±æ˜¯ç­”æ¡ˆã€‚ ä»£ç 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (auto i: nums) &#123; sum ^= i; &#125; sum &amp;= -sum; vector&lt;int&gt; ans = &#123;0, 0&#125;; for (auto i: nums) &#123; if (sum &amp; i) &#123; ans[0] ^= i; &#125; else &#123; ans[1] ^= i; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>ä½è¿ç®—</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åç¼€è‡ªåŠ¨æœºå­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2018%2F10%2F06%2Fsam-learning%2F</url>
    <content type="text"><![CDATA[åç¼€è‡ªåŠ¨æœº(SAM)æ˜¯ä¸€ç§ç”¨äºå¤„ç†å­—ç¬¦ä¸²çš„é«˜æ•ˆæ•°æ®ç»“æ„ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(|S| * CHARSET_SIZE)$ã€‚å…¶åº”ç”¨ä¸€èˆ¬ä¸å­ä¸²æœ‰å…³ï¼Œæ¯”å¦‚æ±‚è§£æœ€é•¿å…¬å…±å­ä¸²ã€æ±‚è§£ä¸åŒå­ä¸²çš„ä¸ªæ•°ã€æ±‚å­—å…¸åºç¬¬kå°çš„å­ä¸²ã€‚ é¢˜ç›®ä¼ é€é—¨ SPOJ LCS Longest Common Substringé¢˜æ„ç»™ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å®ƒä»¬çš„æœ€é•¿å…¬å…±å­ä¸²ã€‚ åˆ†æç”±äºå­—ç¬¦ä¸²é•¿åº¦ä¸Šé™250000ï¼Œæ‰€ä»¥$O(n^2)$çš„ç®—æ³•æ˜¯è¡Œä¸é€šçš„ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘ç»™å…¶ä¸­ä¸€ä¸ªå­—ç¬¦ä¸²å»ºç«‹åç¼€è‡ªåŠ¨æœºï¼Œè¯¥è‡ªåŠ¨æœºä¿å­˜äº†è¿™ä¸ªå­—ç¬¦ä¸²çš„æ‰€æœ‰å­ä¸²ã€‚æ¥ç€ï¼Œæˆ‘ä»¬åœ¨è¿™ä¸ªè‡ªåŠ¨æœºä¸Šè·‘å¦ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå‡å¦‚åŒ¹é…ï¼Œå°±èµ°ä¸‹ä¸€æ­¥ï¼Œå‡å¦‚ä¸åŒ¹é…ï¼Œå°±èµ°å¤±é…æŒ‡é’ˆï¼Œç›´åˆ°åŒ¹é…æˆ–è€…å›åˆ°äº†æ ¹èŠ‚ç‚¹ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œç»´æŠ¤ä¸€ä¸‹åŒ¹é…çš„é•¿åº¦ï¼Œä¸æ–­å–maxå³å¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 250009;/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 4 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; 26; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s) &#123; int ans = 0, now = 1, le = strlen(s), cnt = 0; for(int i = 0; i &lt; le; i++) &#123; int to = s[i] - 'a'; if(ch[now][to]) &#123; ans = max(ans, ++cnt); now = ch[now][to]; &#125; else &#123; while(now &amp;&amp; !ch[now][to]) now = fail[now]; if(now) &#123; cnt = len[now] + 1; now = ch[now][to]; ans = max(ans, cnt); &#125; else &#123; now = 1; cnt = 0; &#125; &#125; &#125; printf("%d\n", ans); &#125;&#125;sam;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; sam.init(); scanf("%s", s); int len = strlen(s); for(int i = 0; i &lt; len; i++) sam.insert(s[i]); scanf("%s", s); sam.solve(s); return 0;&#125; SPOJ LCS2 Longest Common Substring IIé¢˜æ„ç»™n($2 &lt;= n &lt;= 10$)ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å®ƒä»¬çš„æœ€é•¿å…¬å…±å­ä¸²ã€‚ åˆ†æè¿™ä¸€é¢˜åœ¨ä¸Šä¸€é¢˜çš„åŸºç¡€ä¸Šè¿›è¡Œäº†ä¸€å®šçš„æ‹“å±•ã€‚æˆ‘ä»¬è¿˜æ˜¯ç»™å…¶ä¸­ä¸€ä¸ªå­—ç¬¦ä¸²å»ºç«‹åç¼€è‡ªåŠ¨æœºï¼Œç„¶åå°†å…¶ä½™å­—ç¬¦ä¸²åœ¨è‡ªåŠ¨æœºä¸Šè·‘ä¸€éã€‚åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šï¼Œæˆ‘ä»¬éœ€è¦ç»´æŠ¤ä¸€ä¸ª$f$ï¼Œè¡¨ç¤ºæ‰€æœ‰å­—ç¬¦ä¸²åˆ°è¾¾è¯¥ç»“ç‚¹æ—¶çš„æœ€å¤§åŒ¹é…é•¿åº¦ï¼Œåˆå§‹åŒ–ä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„åœ¨è¯¥ç‚¹çš„$len$ã€‚å½“å…¶ä½™å­—ç¬¦ä¸²è¿›æ¥åŒ¹é…çš„æ—¶å€™ï¼Œç”¨å½“å‰æœ€å¤§åŒ¹é…é•¿åº¦æ¥æ›´æ–°è¿™ä¸ª$f$ï¼Œä¸æ–­å–minã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒæŸä¸ªç»“ç‚¹$u$è¢«è®¿é—®åˆ°ï¼Œä½†å…¶åç¼€é“¾æŒ‡å‘çš„ç»“ç‚¹$v$å¯èƒ½æ²¡è¢«è®¿é—®åˆ°ï¼Œä½†æ˜¯ï¼Œæ ¹æ®SAMåç¼€æ ‘çš„æ€§è´¨ï¼Œ$v$ç»“ç‚¹è¡¨ç¤ºçš„æœ€å¤§å­ä¸²æ˜¯ä¼šè¢«å®Œå…¨åŒ¹é…çš„ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å°†å­—ç¬¦ä¸²åœ¨è‡ªåŠ¨æœºè·‘å®Œä¸€éåï¼Œè¿˜éœ€è¦æ ¹æ®æ‹“æ‰‘åºå†åå‘æ›´æ–°ä¸€ä¸‹ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 4 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], mat[MAXN], f[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; 26; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void pre() &#123; for(int i = 1; i &lt; sz; i++) mat[i] = INF; &#125; void update(char *s) &#123; int le = strlen(s), lenn = 0, now = 1; for(int i = 1; i &lt; sz; i++) &#123; f[i] = 0; &#125; for(int i = 0; i &lt; le; i++) &#123; int ne = s[i] - 'a'; while(now != 1 &amp;&amp; !ch[now][ne]) now = fail[now], lenn = len[now]; if(ch[now][ne]) &#123; now = ch[now][ne]; f[now] = max(f[now], ++lenn); &#125; &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; // è¿™ä¸€å¥éå¸¸ç²¾é«“å•Š if(f[topo[i]]) f[fail[topo[i]]] = len[fail[topo[i]]]; &#125; for(int i = 1; i &lt; sz; i++) &#123; mat[i] = min(mat[i], f[i]); &#125; &#125; void solve() &#123; int ans = 0; for(int i = 1; i &lt; sz; i++) ans = max(ans, mat[i]); printf("%d\n", ans); &#125;&#125;sam;/************************************************************/char s[N];int len;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", s); sam.init(); len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.topoSort(); sam.pre(); while(~scanf("%s", s)) &#123; sam.update(s); &#125; sam.solve(); return 0;&#125; SPOJ NSUBSTR Substringsé¢˜æ„æ ¹æ®å­ä¸²çš„é•¿åº¦ï¼Œå¯å°†ä¸€ä¸ªé•¿ä¸º$|S|$çš„å­—ç¬¦ä¸²çš„æ‰€æœ‰å­ä¸²åˆ†åˆ°$|S|$ä¸ªé›†åˆä¸­ã€‚é—®åœ¨å„ä¸ªé›†åˆä¸­ï¼Œåœ¨æ¯ä¸²ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­ä¸²çš„å‡ºç°æ¬¡æ•°ï¼Ÿ åˆ†æè¦ç»Ÿè®¡æŸä¸€å­ä¸²å‡ºç°çš„æ¬¡æ•°ï¼Œéœ€è¦æŒ‰ç…§æ‹“æ‰‘åºé€†ç€æ›´æ–°ã€‚å½“è®¿é—®åˆ°æŸä¸€èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬æŠŠæœ€å¤§é•¿åº¦å­ä¸²æ‰€å±é›†åˆçš„ç­”æ¡ˆæ›´æ–°ä¸€ä¸‹ï¼Œç„¶åä¼ é€’ä¸€ä¸‹$cntPos$ç»™å¤±é…æŒ‡é’ˆæ‰€æŒ‡çš„ç»“ç‚¹ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªç»“ç‚¹è¡¨ç¤ºäº†å¤šä¸ªå­ä¸²ï¼Œä¸ºä»€ä¹ˆåªæ›´æ–°æœ€å¤§é•¿åº¦å­ä¸²æ‰€å±çš„é›†åˆå°±è¡Œäº†å‘¢ï¼Ÿå¯ä»¥è¿™æ ·ç†è§£ï¼Œå‡è®¾æŸä¸€èŠ‚ç‚¹çš„æœ€å¤§é•¿åº¦å­ä¸²ä¸º$S[Lâ€¦R]$ï¼Œæ ¹æ®SAMçš„æ€§è´¨ï¼Œ$S[L..(R-1)]$ä¸€å®šä¸ä¸S[Lâ€¦R]$åœ¨åŒä¸€ç»“ç‚¹ï¼Œä¸”å®ƒå‡ºç°çš„æ¬¡æ•°ä¸å°‘äº$S[Lâ€¦R]$ï¼Œå› æ­¤ï¼Œåç»­è®¿é—®åˆ°è¯¥ç»“ç‚¹æ—¶ä¼šæ›´æ–°$(R-1)$çš„ç­”æ¡ˆï¼Œè€Œé•¿åº¦æ›´çŸ­çš„åŒç†ï¼Œä¹Ÿæ˜¯ä¼šè¢«æ›´æ–°åˆ°ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 250009;char s[N];/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 2 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;-1&#125;, fail[MAXN], sz = 2, last = 1, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; memset(ch, 0, sizeof ch); memset(fail, 0, sizeof fail); memset(len, 0, sizeof len); memset(tong, 0, sizeof tong); memset(cntPos, 0, sizeof cntPos); last = 1; sz = 2; tong[0] = 1; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = last = sz++; cntPos[u] = 1; len[u] = len[v] + 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = sz++; len[n] = len[v] + 1; cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s) &#123; int ans[MAXN]; int le = strlen(s); memset(ans, 0, sizeof ans); for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; ans[len[u]] = max(ans[len[u]], cntPos[u]); // ? cntPos[fail[u]] += cntPos[u]; &#125; for(int i = 1; i &lt;= le; i++) &#123; printf("%d\n", ans[i]); &#125; &#125;&#125;sam;/************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%s", s)) &#123; sam.init(); int len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.topoSort(); &#125; sam.solve(s); return 0;&#125; SPOJ SUBLEX Lexicographical Substring Searché¢˜æ„ç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å­—å…¸åºç¬¬kå°çš„å­ä¸²ã€‚ åˆ†æé¦–å…ˆç»™å­—ç¬¦ä¸²å»ºç«‹SAMï¼Œè¯¥SAMä¿å­˜è¯¥å­—ç¬¦ä¸²çš„æ‰€æœ‰å­ä¸²ã€‚æ¥ç€ï¼Œä»æ ¹å‡ºå‘ï¼Œdfsä¸€éï¼Œå¯¹å„ä¸ªç»“ç‚¹ç»Ÿè®¡ä»è¯¥ç»“ç‚¹å‡ºå‘çš„å­ä¸²æ•°ã€‚ç„¶åï¼Œæˆ‘ä»¬å†ä»æ ¹å‡ºå‘ï¼Œè´ªå¿ƒåœ°èµ°å­—ç¬¦è¾ƒå°çš„è¾¹ã€‚å‡å¦‚ä¸€æ¡è¾¹åˆ°è¾¾çš„ç»“ç‚¹çš„å­ä¸²æ•°å¤§äºç­‰äºkï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å°±å¯ä»¥èµ°ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å‡å»è¯¥ç»“ç‚¹çš„å­ä¸²æ•°ï¼Œç„¶åæ‰¾å¦ä¸€æ¡è¾¹ã€‚ä¸€ç›´åšä¸‹å»ï¼Œç›´åˆ°kç­‰äº0äº†å°±åœæ­¢ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 3 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹pii G[MAXN][26];int ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;-1&#125;, fail[MAXN], sz = 2, last = 1, cntPos[MAXN];int tong[MAXN], topo[MAXN];int path[MAXN], p[MAXN];struct SuffixAutomaton &#123; void init() &#123; last = 1; sz = 2; tong[0] = 1; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = last = sz++; cntPos[u] = 1; len[u] = len[v] + 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = sz++; len[n] = len[v] + 1; cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; int cntPath(int u) &#123; if(path[u]) return path[u]; p[u] = 0; for(int i = 0; i &lt; 26; i++) &#123; if(ch[u][i]) &#123; path[u] += cntPath(ch[u][i]); G[u][p[u]++] = pii(ch[u][i], i); &#125; &#125; path[u]++; return path[u]; &#125; // æ³¨æ„ç”¨é€’å½’å†™æ³•ä¼šè¶…æ—¶ void findK(int u, int k) &#123; while(k) &#123; for(int i = 0; i &lt; p[u]; i++) &#123; int v = G[u][i].x; if(v &amp;&amp; path[v] &gt;= k) &#123; printf("%c", G[u][i].y + 'a'); k--; u = v; break; &#125; else &#123; k -= path[v]; &#125; &#125; &#125; printf("\n"); &#125;&#125;sam;/************************************************************/char ss[N];int q, lenn, k;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", ss); sam.init(); lenn = strlen(ss); for(int i = 0; i &lt; lenn; i++) sam.insert(ss[i]); scanf("%d", &amp;q); sam.cntPath(1); while(q--) &#123; scanf("%d", &amp;k); sam.findK(1, k); &#125; return 0;&#125; SPOJ COT4 Count on a trieç•™å‘å¾…å¡«ã€‚ HDU 4416 Good Article Good sentenceé¢˜æ„ç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¯ä»¥æœ‰å¾ˆå¤šå­ä¸²ï¼Œè®°ä¸ºé›†åˆAã€‚ç„¶åå†ç»™ä¸€äº›å­—ç¬¦ä¸²ï¼ŒåŒæ ·å¯ä»¥æœ‰å¾ˆå¤šå­ä¸²ï¼Œè®°ä¸ºé›†åˆBã€‚ç°åœ¨éœ€è¦æ±‚é›†åˆAå’Œé›†åˆBçš„å·®çš„å¤§å°ï¼Œå³åœ¨Aé›†åˆé‡Œå‡ºç°ä½†ä¸åœ¨Bé›†åˆé‡Œå‡ºç°çš„å…ƒç´ ä¸ªæ•°ã€‚ åˆ†æé¦–å…ˆç»™ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å»ºç«‹SAMï¼Œç„¶åä¾æ¬¡å°†å…¶ä½™çš„å­—ç¬¦ä¸²å–æ›´æ–°è¿™ä¸ªSAMã€‚SAMä¸­çš„å„ä¸ªç»“ç‚¹éœ€è¦ä¿å­˜ä¸€ä¸ªå€¼fï¼Œè¡¨ç¤ºè¢«å…¶ä½™å­—ç¬¦ä¸²åŒ¹é…åˆ°æœ€å¤§é•¿åº¦ã€‚å¯¹äºæŸä¸€ç»“ç‚¹uï¼Œfåˆå§‹åŒ–ä¸ºlen[fail[u]]ã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒåŒå¤šä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­ä¸²é—®é¢˜ä¸€æ ·ï¼Œåœ¨åŒ¹é…å®Œæ•´ä¸ªå­—ç¬¦ä¸²åï¼Œè¿˜éœ€è¦æ ¹æ®æ‹“æ‰‘åºé€†ç€æ›´æ–°fä¸€ä¸‹ã€‚æœ€åï¼Œæ‰€æœ‰èŠ‚ç‚¹çš„len - fçš„å’Œå³ä¸ºç­”æ¡ˆã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 4 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;-1&#125;, fail[MAXN], sz = 2, last = 1, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; int f[MAXN]; bool vis[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; 26; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void pre() &#123; memset(vis, 0, sizeof vis); for(int i = 1; i &lt; sz; i++) &#123; f[i] = len[fail[i]]; &#125; &#125; void update(char *s) &#123; int up = strlen(s), now = 1, le = 0; for(int i = 0; i &lt; up; i++) &#123; int v = s[i] - 'a'; while(now != 1 &amp;&amp; !ch[now][v]) now = fail[now], le = len[now]; if(ch[now][v]) &#123; now = ch[now][v]; vis[now] = true; le++; f[now] = max(f[now], le); &#125; &#125; &#125; void solve() &#123; for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; if(vis[u]) &#123; vis[fail[u]] = true; f[fail[u]] = len[fail[u]]; &#125; &#125; ll ans = 0; for(int i = 1; i &lt; sz; i++) &#123; ans += len[i] - f[i]; &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/int T, n, kase;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; printf("Case %d: ", ++kase); scanf("%d", &amp;n); scanf("%s", s); sam.init(); int len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.pre(); sam.topoSort(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); sam.update(s); &#125; sam.solve(); &#125; return 0;&#125; POJ 3415 Common Substringsé¢˜æ„ç»™ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚æ‰€æœ‰é•¿åº¦å¤§äºkçš„å…¬å…±å­ä¸²çš„å¯¹æ•°ã€‚ åˆ†ææˆ‘ä»¬çŸ¥é“ï¼ŒSAMä¸­æŸä¸ªèŠ‚ç‚¹ä»£è¡¨çš„æ˜¯é•¿åº¦è¿ç»­çš„æ•°ä¸ªåç¼€ï¼Œä¸å¦¨è®¾é•¿åº¦ä¸º$[L, R]$ã€‚åœ¨åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œé•¿åº¦ä¼šè½åœ¨$[L, R]$ä¹‹é—´ï¼Œæˆ‘ä»¬åªéœ€è¦åŠ ä¸Š$[k, R]$çš„è¿™æ®µï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ã€‚å¦å¤–ï¼Œè¿˜éœ€è¦æŒ‰ç…§æ‹“æ‰‘åºé€†ç€æ›´æ–°ä¸€ä¸‹ï¼Œè¿™é‡Œçš„æ›´æ–°éœ€è¦æ˜¯éœ€è¦è®¡æ•°çš„ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;int k;char s[N], t[N];/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 5 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * å¼€ç‚¹æ—¶æ‰åˆå§‹åŒ–ï¼Œåœ¨å¤šç»„æ ·ä¾‹çš„æƒ…å†µä¸‹ä¼šæ¯”ç›´æ¥memsetæ•´ä¸ªæ•°ç»„å¿«å¾ˆå¤šï¼Œæ¯”å¦‚HDU4416 * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 59;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; int sum[MAXN], vis[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; CHARSET_SIZE; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'A'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; sz; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s) &#123; topoSort(); for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; cntPos[fail[u]] += cntPos[u]; vis[i] = sum[i] = 0; &#125; int now = 1, le = 0; ll ans = 0; for(int i = 0, up = strlen(s); i &lt; up; i++) &#123; int v = s[i] - 'A'; while(now != 1 &amp;&amp; !ch[now][v]) now = fail[now], le = len[now]; if(ch[now][v]) &#123; now = ch[now][v]; le++; vis[now]++; if(le &gt;= k) &#123; ans += 1LL * cntPos[now] * (le - max(len[fail[now]] + 1, k) + 1); &#125; &#125; &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; if(vis[u]) &#123; sum[fail[u]] += vis[u]; vis[fail[u]] += vis[u]; &#125; &#125; for(int i = 1; i &lt; sz; i++) &#123; if(len[i] &gt;= k) &#123; ans += 1LL * sum[i] * cntPos[i] * (len[i] - max(len[fail[i]] + 1, k) + 1); &#125; &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d", &amp;k) &amp;&amp; k) &#123; scanf("%s%s", s, t); sam.init(); for(int i = 0, len = strlen(s); i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.solve(t); &#125; return 0;&#125; HDU 3518 Boring countingé¢˜æ„åˆ†æé¦–å…ˆç»™å­—ç¬¦ä¸²å»ºç«‹SAMï¼Œå¯¹äºå„ä¸ªç»“ç‚¹ï¼Œéœ€è¦é¢å¤–ç»´æŠ¤æœ€é•¿å­ä¸²é¦–å…ˆå‡ºç°çš„ä½ç½®ä»¥åŠæœ€åå‡ºç°çš„ä½ç½®ã€‚æœ€åå‡ºç°çš„ä½ç½®éœ€è¦æŒ‰ç…§æ‹“æ‰‘åºé€†ç€æ¥æ›´æ–°ã€‚ç„¶åæ‰«ä¸€éï¼Œæ ¹æ®æŸä¸ªç»“ç‚¹ä»£è¡¨çš„æœ€çŸ­å­—ç¬¦ä¸²ã€æœ€é•¿å­—ç¬¦ä¸²ä¸æœ€é•¿å­ä¸²é¦–å…ˆå‡ºç°ã€æœ€åå‡ºç°ä½ç½®ï¼Œåˆ†æƒ…å†µè®¨è®ºä¸€ä¸‹å³å¯ã€‚ä¸€å¼€å§‹æ²¡æœ‰æ³¨æ„åˆ°å‡ºç°æ¬¡æ•°å¤§äºç­‰äº2è¿™ä¸ªæ¡ä»¶ï¼Œå¤šæƒ³äº†ä¸€ä¸‹ã€‚å‡å¦‚è¦æ±‚å‡ºç°æ¬¡æ•°å¤§äºç­‰äºkçš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯èƒ½éœ€è¦ç»´æŠ¤çš„æ˜¯å„ä¸ªèŠ‚ç‚¹çš„æœ€é•¿å­ä¸²å‡ºç°çš„å…·ä½“ä½ç½®ï¼Œè¿™å¯èƒ½éœ€è¦å°±éœ€è¦ç”¨åˆ°LCTæ¥ç»´æŠ¤äº†ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 6 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * å¼€ç‚¹æ—¶æ‰åˆå§‹åŒ–ï¼Œåœ¨å¤šç»„æ ·ä¾‹çš„æƒ…å†µä¸‹ä¼šæ¯”ç›´æ¥memsetæ•´ä¸ªæ•°ç»„å¿«å¾ˆå¤šï¼Œæ¯”å¦‚HDU4416 * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], l[MAXN], r[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); memset(l, -1, sizeof l); memset(r, -1, sizeof r); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; CHARSET_SIZE; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c, int po) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; l[u] = r[u] = po; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; l[n] = r[n] = l[o]; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; sz; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve() &#123; topoSort(); for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; r[fail[u]] = max(r[fail[u]], r[u]); &#125; ll ans = 0; for(int i = 1; i &lt; sz; i++) &#123; if(len[i] &lt;= r[i] - l[i]) &#123; ans += len[i] - len[fail[i]]; &#125; else &#123; ans += max(0, r[i] - l[i] - len[fail[i]]); &#125; &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%s", s) &amp;&amp; s[0] != '#') &#123; sam.init(); for(int i = 0, up = strlen(s); i &lt; up; i++) &#123; sam.insert(s[i], i); &#125; sam.solve(); &#125; return 0;&#125; HDU 4622 Reincarnationé¢˜æ„ç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åæœ‰$Q$æ¬¡è¯¢é—®ï¼Œæ±‚è¯¥å­—ç¬¦ä¸²$[L, R]$æœ¬è´¨ä¸åŒçš„å­—ç¬¦ä¸²ä¸ªæ•°ã€‚ åˆ†æé¦–å…ˆå»ºç«‹SAMï¼Œç„¶åå¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œåˆ†åˆ«å¤„ç†ï¼Œç»´æŠ¤çš„æ˜¯æœ€å¤§åŒ¹é…é•¿åº¦ã€‚ç„¶åï¼Œæ‰«ä¸€éå„ä¸ªèŠ‚ç‚¹ï¼Œç´¯åŠ æœ€å¤§åŒ¹é…é•¿åº¦ - æœ€å°å­—ç¬¦ä¸² + 1 å³å¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 2009;/************************************************************//* åç¼€è‡ªåŠ¨æœº(Tested 7 times) * æ•°ç»„å®ç°ï¼Œæ•ˆç‡è¾ƒé«˜ * å¼€ç‚¹æ—¶æ‰åˆå§‹åŒ–ï¼Œåœ¨å¤šç»„æ ·ä¾‹çš„æƒ…å†µä¸‹ä¼šæ¯”ç›´æ¥memsetæ•´ä¸ªæ•°ç»„å¿«å¾ˆå¤šï¼Œæ¯”å¦‚HDU4416 * æ—¶é—´å¤æ‚åº¦ï¼šO(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // æ³¨æ„åœ¨SAMé‡Œé¢å¼€çš„æ•°ç»„å¤§å°åº”ä¸ºMAXNï¼Œå› ä¸ºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²æœ€å¤šä¼šæœ‰2*nä¸ªç»“ç‚¹struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; CHARSET_SIZE; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; sz; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s, int l, int r) &#123; int now = 1, le = 0, f[MAXN]; ll ans = 0; memset(f, 0, sizeof f); for(int i = l; i &lt;= r; i++) &#123; int v = s[i] - 'a'; now = ch[now][v]; le++; f[now] = max(f[now], le); &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; if(f[u]) &#123; f[fail[u]] = len[fail[u]]; &#125; &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; ans += max(0, f[i] - len[fail[i]]); &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/int n, T, l, r;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%s", s); sam.init(); for(int i = 0, len = strlen(s); i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.topoSort(); scanf("%d", &amp;n); while(n--) &#123; scanf("%d%d", &amp;l, &amp;r); sam.solve(s, l - 1, r - 1); &#125; &#125; return 0;&#125; HDU 4436 str2intç•™å‘å¾…å¡«ã€‚]]></content>
      <tags>
        <tag>å­—ç¬¦ä¸²</tag>
        <tag>SAM</tag>
        <tag>åç¼€è‡ªåŠ¨æœº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å››åˆ™è¿ç®—é¡¹ç›®æŠ˜è…¾ç¬”è®°]]></title>
    <url>%2F2018%2F09%2F30%2Farithmetic-problems-generator%2F</url>
    <content type="text"><![CDATA[Githubé¡¹ç›®åœ°å€ä¼ é€é—¨ é¡¹ç›®ç›¸å…³è¦æ±‚ (å®Œæˆ)ä½¿ç”¨ -n å‚æ•°æ§åˆ¶ç”Ÿæˆé¢˜ç›®çš„ä¸ªæ•°ã€‚ (å®Œæˆ)ä½¿ç”¨ -r å‚æ•°æ§åˆ¶é¢˜ç›®ä¸­æ•°å€¼ï¼ˆè‡ªç„¶æ•°ã€çœŸåˆ†æ•°å’ŒçœŸåˆ†æ•°åˆ†æ¯ï¼‰çš„èŒƒå›´ã€‚è¯¥å‚æ•°å¯ä»¥è®¾ç½®ä¸º1æˆ–å…¶ä»–è‡ªç„¶æ•°ã€‚è¯¥å‚æ•°å¿…é¡»ç»™å®šï¼Œå¦åˆ™ç¨‹åºæŠ¥é”™å¹¶ç»™å‡ºå¸®åŠ©ä¿¡æ¯ã€‚ (å®Œæˆ)ç”Ÿæˆçš„é¢˜ç›®ä¸­è®¡ç®—è¿‡ç¨‹ä¸èƒ½äº§ç”Ÿè´Ÿæ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ç®—æœ¯è¡¨è¾¾å¼ä¸­å¦‚æœå­˜åœ¨å½¢å¦‚e1 âˆ’ e2çš„å­è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆe1 â‰¥ e2ã€‚ (å®Œæˆ)ç”Ÿæˆçš„é¢˜ç›®ä¸­å¦‚æœå­˜åœ¨å½¢å¦‚e1 Ã· e2çš„å­è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆå…¶ç»“æœåº”æ˜¯çœŸåˆ†æ•°ã€‚ (å®Œæˆ)æ¯é“é¢˜ç›®ä¸­å‡ºç°çš„è¿ç®—ç¬¦ä¸ªæ•°ä¸è¶…è¿‡3ä¸ªã€‚ (å®Œæˆ)ç¨‹åºä¸€æ¬¡è¿è¡Œç”Ÿæˆçš„é¢˜ç›®ä¸èƒ½é‡å¤ï¼Œå³ä»»ä½•ä¸¤é“é¢˜ç›®ä¸èƒ½é€šè¿‡æœ‰é™æ¬¡äº¤æ¢+å’ŒÃ—å·¦å³çš„ç®—æœ¯è¡¨è¾¾å¼å˜æ¢ä¸ºåŒä¸€é“é¢˜ç›®ã€‚ä¾‹å¦‚ï¼Œ23 + 45 = å’Œ45 + 23 = æ˜¯é‡å¤çš„é¢˜ç›®ï¼Œ6 Ã— 8 = å’Œ8 Ã— 6 = ä¹Ÿæ˜¯é‡å¤çš„é¢˜ç›®ã€‚3+(2+1)å’Œ1+2+3è¿™ä¸¤ä¸ªé¢˜ç›®æ˜¯é‡å¤çš„ï¼Œç”±äº+æ˜¯å·¦ç»“åˆçš„ï¼Œ1+2+3ç­‰ä»·äº(1+2)+3ï¼Œä¹Ÿå°±æ˜¯3+(1+2)ï¼Œä¹Ÿå°±æ˜¯3+(2+1)ã€‚ä½†æ˜¯1+2+3å’Œ3+2+1æ˜¯ä¸é‡å¤çš„ä¸¤é“é¢˜ï¼Œå› ä¸º1+2+3ç­‰ä»·äº(1+2)+3ï¼Œè€Œ3+2+1ç­‰ä»·äº(3+2)+1ï¼Œå®ƒä»¬ä¹‹é—´ä¸èƒ½é€šè¿‡æœ‰é™æ¬¡äº¤æ¢å˜æˆåŒä¸€ä¸ªé¢˜ç›®ã€‚ç”Ÿæˆçš„é¢˜ç›®å­˜å…¥æ‰§è¡Œç¨‹åºçš„å½“å‰ç›®å½•ä¸‹çš„Exercises.txtæ–‡ä»¶ã€‚ (å®Œæˆ)åœ¨ç”Ÿæˆé¢˜ç›®çš„åŒæ—¶ï¼Œè®¡ç®—å‡ºæ‰€æœ‰é¢˜ç›®çš„ç­”æ¡ˆï¼Œå¹¶å­˜å…¥æ‰§è¡Œç¨‹åºçš„å½“å‰ç›®å½•ä¸‹çš„Answers.txtæ–‡ä»¶ã€‚ (å®Œæˆ)ç¨‹åºåº”èƒ½æ”¯æŒä¸€ä¸‡é“é¢˜ç›®çš„ç”Ÿæˆã€‚ (å®Œæˆ)ç¨‹åºæ”¯æŒå¯¹ç»™å®šçš„é¢˜ç›®æ–‡ä»¶å’Œç­”æ¡ˆæ–‡ä»¶ï¼Œåˆ¤å®šç­”æ¡ˆä¸­çš„å¯¹é”™å¹¶è¿›è¡Œæ•°é‡ç»Ÿè®¡ï¼Œ ç»Ÿè®¡ç»“æœè¾“å‡ºåˆ°æ–‡ä»¶Grade.txtã€‚ ä»£ç è§„èŒƒæœ¬æ¬¡é¡¹ç›®çš„ä»£ç éµå¾ªäº†è°·æ­Œä»£ç è§„èŒƒ(C++)ï¼Œä½†ç”±äºè°·æ­Œä»£ç è§„èŒƒç¯‡å¹…å¤ªå¤šï¼Œæ‰€ä»¥æˆ‘ä»¬ç›®å‰åªéµå¾ªäº†å…¶ä¸­çš„éƒ¨åˆ†è§„èŒƒï¼Œå…·ä½“å¦‚ä¸‹ï¼š ç¦æ­¢ä½¿ç”¨å® åˆ†å·ä»¥å‰ä¸åŠ ç©ºæ ¼ è¡Œå®½åŸåˆ™ä¸Šä¸è¶…è¿‡80 ä¸€è¡Œåªå®šä¹‰ä¸€ä¸ªå˜é‡ å·¦å¤§æ‹¬å·å‰ä¿ç•™ä¸€ä¸ªç©ºæ ¼ if, elseå‰åéƒ½è¦ä¸€ä¸ªç©ºæ ¼ for, whileåè¦æœ‰ä¸€ä¸ªç©ºæ ¼ return åé¢çš„æ•°å€¼ä¸åŠ  ( ) æ¯ä¸ªæ–‡ä»¶åº”è¯¥å«æœ‰ç‰ˆæƒä¿¡æ¯åŠä½œè€… å·¦åœ†æ‹¬å·ä¹‹åå’Œå³åœ†æ‹¬å·ä¹‹å‰æ— ç©ºæ ¼ å‡½æ•°å‚æ•°è¿‡å¤šæ—¶ï¼Œæ¯è¡Œçš„å‚æ•°å˜é‡å¯¹é½ ä¸€ç›®è¿ç®—ç¬¦ä¸å˜é‡ä¹‹é—´ä¸åŠ ç©ºæ ¼ç¬¦éš”å¼€ ç¦æ­¢ä½¿ç”¨ using æŒ‡ç¤ºï¼ˆusing-directiveï¼‰ ç¦æ­¢ä½¿ç”¨C++çš„æµï¼Œè€Œæ˜¯ç”¨printfä¹‹ç±»çš„æ›¿ä»£ è¦ä¹ˆå‡½æ•°åä¸å‚æ•°åŒè¡Œï¼Œè¦ä¹ˆæ‰€æœ‰å‚æ•°å¹¶æ’åˆ†è¡Œ æ¢è¡Œä»£ç ç¼©è¿›2ä¸ªç©ºæ ¼ï¼Œå¹¶ä¸”ä½¿ç”¨ä¸¤ä¸ªç©ºæ ¼ç¬¦å–ä»£åˆ¶è¡¨ç¬¦ äºŒç›®ä»¥ä¸Šçš„è¿ç®—ç¬¦ä¸å˜é‡ï¼Œå¸¸é‡ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼ˆå„ç±»æ‹¬å·é™¤å¤–ï¼‰ ä¸è®ºæ§åˆ¶è¯­å¥ï¼Œå¾ªç¯è¯­å¥åé¢çš„å¾ªç¯ä½“æœ‰å¤šå°‘è¡Œï¼Œéƒ½å¿…é¡»ä½¿ç”¨èŠ±æ‹¬å· æ™®é€šå‡½æ•°ï¼Œç±»å‹ï¼ˆå«ç±»ä¸ç»“æ„ä½“ï¼Œæšä¸¾ç±»å‹ï¼‰ï¼Œå¸¸é‡ç­‰ä½¿ç”¨å¤§å°å†™æ··åˆï¼Œä¸å«ä¸‹åˆ’çº¿ é™¤å‡½æ•°å®šä¹‰çš„å·¦å¤§æ‹¬å·å¯ç½®äºè¡Œé¦–ä»¥å¤–ï¼ŒåŒ…æ‹¬å‡½æ•°/ç±»/ç»“æ„ä½“/æšä¸¾å£°æ˜ï¼Œå„ç§è¯­å¥çš„å·¦å¤§æ‹¬å·å¿…é¡»ç½®äºè¡Œæœ«ï¼Œæ‰€æœ‰å³å¤§æ‹¬å·ç‹¬ç«‹æˆè¡Œ è®¾è®¡æ€è·¯ å…·ä½“è®¾è®¡&amp;å…³é”®ä»£ç ImproperFractionç±»æ„å»ºä¸€ä¸ªImproperFractionçš„ç±»ï¼Œç„¶åé‡è½½è¿™ä¸ªç±»çš„å››ç§è¿ç®— +-xÃ· ä»¥åŠä»¥åŠå…­ç§é€»è¾‘å…³ç³»â€˜&lt;â€™ â€˜==â€™ â€˜&lt;=â€™ â€˜!=â€™ â€˜&gt;â€™ â€˜&gt;=â€™åˆ¤æ–­ï¼Œåœ¨åç»­çš„ä»£ç ç¼–å†™ä¹‹ä¸­éƒ½æ˜¯åŸºäºè¿™ä¸ªç±»è¿›è¡Œè¿ç®— æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ImproperFraction &#123; public : ImproperFraction()&#123;&#125; ImproperFraction (int Mole, int Deno, int Coef = 0) &#123; int g = std::__gcd (Mole, Deno); g = std::max(g, 1); mole = (Mole + Coef * Deno) / g; deno = Deno / g; &#125; ImproperFraction operator + (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.deno; int MOLE = mole * rhs.deno + rhs.mole * deno; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; ImproperFraction operator - (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.deno; int MOLE = mole * rhs.deno - rhs.mole * deno; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; ImproperFraction operator * (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.deno; int MOLE = mole * rhs.mole; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; ImproperFraction operator / (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.mole; int MOLE = mole * rhs.deno; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; bool operator &lt; (const ImproperFraction &amp; rhs ) const &#123; return mole * rhs.deno &lt; rhs.mole * deno; &#125; bool operator == (const ImproperFraction &amp; rhs ) const &#123; return mole * rhs.deno == rhs.mole * deno; &#125; bool operator != (const ImproperFraction &amp; rhs ) const &#123; return !(mole * rhs.deno == rhs.mole * deno); &#125; bool operator &lt;= (const ImproperFraction &amp; rhs ) const &#123; return (*this) &lt; rhs || (*this) == rhs; &#125; bool operator &gt; (const ImproperFraction &amp; rhs ) const &#123; return !((*this) &lt;= rhs); &#125; bool operator &gt;= (const ImproperFraction &amp; rhs ) const &#123; return (*this) &gt; rhs || (*this) == rhs; &#125; private : int mole = 0; // åˆ†å­ int deno = 1; // åˆ†æ¯ &#125;; é¢˜é›†çš„ç”Ÿæˆè¡¨è¾¾å¼çš„ç”Ÿæˆåœ¨è¿™é‡Œé€‰æ‹©çš„æ˜¯rand() éšæœºç”Ÿæˆ è¿ç®—ç¬¦ä¸ªæ•°ï¼Œç±»å‹ä»¥åŠæ¯ä¸ªè¢«è¿ç®—çš„æ•°å€¼ã€‚ è¡¨è¾¾å¼çš„åˆæ³•æ€§åˆ¤æ–­ åœ¨ç”Ÿæˆè¿‡ç¨‹ä¹‹ä¸­ï¼Œæœ‰ä¸¤ä¸ªè¦ç‚¹ä¼šå¯¼è‡´è¡¨è¾¾å¼éæ³•1.è¿ç®—è¿‡ç¨‹ä¸­å‡ºç°è´Ÿå€¼2.åœ¨Ã·è¿ç®—åé¢å‡ºç°0 è§£å†³åŠæ³•ï¼šä¸¤ä¸ªç‰¹æ®Šåˆ¤æ–­å³å¯ è¡¨è¾¾å¼çš„å»é‡è¡¨è¾¾å¼çš„é‡å¤æœ‰ä¸¤ç§æƒ…å†µ:1.å®Œå®Œå…¨å…¨çš„é‡å¤ï¼Œå¦‚å‡ºç°ä¸¤ä¸ª1 + 2 + 3 çš„è¡¨è¾¾å¼2.è¿ç®—é¡ºåºä¸Šçš„é‡å¤ï¼Œå¦‚: 1 + 2 + 3 å’Œ 2 + 1 + 3é‡å¤2 + 3 x 4 å’Œ 4 x 3 + 2é‡å¤ è§£å†³åŠæ³•ï¼šå¯¹äº(1)çš„æƒ…å†µåªéœ€è¦å°†ç”Ÿæˆçš„è¡¨è¾¾å¼ä¿å­˜è¿›C++STLçš„setä¹‹ä¸­å³å¯è‡ªåŠ¨å»é‡ã€‚å¯¹äº(2)çš„æƒ…å†µï¼Œåˆ™æ˜¯æŒ‰ç…§ä¸€å®šè§„åˆ™ç”Ÿæˆè¡¨è¾¾å¼æ¥é¿å…è¿™ä¸€æƒ…å†µï¼Œè§„åˆ™å¦‚ä¸‹ï¼š 1.é»˜è®¤å·¦è¾¹çš„è¿ç®—ç¬¦çš„ä¼˜å…ˆåº¦é«˜äºå³è¾¹2.ç¬¬ä¸€ä¸ªæ•°å­—ä¸€å®šä¸å°äºç¬¬äºŒä¸ªæ•°å€¼å› æ­¤1 + 2 + 3å’Œ2 + 3 x 4ä¸ä¼šè¢«ç”Ÿæˆï¼Œè€Œåªä¼šç”Ÿæˆ2 + 1 + 3å’Œ4 x 3 + 2 é¢˜é›†æ— æ³•ç”Ÿæˆè¦æ±‚çš„æ•°é‡ ä¾‹å¦‚ï¼šä¼ å…¥çš„å‚æ•°æ˜¯ -n 10000 -r 1 çš„æ—¶å€™ï¼Œå¾ˆæ˜æ˜¾æ— æ³•ç”Ÿæˆ10000é“é¢˜ç›®ï¼Œå› æ­¤é™·å…¥æ­»å¾ªç¯çš„ç”Ÿæˆä¸­ è§£å†³åŠæ³•ï¼šè®¾ç½®ä¸€ä¸ªæ—¶é—´æˆ³timeï¼Œå½“ç”Ÿæˆè¡¨è¾¾å¼çš„éƒ¨åˆ†å¾ªç¯äº†1000000æ¬¡ä¹‹åè‡ªåŠ¨è·³å‡ºå¾ªç¯ï¼Œç»ˆæ­¢ç”Ÿæˆè¡¨è¾¾å¼ ç­”æ¡ˆçš„ç”Ÿæˆ åœ¨è¡¨çš„æ˜¯åˆæ³•æ€§åˆ¤æ–­çš„æ—¶å€™ï¼Œä¼šåˆ¤æ–­æœ€ç»ˆçš„æ•°å€¼æ˜¯å¦å°äº0ï¼Œåœ¨è¿™é‡Œå°±å·²ç»è®¡ç®—æ ‡å‡†ç­”æ¡ˆï¼Œä¿å­˜å¹¶æ‰“å°åˆ°answer.txtå³å¯ æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void questionSetGenerate (int limit, int number) &#123; std::set&lt;std::string&gt;expressions; std::vector&lt;std::string&gt;exercise; std::vector&lt;ImproperFraction&gt;answer; ImproperFraction zero = ImproperFraction(0, 1); // æ—¶é—´æˆ³ int time = 0; while (expressions.size() &lt; number &amp;&amp; time &lt; 1000000) &#123; time ++; int sz = expressions.size(); // è¿ç®—ç¬¦çš„ä¸ªæ•° int opnumber = rand() % 3 + 1; ImproperFraction a[5]; ImproperFraction res = ImproperFraction(0, 1); const ImproperFraction zero = ImproperFraction(0, 1); char op[4]; // éšæœºç”Ÿæˆæ•°å€¼å’Œè¿ç®—ç¬¦ for (int i = 0; i &lt;= opnumber; i++) &#123; a[i] = ImproperFraction(rand() % (limit * limit), std::max(1, rand() % limit)); if (i) &#123; op[i] = oper[rand() % 4]; &#125; &#125; std::string exp = ""; bool flag = true; if (a[0] &lt; a[1]) &#123; std::swap (a[0], a[1]); &#125; // è®¡ç®—ç­”æ¡ˆ,å¹¶æ£€æŸ¥ä¸­é€”å‡ºç°éæ³•æƒ…å†µ for (int i = 0; i &lt;= opnumber; i++) &#123; if (i) &#123; if (op[i] == '+') &#123; res = res + a[i]; &#125; else if (op[i] == '*') &#123; res = res * a[i]; &#125; else if (op[i] == '-') &#123; res = res - a[i]; &#125; else &#123; if (a[i] == zero) &#123; flag = false; break; &#125; res = res / a[i]; &#125; exp = exp + ' '; exp = exp + op[i]; exp = exp + ' '; &#125; else &#123; res = res + a[i]; &#125; // å°†åˆ†æ•°è½¬åŒ–ä¸ºå­—ç¬¦ä¸² fractionToString(a[i], exp); if (res.getdeno() &lt; 0 || res.getmole() &lt; 0) &#123; flag = false; break; &#125; &#125; if (flag) &#123; expressions.insert(exp); if (expressions.size() &gt; sz) &#123; //ä¿å­˜é¢˜é›†å’Œç­”æ¡ˆ exercise.push_back(addbrackets(exp)); answer.push_back(res); &#125; &#125; &#125;&#125; ç­”æ¡ˆæ­£ç¡®æ€§çš„æ£€æµ‹ç”¨æˆ·é€šè¿‡å‚æ•°-e exercises.txt -a answers.txtï¼Œä¼ è¿›æ¥äº†é¢˜ç›®æ–‡ä»¶çš„åç§°å’Œç­”æ¡ˆæ–‡ä»¶çš„åç§°ã€‚é¦–å…ˆï¼Œç”±äºæ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨æˆ–è€…æ²¡æœ‰è®¿é—®çš„æƒé™ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ­¤è¿›è¡Œæ£€æŸ¥ï¼Œå‡å¦‚æœ‰é”™è¯¯ï¼Œåˆ™è¿›è¡ŒæŠ¥é”™ï¼Œæ²¡æœ‰å¼‚å¸¸æ‰è¿›è¡Œä¸‹ä¸€æ­¥ã€‚ç¬¬äºŒæ­¥ï¼Œæˆ‘ä»¬éœ€è¦å¯¹exercises.txtæ–‡ä»¶ä¸­çš„é¢˜ç›®è®¡ç®—ä¸€éï¼Œç„¶åå†å’Œanswers.txtæ–‡ä»¶ä¸­çš„ç­”æ¡ˆè¿›è¡Œæ¯”è¾ƒã€‚é¢˜ç›®çš„è®¡ç®—åˆ†ä¸¤æ­¥è¿›è¡Œï¼Œå³å…ˆå°†ä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–ä¸ºåç¼€è¡¨è¾¾å¼ï¼Œç„¶åè®¡ç®—åç¼€è¡¨è¾¾å¼çš„ç­”æ¡ˆã€‚å¯¹äºè¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬è€ƒè™‘äº†exercises.txtè¡Œæ•°å’Œanswers.txtè¡Œæ•°ä¸ç›¸ç­‰çš„æƒ…å†µï¼Œæ­¤æ—¶æˆ‘ä»¬å°†ä»¥exercises.txtçš„è¡Œæ•°ä¸ºå‡†ï¼Œå‡å¦‚answers.txtè¡Œæ•°è¿‡å°‘ï¼Œé‚£ä¹ˆå°†è§†ä¸ºé”™è¯¯ç­”æ¡ˆï¼Œå‡å¦‚è¿‡å¤šï¼Œé‚£ä¹ˆå°†è¢«å¿½ç•¥ã€‚ 12345678910111213141516171819202122232425262728293031323334// æ£€æŸ¥ç­”æ¡ˆvoid checkAnswer(FILE *exerciseFile, FILE *answerFile) &#123; FILE *pFile = getPointerToGradeFile(); int problemID = 0; char answer[256]; char exercise[256]; std::vector&lt;int&gt; wrongID; std::vector&lt;int&gt; correctID; // ç­”æ¡ˆçš„è¡Œæ•°å¯èƒ½ä¸ç­‰äºé¢˜ç›®çš„è¡Œæ•° while (fgets(answer, 256, answerFile)) &#123; if (!fgets(exercise, 256, exerciseFile)) &#123; break; &#125; problemID++; removeRedundantPart(answer, exercise); handleDivideEncoding(exercise); if (getInfixExpressionAnswer(exercise) == stringToImproperFraction(answer) ) &#123; correctID.push_back(problemID); &#125; else &#123; wrongID.push_back(problemID); &#125; &#125; while (fgets(exercise, 256, exerciseFile)) &#123; problemID++; wrongID.push_back(problemID); &#125; printID(pFile, const_cast&lt;char*&gt;("Correct"), correctID); printID(pFile, const_cast&lt;char*&gt;("Wrong"), wrongID); fclose(pFile); printf("Check answer done!\n");&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// å°†ä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–ä¸ºåç¼€è¡¨è¾¾å¼std::queue&lt;std::string&gt; transformInfixExprToSuffixExpr( const std::string &amp;InfixExpression) &#123; std::stack&lt;char&gt; temp; std::queue&lt;std::string&gt; result; for (int i = 0; i &lt; InfixExpression.length(); i++) &#123; char cc = InfixExpression[i]; if (cc == ' ') &#123; // å‡å¦‚é‡åˆ°ç©ºæ ¼å°±è·³è¿‡ continue; &#125; else if (cc == '(') &#123; // é‡åˆ°å·¦æ‹¬å·å°±ç›´æ¥å…¥æ ˆ temp.push(cc); &#125; else if (cc == ')') &#123; // é‡åˆ°å³æ‹¬å·å°±å¼¹å‡ºæ ˆé‡Œé¢çš„æ‰€æœ‰è¿ç®—ç¬¦ï¼Œç›´åˆ°é‡åˆ°å·¦æ‹¬å· char c; do &#123; c = temp.top(); temp.pop(); if (c != '(') &#123; result.push(charToString(c)); &#125; &#125; while (c != '('); &#125; else if (cc == '+' || cc == '-') &#123; // é‡åˆ°åŠ å·å‡å·ä¹Ÿå¼¹å‡ºæ ˆé¡¶çš„æ‰€æœ‰è¿ç®—ç¬¦ï¼Œç›´åˆ°é‡åˆ°å·¦æ‹¬å·æˆ–è€…ä¸ºæ ˆä¸ºç©º while (!temp.empty()) &#123; char c = temp.top(); if (c != '(') &#123; result.push(charToString(c)); temp.pop(); &#125; else &#123; break; &#125; &#125; temp.push(cc); // ç„¶åå°†åŠ å·å…¥æ ˆ &#125; else if (cc == 'x' || cc == '\xc3') &#123; // å‡å¦‚é‡åˆ°æ‰€æœ‰ä¹˜å·é™¤å·ï¼Œå°±å¼¹å‡ºæ ˆé¡¶çš„ä¹˜å·é™¤å·ï¼ŒçŸ¥é“é‡åˆ°åŠ å·å‡å·æˆ–è€…å·¦æ‹¬å·æˆ–è€…æ ˆä¸ºç©º i += cc == '\xc3'; while (!temp.empty()) &#123; char c = temp.top(); if (c == 'x') &#123; result.push(charToString(c)); temp.pop(); &#125; else if (c == '\xc3') &#123; result.push(charToString(c)); temp.pop(); &#125; else &#123; break; &#125; &#125; temp.push(cc); &#125; else &#123; // å‡å¦‚é‡åˆ°æ•°å­—ï¼Œé‚£å°±ç›´æ¥è¾“å‡º std::string s; while (i &lt; InfixExpression.length()) &#123; char c = InfixExpression[i]; if (isdigit(c) || c == '/' || c == '\'') &#123; s += c; i++; &#125; else &#123; i--; break; &#125; &#125; result.push(s); &#125; &#125; // æŠŠæ ˆé‡Œé¢å‰©ä½™çš„ä¸œè¥¿è¾“å‡º while (!temp.empty()) &#123; char c = temp.top(); temp.pop(); result.push(charToString(c)); &#125; return result;&#125; 1234567891011121314151617181920212223242526272829// è®¡ç®—åç¼€è¡¨è¾¾å¼çš„ç­”æ¡ˆImproperFraction getSuffixExpressionAnswer( std::queue&lt;std::string&gt; suffixExpression) &#123; std::stack&lt;ImproperFraction&gt; sta; while (!suffixExpression.empty()) &#123; std::string s = suffixExpression.front(); suffixExpression.pop(); if (isOperator(s)) &#123; // å‡å¦‚é‡åˆ°è¿ç®—ç¬¦ï¼Œå°±å–å‡ºæ ˆé¡¶å…ƒç´ è¿›è¡Œè®¡ç®— ImproperFraction a = sta.top(); sta.pop(); ImproperFraction b = sta.top(); sta.pop(); if (s[0] == 'x') &#123; sta.push(a * b); &#125; else if (s[0] == '\xc3') &#123; sta.push(b / a); &#125; else if (s[0] == '+') &#123; sta.push(a + b); &#125; else &#123; sta.push(b - a); &#125; &#125; else &#123; // å‡å¦‚é‡åˆ°æ•°å­—ï¼Œå°±ç›´æ¥è¿›æ ˆ sta.push(stringToImproperFraction(s)); &#125; &#125; return sta.top();&#125; æµ‹è¯•æŠ¥å‘Šé¦–å…ˆæ˜¯å„ç§å‚æ•°é”™è¯¯çš„æµ‹è¯• æ¥ç€æ˜¯ä¼ å…¥æ­£ç¡®çš„å‚æ•°çš„æµ‹è¯•ç”Ÿæˆé¢˜é›†çš„æµ‹è¯•ï¼š ç»™å®šçš„é¢˜ç›®æ–‡ä»¶å’Œç­”æ¡ˆæ–‡ä»¶ï¼Œåˆ¤å®šç­”æ¡ˆä¸­çš„å¯¹é”™æµ‹è¯•ï¼š æ•ˆèƒ½åˆ†ææœ¬ç¨‹åºä¸»è¦ç”±ç”Ÿæˆè¿ç®—é¢˜ç›®å’Œæ£€æŸ¥ç­”æ¡ˆæ­£ç¡®æ€§ä¸¤ä¸ªæ¨¡å—ï¼Œå› æ­¤æ•ˆèƒ½åˆ†æä¹Ÿä¸»è¦é’ˆå¯¹è¿™ä¸¤ä¸ªæ¨¡å—è¿›è¡Œã€‚1. ç”Ÿæˆè¿ç®—é¢˜ç›®ç”Ÿæˆä¸€ç™¾ä¸‡æ¡é¢˜ç›®æ—¶å€™çš„æ—¶é—´å æ¯”æƒ…å†µï¼š ç”±ä¸Šå›¾çœ‹å‡ºäº†ï¼Œå ç”¨æ—¶é—´æœ€å¤šçš„å‰äº”ä¸ªå‡½æ•°ä¸º questionSetGenerate gcd addbrackets digToString ImproperFraction å…¶ä¸­ï¼ŒquestionSetGenerateæ˜¯ç”Ÿæˆè¿ç®—é¢˜ç›®çš„å‡½æ•°å…¥å£ï¼Œå ç”¨æ—¶é—´æœ€é•¿ã€‚gcdæ˜¯åœ¨é¢˜ç›®è¿ç®—è¿‡ç¨‹ï¼Œåˆ†æ•°é€šåˆ†æ—¶è¿›è¡Œè°ƒç”¨çš„ï¼Œå…·ä½“å®ç°æ˜¯è¾—è½¬ç›¸é™¤æ³•ã€‚addbracketsæ˜¯åœ¨ç”Ÿæˆé¢˜ç›®çš„è¿‡ç¨‹ç»™è¡¨è¾¾å¼æ·»åŠ æ‹¬å·ã€‚digTostringæ˜¯åœ¨ç”Ÿæˆé¢˜ç›®çš„è¿‡ç¨‹å°†æ•°å­—è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ã€‚ImproperFractionæ˜¯çœŸåˆ†æ•°çš„ç±»åï¼Œç”±äºç”Ÿæˆçš„è¡¨è¾¾å¼ä¸­æ™®éå«æœ‰çœŸåˆ†æ•°ï¼Œæ‰€ä»¥å¤šæ¬¡è°ƒç”¨äº†å®ƒçš„æ„é€ å‡½æ•°ã€‚ 2. æ£€æŸ¥ç­”æ¡ˆæ­£ç¡®æ€§æ£€æŸ¥äº”åä¸‡æ¡é¢˜ç›®æ—¶çš„æ—¶é—´å æ¯”æƒ…å†µï¼š ç”±ä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼Œå ç”¨æ—¶é—´æœ€å¤šçš„å‰äº”ä¸ªå‡½æ•°ä¸ºï¼š gcd stringToImproperFraction __deque_buf_size transformInfixExprToSuffixExpr _Deque_base å…¶ä¸­ï¼Œgcdç”¨äºè¿ç®—è¿‡ç¨‹çš„é€šåˆ†ï¼ŒstringToImproperFractionç”¨äºå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºçœŸåˆ†æ•°ï¼Œ transformInfixExprToSuffixExprç”¨äºå°†ä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–ä¸ºåç¼€è¡¨è¾¾å¼ã€‚å¦å¤–ä¸¤ä¸ªå‡½æ•°æ˜¯ç³»ç»Ÿå‡½æ•°ã€‚ å› æ­¤ï¼Œå‡å¦‚è¦ä¼˜åŒ–æ•ˆèƒ½çš„è¯ï¼Œå¯ä»¥ä¼˜å…ˆåœ¨æºä»£ç è¿½è¸ªä¸€ä¸‹ä¸Šè¿°å‡½æ•°ï¼Œçœ‹èƒ½å¦å‡å°‘è¿™äº›å‡½æ•°çš„è°ƒç”¨æˆ–è€…ä¼˜åŒ–å…¶å®ç°æ–¹å¼ã€‚ PSP PSP2.1 Personal Software Process Stages é¢„ä¼°è€—æ—¶ï¼ˆåˆ†é’Ÿï¼‰ å®é™…è€—æ—¶ï¼ˆåˆ†é’Ÿï¼‰ Planning è®¡åˆ’ 60 50 Â· Estimate Â· ä¼°è®¡è¿™ä¸ªä»»åŠ¡éœ€è¦å¤šå°‘æ—¶é—´ 60 50 Development å¼€å‘ 965 1545 Â· Analysis Â· éœ€æ±‚åˆ†æ (åŒ…æ‹¬å­¦ä¹ æ–°æŠ€æœ¯) 50 100 Â· Design Spec Â· ç”Ÿæˆè®¾è®¡æ–‡æ¡£ 25 35 Â· Design Review Â· è®¾è®¡å¤å®¡ (å’ŒåŒäº‹å®¡æ ¸è®¾è®¡æ–‡æ¡£) 25 35 Â· Coding Standard Â· ä»£ç è§„èŒƒ (ä¸ºç›®å‰çš„å¼€å‘åˆ¶å®šåˆé€‚çš„è§„èŒƒ) 25 65 Â· Design Â· å…·ä½“è®¾è®¡ 60 80 Â· Coding Â· å…·ä½“ç¼–ç  360 415 Â· Code Review Â· ä»£ç å¤å®¡ 60 150 Â· Test Â· æµ‹è¯•ï¼ˆè‡ªæˆ‘æµ‹è¯•ï¼Œä¿®æ”¹ä»£ç ï¼Œæäº¤ä¿®æ”¹ï¼‰ 360 665 Reporting æŠ¥å‘Š 110 130 Â· Test Report Â· æµ‹è¯•æŠ¥å‘Š 60 80 Â· Size Measurement Â· è®¡ç®—å·¥ä½œé‡ 25 25 Â· Postmortem &amp; Process Improvement Plan Â· äº‹åæ€»ç»“, å¹¶æå‡ºè¿‡ç¨‹æ”¹è¿›è®¡åˆ’ 25 25 åˆè®¡ 1135 1725 é¡¹ç›®å°ç»“æœ‰å¾…æ”¹è¿›çš„åœ°æ–¹ æº¢å‡ºé—®é¢˜ï¼šå½“ç»™å®šrè¿‡å¤§çš„æ—¶å€™ï¼Œå°†ä¼šå¯¼è‡´æœ€ç»ˆè¿ç®—ç»“æ„çš„åˆ†æ¯æº¢å‡ºï¼Œè€Œé€ æˆçš„æ•°æ®é”™è¯¯ ç›®å‰æ–¹æ¡ˆï¼šæ£€æŸ¥æº¢å‡ºï¼Œå°†å‘ç”Ÿäº†æº¢å‡ºçš„è¡¨è¾¾å¼åˆ é™¤ æ›´ä½³æ–¹æ¡ˆï¼šä½¿ç”¨å¤§æ•°çš„è¿ç®—ï¼Œå°±å¯ä»¥å®Œç¾é¿å…æ•°æ®æº¢å‡ºçš„é—®é¢˜ ç”Ÿæˆé¢˜ç›®ä¸å¤Ÿå‹å¥½ï¼šå½“ç»™å®šæ•°æ®èŒƒå›´rç¨ç¨æœ‰ç‚¹å¤§çš„æ—¶å€™ï¼Œæœ€ç»ˆç­”æ¡ˆçš„åˆ†æ¯å¯èƒ½è¶…è¿‡ä¸€äº¿ ç›®å‰æ–¹æ¡ˆï¼šä¸å¤„ç† æ›´ä½³æ–¹æ¡ˆ: æš‚æ—  æ­»å¾ªç¯ç”Ÿæˆé¢˜ç›®: å½“ç»™å®šé¢˜æ•°è¿‡å¤§ä¸”ç»™å®šé™åˆ¶å¤ªå°æ—¶,æ— æ³•ç”Ÿæˆè¦æ±‚çš„é¢˜ç›®æ•°é‡, å¯¼è‡´è¿›å…¥æ­»å¾ªç¯ ç›®å‰æ–¹æ¡ˆ: è®¾ç½®æ—¶é—´æˆ³time,åªç”Ÿæˆ1000000æ¬¡è¡¨è¾¾å¼,å†è¿›è¡Œåˆæ³•æ€§åˆ¤æ–­,ä½†ä¹Ÿå¯¼è‡´æœ‰å¯èƒ½æ— æ³•ç”Ÿæˆè¦æ±‚é¢˜ç›®æ•°é‡ æ›´ä½³æ–¹æ¡ˆ: æš‚æ—  å¼€å‘é¡¹ç›®ä¸­å‘ç”Ÿçš„é—®é¢˜ ä¸€å¼€å§‹çš„æ—¶å€™æ˜¯é€‰æ‹©æš´åŠ›æ·±æœç”Ÿæˆé¢˜é›†,å†éšæœºé€‰å–è¡¨è¾¾å¼è¾“å‡º,ä½†æ˜¯ç”Ÿæˆçš„æ•ˆæœæ¥çœ‹,é¢˜ç›®å¹¶ä¸æ˜¯å¾ˆéšæœº,ä¾‹å¦‚å‰ä¸¤ä¸ªæ•°å­—æ˜¯å›ºå®šæ­»çš„,æ€å‰æƒ³å,è§‰å¾—è¿˜æ˜¯ä½¿ç”¨rand()éšæœºç”Ÿæˆæ•ˆæœæ›´ä½³ åœ¨æœ€å¼€å§‹è®¾è®¡æ–¹æ¡ˆçš„æ—¶å€™,è¿˜æ˜¯æ€è™‘çš„ä¸å¤Ÿå¤š,ä»¥è‡³äºåé¢çš„ä»£ç å¤å®¡(Debug)å·¥ä½œåšäº†å¾ˆå¤š,è¿œè¶…è¿‡ä»£ç ç¼–å†™éƒ¨åˆ† è¿˜æœ‰å„ç§äººæ€§åŒ–çš„è®¾ç½®,å¦‚å‚æ•°é”™è¯¯æç¤º,ç¨‹åºè¿è¡Œç»“æœæ˜¾ç¤ºä¹‹ç±»è¯è¯­å¹¶æ²¡æœ‰æƒ³åˆ°,ä½†æ˜¯ä¸€ä¸ªè½¯ä»¶,ä¸€ä¸ªé¡¹ç›®æœ€ç»ˆéƒ½æ˜¯é¢å‘äºäººç¾¤å¤§ä¼—,äººæ€§åŒ–çš„è®¾ç½®æ˜¯å¿…é¡»çš„ å›¢é˜Ÿä¹‹ä¸­çš„é—ªå…‰ç‚¹ è‰¯å¥½çš„ä»£ç é£æ ¼: åœ¨ä¸€å¼€å§‹æˆ‘ä»¬å°±çº¦æŸå¥½äº†å›¢é˜Ÿçš„ä»£ç é£æ ¼,åœ¨åç»­çš„ä»£ç ç¼–å†™ä¹‹ä¸­æˆ‘ä»¬ä¹Ÿèƒ½å¤Ÿå¾ˆå¥½çš„å‚ç…§ä»£ç é£æ ¼è¿›è¡Œä¹¦å†™,å› æ­¤åœ¨ä»£ç å¤å®¡çš„æ—¶å€™æˆ‘ä»¬ä¹Ÿèƒ½å¤Ÿå¾ˆå¥½çš„æŸ¥é˜…å¯¹æ–¹çš„ä»£ç  ä¸é”™çš„ä»£ç èƒ½åŠ›: æƒ³å®šæ€è·¯å­¦ä¹ çŸ¥è¯†ä¹‹å,å¯ç›´æ¥è¿›è¡Œä»£ç çš„å®ç°,åŸºæœ¬ä¸Šä¸ä¼šå‡ºç°ä¸€äº›é€»è¾‘é”™è¯¯.åé¢å‡ºç°çš„bugä¹Ÿæ˜¯å› ä¸ºè®¾è®¡çš„æ—¶å€™ç¨ç¨ä¸å¤Ÿè€ƒè™‘ç»†èŠ‚,ä¸€æ—¦å‡ºç°bug,éƒ½èƒ½å¤Ÿç«‹é©¬æ‰¾åˆ°bugå’Œæƒ³åˆ°ç›¸åº”çš„ä¿®å¤æ–¹æ¡ˆ äº’å¸®äº’åŠ©: åœ¨ä¸€å¼€å§‹æˆ‘ä»¬å°±è¿›è¡Œäº†åˆ†å·¥,ä¸€ä¸ªäººä¸»è¦è´Ÿè´£å¯¹ç»™å®šçš„é¢˜ç›®æ–‡ä»¶å’Œç­”æ¡ˆæ–‡ä»¶è¿›è¡Œç­”æ¡ˆæ ¡å¯¹ã€å‚æ•°ç»„åˆæ­£ç¡®æ€§çš„æ£€æµ‹ï¼Œå¦ä¸€ä¸ªäººè´Ÿè´£äº†é¢˜é›†çš„ç”Ÿæˆéƒ¨åˆ†ã€‚å¹¶ä¸”åœ¨æœ€åï¼Œä¸€èµ·æµ‹è¯•å¹¶æ’°å†™äº†åšå®¢ã€‚é€šè¿‡è¿™æ¬¡é¡¹ç›®ï¼Œæˆ‘ä»¬å®è·µäº†ç»“å¯¹ç¼–ç¨‹ï¼Œæé«˜äº†æ²Ÿé€šèƒ½åŠ›ï¼ŒåŠ å¼ºäº†å›¢é˜Ÿåˆä½œçš„èƒ½åŠ›ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[wcé¡¹ç›®æŠ˜è…¾ç¬”è®°]]></title>
    <url>%2F2018%2F09%2F07%2Fword-count%2F</url>
    <content type="text"><![CDATA[Githubé¡¹ç›®åœ°å€ä¼ é€é—¨ é¡¹ç›®ç›¸å…³è¦æ±‚ åŸºæœ¬åŠŸèƒ½ ç»Ÿè®¡Cè¯­è¨€æºæ–‡ä»¶çš„å­—ç¬¦æ•°ï¼ˆå®Œæˆï¼‰ ç»Ÿè®¡Cè¯­è¨€æºæ–‡ä»¶çš„è¯çš„æ•°ç›®ï¼ˆå®Œæˆï¼‰ ç»Ÿè®¡Cè¯­è¨€æºæ–‡ä»¶çš„è¡Œæ•°ï¼ˆå®Œæˆï¼‰ æ‹“å±•åŠŸèƒ½ é€’å½’å¤„ç†ç›®å½•ä¸‹ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶ï¼ˆå®Œæˆï¼‰ è¿”å›æ›´å¤æ‚çš„æ•°æ®ï¼ˆä»£ç è¡Œ / ç©ºè¡Œ / æ³¨é‡Šè¡Œï¼‰ï¼ˆå®Œæˆï¼‰ æ”¯æŒå„ç§æ–‡ä»¶çš„é€šé…ç¬¦ï¼ˆ*,?ï¼‰ï¼ˆå®Œæˆï¼‰ é«˜çº§åŠŸèƒ½ å®ç°å›¾å½¢ç•Œé¢ï¼ˆå¾…å®Œæˆï¼‰ é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ˜ç¡®ä¸€ä¸‹â€œå­—ç¬¦â€ï¼Œâ€œè¯â€ï¼Œâ€œè¡Œâ€ï¼Œâ€œä»£ç è¡Œâ€ï¼Œâ€œç©ºè¡Œâ€ï¼Œâ€œæ³¨é‡Šè¡Œâ€çš„å®šä¹‰ã€‚å­—ç¬¦ï¼šä¸€ä¸ªASCIIå­—ç¬¦ï¼ŒåŒ…æ‹¬æ§åˆ¶å­—ç¬¦å’Œå¯æ‰“å°å­—ç¬¦ã€‚è¯ï¼šä¸€ä¸ªç”±ç©ºç™½å­—ç¬¦ï¼ˆä¸ä»…æŒ‡ç©ºæ ¼ï¼Œè¿˜æŒ‡â€™\fâ€™,â€™\vâ€™,â€™\nâ€™,â€™\râ€™è¿™äº›æ§åˆ¶å­—ç¬¦ï¼‰åˆ†éš”çš„éç©ºå­—ç¬¦ä¸²ã€‚è¡Œï¼šä¸€ä¸ªç”±æ¢è¡Œç¬¦åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œå¯ä»¥ä¸ºç©ºã€‚ä¸€è¡Œç»“æŸçš„æ ‡å¿—æ˜¯æ¢è¡Œç¬¦ã€‚ ä»£ç è¡Œï¼šæœ¬è¡ŒåŒ…æ‹¬å¤šäºä¸€ä¸ªå­—ç¬¦çš„ä»£ç ã€‚ç©ºè¡Œï¼šæœ¬è¡Œå…¨éƒ¨æ˜¯ç©ºæ ¼æˆ–æ ¼å¼æ§åˆ¶å­—ç¬¦ï¼Œå¦‚æœåŒ…æ‹¬ä»£ç ï¼Œåˆ™åªæœ‰ä¸è¶…è¿‡ä¸€ä¸ªå¯æ˜¾ç¤ºçš„å­—ç¬¦ï¼Œä¾‹å¦‚â€œ{â€ã€‚æ³¨é‡Šè¡Œï¼šæœ¬è¡Œä¸æ˜¯ä»£ç è¡Œï¼Œå¹¶ä¸”æœ¬è¡ŒåŒ…æ‹¬æ³¨é‡Šã€‚ ä»¥ä¸Šä»£ç è¡Œã€ç©ºè¡Œã€æ³¨é‡Šè¡Œçš„è¯´æ˜æ‘˜è‡ªé¡¹ç›®è¯´æ˜ã€‚ ä¸ºäº†æ¶ˆé™¤æ­§ä¹‰ï¼Œç‰¹æå‡ºä»¥ä¸‹è¡¥å……è¯´æ˜ï¼š1.é¡¹ç›®è¯´æ˜æŒ‡å‡ºäº†ä¸‹é¢ç¬¬ä¸€è¡Œæ˜¯æ³¨é‡Šè¡Œï¼Œç±»ä¼¼çš„ï¼Œç¬¬äºŒè¡Œå’Œç¬¬ä¸‰è¡Œä¹Ÿæ˜¯é¡¹ç›®è¡Œã€‚ 123&#125; //æ³¨é‡Š&#123; //æ³¨é‡Š; //æ³¨é‡Š 2.æŒ‰ç…§å®šä¹‰ï¼Œä¸‹é¢è¿™ä¸€è¡Œæ˜¯ä»£ç è¡Œï¼Œä½†ä¸æ˜¯æ³¨é‡Šè¡Œã€‚ 1printf("Hello, world"); //say "Hello, world" 3.æŒ‰ç…§å®šä¹‰ï¼Œç¬¬ä¸€è¡Œæ˜¯ä»£ç è¡Œï¼Œä½†ä¸æ˜¯æ³¨é‡Šè¡Œã€‚ç¬¬äºŒè¡Œå’Œç¬¬ä¸‰è¡Œæ˜¯æ³¨é‡Šè¡Œã€‚ 123printf("Hello, world"); /*say "Hello, world" */ 4.ç¬¬äºŒè¡Œä¸æ˜¯ç©ºç™½è¡Œã€‚ç¬¬ä¸€è¡Œåˆ°ç¬¬ä¸‰è¡Œéƒ½æ˜¯æ³¨é‡Šè¡Œã€‚ 123/* The next line is a comment line. */ æ€è·¯å¯¹äºå­—ç¬¦æ•°çš„ç»Ÿè®¡ï¼Œæ¯è¯»å–ä¸€ä¸ªå­—ç¬¦ï¼Œè®©chractersåŠ ä¸€å³å¯ã€‚å¯¹äºè¯æ•°çš„ç»Ÿè®¡ï¼Œéœ€è¦ä¸€ä¸ªæ ‡è®°ï¼Œç”¨äºè®°å½•å‰é¢ä¸€ä¸ªå­—ç¬¦æ˜¯ä¸æ˜¯ç©ºç™½å­—ç¬¦ï¼Œå‡å¦‚å‰é¢ä¸€ä¸ªå­—ç¬¦æ˜¯ç©ºç™½å­—ç¬¦ä¸”å½“å‰å­—ç¬¦æ˜¯å¯æ˜¾ç¤ºå­—ç¬¦ï¼Œé‚£ä¹ˆè®©wordsåŠ ä¸€ã€‚å¯¹äºè¡Œæ•°çš„ç»Ÿè®¡ï¼Œæ¯è¯»å–åˆ°ä¸€ä¸ªæ¢è¡Œç¬¦ï¼Œè®©linesåŠ ä¸€å³å¯ã€‚å¯¹äºç©ºç™½è¡Œã€ä»£ç è¡Œã€æ³¨é‡Šè¡Œçš„ç»Ÿè®¡ï¼Œéœ€è¦ç”¨åˆ°ä¸€ä¸ªå—æ³¨é‡Šæ ‡è®°å’Œä¸€äº›æ­£åˆ™è¡¨è¾¾å¼ï¼Œå…·ä½“å¦‚ä¸‹ï¼š 123456bool blockCommentFlag = false;string blankLineRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)";string lineCommentRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)";string blockCommentStartFlagRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)";string blockCommentStartFlag1Regex = "(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)";string blockCommentCloseFlagRegex = "(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"; æ¯è¯»å–ä¸€è¡Œï¼Œé¦–å…ˆéœ€è¦åˆ¤æ–­å½“å‰è¡Œæ˜¯ä¸æ˜¯ä½äºå—æ³¨é‡Šä¸­ï¼Œå‡å¦‚æ˜¯ï¼Œè®©æ³¨é‡Šè¡ŒåŠ ä¸€ï¼Œå¦åˆ™è¿›è¡Œ2 ä½¿ç”¨blankLineRegexè¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼åˆ¤æ–­å½“å‰è¡Œæ˜¯ä¸æ˜¯ç©ºç™½è¡Œï¼Œå‡å¦‚æ˜¯ï¼Œè®©ç©ºç™½è¡ŒåŠ ä¸€ï¼Œå¦åˆ™è¿›è¡Œ3 ä½¿ç”¨lineCommentRegexåˆ¤æ–­å½“å‰è¡Œæ˜¯ä¸æ˜¯è¡Œæ³¨é‡Šï¼Œå‡å¦‚æ˜¯ï¼Œè®©æ³¨é‡Šè¡ŒåŠ ä¸€ï¼Œå¦åˆ™è¿›è¡Œ4 ä½¿ç”¨blockCommentStartFlagRegexåˆ¤æ–­å½“å‰è¡Œæ˜¯ä¸æ˜¯å«æœ‰å—æ³¨é‡Šå¼€å§‹çš„æ ‡å¿—ä¸”ä¸ºæ³¨é‡Šè¡Œï¼Œå‡å¦‚æ˜¯ï¼ŒæŠŠblockCommentFlagæ”¹ä¸ºtrueï¼Œå¹¶å°†æ³¨é‡Šè¡ŒåŠ ä¸€ï¼Œå¦åˆ™è¿›è¡Œ5 ä½¿ç”¨blockCommentStartFlag1Regexåˆ¤æ–­å½“å‰è¡Œæ˜¯ä¸æ˜¯å«æœ‰å—æ³¨é‡Šå¼€å§‹çš„æ ‡å¿—ä¸”ä¸ºä»£ç è¡Œï¼Œå‡å¦‚æ˜¯ï¼ŒæŠŠblockCommentFlagæ”¹ä¸ºtrueï¼Œå¹¶å°†ä»£ç è¡ŒåŠ ä¸€ï¼Œå¦åˆ™è¿›è¡Œ6 å‡å¦‚ä»¥ä¸Šæƒ…å†µéƒ½ä¸æ˜¯ï¼Œé‚£ä¹ˆè¯´æ˜è¯¥è¡Œæ˜¯ä»£ç è¡Œï¼Œè®©ä»£ç è¡ŒåŠ ä¸€ï¼Œå¹¶ç»“æŸè¯¥è¡Œçš„åˆ¤æ–­ è®¾è®¡Fileç±»ï¼š å˜é‡ï¼šcharacters, words, lines, blankLines, codeLines, commentLines. æ–¹æ³•ï¼š countBasicï¼šç»Ÿè®¡å­—ç¬¦æ•°ã€è¯æ•°ã€è¡Œæ•°ã€‚ countSpecialLinesï¼šç»Ÿè®¡ç©ºç™½è¡Œã€ä»£ç è¡Œã€æ³¨é‡Šè¡Œã€‚ printï¼šè¾“å‡ºç»Ÿè®¡ç»“æœã€‚ setModeå‡½æ•°ï¼šæ ¹æ®è¾“å…¥å‚æ•°è®¾ç½®æ¨¡å¼ã€‚readFileå‡½æ•°ï¼šå¤„ç†ä¸€ä¸ªæ–‡ä»¶ã€‚recursiveReadFileså‡½æ•°ï¼šå¤„ç†ä¸€ä¸ªç›®å½•ã€‚ ä¸»è¦æµç¨‹å°±æ˜¯è¯»å–å‘½ä»¤è¡Œå‚æ•°ï¼Œç„¶åè°ƒç”¨setModeè®¾ç½®å‚æ•°ï¼Œæ¥ç€æ ¹æ®å¯¹è±¡æ˜¯æ–‡ä»¶è¿˜æ˜¯ç›®å½•ï¼Œåˆ†åˆ«è°ƒç”¨readFileæˆ–recursiveReadFilesã€‚ readFileæ¥ç€åˆä¼šè°ƒç”¨countBasicå’ŒcountSpecialLinesï¼Œæ‰§è¡Œç¨‹åºçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œè¿›è¡Œç»Ÿè®¡ã€‚æ¥ç€è°ƒç”¨printè¾“å‡ºç»“æœã€‚ å…³é”®ä»£ç 1.ç»Ÿè®¡å­—ç¬¦ã€è¯ã€è¡Œ 123456789101112void countBasic(FILE *pFile) &#123; char c; bool spaceFlag = true; while((c = fgetc(pFile)) != EOF) &#123; characters++; words += (spaceFlag == true &amp;&amp; isgraph(c)); spaceFlag = isspace(c); lines += c == '\n'; &#125;&#125; 2.ç»Ÿè®¡ç©ºç™½è¡Œã€ä»£ç è¡Œã€æ³¨é‡Šè¡Œ 12345678910111213141516171819202122232425262728293031323334353637383940/* è¦ç¡®å®šä¸€è¡Œæ˜¯ä¸æ˜¯ç©ºç™½è¡Œï¼Œåªè¦é€šè¿‡åˆ¤æ–­è¯¥è¡Œçš„å¯æ‰“å°å­—ç¬¦ä¸ªæ•°æ˜¯å¦ä¸è¶…è¿‡1ä¸ªå³å¯ã€‚å¦å¤–è¿˜è¦æ³¨æ„ï¼Œè¯¥è¡Œä¸èƒ½åœ¨å—æ³¨é‡Šä¸­ã€‚ * è¦ç¡®å®šä¸€è¡Œæ˜¯ä¸æ˜¯ä»£ç è¡Œï¼Œåªè¦åˆ¤æ–­è¯¥è¡Œçš„å¯æ‰“å°å­—ç¬¦ä¸ªæ•°æ˜¯å¦è¶…è¿‡1ä¸ªå³å¯ã€‚å¦å¤–è¿˜è¦æ³¨æ„ï¼Œæ”¹è¡Œä¸åœ¨å—æ³¨é‡Šä¸­ã€‚ * å‡å¦‚ä¸€è¡Œæ˜¯æ³¨é‡Šè¡Œï¼Œé‚£ä¹ˆè¯¥è¡Œé¦–å…ˆå¿…é¡»ä¸æ˜¯ä»£ç è¡Œï¼Œå…¶æ¬¡ï¼Œéœ€è¦æœ‰æ³¨é‡Šæ ‡å¿—ã€‚ * æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œå¯å†™å‡ºæ­£åˆ™è¡¨è¾¾å¼è¿›è¡ŒåŒ¹é…ã€‚ */void countSpecialLines() &#123; string line; ifstream file(fileName); bool blockCommentFlag = false; string blankLineRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)"; string lineCommentRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)"; string blockCommentStartFlagRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"; string blockCommentStartFlag1Regex = "(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"; string blockCommentCloseFlagRegex = "(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"; while (getline(file, line)) &#123; if(blockCommentFlag) &#123; commentLines++; if(regex_match(line, regex(blockCommentCloseFlagRegex))) &#123; blockCommentFlag = false; &#125; &#125; else if(regex_match(line, regex(blankLineRegex))) &#123; blankLines++; &#125; else if(regex_match(line, regex(lineCommentRegex))) &#123; commentLines++; &#125; else if(regex_match(line, regex(blockCommentStartFlagRegex))) &#123; commentLines++; blockCommentFlag = true; &#125; else if(regex_match(line, regex(blockCommentStartFlag1Regex))) &#123; codeLines++; blockCommentFlag = true; &#125; else &#123; codeLines++; &#125; &#125; file.close();&#125; 3.æ ¹æ®å‚æ•°è¾“å‡ºç»Ÿè®¡ç»“æœï¼Œæ³¨æ„è¾“å‡ºé¡ºåºæ˜¯æœ‰è§„å¾‹çš„ï¼Œä¾æ¬¡ä¸ºå­—ç¬¦æ•° è¯æ•° è¡Œæ•° ç©ºç™½è¡Œæ•° ä»£ç è¡Œæ•° æ³¨é‡Šè¡Œæ•°ã€‚ 1234567891011void print(map&lt;char, bool&gt; mode) &#123; if(mode['c']) printf("%6d", characters); if(mode['w']) printf("%6d", words); if(mode['l']) printf("%6d", lines); if(mode['a']) printf("%6d%6d%6d", blankLines, codeLines, commentLines); putchar('\n');&#125; æµ‹è¯•æŠ¥å‘Šé¦–å…ˆæˆ‘åˆ¶ä½œäº†å‡ ä¸ªç»å…¸çš„æµ‹è¯•æ ·ä¾‹ä»¥åŠå¯¹åº”çš„å‚è€ƒç»Ÿè®¡ç»“æœï¼Œå¦å¤–ï¼Œä¸ºäº†èŠ‚çœæµ‹è¯•æ—¶é—´ï¼Œæˆ‘è¿˜å†™äº†ä¸€ä¸ªè„šæœ¬æ¥è¿›è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•ã€‚å‡å¦‚æ‰€æœ‰çš„æµ‹è¯•æ ·ä¾‹éƒ½é€šè¿‡äº†ï¼Œåˆ™ä¼šæç¤ºokï¼Œå¦‚ä¸‹ï¼šå‡å¦‚æœ‰äº›æ ·ä¾‹æ²¡æœ‰é€šè¿‡ï¼Œåˆ™ä¼šæç¤ºwrongï¼Œå¹¶æŒ‡å‡ºé”™åœ¨å“ªé‡Œï¼Œå¦‚ä¸‹ï¼šæˆ‘æ„é€ çš„æµ‹è¯•æ ·ä¾‹åŠæµ‹è¯•ç»“æœå¦‚ä¸‹ï¼š ç©ºæ–‡ä»¶ è¿™é‡Œè¾“å‡ºçš„ä¾æ¬¡æ˜¯å­—ç¬¦æ•°ã€è¯æ•°ã€è¡Œæ•°ã€ç©ºè¡Œæ•°ã€ä»£ç è¡Œæ•°ã€æ³¨é‡Šè¡Œæ•°ã€‚ä¸‹é¢çš„ä¹Ÿä¸€æ ·ã€‚ä¹‹æ‰€ä»¥è¿™ä¹ˆè¾“å‡ºï¼Œæ˜¯æ¨¡ä»¿äº†Linuxç³»ç»Ÿä¸‹è‡ªå¸¦çš„wcå‘½ä»¤ã€‚ä¸€å¼€å§‹æˆ‘ä¹Ÿä¸å¤ªç†è§£wcå‘½ä»¤è¾“å‡ºçš„ä¸œè¥¿å“ªä¸ªæ˜¯å­—ç¬¦æ•°ã€å“ªä¸ªæ˜¯å•è¯æ•°ï¼Œæ‰€ä»¥é˜…è¯»äº†ä¸€ä¸‹æ–‡æ¡£ï¼Œæ‰¾åˆ°äº†è¾“å‡ºçš„è§„åˆ™ï¼Œç†è§£äº†è¾“å‡ºçš„å«ä¹‰ã€‚æ‰€ä»¥ï¼Œæˆ‘è¿™é‡Œä¹Ÿç”¨äº†è¿™ç§å®ç°æ–¹å¼ï¼Œè¿™æ ·åšèƒ½å‡å°‘è¾“å‡ºå†—ä½™ä¿¡æ¯ï¼Œå‡å°‘ç”¨æˆ·çš„é˜…è¯»è´Ÿæ‹…ï¼Œè®©ç”¨æˆ·æ›´å¿«åœ°è·å¾—æƒ³è¦çš„ä¿¡æ¯ã€‚ ä¸€ä¸ªå­—ç¬¦çš„æ–‡ä»¶ ä¸€ä¸ªå•è¯çš„æ–‡ä»¶ ä¸€è¡Œçš„æ–‡ä»¶ å…¸å‹çš„Cæºæ–‡ä»¶ å¦ä¸€ä¸ªå…¸å‹çš„Cæºæ–‡ä»¶ é™¤äº†æµ‹è¯•è¿™äº›æ ·ä¾‹ï¼Œæˆ‘è¿˜æµ‹è¯•äº†éæ³•è¾“å…¥çš„æƒ…å†µï¼Œå¦‚ä¸‹ï¼š æ²¡æœ‰è¾“å…¥å‚æ•° å‚æ•°éæ³• æ–‡ä»¶æˆ–ç›®å½•ä¸å­˜åœ¨ åœ¨æœªè¾“å…¥så‚æ•°çš„æƒ…å†µä¸‹æŸ¥è¯¢ç›®å½• æ‹“å±•åŠŸèƒ½çš„æŸ¥è¯¢æ›´å¤æ‚ä¿¡æ¯å’ŒæŸ¥è¯¢ç›®å½•çš„æµ‹è¯•ï¼š æ”¯æŒå„ç§æ–‡ä»¶çš„é€šé…ç¬¦ï¼ˆ*,?ï¼‰çš„æµ‹è¯•ï¼š ä»£ç è¦†ç›–ç‡åšä¸»ä½¿ç”¨äº†gcovä¸lcovè¿›è¡Œä»£ç è¦†ç›–ç‡çš„æµ‹è¯•ã€‚ç»è¿‡æµ‹è¯•å‘ç°ï¼Œè¡Œè¦†ç›–ç‡ä¸º91.5%ï¼Œå‡½æ•°è¦†ç›–ç‡ä¸º100%ã€‚ é‡åˆ°çš„å›°éš¾åŠè§£å†³æ–¹æ³• ä¹‹å‰å¾ˆå°‘ç”¨C++å†™ä¸æ–‡ä»¶æ“ä½œç›¸å…³çš„ä»£ç ï¼Œæ‰€ä»¥å¯¹äºå®ç°-sè¿™ä¸ªå‚æ•°çš„æ—¶å€™æ— ä»ä¸‹æ‰‹ï¼Œæœ€åï¼Œé€šè¿‡æœç´¢å¼•æ“ï¼ŒæŸ¥é˜…å®˜æ–¹æ–‡æ¡£å’Œä»–äººçš„åšå®¢ï¼Œå­¦ä¹ åˆ°äº†æ–°çŸ¥è¯†ï¼Œé¡ºåˆ©åœ°è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚ å®ç°-aè¿™ä¸ªå‚æ•°ï¼Œéœ€è¦ç»Ÿè®¡ç©ºè¡Œã€ä»£ç è¡Œã€æ³¨é‡Šè¡Œã€‚ä¸€å¼€å§‹ï¼Œæˆ‘çš„æƒ³æ³•æ˜¯é€ä¸ªè¯»å–å­—ç¬¦ï¼Œè¿›è¡Œç›¸å…³å˜é‡çš„æ›´æ–°ï¼Œå¹¶è¿›è¡ŒçŠ¶æ€è½¬åŒ–ã€‚ä½†æ˜¯ï¼Œè¿™æ ·å®ç°çš„è¯ï¼Œä¼šéœ€è¦å¾ˆå¤šçš„æ ‡è®°ï¼Œè®©ä»£ç æ™¦æ¶©éš¾æ‡‚ã€‚è€Œä¸”ç”±äºè¿™ä¸ªçŠ¶æ€æœºçš„çŠ¶æ€å¾ˆå¤šï¼ŒçŠ¶æ€ä¹‹é—´çš„è½¬åŒ–ä¹Ÿç›¸å½“å¤æ‚ã€‚æ‰€ä»¥ï¼Œæœ€åæˆ‘æ”¾å¼ƒäº†è¿™ç§å®ç°æ–¹å¼ï¼Œæ”¹ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¥å®ç°ï¼Œè¿™æ ·ä¼šç®€å•å¾ˆå¤šã€‚è¿™å¯å‘æˆ‘ï¼Œåœ¨å…·ä½“å®ç°å‰ï¼Œæœ€å¥½å…ˆæ¯”è¾ƒä¸€ä¸‹å„ç§å®ç°æ–¹å¼çš„éš¾æ˜“ç¨‹åº¦ï¼Œå†é€‰æ‹©ä¸€ç§æ¯”è¾ƒå®¹æ˜“çš„æ¥å†™ã€‚ PSP PSP2.1 Personal Software Process Stages é¢„ä¼°è€—æ—¶ï¼ˆåˆ†é’Ÿï¼‰ å®é™…è€—æ—¶ï¼ˆåˆ†é’Ÿï¼‰ Planning è®¡åˆ’ 25 50 Â· Estimate Â· ä¼°è®¡è¿™ä¸ªä»»åŠ¡éœ€è¦å¤šå°‘æ—¶é—´ 25 50 Development å¼€å‘ 525 600 Â· Analysis Â· éœ€æ±‚åˆ†æ (åŒ…æ‹¬å­¦ä¹ æ–°æŠ€æœ¯) 75 75 Â· Design Spec Â· ç”Ÿæˆè®¾è®¡æ–‡æ¡£ 25 0 Â· Design Review Â· è®¾è®¡å¤å®¡ (å’ŒåŒäº‹å®¡æ ¸è®¾è®¡æ–‡æ¡£) 0 0 Â· Coding Standard Â· ä»£ç è§„èŒƒ (ä¸ºç›®å‰çš„å¼€å‘åˆ¶å®šåˆé€‚çš„è§„èŒƒ) 25 0 Â· Design Â· å…·ä½“è®¾è®¡ 25 50 Â· Coding Â· å…·ä½“ç¼–ç  325 425 Â· Code Review Â· ä»£ç å¤å®¡ 25 25 Â· Test Â· æµ‹è¯•ï¼ˆè‡ªæˆ‘æµ‹è¯•ï¼Œä¿®æ”¹ä»£ç ï¼Œæäº¤ä¿®æ”¹ï¼‰ 25 25 Reporting æŠ¥å‘Š 100 100 Â· Test Report Â· æµ‹è¯•æŠ¥å‘Š 50 50 Â· Size Measurement Â· è®¡ç®—å·¥ä½œé‡ 25 25 Â· Postmortem &amp; Process Improvement Plan Â· äº‹åæ€»ç»“, å¹¶æå‡ºè¿‡ç¨‹æ”¹è¿›è®¡åˆ’ 25 25 åˆè®¡ 650 750 æ€»ç»“ä¸€å¼€å§‹æ²¡æœ‰è®¤çœŸåˆ†æéœ€æ±‚ï¼Œæ²¡æœ‰æƒ³å¥½å°±å¼€å§‹åŠ¨æ‰‹ç¼–ç å®ç°ï¼Œä¸­é€”åœåœé¡¿é¡¿ï¼Œæµªè´¹äº†ä¸å°‘æ—¶é—´ã€‚ä»ä¸Šé¢çš„PSPä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œæˆ‘èŠ±äº†å¾ˆå°‘æ—¶é—´åœ¨â€œç”Ÿæˆè®¾è®¡æ–‡æ¡£â€ã€â€œè®¾è®¡å¤å®¡â€ã€â€œä»£ç è§„èŒƒâ€è¿™ä¸‰ä¸ªç¯èŠ‚ä¸Šï¼Œå¯¼è‡´æˆ‘åé¢â€œå…·ä½“ç¼–ç â€çš„ç¯èŠ‚èŠ±çš„æ—¶é—´æ¯”é¢„ä¼°çš„æ—¶é—´é•¿äº†å¾ˆå¤šã€‚åæ¥ï¼Œæˆ‘é‡æ–°é˜…è¯»äº†é¡¹ç›®æ–‡ä»¶ï¼Œæ˜ç¡®äº†éœ€æ±‚ï¼Œå¹¶è¿›è¡Œäº†ç›¸å…³è®¾è®¡ï¼Œç„¶åå°±å®ç°å¾—æ¯”è¾ƒé¡ºåˆ©äº†ã€‚è¿™å¯å‘æˆ‘ï¼Œåœ¨å¼€å§‹åŠ¨æ‰‹ç¼–ç å‰ï¼Œåº”è¯¥å…ˆæƒ³å¥½æ€è·¯ï¼Œå¹¶è®¾è®¡å¥½æ¨¡å—ï¼Œç£¨åˆ€ä¸è¯¯ç æŸ´å·¥å˜›ã€‚ å‚è€ƒ C/C++ä»£ç è¦†ç›–å·¥å…·gcovä¸lcovå…¥é—¨]]></content>
  </entry>
  <entry>
    <title><![CDATA[å›æ–‡è‡ªåŠ¨æœºå­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2018%2F09%2F04%2Fpalindromic-tree-learning%2F</url>
    <content type="text"><![CDATA[å›æ–‡è‡ªåŠ¨æœºæ˜¯ä¸€ç§å¯ä»¥å¤„ç†å›æ–‡ç¬¦é—®é¢˜çš„ä¼˜é›…é«˜æ•ˆçš„æ•°æ®ç»“æ„ã€‚ URAL 1960 Palindromes and Super Abilitiesé¢˜æ„æ±‚å„å‰ç¼€çš„æ‰€æœ‰å­ä¸²ä¸­çš„å›æ–‡ä¸²ç§ç±»ã€‚ åˆ†æä¾æ¬¡æ’å…¥å­—ç¬¦ï¼Œæ¯æ’å…¥å®Œä¸€ä¸ªå­—ç¬¦ï¼Œå‡å¦‚lastæŒ‡é’ˆæ‰€æŒ‡çš„èŠ‚ç‚¹æ˜¯æ–°å¢çš„ï¼Œé‚£ä¹ˆç­”æ¡ˆåŠ ä¸€ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* å›æ–‡è‡ªåŠ¨æœºï¼šè§£å†³ä¸€ç±»å›æ–‡å­—ç¬¦ä¸²é—®é¢˜(Tested 0 times) * æ—¶é—´å¤æ‚åº¦ï¼šO(|S| * log(å­—ç¬¦é›†ä¸ªæ•°)) */const int MAXN = 1e5 + 9;const int NN = 26;struct Palindromic_Tree &#123; int next[MAXN][NN] ;//nextæŒ‡é’ˆï¼ŒnextæŒ‡é’ˆå’Œå­—å…¸æ ‘ç±»ä¼¼ï¼ŒæŒ‡å‘çš„ä¸²ä¸ºå½“å‰ä¸²ä¸¤ç«¯åŠ ä¸ŠåŒä¸€ä¸ªå­—ç¬¦æ„æˆ int fail[MAXN] ;//failæŒ‡é’ˆï¼Œå¤±é…åè·³è½¬åˆ°failæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ int cnt[MAXN] ; //cnt[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²åœ¨æ•´ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ int num[MAXN] ; //num[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬æœ¬èº«ï¼‰ int len[MAXN] ;//len[i]è¡¨ç¤ºèŠ‚ç‚¹iè¡¨ç¤ºçš„å›æ–‡ä¸²çš„é•¿åº¦ int S[MAXN] ;//å­˜æ”¾æ·»åŠ çš„å­—ç¬¦ int last ;//æŒ‡å‘ä¸Šä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡add int n ;//å­—ç¬¦æ•°ç»„æŒ‡é’ˆ int p ;//èŠ‚ç‚¹æŒ‡é’ˆ int newnode ( int l ) &#123;//æ–°å»ºèŠ‚ç‚¹ for ( int i = 0 ; i &lt; NN ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//åˆå§‹åŒ– p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//å¼€å¤´æ”¾ä¸€ä¸ªå­—ç¬¦é›†ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå‡å°‘ç‰¹åˆ¤ fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//å’ŒKMPä¸€æ ·ï¼Œå¤±é…åæ‰¾ä¸€ä¸ªå°½é‡æœ€é•¿çš„ while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//é€šè¿‡ä¸Šä¸€ä¸ªå›æ–‡ä¸²æ‰¾è¿™ä¸ªå›æ–‡ä¸²çš„åŒ¹é…ä½ç½® if ( !next[cur][c] ) &#123;//å¦‚æœè¿™ä¸ªå›æ–‡ä¸²æ²¡æœ‰å‡ºç°è¿‡ï¼Œè¯´æ˜å‡ºç°äº†ä¸€ä¸ªæ–°çš„æœ¬è´¨ä¸åŒçš„å›æ–‡ä¸² int now = newnode ( len[cur] + 2 ) ;//æ–°å»ºèŠ‚ç‚¹ fail[now] = next[get_fail ( fail[cur] )][c] ;//å’ŒACè‡ªåŠ¨æœºä¸€æ ·å»ºç«‹failæŒ‡é’ˆï¼Œä»¥ä¾¿å¤±é…åè·³è½¬ next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //çˆ¶äº²ç´¯åŠ å„¿å­çš„cntï¼Œå› ä¸ºå¦‚æœfail[v]=uï¼Œåˆ™uä¸€å®šæ˜¯vçš„å­å›æ–‡ä¸²ï¼ &#125;&#125;pt;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", s); int len = strlen(s); pt.init(); int ans = 0; for(int i = 0; i &lt; len; i++) &#123; pt.add(s[i]); if(pt.cnt[pt.last] == 1) ans++; printf("%d%c", ans, " \n"[i == len - 1]); &#125; return 0;&#125; Tsinsen A1280 æœ€é•¿åŒå›æ–‡ä¸²é¢˜æ„ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåœ¨ä¸­é—´æŸä¸ªä½ç½®åˆ‡å¼€ï¼Œèƒ½å½¢æˆä¸¤ä¸ªå›æ–‡ä¸²ï¼Œåˆ™ç§°è¿™ä¸ªå›æ–‡ä¸²ä¸ºåŒå›æ–‡ä¸²ã€‚ç°åœ¨éœ€è¦æ±‚æœ€é•¿åŒå›æ–‡ä¸²ã€‚ åˆ†æä»¤a[i]è¡¨ç¤ºä»¥iç»“æŸçš„æœ€é•¿å›æ–‡ä¸²é•¿åº¦ï¼Œb[i]è¡¨ç¤ºä»iå¼€å§‹çš„æœ€é•¿å›æ–‡ä¸²é•¿åº¦ã€‚æ¯æ’å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œå°±æ›´æ–°è¿™ä¸¤ä¸ªæ•°ç»„ï¼Œæœ€åæ‰«ä¸€éï¼Œå–a[i] + b[i+1]çš„æœ€å¤§å€¼ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;int a[N], b[N];/************************************************************//* å›æ–‡è‡ªåŠ¨æœºï¼šè§£å†³ä¸€ç±»å›æ–‡å­—ç¬¦ä¸²é—®é¢˜(Tested 2 times) * æ—¶é—´å¤æ‚åº¦ï¼šO(|S| * log(å­—ç¬¦é›†ä¸ªæ•°)) */const int MAXN = 1e5 + 9;const int NN = 26;struct Palindromic_Tree &#123; int next[MAXN][NN] ;//nextæŒ‡é’ˆï¼ŒnextæŒ‡é’ˆå’Œå­—å…¸æ ‘ç±»ä¼¼ï¼ŒæŒ‡å‘çš„ä¸²ä¸ºå½“å‰ä¸²ä¸¤ç«¯åŠ ä¸ŠåŒä¸€ä¸ªå­—ç¬¦æ„æˆ int fail[MAXN] ;//failæŒ‡é’ˆï¼Œå¤±é…åè·³è½¬åˆ°failæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ int cnt[MAXN] ; //cnt[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²åœ¨æ•´ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ int num[MAXN] ; //num[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬æœ¬èº«ï¼‰ int len[MAXN] ;//len[i]è¡¨ç¤ºèŠ‚ç‚¹iè¡¨ç¤ºçš„å›æ–‡ä¸²çš„é•¿åº¦ int S[MAXN] ;//å­˜æ”¾æ·»åŠ çš„å­—ç¬¦ int last ;//æŒ‡å‘ä¸Šä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡add int n ;//å­—ç¬¦æ•°ç»„æŒ‡é’ˆ int p ;//èŠ‚ç‚¹æŒ‡é’ˆ int newnode ( int l ) &#123;//æ–°å»ºèŠ‚ç‚¹ for ( int i = 0 ; i &lt; NN ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//åˆå§‹åŒ– p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//å¼€å¤´æ”¾ä¸€ä¸ªå­—ç¬¦é›†ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå‡å°‘ç‰¹åˆ¤ fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//å’ŒKMPä¸€æ ·ï¼Œå¤±é…åæ‰¾ä¸€ä¸ªå°½é‡æœ€é•¿çš„ while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; // æ’å…¥çš„æ˜¯å­—ç¬¦ void add (int id, int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//é€šè¿‡ä¸Šä¸€ä¸ªå›æ–‡ä¸²æ‰¾è¿™ä¸ªå›æ–‡ä¸²çš„åŒ¹é…ä½ç½® if ( !next[cur][c] ) &#123;//å¦‚æœè¿™ä¸ªå›æ–‡ä¸²æ²¡æœ‰å‡ºç°è¿‡ï¼Œè¯´æ˜å‡ºç°äº†ä¸€ä¸ªæ–°çš„æœ¬è´¨ä¸åŒçš„å›æ–‡ä¸² int now = newnode ( len[cur] + 2 ) ;//æ–°å»ºèŠ‚ç‚¹ fail[now] = next[get_fail ( fail[cur] )][c] ;//å’ŒACè‡ªåŠ¨æœºä¸€æ ·å»ºç«‹failæŒ‡é’ˆï¼Œä»¥ä¾¿å¤±é…åè·³è½¬ next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; a[id] = len[last]; b[id - len[last] + 1] = max(b[id - len[last] + 1], len[last]); cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //çˆ¶äº²ç´¯åŠ å„¿å­çš„cntï¼Œå› ä¸ºå¦‚æœfail[v]=uï¼Œåˆ™uä¸€å®šæ˜¯vçš„å­å›æ–‡ä¸²ï¼ &#125;&#125;pt;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", s); int len = strlen(s); pt.init(); for(int i = 0; i &lt; len; i++) &#123; pt.add(i, s[i]); &#125; int ans = 2; for(int i = 0; i &lt; len - 1; i++) &#123; ans = max(ans, a[i] + b[i + 1]); &#125; printf("%d\n", ans); return 0;&#125; Tsinsen A1255 æ‹‰æ‹‰é˜Ÿæ’ç»ƒé¢˜æ„æ±‚å‰kå¤§å¥‡æ•°é•¿åº¦çš„å›æ–‡ä¸²çš„ä¹˜ç§¯ã€‚ åˆ†æå…ˆå»ºå›æ–‡è‡ªåŠ¨æœºï¼Œç„¶ådfså¥‡æ ¹èŠ‚ç‚¹ï¼Œæ‰¾å‡ºå¥‡æ•°é•¿åº¦çš„å›æ–‡ä¸²çš„é•¿åº¦å’Œä¸ªæ•°ï¼Œæ”¾åˆ°å®¹å™¨ï¼Œæ’ä¸ªåºè´ªå¿ƒå–å‡ºæ¥å³å¯ã€‚æ³¨æ„ä¸èƒ½ç›´æ¥é€’å½’dfsï¼Œä¼šçˆ†æ ˆï¼Œéœ€è¦ç”¨stackã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#pragma comment(linker, "/STACK:1024000000,1024000000") #include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e6+9;const int mod = 19930726;/************************************************************//* å›æ–‡è‡ªåŠ¨æœºï¼šè§£å†³ä¸€ç±»å›æ–‡å­—ç¬¦ä¸²é—®é¢˜(Tested 4 times) * æ—¶é—´å¤æ‚åº¦ï¼šO(|S| * log(å­—ç¬¦é›†ä¸ªæ•°)) */const int MAXN = 1e6 + 9;const int NN = 26; //å­—ç¬¦é›†ä¸ªæ•°struct Palindromic_Tree &#123; int next[MAXN][NN];//nextæŒ‡é’ˆï¼ŒnextæŒ‡é’ˆå’Œå­—å…¸æ ‘ç±»ä¼¼ï¼ŒæŒ‡å‘çš„ä¸²ä¸ºå½“å‰ä¸²ä¸¤ç«¯åŠ ä¸ŠåŒä¸€ä¸ªå­—ç¬¦æ„æˆ int fail[MAXN];//failæŒ‡é’ˆï¼Œå¤±é…åè·³è½¬åˆ°failæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ int cnt[MAXN]; //cnt[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²åœ¨æ•´ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ int num[MAXN]; //num[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬æœ¬èº«ï¼‰ int len[MAXN];//len[i]è¡¨ç¤ºèŠ‚ç‚¹iè¡¨ç¤ºçš„å›æ–‡ä¸²çš„é•¿åº¦ int S[MAXN];//å­˜æ”¾æ·»åŠ çš„å­—ç¬¦ int last;//æŒ‡å‘ä¸Šä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡add int n;//å­—ç¬¦æ•°ç»„æŒ‡é’ˆ int p;//èŠ‚ç‚¹æŒ‡é’ˆ int newnode(int l) &#123;//æ–°å»ºèŠ‚ç‚¹ for(int i = 0; i &lt; NN; i++) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123;//åˆå§‹åŒ– p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//å¼€å¤´æ”¾ä¸€ä¸ªå­—ç¬¦é›†ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå‡å°‘ç‰¹åˆ¤ fail[0] = 1; &#125; int get_fail(int x) &#123;//å’ŒKMPä¸€æ ·ï¼Œå¤±é…åæ‰¾ä¸€ä¸ªå°½é‡æœ€é•¿çš„ while(S[n - len[x] - 1] != S[n]) x = fail[x]; return x ; &#125; // æ’å…¥çš„æ˜¯å­—ç¬¦ void add(int c) &#123; c -= 'a'; S[++ n] = c; int cur = get_fail(last);//é€šè¿‡ä¸Šä¸€ä¸ªå›æ–‡ä¸²æ‰¾è¿™ä¸ªå›æ–‡ä¸²çš„åŒ¹é…ä½ç½® if(!next[cur][c]) &#123;//å¦‚æœè¿™ä¸ªå›æ–‡ä¸²æ²¡æœ‰å‡ºç°è¿‡ï¼Œè¯´æ˜å‡ºç°äº†ä¸€ä¸ªæ–°çš„æœ¬è´¨ä¸åŒçš„å›æ–‡ä¸² int now = newnode(len[cur] + 2);//æ–°å»ºèŠ‚ç‚¹ fail[now] = next[get_fail(fail[cur])][c];//å’ŒACè‡ªåŠ¨æœºä¸€æ ·å»ºç«‹failæŒ‡é’ˆï¼Œä»¥ä¾¿å¤±é…åè·³è½¬ next[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = next[cur][c]; cnt[last]++; &#125; void count () &#123; for(int i = p - 1; i &gt;= 0; i--) cnt[fail[i]] += cnt[i]; //çˆ¶äº²ç´¯åŠ å„¿å­çš„cntï¼Œå› ä¸ºå¦‚æœfail[v]=uï¼Œåˆ™uä¸€å®šæ˜¯vçš„å­å›æ–‡ä¸²ï¼ &#125;&#125;pt;/************************************************************/char s[N];int n;ll k;pii a[N];vector&lt;pii&gt; v;ll sum;queue&lt;int&gt;que;void dfs(int u) &#123; que.push(u); while(!que.empty()) &#123; int u = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; int t = pt.next[u][i]; if(t) &#123; sum += pt.cnt[t]; que.push(t); //cout &lt;&lt; t &lt;&lt; endl; v.push_back(pii(pt.len[t], pt.cnt[t])); //dfs(t); &#125; &#125; &#125;&#125;bool cmp(pii a, pii b) &#123; return a.x &gt; b.x;&#125;ll ksm(ll x, ll y) &#123; ll ans = 1; while(y) &#123; if(y &amp; 1) (ans *= x) %= mod; (x *= x) %= mod; y &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d%lld", &amp;n, &amp;k); scanf("%s", s); n = strlen(s); pt.init(); for(int i = 0; i &lt; n; i++) &#123; pt.add(s[i]); &#125; pt.count(); dfs(1); if(sum &lt; k) &#123; printf("-1\n"); &#125; else &#123; sort(v.begin(), v.end(), cmp); ll ans = 1; for(auto i: v) &#123; ll num = min(1LL * i.y, k); (ans *= ksm(i.x, num)) %= mod; k -= i.y; if(k &lt;= 0) break; &#125; printf("%lld\n", ans); &#125; return 0;&#125; Tsinsen A1393 Palisectioné¢˜æ„æ±‚ç›¸äº¤å›æ–‡ä¸²çš„å¯¹æ•°ã€‚ åˆ†æç›´æ¥æ±‚ç›¸äº¤å›æ–‡ä¸²çš„å¯¹æ•°çš„è¯ï¼Œä¸å¥½æ±‚ã€‚ç»è¿‡æ€è€ƒï¼Œå‘ç°æ‰€æœ‰å›æ–‡ä¸²å¯¹æ•°ä»¥åŠä¸ç›¸äº¤å›æ–‡ä¸²çš„å¯¹æ•°æ¯”è¾ƒå¥½æ±‚ï¼Œè€Œè¿™ä¸¤è€…ç›¸å‡å°±æ˜¯ç­”æ¡ˆï¼Œå¾—è§£ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 2e6+9;const int mod = 51123987;/************************************************************//* å›æ–‡è‡ªåŠ¨æœºï¼šè§£å†³ä¸€ç±»å›æ–‡å­—ç¬¦ä¸²é—®é¢˜(Tested 5 times) * æ—¶é—´å¤æ‚åº¦ï¼šO(|S| * log(å­—ç¬¦é›†ä¸ªæ•°)) */const int MAXN = 2e6 + 9;const int NN = 26; //å­—ç¬¦é›†ä¸ªæ•°struct Palindromic_Tree &#123; int next[MAXN][NN];//nextæŒ‡é’ˆï¼ŒnextæŒ‡é’ˆå’Œå­—å…¸æ ‘ç±»ä¼¼ï¼ŒæŒ‡å‘çš„ä¸²ä¸ºå½“å‰ä¸²ä¸¤ç«¯åŠ ä¸ŠåŒä¸€ä¸ªå­—ç¬¦æ„æˆ int fail[MAXN];//failæŒ‡é’ˆï¼Œå¤±é…åè·³è½¬åˆ°failæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ int cnt[MAXN]; //cnt[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²åœ¨æ•´ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ int num[MAXN]; //num[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬æœ¬èº«ï¼‰ int len[MAXN];//len[i]è¡¨ç¤ºèŠ‚ç‚¹iè¡¨ç¤ºçš„å›æ–‡ä¸²çš„é•¿åº¦ int S[MAXN];//å­˜æ”¾æ·»åŠ çš„å­—ç¬¦ int last;//æŒ‡å‘ä¸Šä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡add int n;//å­—ç¬¦æ•°ç»„æŒ‡é’ˆ int p;//èŠ‚ç‚¹æŒ‡é’ˆ int newnode(int l) &#123;//æ–°å»ºèŠ‚ç‚¹ for(int i = 0; i &lt; NN; i++) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123;//åˆå§‹åŒ– p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//å¼€å¤´æ”¾ä¸€ä¸ªå­—ç¬¦é›†ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå‡å°‘ç‰¹åˆ¤ fail[0] = 1; &#125; int get_fail(int x) &#123;//å’ŒKMPä¸€æ ·ï¼Œå¤±é…åæ‰¾ä¸€ä¸ªå°½é‡æœ€é•¿çš„ while(S[n - len[x] - 1] != S[n]) x = fail[x]; return x ; &#125; // æ’å…¥çš„æ˜¯å­—ç¬¦ int add(int c) &#123; c -= 'a'; S[++ n] = c; int cur = get_fail(last);//é€šè¿‡ä¸Šä¸€ä¸ªå›æ–‡ä¸²æ‰¾è¿™ä¸ªå›æ–‡ä¸²çš„åŒ¹é…ä½ç½® if(!next[cur][c]) &#123;//å¦‚æœè¿™ä¸ªå›æ–‡ä¸²æ²¡æœ‰å‡ºç°è¿‡ï¼Œè¯´æ˜å‡ºç°äº†ä¸€ä¸ªæ–°çš„æœ¬è´¨ä¸åŒçš„å›æ–‡ä¸² int now = newnode(len[cur] + 2);//æ–°å»ºèŠ‚ç‚¹ fail[now] = next[get_fail(fail[cur])][c];//å’ŒACè‡ªåŠ¨æœºä¸€æ ·å»ºç«‹failæŒ‡é’ˆï¼Œä»¥ä¾¿å¤±é…åè·³è½¬ next[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = next[cur][c]; cnt[last]++; return num[last]; &#125; void count () &#123; for(int i = p - 1; i &gt;= 0; i--) cnt[fail[i]] += cnt[i]; //çˆ¶äº²ç´¯åŠ å„¿å­çš„cntï¼Œå› ä¸ºå¦‚æœfail[v]=uï¼Œåˆ™uä¸€å®šæ˜¯vçš„å­å›æ–‡ä¸²ï¼ &#125;&#125;pt;/************************************************************/char s[N];int n;ll sum[N], ans;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d%s", &amp;n, s); pt.init(); for(int i = 0; i &lt; n; i++) &#123; (sum[i+1] = sum[i] + pt.add(s[i])) %= mod; &#125; (ans = 1LL * sum[n] * (sum[n] - 1) / 2) %= mod; reverse(s, s + n); pt.init(); ll t = 0; for(int i = 0; i &lt; n; i++) &#123; t = pt.add(s[i]); ans -= t * sum[n - i - 1]; (ans += mod) %= mod; &#125; printf("%lld\n", ans); return 0;&#125; Gym 100548G The Problem to Slow Down Youé¢˜æ„ç»™ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­ç›¸åŒå›æ–‡ä¸²çš„å¯¹æ•°ã€‚ åˆ†æé¦–å…ˆåˆ†åˆ«ç»™ä¸¤ä¸ªå­—ç¬¦ä¸²å»ºç«‹å›æ–‡è‡ªåŠ¨æœºï¼Œç„¶ååˆ†åˆ«dfsä¸€ä¸‹å¥‡å¶æ ¹èŠ‚ç‚¹ï¼Œç´¯åŠ ä¸¤ä¸ªå›æ–‡è‡ªåŠ¨æœºç›¸åŒä½ç½®çš„èŠ‚ç‚¹çš„cntä¹˜ç§¯å³å¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 2e5+9;/************************************************************//* å›æ–‡è‡ªåŠ¨æœºï¼šè§£å†³ä¸€ç±»å›æ–‡å­—ç¬¦ä¸²é—®é¢˜(Tested 4 times) * æ—¶é—´å¤æ‚åº¦ï¼šO(|S| * log(å­—ç¬¦é›†ä¸ªæ•°)) */const int MAXN = 2e5 + 9;const int NN = 26; //å­—ç¬¦é›†ä¸ªæ•°struct Palindromic_Tree &#123; int next[MAXN][NN];//nextæŒ‡é’ˆï¼ŒnextæŒ‡é’ˆå’Œå­—å…¸æ ‘ç±»ä¼¼ï¼ŒæŒ‡å‘çš„ä¸²ä¸ºå½“å‰ä¸²ä¸¤ç«¯åŠ ä¸ŠåŒä¸€ä¸ªå­—ç¬¦æ„æˆ int fail[MAXN];//failæŒ‡é’ˆï¼Œå¤±é…åè·³è½¬åˆ°failæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ int cnt[MAXN]; //cnt[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²åœ¨æ•´ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ int num[MAXN]; //num[i]è¡¨ç¤ºiè¡¨ç¤ºçš„å›æ–‡å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬æœ¬èº«ï¼‰ int len[MAXN];//len[i]è¡¨ç¤ºèŠ‚ç‚¹iè¡¨ç¤ºçš„å›æ–‡ä¸²çš„é•¿åº¦ int S[MAXN];//å­˜æ”¾æ·»åŠ çš„å­—ç¬¦ int last;//æŒ‡å‘ä¸Šä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡add int n;//å­—ç¬¦æ•°ç»„æŒ‡é’ˆ int p;//èŠ‚ç‚¹æŒ‡é’ˆ int newnode(int l) &#123;//æ–°å»ºèŠ‚ç‚¹ for(int i = 0; i &lt; NN; i++) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123;//åˆå§‹åŒ– p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//å¼€å¤´æ”¾ä¸€ä¸ªå­—ç¬¦é›†ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå‡å°‘ç‰¹åˆ¤ fail[0] = 1; &#125; int get_fail(int x) &#123;//å’ŒKMPä¸€æ ·ï¼Œå¤±é…åæ‰¾ä¸€ä¸ªå°½é‡æœ€é•¿çš„ while(S[n - len[x] - 1] != S[n]) x = fail[x]; return x ; &#125; // æ’å…¥çš„æ˜¯å­—ç¬¦ void add(int c) &#123; c -= 'a'; S[++ n] = c; int cur = get_fail(last);//é€šè¿‡ä¸Šä¸€ä¸ªå›æ–‡ä¸²æ‰¾è¿™ä¸ªå›æ–‡ä¸²çš„åŒ¹é…ä½ç½® if(!next[cur][c]) &#123;//å¦‚æœè¿™ä¸ªå›æ–‡ä¸²æ²¡æœ‰å‡ºç°è¿‡ï¼Œè¯´æ˜å‡ºç°äº†ä¸€ä¸ªæ–°çš„æœ¬è´¨ä¸åŒçš„å›æ–‡ä¸² int now = newnode(len[cur] + 2);//æ–°å»ºèŠ‚ç‚¹ fail[now] = next[get_fail(fail[cur])][c];//å’ŒACè‡ªåŠ¨æœºä¸€æ ·å»ºç«‹failæŒ‡é’ˆï¼Œä»¥ä¾¿å¤±é…åè·³è½¬ next[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = next[cur][c]; cnt[last]++; &#125; void count () &#123; for(int i = p - 1; i &gt;= 0; i--) cnt[fail[i]] += cnt[i]; //çˆ¶äº²ç´¯åŠ å„¿å­çš„cntï¼Œå› ä¸ºå¦‚æœfail[v]=uï¼Œåˆ™uä¸€å®šæ˜¯vçš„å­å›æ–‡ä¸²ï¼ &#125;&#125;pt[2];/************************************************************/char s[2][N];int len[2], kase;ll ans;void dfs(int u0, int u1) &#123; for(int i = 0; i &lt; 26; i++) &#123; int t0 = pt[0].next[u0][i]; int t1 = pt[1].next[u1][i]; if(t0 &amp;&amp; t1) &#123; ans += 1LL * pt[0].cnt[t0] * pt[1].cnt[t1]; dfs(t0, t1); &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%s%s", s[0], s[1]); for(int k = 0; k &lt; 2; k++) &#123; len[k] = strlen(s[k]); pt[k].init(); for(int i = 0; i &lt; len[k]; i++) &#123; pt[k].add(s[k][i]); &#125; pt[k].count(); &#125; ans = 0; dfs(0, 0); dfs(1, 1); printf("Case #%d: %lld\n", ++kase, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>å­—ç¬¦ä¸²</tag>
        <tag>å›æ–‡è‡ªåŠ¨æœº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbinå¸¦ä½ é£ ä¸“é¢˜åä¸ƒ ACè‡ªåŠ¨æœº é¢˜è§£]]></title>
    <url>%2F2018%2F08%2F23%2Fac-auto-machine-learning%2F</url>
    <content type="text"><![CDATA[kuanginå¸¦ä½ é£ä¸“é¢˜åä¸ƒ ACè‡ªåŠ¨æœº ä¼ é€é—¨ACè‡ªåŠ¨æœºæ˜¯è‘—åçš„å¤šæ¨¡åŒ¹é…ç®—æ³•ï¼Œåœ¨ACMä¸­é€šå¸¸ä¼šç»“åˆè®¡æ•°é—®é¢˜ã€åŠ¨æ€è§„åˆ’é—®é¢˜ç­‰ä¸€èµ·å‡ºç°ã€‚ A. HDU 2222 Keywords Searchç»Ÿè®¡å­—ç¬¦ä¸²å‡ºç°çš„ä¸ªæ•°ï¼ŒACè‡ªåŠ¨æœºæ¨¡æ¿é¢˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=5e5+9;const int shift=1e3+9;const double Eps=1e-7;/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Untested) */struct AC &#123; int next[N][26], fail[N], end[N], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now]++; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; int query(char s[]) &#123; int ans = 0, len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; now = next[now][s[i] - 'a']; int temp = now; while(temp != root) &#123; ans += end[temp]; end[temp] = 0; temp = fail[temp]; &#125; &#125; return ans; &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int T, n;char s[N * 2];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); ac.init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); scanf("%s", s); int ans = ac.query(s); printf("%d\n", ans); &#125; return 0;&#125; B.HDU 2896 ç—…æ¯’ä¾µè¢­å’Œä¸Šé“é¢˜å·®ä¸å¤šï¼Œä½†è¿™é“é¢˜è¦æ±‚è¾“å‡ºå‡ºç°çš„å­—ç¬¦ä¸²ï¼Œä¿®æ”¹ä¸€ä¸‹èŠ‚ç‚¹ä¿å­˜çš„ä¿¡æ¯å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// æ¨¡å¼ä¸²ä¹‹é—´å¯ä»¥é‡å #include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, total;char s[10009];//å†™ACè‡ªåŠ¨æœºç­‰æ ‘çŠ¶æ•°æ®ç»“æ„ä¸€å®šè¦æ³¨æ„ç©ºé—´ï¼//æ¯”å¦‚è¿™é“é¢˜ï¼Œå¤šç”³è¯·ä¸ªset&lt;int&gt; se[N] å°±ä¼šMLE struct acAuto &#123; int next[N][128], fail[N], root, L; vi end[N]; void init() &#123; L = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 128; i++) next[L][i] = -1; end[L].clear(); return L++; &#125; void insert(char s[], int id) &#123; int now = root, len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i]] == -1) next[now][s[i]] = newNode(); now = next[now][s[i]]; &#125; end[now].push_back(id); &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; //! for(int i = 0; i &lt; 128; i++) &#123; if(next[root][i] == -1) next[root][i] = root; // else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 128; i++) &#123; if(next[now][i] == -1) next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; bool query(char s[], int id) &#123; int now = root, len = strlen(s); set&lt;int&gt; se; bool flag[N]; memset(flag, 0, sizeof flag); for(int i = 0; i &lt; len; i++) &#123; now = next[now][s[i]]; int temp = now; while(temp != root) &#123; if(!flag[temp]) &#123; for(auto j: end[temp]) se.insert(j); flag[temp] = true; &#125; if(se.size() &gt;= 3) break; temp = fail[temp]; &#125; &#125; if(se.size()) &#123; printf("web %d:", id); for(auto i: se) printf(" %d", i); printf("\n"); return true; &#125; return false; &#125; void debug() &#123; printf("%27c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; L;i++) &#123; printf("id = %3d,fail = %3d,chi = [",i,fail[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;n); ac.init(); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); ac.insert(s, i); &#125; ac.build(); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); if(ac.query(s ,i)) total++; &#125; printf("total: %d\n", total); return 0;&#125; C. HDU 3065 ç—…æ¯’ä¾µè¢­æŒç»­ä¸­éœ€è¦ç»Ÿè®¡å„å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•°ï¼Œä½¿ç”¨vectoræ¥ç»´æŠ¤èŠ‚ç‚¹ä¸Šå‡ºç°çš„å­—ç¬¦ä¸²å³å¯ã€‚æ³¨æ„æ˜¯å¤šç»„æ ·ä¾‹ï¼Œåˆå§‹åŒ–è¦å¤„ç†å¥½ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//é¢˜ç›®æœ‰ç‚¹å‘å•Šï¼Œæ²¡æœ‰è¯´å¤šç»„æ ·ä¾‹ï¼ŒWAäº†ä¸€å‘:(#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n;char s[2000009];char ss[1009][59];struct acAuto &#123; int next[N][26], fail[N], root, L; vi end[N]; void init() &#123; L = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[L][i] = -1; end[L].clear(); return L++; &#125; void insert(char s[], int id) &#123; int now = root, len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'A'] == -1) next[now][s[i] - 'A'] = newNode(); now = next[now][s[i] - 'A']; &#125; end[now].push_back(id); &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(char s[]) &#123; int now = root, len = strlen(s); int cnt[N]; bool flag[N]; memset(flag, 0, sizeof flag); memset(cnt, 0, sizeof cnt); set&lt;int&gt;se; for(int i = 0; i &lt; len; i++) &#123; now = isupper(s[i]) ? next[now][s[i] - 'A'] : root; int temp = now; while(temp != root) &#123; for(auto id: end[temp]) &#123; cnt[id]++; if(!flag[id]) &#123; se.insert(id); flag[id] = true; &#125; &#125; temp = fail[temp]; &#125; &#125; for(auto i: se) &#123; printf("%s: %d\n", ss[i], cnt[i]); &#125; &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d", &amp;n)) &#123; ac.init(); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", ss[i]); ac.insert(ss[i], i); &#125; ac.build(); scanf("%s", s); ac.query(s); &#125; return 0;&#125; D. ZOJ 3430 Detect the Virusé¢˜ç›®æœ‰ç‚¹éš¾æ‡‚ï¼Œç•™å‘å¾…å¡«ã€‚ E. POJ 2778 DNA Sequenceæ±‚ä¸å«æ¨¡å¼ä¸²çš„å­—ç¬¦ä¸²æ€»æ•°ã€‚è¯¥è®¡æ•°é—®é¢˜å¯ç”¨ACè‡ªåŠ¨æœº+çŸ©é˜µå¿«é€Ÿå¹‚è§£å†³ï¼Œå¾ˆç»å…¸ã€‚è¯¦ç»†é¢˜è§£ä¼ é€é—¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt; #include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;const int mod = 100000;map&lt;char, int&gt; m;int n, mm;char s[19];/************************************************************//* çŸ©é˜µå¿«é€Ÿå¹‚ï¼šæ ¹æ®é€’æ¨å¼å¿«é€Ÿè®¡ç®—ç¬¬né¡¹ * çŸ©é˜µæ„é€ ã€æ—¶é—´å¤æ‚åº¦å‚è€ƒç™½ä¹¦P201 */typedef vector&lt;vi&gt; mat;mat mul(mat A, mat B)&#123; mat C(A.size(), vi(B[0].size())); for(int i=0; i&lt;A.size(); i++) for(int k=0; k&lt;A[0].size(); k++) for(int j=0; j&lt;B[0].size(); j++) C[i][j]=(1LL * C[i][j]+1LL * A[i][k]*B[k][j])%mod; return C;&#125;mat pow(mat A, int n)&#123; mat B(A.size(), vi(A.size())); for(int i=0; i&lt;B.size(); i++) B[i][i]=1; while(n)&#123; if(n&amp;1) B=mul(B, A); A=mul(A, A); n&gt;&gt;=1; &#125; return B;&#125;/************************************************************/struct acAuto &#123; int next[109][4], fail[109], L, root; bool end[109]; void init() &#123; L = 0; m['A'] = 0; m['T'] = 1; m['C'] = 2; m['G'] = 3; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[L][i] = -1; end[L] = false; return L++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; int j = m[s[i]]; if(next[now][j] == -1) next[now][j] = newNode(); now = next[now][j]; &#125; end[now] = true; &#125; void build() &#123; fail[root] = root; queue&lt;int&gt; que; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]]) //å‡å¦‚failè½¬ç§»åˆ°çš„çŠ¶æ€ä¸åˆæ³•ï¼Œé‚£ä¹ˆè¯¥çŠ¶æ€ä¹Ÿä¸åˆæ³•ï¼ end[now] = true; for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void buildMatrix(::mat &amp;a) &#123; for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; 4; j++) if(end[next[i][j]] == false) a[i][next[i][j]]++; &#125; void solve() &#123; ::mat a(L, vi(L)); buildMatrix(a); a = pow(a, n); ll ans = 0; for(int j = 0; j &lt; L; j++) (ans += a[0][j]) %= mod; printf("%lld\n", ans); &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;mm, &amp;n)) &#123; ac.init(); for(int i = 0; i &lt; mm; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); ac.solve(); &#125;; return 0;&#125; F. HDU 2243 è€ƒç ”è·¯èŒ«èŒ«â€•â€•å•è¯æƒ…ç»“æ±‚å«æ¨¡å¼ä¸²çš„å­—ç¬¦ä¸²æ€»æ•°ï¼Œæ³¨æ„è¿™é“é¢˜çš„å­—ç¬¦ä¸²é•¿åº¦æ˜¯å¯å˜çš„ï¼Œæ‰€ä»¥çŸ©é˜µæ„é€ éœ€è¦æœ‰æ‰€å˜åŒ–ã€‚åŒæ ·æ˜¯è®¡æ•°é—®é¢˜ï¼Œè¿˜æ˜¯ACè‡ªåŠ¨æœº+çŸ©é˜µå¿«é€Ÿå¹‚çš„å¥—è·¯ã€‚è¯¦ç»†é¢˜è§£ä¼ é€é—¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* çŸ©é˜µå¿«é€Ÿå¹‚ï¼šæ ¹æ®é€’æ¨å¼å¿«é€Ÿè®¡ç®—ç¬¬né¡¹(Untested) * çŸ©é˜µæ„é€ ã€æ—¶é—´å¤æ‚åº¦å‚è€ƒç™½ä¹¦P201 */// å®šä¹‰çŸ©é˜µå…ƒç´ ä¸ºlong longçš„çŸ©é˜µï¼štypedef vector&lt;ull&gt; vll;typedef vector&lt;vll&gt; mat;mat mul(mat A, mat B)&#123; mat C(A.size(), vll(B[0].size(), 0)); for(int i = 0; i &lt; A.size(); i++) for(int k = 0; k &lt; A[0].size(); k++) for(int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]); return C;&#125;mat pow(mat A, ll n) &#123; mat B(A.size(), vll(A.size(), 0)); for(int i = 0; i &lt; B.size(); i++) B[i][i] = 1; while(n) &#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;/************************************************************//********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 1 times) */struct AC &#123; int next[39][26], fail[39], end[39], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = false; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = true; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]] == true) end[now] = true; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; ull cntIllegal(ll L) &#123; mat a(idx + 1, vll(idx + 1, 0)); for(int i = 0; i &lt; idx; i++) for(int j = 0; j &lt; 26; j++) if(end[next[i][j]] == false) a[i][next[i][j]]++; for(int i = 0; i &lt; idx + 1; i++) a[i][idx] = 1; a = pow(a, L); ull ans = 0; for(int i = 0; i &lt; idx + 1; i++) ans += a[0][i]; return ans - 1; &#125;&#125;ac;/********************************************************************************/int n;ll L;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%lld", &amp;n, &amp;L)) &#123; ac.init(); while(n--) &#123; scanf("%s", s); ac.insert(s); &#125; mat a(2, vll(2, 0)), b(2, vll(1, 0)); a[0][0] = 26, a[0][1] = 1; a[1][0] = 0, a[1][1] = 1; b[0][0] = 1; b[1][0] = 1; a = pow(a, L); a = mul(a, b); ull ans = a[0][0] - 1; ac.build(); ans -= ac.cntIllegal(L); printf("%llu\n", ans); &#125; return 0;&#125; G. POJ 1625 Censored!æ±‚ä¸å«æ¨¡å¼ä¸²çš„å­—ç¬¦ä¸²æ€»æ•°ï¼Œéœ€è¦ä½¿ç”¨å¤§æ•°ï¼Œä½†æ˜¯ä¸èƒ½ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ï¼Œå› ä¸ºä¼šMLEã€‚æ³¨æ„åˆ°mæŒºå°ï¼Œæ‰€ä»¥è€ƒè™‘ç”¨DPè§£å†³ï¼Œè€Œä¸”è¿˜éœ€è¦ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ä¸€ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;int chr = 0;char c, s[59];map&lt;char, int&gt; m;int n, mm, p;/* * é«˜ç²¾åº¦ï¼Œæ”¯æŒä¹˜æ³•å’ŒåŠ æ³•(Tested 0 times) */struct BigInt&#123; const static int mod = 10000; const static int DLEN = 4; int a[90],len; BigInt()&#123; memset(a,0,sizeof(a)); len = 1; &#125; BigInt(int v)&#123; memset(a,0,sizeof(a)); len = 0; do&#123; a[len++] = v%mod; v /= mod; &#125;while(v); &#125; BigInt(const char s[])&#123; memset(a,0,sizeof(a)); int L = strlen(s); len = L/DLEN; if(L%DLEN)len++; int index = 0; for(int i = L-1;i &gt;= 0;i -= DLEN)&#123; int t = 0; int k = i - DLEN + 1; if(k &lt; 0)k = 0; for(int j = k;j &lt;= i;j++) t = t*10 + s[j] - '0'; a[index++] = t; &#125; &#125; BigInt operator +(const BigInt &amp;b)const&#123; BigInt res; res.len = max(len,b.len); for(int i = 0;i &lt;= res.len;i++) res.a[i] = 0; for(int i = 0;i &lt; res.len;i++)&#123; res.a[i] += ((i &lt; len)?a[i]:0)+((i &lt; b.len)?b.a[i]:0); res.a[i+1] += res.a[i]/mod; res.a[i] %= mod; &#125; if(res.a[res.len] &gt; 0)res.len++; return res; &#125; BigInt operator *(const BigInt &amp;b)const&#123; BigInt res; for(int i = 0; i &lt; len;i++)&#123; int up = 0; for(int j = 0;j &lt; b.len;j++)&#123; int temp = a[i]*b.a[j] + res.a[i+j] + up; res.a[i+j] = temp%mod; up = temp/mod; &#125; if(up != 0) res.a[i + b.len] = up; &#125; res.len = len + b.len; while(res.a[res.len - 1] == 0 &amp;&amp;res.len &gt; 1)res.len--; return res; &#125; void output()&#123; printf("%d",a[len-1]); for(int i = len-2;i &gt;=0 ;i--) printf("%04d",a[i]); printf("\n"); &#125;&#125;;/* çŸ©é˜µå¿«é€Ÿå¹‚ï¼šæ ¹æ®é€’æ¨å¼å¿«é€Ÿè®¡ç®—ç¬¬né¡¹(Tested 1 times) * çŸ©é˜µæ„é€ ã€æ—¶é—´å¤æ‚åº¦å‚è€ƒç™½ä¹¦P201 */typedef vector&lt;BigInt&gt; vll;typedef vector&lt;vll&gt; mat;mat mul(mat A, mat B) &#123; mat C(A.size(), vll(B[0].size(), 0)); // å‡å¦‚ä¸ºlong longï¼Œviéœ€è¦ä¿®æ”¹ä¸ºvll for(int i = 0; i &lt; A.size(); i++) for(int k = 0; k &lt; A[0].size(); k++) for(int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]); return C;&#125;mat pow(mat A, ll n) &#123; mat B(A.size(), vll(A.size(), 0)); // å‡å¦‚ä¸ºlong longï¼Œviéœ€è¦ä¿®æ”¹ä¸ºvll for(int i = 0; i &lt; B.size(); i++) B[i][i] = 1; while(n) &#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;/* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 3 times) */struct AC &#123; int next[109][50], fail[109], end[109], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; chr; i++) next[idx][i] = -1; end[idx] = false; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; int c = m[s[i]]; if(next[now][c] == -1) next[now][c] = newNode(); now = next[now][c]; &#125; end[now] = true; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; chr; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]] == true) end[now] = true; for(int i = 0; i &lt; chr; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query() &#123; mat a(idx, vll(idx, 0)); for(int i = 0; i &lt; idx; i++) for(int j = 0; j &lt; chr; j++) if(end[next[i][j]] == false) a[i][next[i][j]] = a[i][next[i][j]] + 1; mat dp(2, vll(idx, 0)); dp[0][0] = 1; int now = 0; for(int i = 0; i &lt; mm; i++) &#123; now ^= 1; for(int j = 0; j &lt; idx; j++) dp[now][j] = 0; for(int j = 0; j &lt; idx; j++) for(int k = 0; k &lt; idx; k++) dp[now][k] = dp[now][k] + dp[now ^ 1][j] * a[j][k]; &#125; BigInt ans = 0; for(int i = 0; i &lt; idx; i++) ans = ans + dp[now][i]; ans.output(); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;mm, &amp;p)) &#123; chr = 0; getchar(); m.clear(); for(int i = 0; i &lt; n; i++) &#123; c = getchar(); m[c] = chr++; &#125; ac.init(); while(p--) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); ac.query(); &#125; return 0;&#125; H. HDU 2825 Wireless PasswordACè‡ªåŠ¨æœº+åŠ¨æ€è§„åˆ’è¯¦ç»†é¢˜è§£ä¼ é€é—¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;const int mod = 20090717;char s[19];int n, m, k, dp[26][109][1029];struct node &#123; int idx, status; node() &#123;&#125; node(int idx, int status): idx(idx), status(status)&#123;&#125;&#125;;/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 3 times) */struct AC &#123; int next[109][26], fail[109], end[109], idx, root; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[], int id) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = 1 &lt;&lt; id; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query() &#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt; idx; j++) for(int k = 0; k &lt; (1 &lt;&lt; m); k++) dp[i][j][k] = 0; dp[0][0][0] = 1; queue&lt;node&gt; que; que.push(node&#123;0, 0&#125;); bool vis[259][1029]; for(int i = 1; i &lt;= n; i++) &#123; queue&lt;node&gt; nextque; memset(vis, 0, sizeof vis); while(que.size()) &#123; node t = que.front(); que.pop(); for(int o = 0; o &lt; 26; o++) &#123; int j = t.idx; int k = t.status; int newj = next[j][o]; int newk = t.status | end[newj]; dp[i][newj][newk] += dp[i - 1][j][k]; if(dp[i][newj][newk] &gt;= mod) dp[i][newj][newk] -= mod; if(!vis[newj][newk]) &#123; vis[newj][newk] = true; nextque.push(&#123;newj, newk&#125;); &#125; &#125; &#125; que = nextque; &#125; ll ans = 0; for(int i = 0; i &lt; idx; i++) &#123; for(int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; // å¯ä»¥æŠŠ__builtin_popcount(j)é¢„å¤„ç†æ‰ï¼Œè¿™æ ·æ›´å¿« if(__builtin_popcount(j) &gt;= k) &#123; ans += dp[n][i][j]; if(ans &gt;= mod) ans -= mod; &#125; &#125; &#125; printf("%lld\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;k) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%s", s); ac.insert(s, i); &#125; ac.build(); ac.query(); &#125; return 0;&#125; I. HDU 2296 RingACè‡ªåŠ¨æœº+åŠ¨æ€è§„åˆ’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e3+9;string min(string s, string t) &#123; if(s.length() &lt; t.length()) return s; return s &lt; t ? s : t;&#125;/* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 4 times) */struct AC &#123; int next[N][26], fail[N], end[N], idx, root; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE string c[N]; int dp[59][N]; string s[59][N]; void init() &#123; idx = 0; root = newNode(""); &#125; int newNode(string cc) &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; c[idx] = cc; return idx++; &#125; void insert(char s[], int d) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; string t; t += s[i]; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(t); now = next[now][s[i] - 'a']; &#125; end[now] += d; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] += end[fail[now]]; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(int n) &#123; string ans; int ma = -1; memset(dp, -1, sizeof dp); dp[0][0] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int u = 0; u &lt; idx; u++) &#123; if(dp[i-1][u] == -1) continue; for(int k = 0; k &lt; 26; k++) &#123; int v = next[u][k]; if(dp[i-1][u] + end[v] &gt; dp[i][v]) &#123; dp[i][v] = dp[i-1][u] + end[v]; s[i][v] = s[i-1][u] + c[v]; &#125; else if(dp[i-1][u] + end[v] == dp[i][v] &amp;&amp; s[i-1][u] + c[u] &lt; s[i][v]) &#123; s[i][v] = s[i-1][u] + c[v]; &#125; &#125; &#125; for(int j = 0; j &lt; idx; j++) ma = max(ma, dp[i][j]); &#125; if(ma &lt;= 0) cout &lt;&lt; "" &lt;&lt; endl; else &#123; for(int i = 1; i &lt;= n; i++) &#123; bool flag = false; string ans = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"; for(int j = 0; j &lt; idx; j++) &#123; if(dp[i][j] == ma) &#123; ans = min(ans, s[i][j]); //é‡è½½äº†minå‡½æ•° flag = true; &#125; &#125; if(flag) &#123; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; &#125; &#125; &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;int T, n, m, d;char s[109][19];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; T; while(T--) &#123; scanf("%d%d", &amp;n, &amp;m); ac.init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%s", s[i]); &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d); ac.insert(s[i], d); &#125; ac.build(); ac.query(n); &#125; return 0;&#125; J. HDU 2457 DNA repairACè‡ªåŠ¨æœº+åŠ¨æ€è§„åˆ’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e3+9;int dp[1009][1009];map&lt;char, int&gt; m;int kase;/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 5 times) */struct AC &#123; int next[N][4], fail[N], idx, root; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE bool end[N]; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[idx][i] = -1; end[idx] = true; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][m[s[i]]] == -1) next[now][m[s[i]]] = newNode(); now = next[now][m[s[i]]]; &#125; end[now] = false; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(!end[fail[now]]) end[now] = end[fail[now]]; for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(char s[]) &#123; memset(dp, INF, sizeof dp); dp[0][0] = 0; int len = strlen(s); int ans = INF; for(int i = 0; i &lt; len; i++) &#123; bool flag = false; for(int u = 0; u &lt; idx; u++) &#123; if(dp[i][u] == INF) continue; int v = next[u][m[s[i]]]; if(end[v]) &#123; flag = true; dp[i+1][v] = min(dp[i+1][v], dp[i][u]); &#125; for(int j = 0; j &lt; 4; j++) &#123; if(j == m[s[i]]) continue; v = next[u][j]; if(end[v]) &#123; dp[i+1][v] = min(dp[i+1][v], dp[i][u] + 1); flag = true; &#125; &#125; &#125; if(!flag) &#123; printf("Case %d: %d\n", ++kase, -1); return; &#125; &#125; for(int j = 0; j &lt; idx; j++) ans = min(ans, dp[len][j]); printf("Case %d: %d\n", ++kase, ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/char s[1009];int n;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; m['A'] = 0; m['C'] = 1; m['G'] = 2; m['T'] = 3; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); scanf("%s", s); ac.query(s); &#125; return 0;&#125; K. ZOJ 3228 Searching the StringACè‡ªåŠ¨æœº+è®¡æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 6e5+9;char s[N], t[9];int n, ty[N], pos[N], cnt[N][2]; //æ”¹ç”¨posè®°å½•ä½ç½®ï¼Œé¿å…åœ¨acè‡ªåŠ¨æœºé‡Œé¢ä½¿ç”¨endé›†åˆï¼Œå¦™/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 6 times) */struct AC &#123; int next[N][26], fail[N], deep[N], idx, root; void init() &#123; idx = 0; root = newNode(); deep[root] = 0; &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; cnt[idx][0] = cnt[idx][1] = 0; return idx++; &#125; int insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) &#123; next[now][s[i] - 'a'] = newNode(); deep[next[now][s[i] - 'a']] = i + 1; &#125; now = next[now][s[i] - 'a']; &#125; return now; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(char s[]) &#123; int len = strlen(s), now = root; int last[N]; memset(last, -1, sizeof last); for(int i = 0; i &lt; len; i++) &#123; now = next[now][s[i] - 'a']; int temp = now; while(temp != root) &#123; cnt[temp][0]++; if(i - last[temp] &gt;= deep[temp]) &#123; cnt[temp][1]++; last[temp] = i; &#125; temp = fail[temp]; &#125; &#125; for(int i = 0; i &lt; n; i++) printf("%d\n", cnt[pos[i]][ty[i]]); puts(""); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; //printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; int kase = 0; while(~scanf("%s", s)) &#123; printf("Case %d\n", ++kase); scanf("%d", &amp;n); ac.init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%d%s", &amp;ty[i], t); pos[i] = ac.insert(t); &#125; ac.build(); ac.query(s); &#125; return 0;&#125; L. HDU 3341 Lostâ€™s revengeACè‡ªåŠ¨æœº+åŠ¨æ€è§„åˆ’ä¸ºäº†ä¸MLEï¼ŒåŠ¨æ€è§„åˆ’è¿‡ç¨‹ä¸­çš„çŠ¶æ€è¦å·§å¦™è®¾è®¡ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 509;map&lt;char, int&gt; m;int dp[509][11*11*11*11+9];/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 7 times)*/struct AC &#123; int next[N][26], fail[N], idx, root, end[N]; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][m[s[i]]] == -1) next[now][m[s[i]]] = newNode(); now = next[now][m[s[i]]]; &#125; end[now]++; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] += end[fail[now]]; for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; int bit[4]; int func(int i, int j, int k, int l) &#123; return i * bit[3] + j * bit[2] + k * bit[1] + l * bit[0]; &#125; void query(char s[]) &#123; int cnt[4]; int len = strlen(s); memset(cnt, 0, sizeof cnt); for(int i = 0; i &lt; len; i++) cnt[m[s[i]]]++; bit[3] = (cnt[2] + 1) * (cnt[1] + 1) * (cnt[0] + 1); bit[2] = (cnt[1] + 1) * (cnt[0] + 1); bit[1] = cnt[0] + 1; bit[0] = 1; memset(dp, -1, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt;= cnt[3]; i++) &#123; for(int j = 0; j &lt;= cnt[2]; j++) &#123; for(int k = 0; k &lt;= cnt[1]; k++) &#123; for(int l = 0; l &lt;= cnt[0]; l++) &#123; for(int u = 0; u &lt; idx; u++) &#123; if(dp[u][func(i, j, k, l)] &lt; 0) continue; for(int o = 0; o &lt; 4; o++) &#123; int v = next[u][o]; if(o == 0 &amp;&amp; l == cnt[0]) continue; if(o == 1 &amp;&amp; k == cnt[1]) continue; if(o == 2 &amp;&amp; j == cnt[2]) continue; if(o == 3 &amp;&amp; i == cnt[3]) continue; int id = func(i, j, k, l); dp[v][id + bit[o]] = max(dp[v][id + bit[o]], dp[u][id] + end[v]); &#125; &#125; &#125; &#125; &#125; &#125; int ans = -1; for(int i = 0; i &lt; idx; i++) ans = max(ans, dp[i][func(cnt[3], cnt[2], cnt[1], cnt[0])]); printf("%d\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/char s[49];int n, kase;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; m['A'] = 0; m['C'] = 1; m['G'] = 2; m['T'] = 3; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; printf("Case %d: ", ++kase); ac.init(); while(n--) &#123; scanf("%s", s); ac.insert(s); &#125; scanf("%s", s); ac.build(); ac.query(s); &#125; return 0;&#125; M. HDU 3247 Resource Archiverç•™å‘å¾…å¡«ã€‚ N. ZOJ 3494 BCD Codeç•™å‘å¾…å¡«ã€‚ O. HDU 4758 Walk Through SquaresACè‡ªåŠ¨æœº+åŠ¨æ€è§„åˆ’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;const int mod = 1000000007;map&lt;char, int&gt; m;/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 8 times) */struct AC &#123; int next[N][26], fail[N], idx, root, end[N]; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 2; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[], int id) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][m[s[i]]] == -1) next[now][m[s[i]]] = newNode(); now = next[now][m[s[i]]]; &#125; end[now] |= id; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 2; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; 2; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; int bit[2], dp[209][101 * 101 + 9][4]; int get(int i, int j) &#123; return bit[1] * i + bit[0] * j; &#125; void query(int down, int right) &#123; bit[1] = right + 1; bit[0] = 1; memset(dp, 0, sizeof dp); dp[0][0][0] = 1; for(int i = 0; i &lt;= down; i++) &#123; for(int j = 0; j &lt;= right; j++) &#123; for(int u = 0; u &lt; idx; u++) &#123; for(int k = 0; k &lt; 4; k++) &#123; if(dp[u][get(i, j)][k] == 0) continue; for(int o = 0; o &lt; 2; o++) &#123; int v = next[u][o]; if(i == down &amp;&amp; o == 0) continue; if(j == right &amp;&amp; o == 1) continue; (dp[v][get(i + (o == 0), j + (o == 1))][k | end[v]] += dp[u][get(i, j)][k]) %= mod; &#125; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 0; i &lt; idx; i++) &#123; (ans += dp[i][down * bit[1] + right][3]) %= mod; &#125; printf("%d\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int T, n, mm;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); m['D'] = 0; m['R'] = 1; while(T--) &#123; scanf("%d%d", &amp;mm, &amp;n); ac.init(); for(int i = 0; i &lt; 2; i++) &#123; scanf("%s", s); ac.insert(s, i + 1); &#125; ac.build(); ac.query(n, mm); &#125; return 0;&#125; P. HDU 4511 å°æ˜ç³»åˆ—æ•…äº‹â€•â€•å¥³å‹çš„è€ƒéªŒACè‡ªåŠ¨æœº+åŠ¨æ€è§„åˆ’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 509;int n, m, k, b[9];pair&lt;double, double&gt; a[59];/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 9 times)*/struct AC &#123; int next[N][50], fail[N], idx, root; bool end[N]; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; n; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(int b[], int k) &#123; int now = root; for(int i = 0; i &lt; k; i++) &#123; b[i]--; if(next[now][b[i]] == -1) next[now][b[i]] = newNode(); now = next[now][b[i]]; &#125; end[now] = 1; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; n; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; n; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; inline double get(pair&lt;double, double&gt; a, pair&lt;double, double&gt; b) &#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); &#125; void query(int n) &#123; double dp[50][509]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; idx; j++) dp[i][j] = LINF; dp[0][next[root][0]] = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; idx; j++) &#123; if(dp[i][j] &gt;= LINF - Eps) continue; for(int k = i + 1; k &lt; n; k++) &#123; int v = next[j][k]; if(end[v]) continue; dp[k][v] = min(dp[k][v], dp[i][j] + get(a[i], a[k])); &#125; &#125; &#125; double ans = LINF; for(int i = 0; i &lt; idx; i++) ans = min(ans, dp[n-1][i]); if(ans &gt;= LINF - Eps) printf("Can not be reached!\n"); else printf("%.2f\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;k); for(int j = 0; j &lt; k; j++) scanf("%d", b + j); ac.insert(b, k); &#125; ac.build(); ac.query(n); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACè‡ªåŠ¨æœº</tag>
        <tag>DP</tag>
        <tag>è®¡æ•°</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1025D Recovering BST é¢˜è§£]]></title>
    <url>%2F2018%2F08%2F21%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ªå‡åºåºåˆ—ï¼Œé—®èƒ½å¦æ„é€ ä»»æ„ç›¸é‚»èŠ‚ç‚¹çš„gcdéƒ½å¤§äº1çš„äºŒå‰æ’åºæ ‘ã€‚ åˆ†ææ³¨æ„åˆ°næœ€å¤§åªæœ‰700ï¼Œå¯è€ƒè™‘$n^3$çš„åšæ³•ã€‚ä»¤dp[i][j][0]è¡¨ç¤º$i$ ~ $j$çš„å…ƒç´ èƒ½å¦æ„é€ å‡ºä»¥$i - 1$ä¸ºæ ¹çš„äºŒå‰æ’åºæ ‘ï¼Œä»¤dp[i][j][1]è¡¨ç¤º$i$ ~ $j$çš„å…ƒç´ èƒ½å¦æ„é€ å‡ºä»¥$j + 1$ä¸ºæ ¹çš„äºŒå‰æ’åºæ ‘ã€‚è‡³äºè½¬ç§»æ–¹ç¨‹ï¼Œä»¥dp[i][j][0]ä¸ºä¾‹ï¼Œå®ƒçš„æ ¹ä¸º$i - 1$ï¼Œå³å„¿å­å¯ä»¥æ˜¯ä¸‹æ ‡ä¸º$i$ ~ $j$ä¸­æŸä¸ªæ•°ç»„å…ƒç´ ï¼Œæˆ‘ä»¬æšä¸¾è¿™ä¸ªå³å„¿å­ï¼Œä¸å¦¨è®¾ä¸‹æ ‡ä¸º$k$ï¼Œåˆ¤æ–­æ ¹ä¸å®ƒèƒ½å¦è¿è¾¹ï¼Œä»¥åŠ$i$ ~ $k - 1$èƒ½å¦ä½œä¸º$k$çš„å·¦å­æ ‘ï¼Œ$k + 1$ ~ $j$ èƒ½å¦äºä½œä¸º$k$çš„å³å­æ ‘ã€‚å¦å¤–éœ€è¦æ³¨æ„å¤„ç†å¥½dpè¾¹ç•Œã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 700+9;int a[N], dp[N][N][2], n, link[N][N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", a + i); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; if(__gcd(a[i], a[j]) &gt;= 2) link[i][j] = link[j][i] = 1; &#125; link[0][i] = link[i][n+1] = 1; dp[i][i-1][0] = dp[i+1][i][1] = 1; &#125; for(int len = 1; len &lt;= n; len++) &#123; for(int i = 1, j = i + len - 1; j &lt;= n; i++, j++) &#123; for(int k = i; k &lt;= j; k++) &#123; if(link[i-1][k]) dp[i][j][1] |= dp[i][k-1][0] &amp; dp[k+1][j][1]; if(link[k][j+1]) dp[i][j][0] |= dp[i][k-1][0] &amp; dp[k+1][j][1]; &#125; &#125; &#125; printf("%s\n", dp[1][n][0]?"Yes":"No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>åŒºé—´DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2825 Wireless Password é¢˜è§£]]></title>
    <url>%2F2018%2F08%2F18%2F1%2F</url>
    <content type="text"><![CDATA[é¢˜æ„å·²çŸ¥æœ‰mä¸ªå•è¯ï¼Œé—®æœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸ºnçš„ã€ä¸”è‡³å°‘å«æœ‰mä¸ªå•è¯ä¸­çš„kä¸ªçš„WIFIå¯†ç ï¼Œæ³¨æ„å•è¯å¯ä»¥é‡å ã€‚ åˆ†ææ³¨æ„åˆ°æ˜¯å¤šæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜ï¼Œè€ƒè™‘ç”¨ACè‡ªåŠ¨æœºå»ºçŠ¶æ€è½¬ç§»å›¾ã€‚èŠ‚ç‚¹ä¸Šæ ‡è®°ä¸‹è¯¥èŠ‚ç‚¹è¦†ç›–äº†å“ªäº›å•è¯ï¼Œç”¨ä¸€ä¸ªintè¡¨ç¤ºå³å¯ï¼Œæ³¨æ„è¦æˆ–ä¸ŠfailæŒ‡é’ˆæŒ‡å‘èŠ‚ç‚¹çš„æ ‡è®°ã€‚ç„¶åä»¥dp[i][j][k]è¡¨ç¤ºä»å•è¯é•¿åº¦ä¸ºiã€å½“å‰èŠ‚ç‚¹ä¸ºjã€è¦†ç›–å•è¯ä¸ºkçš„æ–¹æ¡ˆæ•°ï¼Œè½¬ç§»é€”å¾„ä¸ºjçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚æœ€ç»ˆç­”æ¡ˆå°±æ˜¯å•è¯é•¿åº¦ä¸ºnã€å›¾ä¸Šå„èŠ‚ç‚¹ã€è¦†ç›–å•è¯æ•°ä¸å°äºkçš„dpå’Œã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;const int mod = 20090717;char s[19];int n, m, k, dp[26][109][1029];struct node &#123; int idx, status; node() &#123;&#125; node(int idx, int status): idx(idx), status(status)&#123;&#125;&#125;;/********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 3 times) */struct AC &#123; int next[109][26], fail[109], end[109], idx, root; // å¯ä»¥ä¿®æ”¹ä¸‹æ•°ç»„å¤§å°ï¼Œä»¥é˜²MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[], int id) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = 1 &lt;&lt; id; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query() &#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt; idx; j++) for(int k = 0; k &lt; (1 &lt;&lt; m); k++) dp[i][j][k] = 0; dp[0][0][0] = 1; queue&lt;node&gt; que; que.push(node&#123;0, 0&#125;); bool vis[259][1029]; for(int i = 1; i &lt;= n; i++) &#123; queue&lt;node&gt; nextque; memset(vis, 0, sizeof vis); while(que.size()) &#123; node t = que.front(); que.pop(); for(int o = 0; o &lt; 26; o++) &#123; int j = t.idx; int k = t.status; int newj = next[j][o]; int newk = t.status | end[newj]; dp[i][newj][newk] += dp[i - 1][j][k]; if(dp[i][newj][newk] &gt;= mod) dp[i][newj][newk] -= mod; if(!vis[newj][newk]) &#123; vis[newj][newk] = true; nextque.push(&#123;newj, newk&#125;); &#125; &#125; &#125; que = nextque; &#125; ll ans = 0; for(int i = 0; i &lt; idx; i++) &#123; for(int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; // å¯ä»¥æŠŠ__builtin_popcount(j)é¢„å¤„ç†æ‰ï¼Œè¿™æ ·æ›´å¿« if(__builtin_popcount(j) &gt;= k) &#123; ans += dp[n][i][j]; if(ans &gt;= mod) ans -= mod; &#125; &#125; &#125; printf("%lld\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;k) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%s", s); ac.insert(s, i); &#125; ac.build(); ac.query(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACè‡ªåŠ¨æœº</tag>
        <tag>çŠ¶å‹DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1023E Down or Right é¢˜è§£]]></title>
    <url>%2F2018%2F08%2F18%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„å·²çŸ¥ä¸€ä¸ªnÃ—n$(2 &lt;= n &lt;= 500)$çš„è¿·å®«ä¸­å­˜åœ¨ä¸€æ¡(1, 1)åˆ°è¾¾(n, n)çš„è·¯å¾„ï¼Œè¡Œèµ°æ–¹å‘åªèƒ½æ˜¯å‘ä¸‹æˆ–å‘å³ã€‚ç°åœ¨éœ€è¦ä½ é€šè¿‡ä¸è¶…è¿‡$4*n$æ¬¡çš„è¯¢é—®æ‰¾å‡ºè¿™æ¡è·¯å¾„ï¼Œæ³¨æ„æ¯æ¬¡è¯¢é—®çš„ä¸¤ä¸ªç‚¹æ›¼å“ˆé¡¿è·ç¦»ä¸èƒ½å°äº$n-1$ã€‚å…·ä½“äº¤äº’è§„åˆ™è¯·å‚è€ƒåŸé¢˜ã€‚ åˆ†ææ³¨æ„åˆ°æ¬¡å¯¹è§’çº¿ä¸€å®šå­˜åœ¨ä¸€ç‚¹å¯åŒæ—¶åˆ°è¾¾(1, 1)å’Œ(n, n)ï¼Œå› æ­¤ï¼Œé—®é¢˜è½¬åŒ–æˆäº†æ‰¾(1, 1)åˆ°è¾¾è¿™ä¸€ç‚¹çš„è·¯å¾„ä»¥åŠè¿™ä¸€ç‚¹åˆ°è¾¾(n, n)çš„è·¯å¾„çš„é—®é¢˜ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬é¦–å…ˆå›ºå®š(n, n)ï¼Œç„¶åä»(1, 1)å‡ºå‘ï¼Œä¸æ–­è¯¢é—®ä¸‹è¾¹ä¸€ç‚¹å’Œå³è¾¹ä¸€ç‚¹èƒ½å¦åˆ°è¾¾(n, n)ï¼Œé€šè¿‡$n-1$æ¬¡è¯¢é—®å³å¯åˆ°è¾¾æ¬¡å¯¹è§’çº¿ä¸Šçš„ä¸€ç‚¹ã€‚åŒç†ï¼Œæˆ‘ä»¬å¯ä»¥å†æ‰¾å‡ºä»(n, n)åˆ°æ¬¡å¯¹è§’çº¿ä¸Šä¸€ç‚¹çš„è·¯çº¿ã€‚ä¸ºäº†ä¿è¯(1, 1)å’Œ(n, n)åˆ°è¾¾çš„æ¬¡å¯¹è§’çº¿çš„ä½ç½®æ˜¯ç›¸åŒçš„ï¼Œæˆ‘ä»¬éœ€è¦è®©ä»(1, 1)å‡ºå‘çš„è·¯çº¿å°½å¯èƒ½å¾€ä¸‹èµ°ï¼Œç„¶åä»(n, n)å‡ºå‘çš„è·¯çº¿å°½å¯èƒ½åœ°å¾€å·¦èµ°ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;int n, a[509][509], x, y;pii pre[509][509];string s;bool ask(int x, int y, int xx, int yy) &#123; cout &lt;&lt; "? " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; xx &lt;&lt; " " &lt;&lt; yy &lt;&lt; endl; cin &gt;&gt; s; return s[0] == 'Y';&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; x = 1, y = 1; for(int i = 1; i &lt; n; i++) &#123; if(ask(x + 1, y, n, n)) &#123; x++; a[x][y]++; pre[x][y] = pii(x - 1, y); &#125; else &#123; y++; a[x][y]++; pre[x][y] = pii(x, y - 1); &#125; &#125; string ans; while(!(x == 1 &amp;&amp; y == 1)) &#123; if(pre[x][y].x == x) &#123; y--; ans += 'R'; &#125; else &#123; x--; ans += 'D'; &#125; &#125; reverse(ans.begin(), ans.end()); x = n, y = n; for(int i = 1; i &lt; n; i++) &#123; if(ask(1, 1, x, y - 1)) &#123; y--; a[x][y]++; pre[x][y] = pii(x, y + 1); &#125; else &#123; x--; a[x][y]++; pre[x][y] = pii(x + 1, y); &#125; &#125; while(!(x == n &amp;&amp; y == n)) &#123; if(pre[x][y].x == x) &#123; y++; ans += 'R'; &#125; else &#123; x++; ans += 'D'; &#125; &#125; cout &lt;&lt; "! " &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>æ„é€ </tag>
        <tag>äº¤äº’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2243 è€ƒç ”è·¯èŒ«èŒ«â€•â€•å•è¯æƒ…ç»“ é¢˜è§£]]></title>
    <url>%2F2018%2F08%2F16%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™äº†n($0 &lt; n &lt; 6$)ä¸ªæ¨¡å¼ä¸²ï¼Œéœ€è¦æ±‚è‡³å°‘åŒ…å«ä¸€ä¸ªæ¨¡å¼ä¸²ã€é•¿åº¦æœ€é•¿ä¸ºL($ 0 &lt; L &lt; 2^{31} $)çš„å­—ç¬¦ä¸²æ•°ã€‚ åˆ†ææ³¨æ„åˆ°æ˜¯å¤šæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜ï¼Œæ‰€ä»¥è€ƒè™‘ç”¨ACè‡ªåŠ¨æœºã€‚åˆå› ä¸ºè‡³å°‘åŒ…å«ä¸€ä¸ªæ¨¡å¼ä¸²çš„é—®é¢˜ä¸å¤ªå¥½ç›´æ¥æ±‚è§£ï¼Œå› æ­¤æˆ‘ä»¬å°†å…¶è½¬åŒ–ä¸ºæ±‚ä¸€ä¸ªæ¨¡å¼ä¸²éƒ½ä¸åŒ…å«çš„é—®é¢˜ã€‚æˆ‘ä»¬ç”¨æ¨¡å¼ä¸²å»ºç«‹ACè‡ªåŠ¨æœºï¼Œæ¯ä¸ªæ¨¡å¼ä¸²æœ€ç»ˆèµ°åˆ°çš„èŠ‚ç‚¹æ˜¯ä¸åˆæ³•çš„ï¼Œä¸”å‡å¦‚å®ƒçš„å¤±é…æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹æ˜¯ä¸åˆæ³•çš„è¯ï¼Œå®ƒä¹Ÿæ˜¯ä¸åˆæ³•çš„ï¼Œå› ä¸ºå®ƒæŒ‡å‘çš„èŠ‚ç‚¹æ˜¯å®ƒçš„ä¸€ä¸ªåç¼€ã€‚ç„¶åï¼Œå‡è®¾ACè‡ªåŠ¨æœºçš„èŠ‚ç‚¹ä¸ªæ•°ä¸º$L$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å»ºç«‹ä¸€ä¸ª$ L * L $çš„æ–¹æ¡ˆçŸ©é˜µï¼Œè¿™ä¸ªçŸ©é˜µçš„$mat[i][j]$è¡¨ç¤º$i$åˆ°$j$çš„åˆæ³•æ–¹æ¡ˆæ•°ï¼Œå°†è¿™ä¸ªçŸ©é˜µæ±‚$n$æ¬¡å¹‚ï¼Œå°±å¾—åˆ°äº†èµ°$n$æ­¥çš„æ–¹æ¡ˆçŸ©é˜µã€‚ä½†æ˜¯ç”±äºæˆ‘ä»¬éœ€è¦æ±‚èµ°äº†$1$ ~ $n$æ­¥çš„æ–¹æ¡ˆæ•°ï¼Œæ‰€ä»¥éœ€è¦æ±‚å’Œï¼Œéœ€è¦ç»™çŸ©é˜µæœ€å³ç«¯å¢åŠ ä¸€åˆ—ï¼Œå…¨ç½®ä¸º1ï¼Œé‚£ä¹ˆç¬¬ä¸€è¡Œæœ€åä¸€åˆ—çš„å€¼å‡å»1å°±æ˜¯èµ°äº†$1$ ~ $n-1$æ­¥çš„æ–¹æ¡ˆæ•°ã€‚è‡³äºå­—ç¬¦ä¸²æ€»æ•°ï¼Œä¹Ÿæ˜¯å¯ä»¥é€šè¿‡æ„é€ çŸ©é˜µæ±‚è§£çš„ï¼Œå…·ä½“æ„é€ æ–¹æ³•è¯·å‚è€ƒä»£ç ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* çŸ©é˜µå¿«é€Ÿå¹‚ï¼šæ ¹æ®é€’æ¨å¼å¿«é€Ÿè®¡ç®—ç¬¬né¡¹(Untested) * çŸ©é˜µæ„é€ ã€æ—¶é—´å¤æ‚åº¦å‚è€ƒç™½ä¹¦P201 */// å®šä¹‰çŸ©é˜µå…ƒç´ ä¸ºlong longçš„çŸ©é˜µï¼štypedef vector&lt;ull&gt; vll;typedef vector&lt;vll&gt; mat;mat mul(mat A, mat B)&#123; mat C(A.size(), vll(B[0].size(), 0)); for(int i = 0; i &lt; A.size(); i++) for(int k = 0; k &lt; A[0].size(); k++) for(int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]); return C;&#125;mat pow(mat A, ll n) &#123; mat B(A.size(), vll(A.size(), 0)); for(int i = 0; i &lt; B.size(); i++) B[i][i] = 1; while(n) &#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;/************************************************************//********************************************************************************//* ACè‡ªåŠ¨æœºï¼šè§£å†³å¤šä¸ªæ¨¡å¼ä¸²åŒ¹é…é—®é¢˜(Tested 1 times) */struct AC &#123; int next[39][26], fail[39], end[39], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = false; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = true; //æ ¹æ®å®é™…æƒ…å†µå¯èƒ½éœ€è¦ä¿å­˜ä¸åŒçš„ä¿¡æ¯ &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]] == true) end[now] = true; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; ull cntIllegal(ll L) &#123; mat a(idx + 1, vll(idx + 1, 0)); for(int i = 0; i &lt; idx; i++) for(int j = 0; j &lt; 26; j++) if(end[next[i][j]] == false) a[i][next[i][j]]++; for(int i = 0; i &lt; idx + 1; i++) a[i][idx] = 1; a = pow(a, L); ull ans = 0; for(int i = 0; i &lt; idx + 1; i++) ans += a[0][i]; return ans - 1; &#125;&#125;ac;/********************************************************************************/int n;ll L;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%lld", &amp;n, &amp;L)) &#123; ac.init(); while(n--) &#123; scanf("%s", s); ac.insert(s); &#125; mat a(2, vll(2, 0)), b(2, vll(1, 0)); a[0][0] = 26, a[0][1] = 1; a[1][0] = 0, a[1][1] = 1; b[0][0] = 1; b[1][0] = 1; a = pow(a, L); a = mul(a, b); ull ans = a[0][0] - 1; ac.build(); ans -= ac.cntIllegal(L); printf("%llu\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACè‡ªåŠ¨æœº</tag>
        <tag>è®¡æ•°</tag>
        <tag>çŸ©é˜µå¿«é€Ÿå¹‚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1020E Sergey's problem]]></title>
    <url>%2F2018%2F08%2F14%2F1%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ªå¯èƒ½æœ‰ç¯ï¼ˆä½†è‚¯å®šæ²¡æœ‰è‡ªç¯ï¼‰çš„æœ‰å‘å›¾ï¼Œn($1 &lt;= n &lt;= 1e6$)ä¸ªç‚¹ï¼Œm($1 &lt;= m &lt;= 1e6$)æ¡è¾¹ï¼Œç°åœ¨éœ€è¦ä½ é€‰æ‹©ä¸€ä¸ªç‚¹é›†ï¼Œä½¿å¾—è¿™äº›ç‚¹ä¹‹é—´æ²¡æœ‰è¿è¾¹ï¼Œä¸”è¿™äº›ç‚¹åˆ°ç‚¹é›†ä¹‹å¤–çš„ç‚¹çš„è·ç¦»ä¸è¶…è¿‡2ã€‚ åˆ†æé¦–å…ˆä»»æ„é€‰æ‹©ä¸€ç‚¹Aæ”¾åˆ°ç‚¹é›†é‡Œé¢ï¼Œåˆ™è¿™ä¸ªç‚¹æŒ‡å‘çš„ç‚¹éƒ½ä¸èƒ½æ”¾åˆ°ç‚¹é›†é‡Œé¢ï¼Œæˆ‘ä»¬ä»åŸå›¾ä¸­åˆ æ‰è¿™äº›ç‚¹ï¼Œç„¶åå†ä»æ®‹ä½™å›¾ä¸­æ‰¾ç‚¹é›†ï¼Œå‡è®¾è¿™ä¸ªç‚¹é›†ä¸ºMã€‚å‡å¦‚ç‚¹é›†Mä¸­å­˜åœ¨ä¸€ç‚¹Bæœ‰æŒ‡å‘Açš„è¾¹ï¼Œä¸ºäº†å¤„ç†æ‰è¿™ä¸ªå†²çªï¼Œæˆ‘ä»¬åˆ æ‰Aï¼Œå› ä¸ºBåˆ°AæŒ‡å‘çš„ç‚¹çš„è·ç¦»ä¸è¶…è¿‡2ï¼Œæ‰€ä»¥ä¿è¯è¦†ç›–äº†å…¨å›¾ã€‚å‡å¦‚ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†ç‚¹é›†Må’ŒAåˆå¹¶ï¼Œä¹Ÿä¿è¯äº†è¦†ç›–å…¨å›¾ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 2e6+9;int head[2][N], tot, n, m, u, v;bool vis[N], used[N];;void init() &#123; tot = 0; memset(head, -1, sizeof head);&#125;struct node &#123; int to, nex;&#125;edge[N];void addedge(int u, int v, int id) &#123; edge[tot] = node&#123;v, head[id][u]&#125;; head[id][u] = tot++;&#125;void dfs(int u) &#123; while(u &lt;= n &amp;&amp; vis[u]) u++; if(u == n + 1) return; used[u] = vis[u] = true; for(int i = head[0][u]; ~i; i = edge[i].nex) &#123; v = edge[i].to; vis[v] = true; &#125; dfs(u + 1); for(int i = head[1][u]; ~i; i = edge[i].nex) &#123; v = edge[i].to; if(used[v]) &#123; used[u] = false; break; &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v, 0); addedge(v, u, 1); &#125; dfs(1); vi ans; for(int i = 1; i &lt;= n; i++) if(used[i]) ans.push_back(i); printf("%d\n", (int)ans.size()); for(int i = 0; i &lt; ans.size(); i++) printf("%d%c", ans[i], " \n"[ans.size() - 1 == i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ„é€ </tag>
        <tag>å›¾è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1020D The hat]]></title>
    <url>%2F2018%2F08%2F14%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„æœ‰n($2 &lt;= n &lt;= 1e5, n ä¸ºå¶æ•°$)ä¸ªäººå›´æˆä¸€ä¸ªåœˆï¼Œæ¯ä¸ªäººæœ‰ä¸€ä¸ªèº«ä¸Šæœ‰ä¸€ä¸ªå·ç ï¼Œä¸”ç›¸é‚»ä¸¤äººçš„å·ç å·®å€¼ä¸º1ï¼Œç°åœ¨éœ€è¦æ±‚æ˜¯å¦å­˜åœ¨ä¸€å¯¹å¯¹ä¾§çš„äººçš„å·ç ç›¸åŒï¼Œå‡å¦‚å­˜åœ¨ï¼Œè¾“å‡ºä¸‹æ ‡ï¼Œå‡å¦‚ä¸å­˜åœ¨ï¼Œè¾“å‡º-1ã€‚æœ€å¤šè¯¢é—®60æ¬¡ï¼Œå…·ä½“äº¤äº’è§„åˆ™è¯·å‚è€ƒåŸé¢˜ã€‚ åˆ†æé¦–å…ˆæ³¨æ„åˆ°å‡å¦‚å¯¹ä¾§ä¸¤äººçš„å·®å€¼ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆä¸€å®šä¸å­˜åœ¨ç­”æ¡ˆï¼Œè¾“å‡º-1ã€‚å¦åˆ™ï¼Œå› ä¸ºå·®å€¼æ˜¯ä»è´Ÿæ•°æ¸å˜åˆ°æ­£æ•°çš„ï¼Œæ‰€ä»¥è‚¯å®šå­˜åœ¨ç­”æ¡ˆï¼ŒäºŒåˆ†å³å¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;int ask(int id) &#123; int ans; printf("? %d\n", id); fflush(stdout); scanf("%d", &amp;ans); return ans;&#125;int n, m, d[N], l, r;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; n; m = n / 2; d[1] = ask(1) - ask(1 + m); if(d[1] &amp; 1) &#123; printf("! -1\n"); fflush(stdout); return 0; &#125; if(d[1] == 0) &#123; printf("! 1\n"); fflush(stdout); return 0; &#125; l = 1, r = n / 2; while(true &amp;&amp; l + 1 != r) &#123; int mid = (l + r) &gt;&gt; 1; d[mid] = ask(mid) - ask(mid + m); if(d[mid] == 0) &#123; printf("! %d\n", mid); fflush(stdout); return 0; &#125; if((d[l] &lt; 0 &amp;&amp; d[mid] &lt; 0) || (d[l] &gt; 0 &amp;&amp; d[mid] &gt; 0)) l = mid; else r = mid; &#125; d[l] = ask(l) - ask(l + m); if(d[l] == 0) printf("! %d\n", l); else printf("! %d\n", r); return 0;&#125;]]></content>
      <tags>
        <tag>äºŒåˆ†</tag>
        <tag>äº¤äº’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbinå¸¦ä½ é£ ä¸“é¢˜åä¸€ ç½‘ç»œæµ é¢˜è§£]]></title>
    <url>%2F2018%2F08%2F12%2F1%2F</url>
    <content type="text"><![CDATA[kuanginå¸¦ä½ é£ä¸“é¢˜åä¸€ ç½‘ç»œæµ ä¼ é€é—¨ç½‘ç»œæµé—®é¢˜ = å»ºæ¨¡ + é«˜æ•ˆæ¨¡æ¿ A. POJ 3436 ACM Computer Factoryæœ€å¤§æµé—®é¢˜ï¼Œéœ€è¦æ‹†ç‚¹ã€æ‰“å°è·¯å¾„ã€‚ B. POJ 3281 Diningæœ€å¤§æµé—®é¢˜ï¼Œéœ€è¦æ‹†ç‚¹ã€‚ç»å…¸å»ºæ¨¡æ€è·¯ï¼šå°†ç‰›æ‹†ç‚¹æ”¾åœ¨ä¸­é—´ï¼Œç„¶åå·¦è¾¹è¿é£Ÿç‰©ï¼Œå³è¾¹è¿é¥®æ–™ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// ç»æµ‹è¯•ï¼ŒISAPæ¯”dinicå¿«äº†ä¸å°‘#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;/************************************************************/const int MAXN = 409;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = N;//è¾¹æ•°çš„æœ€å¤§å€¼struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, f, d, start, en, ff, dd, t;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;f, &amp;d)) &#123; start = 0, en = f + 2 * n + d + 1; init(); for(int i = 1; i &lt;= f; i++) addedge(0, i, 1); for(int i = 1; i &lt;= d; i++) addedge(f + 2 * n + i, en, 1); for(int i = 1; i &lt;= n; i++) addedge(f + i, f + n + i, 1); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;ff, &amp;dd); for(int j = 0; j &lt; ff; j++) &#123; scanf("%d", &amp;t); addedge(t, f + i, 1); &#125; for(int j = 0; j &lt; dd; j++) &#123; scanf("%d", &amp;t); addedge(f + n + i, f + 2 * n + t, 1); &#125; &#125; int ans = sap(start, en, en + 1); printf("%d\n", ans); &#125; return 0;&#125; C. POJ 1087 A Plug for UNIXæœ€å¤§æµé—®é¢˜ï¼Œå¾ˆå®¹æ˜“æƒ³ï¼Œä½†æ˜¯éœ€è¦ç»†å¿ƒï¼Œç†è§£å¥½é¢˜æ„ï¼Œè®¡ç®—å¥½èŠ‚ç‚¹ä¸ªæ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;/************************************************************************************//* dinicç®—æ³•ï¼šè§£å†³æœ€å¤§æµé—®é¢˜ã€‚ * æ—¶é—´å¤æ‚åº¦ä¸ºO(|E| * |V| * |V|)ï¼Œä¸è¿‡ï¼Œè¯¥ç®—æ³•åœ¨å®é™…åº”ç”¨ä¸­é€Ÿåº¦éå¸¸å¿«ã€‚ * */const int MAX_V = 509;struct edge&#123;int to, cap, rev; &#125;;vector&lt;edge&gt; G[MAX_V];int level[MAX_V];int iter[MAX_V];void add_edge(int from, int to, int cap)&#123; G[from].push_back((edge)&#123;to, cap, static_cast&lt;int&gt;(G[to].size())&#125;); G[to].push_back((edge)&#123;from, 0, static_cast&lt;int&gt;(G[from].size()-1)&#125;);&#125;void bfs(int s)&#123; memset(level, -1, sizeof level); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty())&#123; int v=que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++)&#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[e.to]&lt;0)&#123; level[e.to]=level[v]+1; que.push(e.to); &#125; &#125; &#125;&#125;int dfs(int v, int t, int f)&#123; if(v==t) return f; for(int &amp;i=iter[v]; i&lt;G[v].size(); i++)&#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])&#123; int d=dfs(e.to, t, min(f, e.cap)); if(d&gt;0)&#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int max_flow(int s, int t)&#123; int flow=0; while(1)&#123; bfs(s); if(level[t]&lt;0) return flow; memset(iter, 0, sizeof iter); int f; while((f=dfs(s, t, INF))&gt;0) flow+=f; &#125;&#125;/************************************************************************************/int start, en, n, m, k, tot;string s, t, s1, s2;map&lt;string, int&gt; ms, mt;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; start = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; if(!ms[s]) ms[s] = ++tot; add_edge(0, ms[s], 1); &#125; scanf("%d", &amp;m); en = 400 + m + 1; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; t &gt;&gt; s; if(!mt[t]) mt[t] = ++tot; if(!ms[s]) ms[s] = ++tot; add_edge(ms[s], mt[t], 1); add_edge(mt[t], en, 1); &#125; scanf("%d", &amp;k); for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2; if(!ms[s1]) ms[s1] = ++tot; if(!ms[s2]) ms[s2] = ++tot; add_edge(ms[s2], ms[s1], INF); &#125; int ans = m - max_flow(start, en); printf("%d\n", ans); return 0;&#125; D. POJ 2195 Going Homeæœ€å°è´¹ç”¨æœ€å¤§æµé—®é¢˜ï¼Œä¹Ÿå¯ä»¥å½“æˆäºŒåˆ†å›¾æœ€å°æƒåŒ¹é…é—®é¢˜æ¥å†™ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;/************************************************************//* SPFAç‰ˆæœ€å°è´¹ç”¨æœ€å¤§æµç®—æ³•(Untested) * æœ€å°è´¹ç”¨æœ€å¤§æµ,æ±‚æœ€å¤§è´¹ç”¨åªéœ€è¦å–ç›¸åæ•°,ç»“æœå–ç›¸åæ•°å³å¯ã€‚ * ç‚¹çš„æ€»æ•°ä¸º N,ç‚¹çš„ç¼–å· 0 ~ N-1 */const int MAXN = 10000;const int MAXM = 100000;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int N;//èŠ‚ç‚¹æ€»ä¸ªæ•°,èŠ‚ç‚¹ç¼–å·ä» 0 âˆ¼ N-1void init(int n)&#123; N = n; tol = 0; memset(head, -1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; N;i++)&#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge [i].cost ) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;//è¿”å›çš„æ˜¯æœ€å¤§æµ,cost å­˜çš„æ˜¯æœ€å°è´¹ç”¨int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t))&#123; int Min = INF; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow;&#125;/************************************************************/vector&lt;pii&gt; vm, vh;int n, m, start, en, id, id1, cost;char g[109][109];int ID(int i, int j) &#123; return i * m + j + 1;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; if(!n &amp;&amp; !m) break; start = 0; en = n * m + 1; init(en + 1); vm.clear(); vh.clear(); for(int i = 0; i &lt; n; i++) scanf("%s", g[i]); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(g[i][j] == 'm') vm.push_back(pii(i, j)); else if(g[i][j] == 'H') vh.push_back(pii(i, j)); &#125; &#125; for(vector&lt;pii&gt;::iterator it = vm.begin(); it != vm.end(); it++) &#123; pii i = *it; id = ID(i.x, i.y); addedge(start, id, 1, 0); for(vector&lt;pii&gt;::iterator it1 = vh.begin(); it1 != vh.end(); it1++) &#123; pii j = *it1; id1 = ID(j.x, j.y); cost = abs(i.x - j.x) + abs(i.y - j.y); addedge(id, id1, 1, cost); &#125; &#125; for(vector&lt;pii&gt;::iterator it = vh.begin(); it != vh.end(); it++) &#123; pii i = *it; id = ID(i.x, i.y); addedge(id, en, 1, 0); &#125; minCostMaxflow(start, en, cost); printf("%d\n", cost); &#125; return 0;&#125; E. POJ 2516 Minimum Costæœ€å°è´¹ç”¨æœ€å¤§æµé—®é¢˜ï¼Œéœ€è¦å°†æ¯ä¸ªç‰©å“åˆ†åˆ«å¤„ç†ï¼Œæœ€åç´¯åŠ ã€‚å‡å¦‚ç›´æ¥å°†æ‰€æœ‰ç‰©å“ä¸€èµ·å»ºå›¾å¤„ç†çš„è¯ï¼Œä¸ä»…éº»çƒ¦ï¼Œè€Œä¸”ä¼šè¶…æ—¶ã€‚å¥—è·¯ï¼šæŠŠä¸€ä¸ªé—®é¢˜åˆ†æˆå‡ ä¸ªå­é—®é¢˜æ¥æ±‚è§£ï¼Œå¯é™ä½æ—¶é—´å¤æ‚åº¦ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;/************************************************************//* SPFAç‰ˆæœ€å°è´¹ç”¨æœ€å¤§æµç®—æ³•(Tested 1 times) * æœ€å°è´¹ç”¨æœ€å¤§æµ,æ±‚æœ€å¤§è´¹ç”¨åªéœ€è¦å–ç›¸åæ•°,ç»“æœå–ç›¸åæ•°å³å¯ã€‚ * ç‚¹çš„æ€»æ•°ä¸º N,ç‚¹çš„ç¼–å· 0 ~ N-1 */const int MAXN = 10000;const int MAXM = 100000;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int NN;//èŠ‚ç‚¹æ€»ä¸ªæ•°,èŠ‚ç‚¹ç¼–å·ä» 0 âˆ¼ NN-1void init(int n)&#123; NN = n; tol = 0; memset(head, -1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; NN;i++)&#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge [i].cost ) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;//è¿”å›çš„æ˜¯æœ€å¤§æµ,cost å­˜çš„æ˜¯æœ€å°è´¹ç”¨int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t))&#123; int Min = INF; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow;&#125;/************************************************************/int n, m, k, need, ans, cost, a[109][109], start, en, b[109][109], d, tot;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; if(!n) break; need = 0, tot = 0, ans = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; scanf("%d", a[i] + j); need += a[i][j]; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; scanf("%d", b[i] + j); &#125; &#125; start = 0, en = n + m + 1; for(int o = 0; o &lt; k; o++) &#123; init(en + 1); for(int i = 0; i &lt; m; i++) &#123; addedge(start, i + 1, b[i][o], 0); &#125; for(int i = 0; i &lt; n; i++) &#123; addedge(m + i + 1, en, a[i][o], 0); &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;d); addedge(j + 1, m + i + 1, INF, d); &#125; &#125; tot += minCostMaxflow(start, en, cost); ans += cost; &#125; if(tot != need) printf("-1\n"); else printf("%d\n", ans); &#125; return 0;&#125; F. POJ 1459 Power Networkæœ€å¤§æµé—®é¢˜ï¼Œé¢˜æ„æœ‰ç‚¹éš¾æ‡‚ï¼Œè¾“å…¥éœ€è¦ç‚¹å¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;const int N=1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜ * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ */const int MAXN = 109;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 20409;//è¾¹æ•°çš„æœ€å¤§å€¼struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, np, nc, m, start, en, u, v, cap;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d%d", &amp;n, &amp;np, &amp;nc, &amp;m)) &#123; init(); start = 0, en = n + 1; for(int i = 0; i &lt; m; i++) &#123; scanf(" (%d,%d)%d", &amp;u, &amp;v, &amp;cap); addedge(u + 1, v + 1, cap); &#125; for(int i = 0; i &lt; np; i++) &#123; scanf(" (%d)%d", &amp;u, &amp;cap); addedge(start, u + 1, cap); &#125; for(int i = 0; i &lt; nc; i++) &#123; scanf(" (%d)%d", &amp;u, &amp;cap); addedge(u + 1, en, cap); &#125; int ans = sap(start, en, en + 1); printf("%d\n", ans); &#125; return 0;&#125; G. HDU 4280 Island Transportæœ€å¤§æµé—®é¢˜ï¼Œå¾ˆè£¸ï¼Œä½†æ˜¯ç›´æ¥ä¸Šdinicç®—æ³•çš„è¯ï¼Œä¼šè¶…æ—¶ï¼Œéœ€è¦ç”¨å¸¦ä¼˜åŒ–çš„ISPAç®—æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;const int MAXN = 100010;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 400010;//è¾¹æ•°çš„æœ€å¤§å€¼struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;int start, en, mifix, mafix, T, n, m, x, u, v, cap;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; T; while(T--) &#123; scanf("%d%d", &amp;n, &amp;m); init(); start = -1, mifix = INF, en = -1, mafix = -INF; for(int i = 0; i &lt; n; i++) &#123; scanf("%d%*d", &amp;x); if(x &lt; mifix) &#123; start = i; mifix = x; &#125; if(x &gt; mafix) &#123; en = i; mafix = x; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;cap); u--, v--; addedge(u, v, cap); addedge(v, u, cap); &#125; int ans = sap(start, en, n); printf("%d\n", ans); &#125; return 0;&#125; H. HDU 4292 Foodæœ€å¤§æµé—®é¢˜ï¼Œæ˜¯POJ 3281çš„å‡çº§ç‰ˆï¼Œçµæ´»ä¿®æ”¹ä¸€ä¸‹è¾¹æƒå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;const int N=1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜ * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ */const int MAXN = 1009;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 400010;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, f, d, start, en, t;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;f, &amp;d)) &#123; init(); start = 0, en = f + 2 * n + d + 1; for(int i = 1; i &lt;= f; i++) &#123; scanf("%d", &amp;t); addedge(start, i, t); &#125; for(int i = 1; i &lt;= d; i++) &#123; scanf("%d", &amp;t); addedge(f + 2 * n + i, en, t); &#125; for(int i = 1; i &lt;= n; i++) &#123; addedge(f + i, f + n + i, 1); &#125; for(int i = 1; i &lt;= n; i++) &#123; getchar(); for(int j = 1; j &lt;= f; j++) &#123; if(getchar() == 'Y') &#123; addedge(j, f + i, 1); &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; getchar(); for(int j = 1; j &lt;= d; j++) &#123; if(getchar() == 'Y') &#123; addedge(f + n + i, f + 2 * n + j, 1); &#125; &#125; &#125; int ans = sap(start, en, en + 1); printf("%d\n", ans); &#125; return 0;&#125; I. HDU 4289 Controlæœ€å°å‰²é—®é¢˜ï¼Œéœ€è¦æ‹†ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;const int N=1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜ * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ */const int MAXN = 409;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 400010;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, m, start, en, d, u, v;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); scanf("%d%d", &amp;start, &amp;en); en += n; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;d); addedge(i, i + n, d); &#125; while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u + n, v, INF); addedge(v + n, u, INF); &#125; int ans = sap(start, en, 2 * n + 1); printf("%d\n", ans); &#125; return 0;&#125; J. UVA 10480 Sabotageæœ€å°å‰²é—®é¢˜ï¼Œè¦æ±‚è¾“å‡ºå‰²è¾¹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* EKç®—æ³•ï¼šè§£å†³æœ€å¤§æµé—®é¢˜ï¼Œä½¿ç”¨é‚»æ¥çŸ©é˜µï¼Œå¯æ‰“å°è·¯å¾„(Tested 0 times) * åˆå§‹åŒ–ï¼šg[][], start, end, nn * æ—¶é—´å¤æ‚åº¦ï¼šO(|V| * |E| * |E|) */const int MAXN = 110;int g[MAXN][MAXN];//å­˜è¾¹çš„å®¹é‡ï¼Œæ²¡æœ‰è¾¹çš„åˆå§‹åŒ–ä¸º0int path[MAXN], flow[MAXN], start, en;int nn;//ç‚¹çš„ä¸ªæ•°ï¼Œç¼–å·0-nn.nnåŒ…æ‹¬äº†æºç‚¹å’Œæ±‡ç‚¹queue&lt;int&gt;q;int bfs() &#123; int i,t; memset(flow, 0, sizeof flow); while(!q.empty()) q.pop();//æŠŠæ¸…ç©ºé˜Ÿåˆ— memset(path, -1, sizeof path);//æ¯æ¬¡æœç´¢å‰éƒ½æŠŠè·¯å¾„åˆå§‹åŒ–æˆ-1 path[start] = 0; flow[start] = INF;//æºç‚¹å¯ä»¥æœ‰æ— ç©·çš„æµæµè¿› q.push(start); while(!q.empty()) &#123; t = q.front(); q.pop(); if(t == en) break; //æšä¸¾æ‰€æœ‰çš„ç‚¹ï¼Œå¦‚æœç‚¹çš„ç¼–å·èµ·å§‹ç‚¹æœ‰å˜åŒ–å¯ä»¥æ”¹è¿™é‡Œ for(i = 1;i &lt;= nn; i++) &#123; if(i != start &amp;&amp; path[i] == -1 &amp;&amp; g[t][i]) &#123; flow[i] = min(flow[t], g[t][i]); q.push(i); path[i] = t; &#125; &#125; &#125; if(path[en] == -1) return -1;//æ‰¾ä¸åˆ°å¢å¹¿è·¯å¾„äº† return flow[en];&#125;int max_flow() &#123; int max_flow = 0; int step, now, pre; while((step = bfs()) != -1) &#123; max_flow += step; now = en; while(now != start) &#123; pre = path[now]; g[pre][now] -= step; g[now][pre] += step; now = pre; &#125; &#125; return max_flow;&#125;/************************************************************/pii a[N];int n, m, w;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n) &#123; memset(g, 0, sizeof g); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;a[i].x, &amp;a[i].y, &amp;w); g[a[i].x][a[i].y] = g[a[i].y][a[i].x] = w; &#125; start = 1, en = 2, nn = n; max_flow(); for(int i = 0; i &lt; m; i++) &#123; if((flow[a[i].x] &amp;&amp; !flow[a[i].y]) || (flow[a[i].y] &amp;&amp; !flow[a[i].x])) printf("%d %d\n", a[i].x, a[i].y); &#125; printf("\n"); &#125; return 0;&#125; K. HDU 2732 Leapinâ€™ Lizardsæœ€å¤§æµé—®é¢˜ï¼Œéœ€è¦æ‹†ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜(Tested 3+ times) * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ */const int MAXN = 1001;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 20009;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/char g[29][29];int n, m, d, start, en, T, kase;int ID(int i, int j) &#123; return (i - 1) * m + j;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;n, &amp;d); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", g[i] + 1); &#125; m = strlen(g[1] + 1); init(); start = 0, en = 2 * n * m + 1; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(g[i][j] == '0') continue; addedge(ID(i, j), n * m + ID(i, j), g[i][j] - '0'); for(int x = -d; x &lt;= d; x++) &#123; for(int y = -d; y &lt;= d; y++) &#123; if(!x &amp;&amp; !y) continue; if(abs(x) + abs(y) &gt; d) continue; int nx = i + x, ny = j + y; if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) &#123; addedge(n * m + ID(i, j), en, 3); &#125; else addedge(n * m + ID(i, j), ID(nx, ny), 3); &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", g[i] + 1); for(int j = 1; j &lt;= m; j++) &#123; if(g[i][j] == 'L') &#123; ans++; addedge(start, ID(i, j), 1); &#125; &#125; &#125; ans -= sap(start, en, en + 1); if(ans == 0) &#123; printf("Case #%d: no lizard was left behind.\n", ++kase); &#125; else if(ans == 1) &#123; printf("Case #%d: %d lizard was left behind.\n", ++kase, ans); &#125; else &#123; printf("Case #%d: %d lizards were left behind.\n", ++kase, ans); &#125; &#125; return 0;&#125; L. HDU 3338 Kakuro Extensionè¡Œåˆ—æ¨¡å‹çš„æœ€å¤§æµé—®é¢˜ï¼Œæ¯”è¾ƒç¥å¥‡ã€‚è¿˜éœ€è¦å¤„ç†ä¸€ä¸‹æœ€å°ä¸‹ç•Œæµé‡çš„é™åˆ¶ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜(Tested 6 times) * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ * æ—¶é—´å¤æ‚åº¦ï¼šO(|E| * |V| * |V|) */const int MAXN = 100010;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 400010;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];// startèµ·ç‚¹ï¼Œendä¸ºç»ˆç‚¹ï¼ŒnodeNumä¸ºé¡¶ç‚¹æ•°ï¼Œä¸€èˆ¬ä¸ºen+1ï¼Œæ³¨æ„enä¸ä¸ºæœ€åä¸€ä¸ªé¡¶ç‚¹çš„æƒ…å†µï¼int sap(int start,int end,int nodeNum) &#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, m, lx[109][109], ly[109][109], num[10009], cnt, id[109][109];char s[109][109][9];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; cnt = 0; memset(lx, 0, sizeof lx); memset(ly, 0, sizeof ly); memset(num, 0, sizeof num); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; scanf("%s", s[i][j]); if(strcmp(s[i][j], ".......") == 0) &#123; if(j == 0 || lx[i][j - 1] == 0) lx[i][j] = ++cnt; else lx[i][j] = cnt; num[cnt]++; &#125; &#125; &#125; for(int j = 0; j &lt; m; j++) &#123; for(int i = 0; i &lt; n; i++) &#123; if(strcmp(s[i][j], ".......") == 0) &#123; if(i == 0 || lx[i - 1][j] == 0) ly[i][j] = ++cnt; else ly[i][j] = cnt; num[cnt]++; &#125; &#125; &#125; init(); int start = 0, en = cnt + 1, nodeNum = en + 1; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(strcmp(s[i][j], ".......") == 0) &#123; id[i][j] = tol; addedge(lx[i][j], ly[i][j], 8); &#125; if(s[i][j][3] != '\\') continue; if(s[i][j][0] != 'X') &#123; int t = (s[i][j][0] - '0') * 100 + (s[i][j][1] - '0') * 10 + (s[i][j][2] - '0'); addedge(ly[i + 1][j], en, t - num[ly[i + 1][j]]); &#125; if(s[i][j][4] != 'X') &#123; int t = (s[i][j][4] - '0') * 100 + (s[i][j][5] - '0') * 10 + (s[i][j][6] - '0'); addedge(start, lx[i][j + 1], t - num[lx[i][j + 1]]); &#125; &#125; &#125; sap(start, en, nodeNum); //cout &lt;&lt; t &lt;&lt; endl; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(j) putchar(' '); if(strcmp(s[i][j], ".......") == 0) &#123; putchar('0' + edge[id[i][j]].flow + 1); &#125; else &#123; putchar('_'); &#125; &#125; putchar('\n'); &#125; &#125; return 0;&#125; M. HDU 3605 Escapeæœ€å¤§æµé—®é¢˜ï¼Œç›´æ¥å»ºæµé‡ä¸º1çš„å›¾ä¼šTLEï¼Œéœ€è¦æŠŠåŒç§ç±»å‹çš„äººçœ‹åšä¸€ä¸ªç‚¹ï¼Œç„¶åå»ºæµé‡ç­‰äºäººæ•°çš„è¾¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜(Tested 4 times) * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ */const int MAXN = 100029;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = MAXN * 23;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init(int t)&#123; tol = 0; memset(head,-1,sizeof(int) * t);&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, m, start, en, d, cnt[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; start = 0, en = (1 &lt;&lt; m) + m; memset(cnt, 0, sizeof(int) * (1 &lt;&lt; m)); init(en + 1); for(int i = 0; i &lt; n; i++) &#123; int sum = 0; for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;d); if(d) sum += 1 &lt;&lt; j; &#125; cnt[sum]++; &#125; int up = 1 &lt;&lt; m; for(int i = 1; i &lt; up; i++) &#123; addedge(start, i, cnt[i]); for(int j = 0; j &lt; m; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; addedge(i, up + j, cnt[i]); &#125; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d); addedge(up + i, en, d); &#125; int ans = sap(start, en, en + 1); if(ans == n) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; N. HDU 3081 Marriage Match IIæœ€å¤§æµé—®é¢˜ + äºŒåˆ†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜(Tested 4 times) * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ */const int MAXN = 209;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 20409;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM], edget[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int fa[N];int find(int u) &#123; return fa[u] == u ? u : fa[u] = find(fa[u]);&#125;void uf(int u, int v) &#123; fa[find(u)] = fa[find(v)];&#125;int T, n, m, k, u, v;int headt[N];vi to[N], too[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); init(); int start = 0, en = 2 * n + 1; for(int i = 1; i &lt;= n; i++) &#123; to[i].clear(); too[i].clear(); fa[i] = i; &#125; while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); to[u].push_back(v); &#125; while(k--) &#123; scanf("%d%d", &amp;u, &amp;v); uf(u, v); &#125; for(int i = 1; i &lt;= n; i++) &#123; int fa = find(i); for(auto j: to[i]) &#123; too[fa].push_back(j); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; sort(too[i].begin(), too[i].end()); too[i].resize(unique(too[i].begin(), too[i].end()) - too[i].begin()); &#125; for(int i = 1; i &lt;= n; i++) &#123; int fa = find(i); for(auto j: too[fa]) &#123; addedge(i, n + j, 1); &#125; &#125; int tolt = tol; memcpy(headt, head, sizeof head); memcpy(edget, edge, sizeof edge); int l = 0, r = n + 1; while(l + 1 != r) &#123; int mid = l + (r - l) / 2; memcpy(head, headt, sizeof(int) * (en + 1)); memcpy(edge, edget, sizeof(Edge) * (tol + 1)); tol = tolt; for(int i = 1; i &lt;= n; i++) &#123; addedge(start, i, mid); addedge(n + i, en, mid); &#125; int t = sap(start, en, en + 1); if(t == n * mid) l = mid; else r = mid; &#125; printf("%d\n", l); &#125; return 0;&#125; O. HDU 3416 Marriage Match IVæœ€å¤§æµé—®é¢˜ + æœ€çŸ­è·¯é—®é¢˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;int head[2][1009], tot;struct Edge &#123; int v, c, next; Edge () &#123;&#125; Edge (int v, int c, int next): v(v), c(c), next(next) &#123;&#125;&#125;edge[2 * N];void addedge(int u, int v, int c, int ty) &#123; edge[tot] = Edge&#123;v, c, head[ty][u]&#125;; head[ty][u] = tot++;&#125;void init() &#123; memset(head, -1, sizeof head); tot = 0;&#125;/************************************************************//* dijkstraç®—æ³•ï¼šè§£å†³æœ€çŸ­è·¯é—®é¢˜(Tested 0 times) * å‰å‘å¿ƒå­˜å›¾ */const int MAX_V=10009;int d[2][MAX_V];void dijkstra(int s, int ty) &#123; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; que; d[ty][s] = 0; que.push(pii(0, s)); while(!que.empty()) &#123; pii p = que.top(); que.pop(); int u = p.second; if(d[ty][u] &lt; p.first) continue; for(int i = head[ty][u]; ~i; i = edge[i].next) &#123; Edge e = edge[i]; if(d[ty][e.v] &gt; d[ty][u] + e.c) &#123; d[ty][e.v] = d[ty][u] + e.c; que.push(pii(d[ty][e.v], e.v)); &#125; &#125; &#125;&#125;/************************************************************//************************************************************//* ISAP + bfsåˆå§‹åŒ– + æ ˆä¼˜åŒ–ï¼šè¶…é«˜æ•ˆåœ°è§£å†³æœ€å¤§æµé—®é¢˜(Tested 5 times) * æ³¨æ„ä¿®æ”¹MAXNå’ŒMAXMæˆé€‚åˆçš„å¤§å°ï¼Œä»¥æé«˜æ—¶é—´æ•ˆç‡ * æ—¶é—´å¤æ‚åº¦ï¼šO(|E| * |V| * |V|) */const int MAXN = 1009;//ç‚¹æ•°çš„æœ€å¤§å€¼const int MAXM = 200009;//è¾¹æ•°çš„æœ€å¤§å€¼ï¼Œæ³¨æ„åå‘è¾¹ä¹Ÿè¦ç®—è¿›å»ï¼Œä¹Ÿå°±æ˜¯è¯´è¦ä¹˜ä»¥2struct Edge1&#123; int to,next,cap,flow;&#125;edge1[MAXM];//æ³¨æ„æ˜¯ MAXMint tol;int head1[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init1()&#123; tol = 0; memset(head1,-1,sizeof(head1));&#125;void addedge1(int u,int v,int w,int rw = 0)&#123; edge1[tol].to = v; edge1[tol].cap = w; edge1[tol].flow = 0; edge1[tol].next = head1[u]; head1[u] = tol++; edge1[tol].to = u; edge1[tol].cap = rw; edge1[tol].flow = 0; edge1[tol].next = head1[v]; head1[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head1[u]; i != -1; i = edge1[i].next)&#123; int v = edge1[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head1,sizeof(head1)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge1[S[i]].cap - edge1[S[i]].flow)&#123; Min = edge1[S[i]].cap - edge1[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge1[S[i]].flow += Min; edge1[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge1[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge1[i].next)&#123; v = edge1[i].to; if(edge1[i].cap - edge1[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head1[u]; i != -1; i = edge1[i].next) if(edge1[i].cap - edge1[i].flow &amp;&amp; dep[edge1[i].to] &lt; Min) &#123; Min = dep[edge1[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge1[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int T, n, m, u, v, c[N];pii a[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; init(); scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, c + i); a[i] = pii(u, v); addedge(u, v, c[i], 0); addedge(v, u, c[i], 1); &#125; scanf("%d%d", &amp;u, &amp;v); memset(d, INF, sizeof d); dijkstra(u, 0); dijkstra(v, 1); init1(); int start = 0, en = v; for(int i = 0; i &lt; m; i++) &#123; if(d[0][a[i].x] + c[i] + d[1][a[i].y] == d[0][v]) &#123; addedge1(a[i].x, a[i].y, 1); &#125; &#125; addedge1(start, u, INF); printf("%d\n", sap(start, en, n + 1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ç½‘ç»œæµ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1016E Rest In The Shades]]></title>
    <url>%2F2018%2F08%2F12%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„æœ‰ä¸€ä¸ªå…‰æºåœ¨xè½´ä¸‹æ–¹ä¸”å¹³è¡Œäºxè½´çš„æŸæ¡çº¿æ®µABä¸Šä½œåŒ€é€Ÿç›´çº¿è¿åŠ¨ï¼Œxè½´ä¸Šæœ‰n($$1 &lt;= n &lt;= 210^5$$)æ¡ä¼šé˜»æŒ¡å…‰çº¿çš„çº¿æ®µï¼Œç°åœ¨æœ‰q($$1 &lt;= n &lt;= 210^5$$)ä¸ªåœ¨xè½´ä¸Šæ–¹çš„ç‚¹ï¼Œé—®è¿™qä¸ªç‚¹æ²¡æœ‰è¢«å…‰çº¿ç…§å°„åˆ°çš„æ—¶é—´åˆ†åˆ«æ˜¯å¤šå°‘ã€‚ åˆ†æç»è¿‡è§‚å¯Ÿå‘ç°ï¼Œåˆ°è¾¾æŸä¸ªç‚¹çš„å…‰å‡å¦‚ä¼šè¢«å¤šæ¡çº¿æ®µé˜»æŒ¡ï¼Œé‚£ä¹ˆè¿™äº›çº¿æ®µå¤§éƒ¨åˆ†æ˜¯å®Œæ•´ä¸”ç›¸é‚»çš„ï¼Œæœ€å¤šåªæœ‰ä¸¤æ¡çº¿æ®µæ˜¯ä¸å®Œæ•´çš„ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å‰ç¼€å’Œæ¥å¤„ç†å®Œæ•´çš„çº¿æ®µï¼Œç„¶åç”¨äºŒåˆ†æœç´¢æ¥å¤„ç†ä¸å®Œæ•´çš„çº¿æ®µï¼Œæ±‚å’Œã€‚æ¥ç€ï¼Œç”±ç›¸ä¼¼ä¸‰è§’å½¢çš„ç›¸å…³å®šç†å¯è®¡ç®—å‡ºåœ¨xè½´ä¸Šçº¿æ®µåœ¨ABä¸ŠæŠ•å½±ï¼Œè¿›è€Œæ±‚å¾—ç­”æ¡ˆã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const double Eps=1e-7;double sum[N];int n, l, r, q, x, y, vis, idx1, idx2;double sy, xa, xb;struct node &#123; double l, r, id; node() &#123;&#125; node(double l, double r, int id): l(l), r(r), id(id) &#123;&#125; bool operator &lt; (const node &amp;rhs) const &#123; if(l != rhs.l) return l &lt; rhs.l; if(r != rhs.r) return r &lt; rhs.r; return id &lt; rhs.id; &#125;&#125;;set&lt;node&gt; se;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%lf%lf%lf", &amp;sy, &amp;xa, &amp;xb)) &#123; scanf("%d", &amp;n); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;l, &amp;r); sum[i] = sum[i-1] + r - l; se.insert(node(l, r, i)); &#125; scanf("%d", &amp;q); while(q--) &#123; scanf("%d%d", &amp;x, &amp;y); double ans = 0; double x1 = (y * xa - sy * x) / (y - sy); double x2 = (y * xb - sy * x) / (y - sy); auto it = se.lower_bound(node(x1, -1, -1)); vis = -1; idx1 = (it == se.end() ? INF : it-&gt;id); if(it != se.begin()) &#123; it--; if(x1 &lt; it-&gt;r) &#123; ans += min(it-&gt;r, x2) - x1; vis = it-&gt;id; &#125; &#125; it = se.lower_bound(node(x2, -1, -1)); if(it != se.begin()) &#123; it--; if(x2 &lt; it-&gt;r &amp;&amp; vis != it-&gt;id) &#123; ans += x2 - max(it-&gt;l, x1); &#125; if(x2 &lt; it-&gt;r) &#123; if(it != se.begin()) &#123; it--; idx2 = it-&gt;id; &#125; else &#123; idx2 = -INF; &#125; &#125; else &#123; idx2 = it-&gt;id; &#125; &#125; else &#123; idx2 = -INF; &#125; if(idx1 &lt;= idx2) &#123; ans += sum[idx2] - sum[idx1-1]; &#125; ans *= 1.0 * (y - sy) / y; printf("%.10f\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>äºŒåˆ†</tag>
        <tag>è®¡ç®—å‡ ä½•</tag>
        <tag>å‰ç¼€å’Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6356 Glad You Came]]></title>
    <url>%2F2018%2F08%2F09%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ªé•¿åº¦ä¸ºn$ (1 &lt;= n &lt;= 10^5 $)çš„æ•°ç»„ï¼Œæ‰€æœ‰å…ƒç´ çš„åˆå§‹å€¼ä¸º0ï¼Œç„¶åæœ‰m$ (1 &lt;= m &lt;= 5*10^6 $)ä¸ªæ“ä½œï¼Œæ›´æ–°æŸæ®µåŒºé—´çš„æœ€å¤§å€¼ã€‚ åˆ†æ å®˜æ–¹é¢˜è§£ï¼šå¦‚æœæœ‰ä¸¤ä¸ªæ“ä½œè¦†ç›–ç›¸åŒçš„åŒºé—´ï¼Œæˆ‘ä»¬å¯ä»¥ä¿ç•™æœ€å¤§çš„é‚£ä¸ªã€‚ å¯¹äºæ¯ä¸ªæ“ä½œ$(l, r, v)$ï¼Œä»¤dç­‰äº$\lfloor log_2(r - l + 1) \rfloor$ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ä¸ªæ“ä½œ $(l, l + 2^d - 1, v)$ å’Œ$(r - 2^d + 1, r, v)$ æ›¿æ¢æ­¤æ“ä½œã€‚è¿™æ ·åšä¹‹åï¼Œæ¯ä¸ªæ“ä½œæ‰€è¦†ç›–çš„åŒºé—´é•¿åº¦å‡ä¸º 2 çš„å¹‚ï¼Œè¿™æ„å‘³ç€é•¿åº¦ä»…æœ‰ $O(logn)$ç§ã€‚å‰©ä¸‹çš„åªä¸è¿‡æ˜¯ï¼ŒæŒ‰é•¿åº¦é€’å‡çš„é¡ºåºæšä¸¾æ“ä½œï¼Œå°†æ¯ä¸ªæ“ä½œåˆ†æˆä¸¤ä¸ªç›¸ç­‰é•¿åº¦çš„æ“ä½œï¼Œç›´åˆ°åŒºé—´é•¿åº¦ä¸ºä¸€ã€‚è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(m + nlogn)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º$O(nlogn)$ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;unsigned X, Y, Z;int T, Log[N], n, m, mx, l, r, v, d, a[19][N];unsigned int rng61() &#123; X ^= X &lt;&lt; 11; X ^= X &gt;&gt; 4; X ^= X &lt;&lt; 5; X ^= X &gt;&gt; 14; unsigned int tmp = X ^ Y ^ Z; X = Y; Y = Z; Z = tmp; return Z;&#125;void upd(int &amp;d, int v) &#123; d &lt; v &amp;&amp; (d = v);&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; // 2^k &lt;= i &lt; 2^(k+1)ï¼Œé¢„å¤„ç†å‡ºiå¯¹åº”çš„k for(int i = 2; i &lt; N; i++) Log[i] = Log[i &gt;&gt; 1] + 1; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%u%u%u", &amp;n, &amp;m, &amp;X, &amp;Y, &amp;Z); while(m--) &#123; l = rng61() % n + 1, r = rng61() % n + 1; if(l &gt; r) swap(l, r); v = rng61() % (1 &lt;&lt; 30); d = Log[r - l + 1]; // é€†ç”¨STè¡¨ upd(a[d][l], v); upd(a[d][r - (1 &lt;&lt; d) + 1], v); &#125; // æ±‚å‡ºæ»¡è¶³2^mx &gt; n çš„æœ€å°mx mx = 0; while(1 &lt;&lt; mx &lt;= n) mx++; // O(nlogn) ä»å¤§åŒºé—´æ¨åˆ°å°åŒºé—´ï¼Œç›´åˆ°1 for(int i = mx - 1; i &gt; 0; i--) &#123; for(int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) &#123; upd(a[i - 1][j], a[i][j]); upd(a[i - 1][j + (1 &lt;&lt; (i - 1))], a[i][j]); a[i][j] = 0; &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans ^= 1LL * i * a[0][i]; a[0][i] = 0; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ€ç»´</tag>
        <tag>STè¡¨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018æ­ç”µå¤šæ ¡ç¬¬å››åœºBé¢˜ Harvest of Apples]]></title>
    <url>%2F2018%2F08%2F01%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„æœ‰nä¸ªè‹¹æœï¼Œç¼–å·ä¸º1åˆ°nï¼Œæ±‚ä»ä¸­æœ€å¤šé€‰å–mä¸ªè‹¹æœçš„æ–¹æ¡ˆæ•°ã€‚æµ‹è¯•ç»„æ•°æœ‰Tç»„ã€‚($$ 1â‰¤Tâ‰¤10^5, 1â‰¤mâ‰¤nâ‰¤10^5 $$) åˆ†æ å®˜æ–¹é¢˜è§£:å®šä¹‰ $$ S(n, m) = \sum_{i = 0} ^ {m} {n \choose i} $$ï¼Œä¸éš¾å‘ç°$$ S(n,m)=S(n,mâˆ’1)+{n \choose m} $$, $$ S(n,m)=2S(nâˆ’1,m)âˆ’{n-1 \choose m} $$.ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬çŸ¥é“ S(n, m)ï¼Œå°±èƒ½ä»¥ O(1) çš„ä»£ä»·è®¡ç®—å‡ºS(nâˆ’1,m), S(n,mâˆ’1), S(n+1,m), S(n,m+1)ï¼Œå¯ä»¥é‡‡ç”¨è«é˜Ÿç®—æ³•ã€‚ æ°´é¢˜ï¼Œç›´æ¥å®ç°å°±è¡Œäº†ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;const int p = 1e9 + 7;ll fac[N], ni[N], ans, an[N], ni2;int len, n, m, T;ll pow_mod(ll a, ll b, ll p) &#123; //è¾…åŠ©å‡½æ•° ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;ll inv_Fermat(ll a, ll p) &#123; //è´¹é©¬å°å®šç†æ±‚aå…³äºpçš„é€†å…ƒ return pow_mod(a, p-2, p);&#125;void init() &#123; fac[0] = 1; len = sqrt(100000); ni2 = inv_Fermat(2, p); for(int i = 1; i &lt;= 100005; i++) fac[i] = fac[i-1] * i % p; ni[100005] = inv_Fermat(fac[100005], p); for(int i = 100004; i &gt;= 0; i--) ni[i] = ni[i+1] * (i + 1) % p;&#125;struct Node &#123; int n, m, block, id; Node() &#123;&#125; Node(int n, int m, int id):n(n), m(m), id(id) &#123; block = n / len; &#125; bool operator &lt; (Node &amp;rhs) const &#123; if(block == rhs.block) return m &lt; rhs.m; return block &lt; rhs.block; &#125;&#125;q[N];ll C(int n, int m) &#123; return fac[n] * ni[m] % p * ni[n-m] % p;&#125;int main(void) &#123; init(); scanf("%d", &amp;T); for(int i = 0; i &lt; T; i++) &#123; scanf("%d%d", &amp;n, &amp;m); q[i]= Node&#123;n, m, i&#125;; &#125; sort(q, q + T); n = 1, m = 1; ans = 2; for(int i = 0; i &lt; T; i++) &#123; Node &amp;t = q[i]; while(n &lt; t.n) &#123; ++n; (ans = ans * 2 - C(n-1, m)) %= p; &#125; while(m &lt; t.m) &#123; ++m; (ans = ans + C(n, m)) %= p; &#125; while(n &gt; t.n) &#123; (ans = (ans + C(n-1, m)) * ni2) %= p; n--; &#125; while(m &gt; t.m) &#123; (ans = ans - C(n, m)) %= p; m--; &#125; ans = (ans + p) % p; an[t.id] = ans; &#125; for(int i = 0; i &lt; T; i++) &#123; printf("%lld\n", an[i]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018ç‰›å®¢å¤šæ ¡ç¬¬äºŒåœºJé¢˜ farm]]></title>
    <url>%2F2018%2F07%2F30%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„æœ‰ä¸€ä¸ª$$ nm(nm&lt;=1e6) $$çš„çŸ©å½¢,æ¯ä¸ªä½ç½®æœ‰ä¸€ä¸ªæ•°ã€‚æœ‰$$ T(T&lt;=1e6) $$æ¬¡æ“ä½œ,æ¯æ¬¡å¾€ä¸€ä¸ªå­çŸ©å½¢çš„æ¯ä¸ªæ ¼å­ä¸­æ”¾å…¥ä¸€ä¸ªæ•°ã€‚æ±‚æœ‰å¤šå°‘ä¸ªæ ¼å­ä¸­è¢«æ”¾å…¥äº†è‡³å°‘ä¸€ä¸ªä¸å¯¹åº”ä½ç½®ä¸ç›¸åŒçš„æ•°ã€‚ åˆ†æ å®˜æ–¹é¢˜è§£ï¼šå…ˆè€ƒè™‘ä¸€ä¸ªç‰¹æ®Šçš„æƒ…å†µ:çŸ©å½¢ä¸­çš„æ•°å’ŒTæ¬¡æ“ä½œæ”¾çš„æ•°éƒ½ä¸º0æˆ–1ã€‚å¯¹äºè¿™ç§æƒ…å†µ,æˆ‘ä»¬åªéœ€è¦ç”¨çŸ©é˜µå‰ç¼€å’Œç»Ÿè®¡ä¸€ä¸‹æ¯ä¸ªæ ¼å­è¢«å¤šå°‘ä¸ª0è¦†ç›–,è¢«å¤šå°‘ä¸ª1è¦†ç›–ã€‚å¦‚æœä¸€ä¸ªæ ¼å­çš„æ•°ä¸º0ä¸”è¢«æ”¾å…¥äº†è‡³å°‘ä¸€ä¸ª1æˆ–è¿™ä¸ªæ ¼å­çš„æ•°ä½1ä¸”è¢«æ”¾å…¥äº†è‡³å°‘ä¸€ä¸ª0åˆ™å°±ä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®ã€‚ç„¶åè€ƒè™‘åŸé—®é¢˜ã€‚å¦‚æœæŸä¸ªæ ¼å­çš„æ•°æ˜¯i,è€Œå®ƒè¢«æ”¾å…¥äº†è‡³å°‘ä¸€ä¸ªj,ä¸”i!=j,åˆ™éœ€è¦ç»Ÿè®¡è¿›å…¥ç­”æ¡ˆã€‚æ³¨æ„åˆ°,i!=jåˆ™iå’Œjè‡³å°‘æœ‰ä¸€ä¸ªäºŒè¿›åˆ¶ä½ä¸ç›¸åŒã€‚æˆ‘ä»¬æšä¸¾0~19çš„æ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½,ç„¶åæŠŠæ‰€æœ‰æ•°å­—æŒ‰ç…§è¿™ä¸€ä½æ˜¯0è¿˜æ˜¯1åˆ’åˆ†æˆä¸¤ä¸ªé›†åˆ,å°±å˜æˆäº†ä¸Šè¿°ç‰¹æ®Šæƒ…å†µçš„é—®é¢˜ã€‚ä¸€ä¸ªæ ¼å­åªè¦è‡³å°‘åœ¨æŸä¸€ä¸ªäºŒè¿›åˆ¶ä½çš„å­é—®é¢˜æ—¶è¢«ç»Ÿè®¡è¿›å…¥ç­”æ¡ˆ,å°±åŠ åˆ°æ€»ç­”æ¡ˆä¸­å»ã€‚å¤æ‚åº¦ $O((nm+T)log(nm)) $ å®˜æ–¹é¢˜è§£è¯´å¾—å¾ˆæ¸…æ¥šäº†ï¼Œç›´æ¥å®ç°å°±è¡Œäº†ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const double Eps=1e-7; int n, m, T, a[N], x, y, xx, yy, k, num[N][20][2], ans; int id(int x, int y) &#123; if(x == 0 || y == 0) return 0; return (x - 1) * m + y;&#125; int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;T)) &#123; ans = 0; memset(num, 0, sizeof num); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[id(i, j)]); while(T--) &#123; scanf("%d%d%d%d%d", &amp;x, &amp;y, &amp;xx, &amp;yy, &amp;k); for(int bit = 0; bit &lt; 20; bit++) &#123; num[id(x, y)][bit][k &gt;&gt; bit &amp; 1]++; if(yy + 1 &lt;= m) num[id(x, yy + 1)][bit][k &gt;&gt; bit &amp; 1]--; if(xx + 1 &lt;= n) num[id(xx + 1, y)][bit][k &gt;&gt; bit &amp; 1]--; if(xx + 1 &lt;= n &amp;&amp; yy + 1 &lt;= m) num[id(xx + 1, yy + 1)][bit][k &gt;&gt; bit &amp; 1]++; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; bool flag = false; for(int bit = 0; bit &lt; 20; bit++) &#123; num[id(i, j)][bit][0] += num[id(i - 1, j)][bit][0] + num[id(i, j - 1)][bit][0] - num[id(i - 1, j - 1)][bit][0]; num[id(i, j)][bit][1] += num[id(i - 1, j)][bit][1] + num[id(i, j - 1)][bit][1] - num[id(i - 1, j - 1)][bit][1]; if((a[id(i, j)] &gt;&gt; bit &amp; 1 &amp;&amp; num[id(i, j)][bit][0]) || (!(a[id(i, j)] &gt;&gt; bit &amp; 1) &amp;&amp; num[id(i, j)][bit][1])) flag = true; &#125; if(flag) ans++; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ€ç»´</tag>
        <tag>å‰ç¼€å’Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è«é˜Ÿç®—æ³•å­¦ä¹ ç¬”è®°ï¼ˆäºŒï¼‰]]></title>
    <url>%2F2018%2F07%2F27%2F0%2F</url>
    <content type="text"><![CDATA[ä»‹ç»ä¸Šä¸€ç¯‡è«é˜Ÿç®—æ³•å­¦ä¹ ç¬”è®°ä¸»è¦å†™äº†æ™®é€šè«é˜Ÿç®—æ³•çš„åº”ç”¨ï¼Œè¿™æ¬¡æ¥å†™ä¸€å†™æ ‘ä¸Šè«é˜Ÿå’Œå¸¦ä¿®æ”¹è«é˜Ÿã€‚æ ‘ä¸Šè«é˜Ÿï¼Œå°±æ˜¯å°†æ ‘è½¬åŒ–ä¸ºåºåˆ—ï¼Œç„¶ååº”ç”¨è«é˜Ÿç®—æ³•æ¥è§£å†³ã€‚å¸¦ä¿®æ”¹è«é˜Ÿï¼Œç›¸æ¯”äºæ™®é€šè«é˜Ÿï¼Œå¢åŠ äº†å•ç‚¹ä¿®æ”¹çš„æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦ç”±$ O(n\sqrt{n}) $ ä¸Šå‡åˆ°äº†$ O(n^{\frac{5}{3}}) $ã€‚æ‰€ä»¥ï¼Œåœ¨æ²¡æœ‰å…¶ä»–ç‰¹æ®Šæ¡ä»¶çš„æƒ…å†µä¸‹ï¼Œå¯¹äº$ n = 1e5 $æ¬¡è¯¢é—®ï¼Œä¸€èˆ¬éœ€è¦2ç§’çš„å¤„ç†æ—¶é—´ã€‚ç»è¿‡å®æˆ˜å‘ç°ï¼Œè«é˜Ÿç®—æ³•å¾ˆé€‚åˆå¤„ç†éœ€è¦ç»Ÿè®¡å…ƒç´ å‡ºç°æ¬¡æ•°çš„é—®é¢˜ï¼Œè€Œè¿™ç±»é—®é¢˜ç”¨å…¶ä»–æ•°æ®ç»“æ„ï¼Œå¦‚çº¿æ®µæ ‘ï¼Œä¸å¤ªå¥½è§£å†³ï¼ˆç¥çŠ‡è¯·æ— è§†ï¼‰ã€‚è€Œä¸”ï¼Œè«é˜Ÿç®—æ³•å®ç°èµ·æ¥ç›¸å¯¹å®¹æ˜“ï¼Œç©ºé—´æ¶ˆè€—å°ã€‚ä½†æ˜¯ï¼Œè«é˜Ÿç®—æ³•ä¹Ÿæœ‰å®ƒçš„å±€é™æ€§ï¼Œå³æ—¶é—´å¤æ‚åº¦åé«˜ï¼Œä¸”ä¸èƒ½å¤„ç†åŒºé—´ä¿®æ”¹çš„é—®é¢˜ã€‚ é¢˜ç›®1ï¼šCodeForces - 375D - Tree and Queriesé¢˜æ„ç»™ä¸€é¢—å…·æœ‰nä¸ªèŠ‚ç‚¹çš„æœ‰æ ¹æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æŸ“æœ‰ä¸€ç§é¢œè‰²ã€‚ç„¶åæœ‰mä¸ªè¯¢é—®ï¼Œè¯¢é—®çš„æ˜¯æŸä¸ªèŠ‚ç‚¹å­æ ‘çš„é¢œè‰²æ•°ã€‚ åˆ†æå‡å¦‚æˆ‘ä»¬çŸ¥é“äº†ä»æ ¹å‡ºå‘çš„dfsåºï¼Œé‚£ä¹ˆä¸€é¢—å­æ ‘å°±å¯¹åº”dfsåºçš„ä¸€ä¸ªåŒºé—´ï¼Œå› æ­¤ï¼ŒåŸé—®é¢˜å°±è½¬åŒ–æˆäº†æ±‚æŸä¸ªåŒºé—´çš„é¢œè‰²æ•°ï¼Œåº”ç”¨æ™®é€šè«é˜Ÿå³å¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const double Eps=1e-7;int len, cnt, in[N], out[N], c[N], nc[N], u, k, v, n, m, f[N], sum[N], ans[N];vi G[N];struct node &#123; int l, r, k, id, block; node() &#123;&#125; node(int l, int r, int k, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;k = k; this-&gt;id = id; this-&gt;block = l / len ; &#125; bool operator &lt; (const node t) const &#123; if(block == t.block) return r &lt; t.r; return block &lt; t.block; &#125;&#125;q[N];void dfs(int u, int fa) &#123; in[u] = ++cnt; nc[cnt] = c[u]; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if(v == fa) continue; dfs(v, u); &#125; out[u] = cnt;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", c + i); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;k); q[i] = node&#123;in[u], out[u], k, i&#125;; &#125; sort(q, q + m); int l = 1, r = 0; for(int i = 0; i &lt; m; i++) &#123; node t = q[i]; while(r &lt; t.r) &#123; ++f[nc[++r]]; ++sum[f[nc[r]]]; &#125; while(l &gt; t.l) &#123; ++f[nc[--l]]; ++sum[f[nc[l]]]; &#125; while(r &gt; t.r) &#123; --sum[f[nc[r]]]; --f[nc[r--]]; &#125; while(l &lt; t.l) &#123; --sum[f[nc[l]]]; --f[nc[l++]]; &#125; ans[t.id] = sum[t.k]; &#125; for(int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); &#125; return 0;&#125; é¢˜ç›®2ï¼šUVA - 12345 - Dynamic lené¢˜æ„ç»™ä¸€ä¸ªå…·æœ‰nä¸ªå…ƒç´ çš„æ•°åˆ—ï¼Œç„¶åæœ‰mä¸ªä¿®æ”¹æˆ–æŸ¥è¯¢ã€‚æŸ¥è¯¢çš„æ˜¯æŸä¸ªåŒºé—´çš„ä¸åŒæ•°å­ä¸ªæ•°ï¼Œä¿®æ”¹çš„æ˜¯æŸä¸ªå…ƒç´ çš„å€¼ã€‚ åˆ†æå¸¦ä¿®æ”¹è«é˜Ÿæ¨¡æ¿é¢˜ï¼Œéœ€è¦æ³¨æ„çš„ç‚¹æœ‰ï¼š åˆ†å—å¤§å°ä¸º$ O( n^{\frac{2}{3}}) $ ã€‚ æ’åºæ—¶ä»¥å·¦ç«¯ç‚¹æ‰€åœ¨åŒºå—ä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œå³ç«¯ç‚¹æ‰€åœ¨åŒºå—ä¸ºç¬¬äºŒå…³é”®å­—ï¼Œæ—¶é—´æˆ³ä¸ºç¬¬ä¸‰å…³é”®å­—ã€‚ æ¯ä¸ªæ—¶é—´æˆ³éƒ½æ„å‘³ç€çŠ¶æ€çš„æ”¹å˜ï¼Œæ‰€ä»¥éœ€è¦ä¿å­˜æ›´æ–°åˆ°æ–°çŠ¶æ€å’Œæ’¤é”€å›æ—§çŠ¶æ€çš„ç›¸å…³ä¿¡æ¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;int len, n, m, x, y, last[N], tot, timer, a[N], l, r, ans, an[N], cnt[10*N];bool flag[N];char op[N];struct node1 &#123; int last, x, val;&#125;chg[N];struct node &#123; int l, r, id, lblock, rblock, timer; node() &#123;&#125; node(int l, int r, int id, int timer):l(l), r(r), id(id), timer(timer) &#123; this-&gt;lblock = l / len; this-&gt;rblock = r / len; &#125; bool operator &lt; (const node t) const &#123; if(lblock != t.lblock) return lblock &lt; t.lblock; else if(rblock != t.rblock) return rblock &lt; t.rblock; return timer &lt; t.timer; &#125;&#125;q[N];void sub(int x) &#123; if(cnt[a[x]] == 1) ans--; cnt[a[x]]--; flag[x] = 0;&#125;void add(int x) &#123; if(cnt[a[x]] == 0) ans++; cnt[a[x]]++; flag[x] = 1;&#125;void modify(int x, int val) &#123; if(!flag[x]) a[x] = val; else &#123; sub(x); a[x] = val; add(x); &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = pow(n, 2.0/3); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", a + i); last[i] = a[i]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%s%d%d", op, &amp;x, &amp;y); ++x; if(op[0] == 'Q') &#123; q[tot] = node&#123;x, y, tot, timer&#125;; ++tot; &#125; else &#123; chg[++timer].last = last[x]; chg[timer].x = x; chg[timer].val = last[x] = y; &#125; &#125; sort(q, q + tot); l = 1, r = 0, ans = 0, timer = 0; for(int i = 0; i &lt; tot; i++) &#123; node t = q[i]; while(timer &lt; q[i].timer) &#123; timer++; modify(chg[timer].x, chg[timer].val); &#125; while(timer &gt; q[i].timer) &#123; modify(chg[timer].x, chg[timer].last); timer--; &#125; while(r &lt; t.r) add(++r); while(l &gt; t.l) add(--l); while(r &gt; t.r) sub(r--); while(l &lt; t.l) sub(l++); an[t.id] = ans; &#125; for(int i = 0; i &lt; tot; i++) printf("%d\n", an[i]); &#125; return 0;&#125; é¢˜ç›®3ï¼šCodeForces - 940F - Machine Learning é¢˜æ„ç»™ä¸€ä¸ªå…·æœ‰nä¸ªå…ƒç´ çš„æ•°åˆ—ï¼Œç„¶åæœ‰qæ¬¡ä¿®æ”¹æˆ–æŸ¥è¯¢ã€‚ä¿®æ”¹ï¼Œå³è®©æŸä¸ªå…ƒç´ çš„å€¼æ”¹å˜ã€‚æŸ¥è¯¢çš„æ˜¯åŒºé—´[L, R]çš„Mexï¼ŒMexçš„å®šä¹‰æ˜¯æœ€å°çš„å…ƒç´ å‡ºç°æ¬¡æ•°çš„æ¬¡æ•°ä¸º0çš„æ¬¡æ•°ï¼ˆä¸æ‡‚å¯ä»¥çœ‹åŸé¢˜ï¼‰ã€‚ åˆ†æç”±æ•°å­¦çŸ¥è¯†å¾—ï¼Œä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°åˆ—ï¼Œç­”æ¡ˆæœ€å¤§ä¸º$ \sqrt{2n} $ï¼Œæ‰€ä»¥ï¼Œå‡å¦‚æˆ‘ä»¬ç»´æŠ¤äº†å…ƒç´ å‡ºç°çš„æ¬¡æ•°çš„æ¬¡æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åœ¨ $ O(\sqrt{n})$å¾—åˆ°æŸä¸ªåŒºé—´çš„ç­”æ¡ˆã€‚å‡å¦‚æ²¡æœ‰ä¿®æ”¹æ“ä½œï¼Œå¯ä»¥ç›´æ¥ç”¨æ™®é€šè«é˜Ÿç»´æŠ¤ã€‚ä½†æ˜¯è¿™é‡Œæœ‰äº†å•ç‚¹çš„ä¿®æ”¹æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘ç”¨å¸¦ä¿®æ”¹çš„è«é˜Ÿæ¥å®ç°ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const double Eps=1e-7;set&lt;int&gt; s;map&lt;int, int&gt; ma;int len, n, m, a[N], cnt[N], se[N], x, y, tot, timer, l, r, last[N], an[N], op, flag[N], dis, up;struct node &#123; int l, r, id, lblock, rblock, timer; node() &#123;&#125; node(int l, int r, int id, int timer): l(l), r(r), id(id), timer(timer) &#123; this-&gt;lblock = l / len; this-&gt;rblock = r / len; &#125; bool operator &lt; (const node t) const &#123; if(lblock != t.lblock) return lblock &lt; t.lblock; if(rblock != t.rblock) return rblock &lt; t.rblock; return timer &lt; t.timer; &#125;&#125;q[N];struct node1 &#123; int x, val, last; node1() &#123;&#125; node1(int x, int val, int last): x(x), val(val), last(last) &#123;&#125;&#125;chg[N];void sub(int x) &#123; int &amp;t = cnt[a[x]]; se[t]--; se[--t]++; flag[x] = 0;&#125;void add(int x) &#123; int &amp;t = cnt[a[x]]; se[t]--; se[++t]++; flag[x] = 1;&#125;void modify(int x, int val) &#123; if(!flag[x]) a[x] = val; else &#123; sub(x); a[x] = val; add(x); &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = pow(n, 2.0/3); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", a + i); s.insert(a[i]); last[i] = a[i]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if(op == 1) &#123; q[tot] = node&#123;x, y, tot, timer&#125;; tot++; &#125; else &#123; timer++; chg[timer] = node1&#123;x, y, last[x]&#125;; s.insert(y); last[x] = y; &#125; &#125; // ç¦»æ•£åŒ– for(auto i: s) ma[i] = dis++; for(int i = 1; i &lt;= n; i++) a[i] = ma[a[i]]; for(int i = 1; i &lt;= timer; i++) chg[i].val = ma[chg[i].val], chg[i].last = ma[chg[i].last]; // è«é˜Ÿ l = 1, r = 0, timer = 0; up = sqrt(2 * n); sort(q, q + tot); for(int i = 0; i &lt; tot; i++) &#123; node t = q[i]; while(timer &lt; t.timer) &#123; timer++; modify(chg[timer].x, chg[timer].val); &#125; while(timer &gt; t.timer) &#123; modify(chg[timer].x, chg[timer].last); timer--; &#125; while(r &lt; t.r) add(++r); while(l &gt; t.l) add(--l); while(r &gt; t.r) sub(r--); while(l &lt; t.l) sub(l++); for(int j = 1; j &lt;= up; j++) if(se[j] == 0) &#123; an[t.id] = j; break; &#125; &#125; for(int i = 0; i &lt; tot; i++) &#123; printf("%d\n", an[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>è«é˜Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LindstrÃ¶m-Gessel-Vienot-Lemmaå­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2018%2F07%2F21%2F0%2F</url>
    <content type="text"><![CDATA[ä»‹ç»LindstrÃ¶m-Gessel-Vienot Lemmaå¯ä»¥ç”¨æ¥è§£å†³ä¸€ç±»è·¯å¾„è®¡æ•°é—®é¢˜ã€‚è¦æƒ³å°†è¿™ä¸ªå¼•ç†ç”¨äºè§£å†³è®¡æ•°é—®é¢˜ï¼Œé¦–å…ˆéœ€è¦ä»¤å›¾çš„æ‰€æœ‰è¾¹çš„æƒå€¼ç­‰äº1ã€‚æ¥ç€éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œä»èµ·ç‚¹ $$ A={a_{1},\ldots ,a_{n}} $$ åˆ°ç»ˆç‚¹ $$ B={b_{1},\ldots ,b_{n}} $$ çš„æ‰€æœ‰ä¸ç›¸äº¤è·¯å¾„ï¼Œå¹¶ä¸æ˜¯æŒ‡$$ {a_{i} } $$ä¸€å®šåˆ°$$ {b_{i} } $$ï¼Œå®ƒåŒ…æ‹¬å¾—æ›´å¹¿ï¼Œèµ·ç‚¹Aä¸­çš„æŸç‚¹åˆ°è¾¾ç»ˆç‚¹Bä¸­çš„ä»»æ„ä¸€ç‚¹å³å¯ï¼Œä½†ç”±äºä¸¥æ ¼ä¸ç›¸äº¤ï¼Œæ‰€ä»¥å®ƒä»¬æ˜¯ä¸€ä¸ªâ€œåŒå°„â€ã€‚å…¬å¼çš„å³è¾¹ï¼Œè®¡ç®—çš„æ˜¯æ‰€æœ‰è·¯å¾„çš„æœ‰ç¬¦å·æƒå€¼å’Œï¼Œè¿™é‡Œçš„ç¬¦å·ç”±æ’åˆ—çš„é€†åºå¯¹ä¸ªæ•°å†³å®šï¼Œå‡å¦‚é€†åºå¯¹çš„ä¸ªæ•°æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆç¬¦å·ä¸ºè´Ÿï¼Œå¦åˆ™ä¸ºæ­£ã€‚å‡å¦‚æˆ‘ä»¬è¦æ±‚ä»èµ·ç‚¹ $$ A={a_{1},\ldots ,a_{n}} $$ åˆ°ç»ˆç‚¹ $$ B={b_{1},\ldots ,b_{n}} $$ ï¼Œä¸”$$ {a_{i} } $$ä¸€å®šåˆ°$$ {b_{i} } $$çš„æ‰€æœ‰ä¸ç›¸äº¤è·¯å¾„ï¼Œé‚£ä¹ˆç­‰å¼çš„å³è¾¹å°±æ°å¥½ç­‰äºè¿™ä¸ªæ–¹æ¡ˆæ•°ã€‚ é¢˜ç›®é¢˜æ„è¯¦æƒ…è¯·çœ‹Monotonic Matrixã€‚ åˆ†æ å®˜æ–¹é¢˜è§£ï¼šè€ƒè™‘ 01 å’Œ 12 çš„åˆ†ç•Œçº¿æ˜¯ (n, 0) åˆ° (0, m) çš„ä¸¤æ¡ä¸ç›¸äº¤(å¯é‡åˆ)è·¯å¾„å¹³ç§»å…¶ä¸­ä¸€æ¡å˜æˆ (n-1, -1) åˆ° (-1, m-1)å˜æˆèµ·ç‚¹ (n, 0) å’Œ (n-1, -1),ç»ˆç‚¹ (0, m) å’Œ (-1, m-1) çš„ä¸¥æ ¼ä¸ç›¸äº¤è·¯å¾„å¥— LindstrÃ¶mâ€“Gesselâ€“Viennot lemmaç­”æ¡ˆæ˜¯ $$ {C_{n+m}^n}^2 - C_{n+m}^{m - 1} C_{n+m}^{n-1} $$ æˆ‘ä»¬è®¾å·¦ä¸‹è§’çš„ä¸¤ç‚¹ä¸ºèµ·ç‚¹a1, a2ï¼Œå³ä¸Šè§’çš„ä¸¤ç‚¹ä¸ºç»ˆç‚¹b1, b2ï¼Œæˆ‘ä»¬éœ€è¦æ±‚çš„æ˜¯ä»a1åˆ°b1ã€a2åˆ°b2çš„è·¯å¾„æ–¹æ¡ˆæ•°ï¼Œç”±äºé¢˜ç›®çš„é™åˆ¶ï¼Œa1åˆ°b2ã€a2åˆ°b1çš„è·¯å¾„æ˜¯ä¸åˆæ³•çš„ï¼Œæ‰€ä»¥ï¼Œå…¬å¼çš„å³è¾¹æ°å¥½å°±ä¸åŒ…å«a1åˆ°b2ã€a2åˆ°b1çš„è·¯å¾„æ–¹æ¡ˆæ•°äº†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è®¡ç®—çŸ©é˜µè¡Œåˆ—å¼æ¥è®¡ç®—ç­”æ¡ˆäº†ã€‚ æ¨å¹¿ç•™å‘å¾…å¡«ã€‚ å‚è€ƒèµ„æ–™ LindstrÃ¶mâ€“Gesselâ€“Viennot lemma - Wikipedia Determinants and the LindstrÃ¶m-Gessel-Vienot Lemma]]></content>
      <tags>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è«é˜Ÿç®—æ³•å­¦ä¹ ç¬”è®°ï¼ˆä¸€ï¼‰]]></title>
    <url>%2F2018%2F07%2F19%2F0%2F</url>
    <content type="text"><![CDATA[ä»‹ç»è«é˜Ÿç®—æ³•ä¸»è¦ç”¨äºå¯ä»¥ç¦»çº¿å¤„ç†çš„ã€ä¸å¸¦ä¿®æ”¹çš„ã€åªæœ‰æŸ¥è¯¢çš„ä¸€ç±»åŒºé—´é—®é¢˜ã€‚å‡çº§ç‰ˆçš„è«é˜Ÿç®—æ³•å¯ä»¥è§£å†³å¸¦ä¿®æ”¹çš„åŒºé—´é—®é¢˜ã€‚æˆ‘çœ‹è¿‡çš„æ¯”è¾ƒå¥½çš„æ•™ç¨‹ï¼šè«é˜Ÿç®—æ³• (Moâ€™s Algorithm)ã€‚ é¢˜ç›®1: HYSBZ - 2038é¢˜æ„ç»™ä¸€ä¸ªå…·æœ‰nä¸ªå…ƒç´ çš„æ•°åˆ—ï¼Œç„¶åæœ‰mä¸ªè¯¢é—®ï¼ŒæŸ¥è¯¢çš„æ˜¯æŸä¸ªåŒºé—´ä»»å–ä¸¤ä¸ªæ•°ï¼Œè¿™ä¸¤ä¸ªæ•°ç›¸åŒçš„æ¦‚ç‡ã€‚ åˆ†æè«é˜Ÿç®—æ³•çš„æ ¸å¿ƒæ˜¯è¦æ‰¾åˆ°[L, R]è½¬ç§»åˆ°[L-1, R], [L+1, R], [L, R-1], [L, R+1]æ—¶ç­”æ¡ˆæ˜¯æ€ä¹ˆæ”¹å˜çš„ã€‚å…·ä½“åˆ°è¿™é“é¢˜ï¼Œä»¥[L, R]è½¬ç§»åˆ°[L, R+1]çš„æƒ…å†µä¸ºä¾‹ï¼Œç”±äºå¢åŠ äº†ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å‡‘æˆä¸¤ä¸ªç›¸åŒçš„æ•°çš„æ–¹æ¡ˆæ•°ä»¥åŠæ€»çš„ç»„åˆæ•°éƒ½ä¼šæ”¹å˜ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ç»´æŠ¤çš„æ˜¯å„æ•°å­—å‡ºç°çš„æ¬¡æ•°ä»¥åŠåŒºé—´å¤§å°ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, m, a[N], b[N], l, r, len;ll up[N], down[N];struct node &#123; int l, r, id, block; node() &#123;&#125; node(int l, int r, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;id = id; block = l / len; &#125; bool operator &lt; (const node b) const &#123; if(block == b.block) return r &lt; b.r; return block &lt; b.block; &#125;&#125;q[N];void cal(ll &amp;ans, int pos, int fix) &#123; ans -= 1LL * b[a[pos]] * (b[a[pos]] - 1) / 2; b[a[pos]] += fix; ans += 1LL * b[a[pos]] * (b[a[pos]] - 1) / 2;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; m) &#123; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;l, &amp;r); q[i] = node&#123;l, r, i&#125;; &#125; sort(q, q + m); ll ans = 0; l = r = 1; b[a[l]]++; for(int i = 0; i &lt; m; i++) &#123; node &amp;t = q[i]; while(r &lt; t.r) cal(ans, ++r, 1); while(l &gt; t.l) cal(ans, --l, 1); while(r &gt; t.r) cal(ans, r--, -1); while(l &lt; t.l) cal(ans, l++, -1); ll t0 = ans; ll t1 = 1LL * (t.r - t.l + 1) * (t.r - t.l) / 2; ll g = __gcd(t0, t1); t0 /= g; t1 /= g; up[t.id] = t0; down[t.id] = t1; &#125; for(int i = 0; i &lt; m; i++) printf("%lld/%lld\n", up[i], down[i]); &#125; return 0;&#125; é¢˜ç›®2: SPOJ - DQUERYé¢˜æ„ç»™ä¸€ä¸ªå…·æœ‰nä¸ªå…ƒç´ çš„æ•°åˆ—ï¼Œç„¶åæœ‰qä¸ªè¯¢é—®ï¼ŒæŸ¥è¯¢çš„æ˜¯æŸä¸ªåŒºé—´ä¸åŒæ•°å­—çš„ä¸ªæ•°ã€‚ åˆ†ææˆ‘ä»¬åªéœ€è¦ç»´æŠ¤å„æ•°å­—å‡ºç°çš„æ¬¡æ•°å³å¯ï¼Œå‡å¦‚åœ¨åŒºé—´æ”¹å˜çš„è¿‡ç¨‹ï¼ŒæŸä¸€ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ç”±1å˜æˆ0ï¼Œé‚£ä¹ˆç­”æ¡ˆåº”è¯¥å‡1ï¼Œè€Œå‡å¦‚ç”±0å˜æˆ1ï¼Œé‚£ä¹ˆç­”æ¡ˆåº”è¯¥åŠ 1ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const int shift=1e3+9;const double Eps=1e-7;int n, m, len, a[N], b[N], l, r, sum, ans[N];struct node &#123; int l, r, id, block; node() &#123;&#125; node(int l, int r, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;id = id; block = l / len; &#125; bool operator &lt; (const node b) const &#123; if(block == b.block) return r &lt; b.r; return block &lt; b.block; &#125;&#125;q[N];inline void cal(int &amp;sum, int pos, int fix) &#123; int &amp;t = b[a[pos]]; t += fix; if(fix == 1 &amp;&amp; t == 1) sum++; else if(fix == -1 &amp;&amp; t == 0) sum--;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; n; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", a + i); cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;l, &amp;r); q[i] = node&#123;l, r, i&#125;; &#125; sort(q, q + m); l = r = sum = 1; b[a[1]]++; for(int i = 0; i &lt; m; i++) &#123; node &amp;t = q[i]; while(r &lt; t.r) cal(sum, ++r, 1); while(l &gt; t.l) cal(sum, --l, 1); while(r &gt; t.r) cal(sum, r--, -1); while(l &lt; t.l) cal(sum, l++, -1); ans[t.id] = sum; &#125; for(int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); return 0;&#125; é¢˜ç›®3: Powerful arrayé¢˜æ„ç»™ä¸€ä¸ªå…·æœ‰nä¸ªå…ƒç´ çš„æ•°åˆ—ï¼Œç„¶åæœ‰tä¸ªè¯¢é—®ï¼ŒæŸ¥è¯¢çš„æ˜¯æŸä¸€åŒºé—´KsÂ·KsÂ·sçš„å’Œï¼Œå…¶ä¸­sè¡¨ç¤ºçš„æ˜¯æŸä¸€ä¸ªæ•°å­—ï¼ŒKsè¡¨ç¤ºçš„æ˜¯è¯¥æ•°å­—å‡ºç°çš„æ¬¡æ•°ã€‚ åˆ†ææˆ‘ä»¬åªéœ€è¦ç»´æŠ¤å„æ•°å­—å‡ºç°çš„æ¬¡æ•°å³å¯ã€‚ç»´æŠ¤å‰ï¼Œå…ˆå‡å»è¯¥æ•°å­—çš„è´¡çŒ®å€¼ï¼Œç»´æŠ¤åï¼Œå†åŠ ä¸Šè¯¥æ•°å­—çš„è´¡çŒ®å€¼ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const double Eps=1e-7;int n, m, a[N], l, r, len, cnt[N];ll ans, an[N];struct node &#123; int l, r, id, block; node() &#123;&#125; node(int l, int r, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;id = id; this-&gt;block = l / len; &#125; bool operator &lt; (const node t) const &#123; if(t.block == block) return r &lt; t.r; return block &lt; t.block; &#125;&#125;q[N];void cal(ll &amp;ans, int pos, int fix) &#123; int &amp;t = cnt[a[pos]]; ans -= 1LL * t * t * a[pos]; t += fix; ans += 1LL * t * t * a[pos];&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", a + i); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;l, &amp;r); q[i] = node&#123;l, r, i&#125;; &#125; sort(q, q + m); l = 1, r = 1; cnt[a[1]]++; ans = a[1]; for(int i = 0; i &lt; m; i++) &#123; node t = q[i]; while(r &lt; t.r) cal(ans, ++r, 1); while(l &gt; t.l) cal(ans, --l, 1); while(r &gt; t.r) cal(ans, r--, -1); while(l &lt; t.l) cal(ans, l++, -1); an[t.id] = ans; &#125; for(int i = 0; i &lt; m; i++) printf("%I64d\n", an[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>è«é˜Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æˆªæ­¢äº180718çš„AOBOè¡¥é¢˜æ±‡æ€»]]></title>
    <url>%2F2018%2F07%2F18%2F0%2F</url>
    <content type="text"><![CDATA[å¾…è¡¥é¢˜ç›®æŒ‰ACæ•°é™åºæ’åˆ—ã€‚ 180429ï¼ˆæµ™æ±Ÿçœèµ›ï¼‰è¡¥é¢˜ä¼ é€é—¨å¾…è¡¥ï¼šDé¢˜ï¼šSequence SwappingEé¢˜ï¼šLISIé¢˜ï¼šMagic Points 180426ï¼ˆ2017æ­å·äºšæ´²åŒºåŸŸèµ›ï¼‰è¡¥é¢˜ä¼ é€é—¨å¾…è¡¥ï¼š Ké¢˜ï¼šMaster of Sequence Bé¢˜ï¼šMaster of Phi 180422ï¼ˆ2018 ACM-ICPC ä¸­å›½å¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ›çº¿ä¸Šèµ›ï¼‰è¡¥é¢˜ä¼ é€é—¨å¾…è¡¥ï¼š Gé¢˜ï¼šTrouble of Tyrant Fé¢˜ï¼šClever King Hé¢˜ï¼šRock Paper Scissors Lizard Spock 180419ï¼ˆ2017ä¸­å›½å¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ› - å¥³ç”Ÿä¸“åœºï¼‰è¡¥é¢˜ä¼ é€é—¨å¾…è¡¥ï¼š Jé¢˜ï¼šJudicious Strategy Ié¢˜ï¼šInnumerable Ancestors 180412ï¼ˆOIé¢˜ç›®ï¼‰è¡¥é¢˜ä¼ é€é—¨å¾…è¡¥ï¼š Hé¢˜ï¼šä»¥æ’’ Ié¢˜ï¼šæ°¸æ’ Aé¢˜ï¼šåŠ¨ç‰©æœ‹å‹ Dé¢˜ï¼šæ°¸æ’çš„å²è¯— Eé¢˜ï¼šä¸­äºŒç—…ä¹Ÿè¦æµªæ¼«!]]></content>
  </entry>
  <entry>
    <title><![CDATA[CF 980E: The Number Games]]></title>
    <url>%2F2018%2F05%2F09%2F1%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€æ£µæ ‘ï¼ŒèŠ‚ç‚¹æ ‡è®°ä¸º$1$~$n$ï¼ŒèŠ‚ç‚¹$i$çš„ç‚¹æƒä¸ºä¸º$2^i$ï¼Œç°åœ¨éœ€è¦åˆ å»kä¸ªç‚¹ï¼Œä½¿å¾—å‰©ä½™çš„ç‚¹ç›¸äº’è”é€šï¼Œä¸”ç‚¹æƒçš„å’Œæœ€å¤§ã€‚ åˆ†æçœ‹å®Œè¿™é“é¢˜ï¼Œé¦–å…ˆæƒ³åˆ°çš„æ˜¯è´ªå¿ƒï¼Œå³å°½é‡åˆ å»ç‚¹æƒå°çš„èŠ‚ç‚¹ï¼Œä½†æ˜¯ç»è¿‡ä»”ç»†æ€è€ƒï¼Œå®¹æ˜“æ‰¾åˆ°ä¸€äº›åä¾‹ï¼Œå› æ­¤è¿™ä¸ªæ€è·¯æ˜¯è¡Œä¸é€šçš„ã€‚è¿™é“é¢˜çš„æ€ç»´éš¾ç‚¹åœ¨äºå°†åˆ å»èŠ‚ç‚¹è½¬åŒ–ä¸ºé€‰å–èŠ‚ç‚¹ã€‚ç”±æ•°å­¦çŸ¥è¯†å¾—ï¼Œ$2^{i} = 2^{i-1} + 2^{i-2} + â€¦ + 2^{0} + 1 $ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åº”è¯¥å°½é‡é€‰å–æ ‡å·å¤§çš„èŠ‚ç‚¹ã€‚é¦–å…ˆï¼Œæ ‡å·ä¸º$n$ çš„èŠ‚ç‚¹æ˜¯ä¸€å®šå¯ä»¥é€‰å–çš„ï¼ŒæŠŠå®ƒæ”¾åˆ°è”é€šå—é‡Œé¢ï¼Œç„¶åæˆ‘ä»¬ä»å¤§åˆ°å°ï¼Œä¸æ–­å¾€è¿™ä¸ªè”é€šå—æ·»åŠ èŠ‚ç‚¹ã€‚åˆ¤æ–­æŸç‚¹èƒ½å¦æ”¾è¿›è”é€šå—é‡Œé¢ï¼Œéœ€è¦çœ‹è¿™ç‚¹ä¸è”é€šå—çš„æœ€çŸ­è·ç¦»æ˜¯å¦å°äºå‰©ä½™å¯æ”¾çš„èŠ‚ç‚¹æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨STè¡¨ï¼Œåœ¨$O(logn)$çš„æ—¶é—´å†…æ¥å®Œæˆã€‚æ€»çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯$O(nlogn)$ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const int shift=1e3+9;const double Eps=1e-7;int u, v, n, k, fa[N][29], vis[N], mm[N];vi G[N], v1;set&lt;int&gt; se;void dfs(int u) &#123; vis[u] = 1; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if(vis[v]) continue; fa[v][0] = u; dfs(v); &#125;&#125;void buildST() &#123; mm[0] = 0; for(int i = 1; i &lt;= n; i++) mm[i] = ((i &amp; (i-1)) == 0 ? mm[i-1] + 1 : mm[i-1]); for(int j = 1; j &lt;= mm[n]; j++) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(fa[i][j-1] == -1) fa[i][j] = -1; else fa[i][j] = fa[fa[i][j-1]][j-1]; &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(fa, -1, sizeof fa); dfs(n); buildST(); k = n - k; memset(vis, 0, sizeof vis); vis[n] = true; v1.push_back(n); k--; u = n - 1; while(k &gt; 0 &amp;&amp; u &gt; 0) &#123; if(vis[u]) &#123; u--; continue; &#125; int t = u, dis = 0; for(int i = 20; i &gt;= 0; i--) &#123; if(fa[u][i] == -1 || vis[fa[u][i]] == true) continue; else &#123; dis += 1 &lt;&lt; i; u = fa[u][i]; &#125; &#125; u = t; dis++; if(dis &lt;= k) &#123; vis[u] = true; v1.push_back(u); k--; while(vis[fa[u][0]] != true) &#123; k--; u = fa[u][0]; vis[u] = true; v1.push_back(u); &#125; &#125; u = t - 1; &#125; for(int i = 1; i &lt;= n; i++) se.insert(i); for(auto i: v1) se.erase(i); for(auto i: se) printf("%d ", i); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>æ€ç»´</tag>
        <tag>æ ‘</tag>
        <tag>è´ªå¿ƒ</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 980D: Perfect Groups]]></title>
    <url>%2F2018%2F05%2F09%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ªæ•°ç»„ï¼Œè®©ä½ ç»™è¿™ä¸ªæ•°ç»„åˆ†ç»„ï¼Œä½¿å¾—ç»„å†…çš„å…ƒç´ ä¸¤ä¸¤ç›¸ä¹˜éƒ½æ˜¯å¹³æ–¹æ•°ï¼Œè®°æœ€å°‘åˆ†ç»„æ•°ä¸ºdã€‚ ç°åœ¨ç»™ä½ ä¸€ä¸ªæ•°ç»„aï¼Œæ±‚å‡ºå®ƒæ‰€æœ‰è¿ç»­å­åºåˆ—çš„dï¼Œç„¶åè¾“å‡ºæ¯ä¸ªd(1&lt;= d &lt;= n)çš„è®¡æ•°ã€‚ åˆ†æç”¨å”¯ä¸€åˆ†è§£å®šç†åˆ†è§£å¹³æ–¹æ•°ï¼Œå¯ä»¥å‘ç°å®ƒçš„æŸä¸€ç´ å› å­çš„ä¸ªæ•°ä¸ºå¶æ•°ä¸ªã€‚è‹¥ä¸¤ä¸ªæ•°ç›¸ä¹˜æ˜¯å¹³æ–¹æ•°ï¼Œåˆ™ä¸¤è€…çš„æ‰€æœ‰ç´ å› å­ä¸­ï¼Œè¦ä¹ˆä¸¤ä¸ªæ•°éƒ½å…·æœ‰å¶æ•°ä¸ªï¼Œè¦ä¹ˆéƒ½å…·æœ‰å¥‡æ•°ä¸ªã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸€ä¸ªæ•°è¡¨ç¤ºæˆå®ƒé‚£äº›å¥‡æ•°ä¸ªæ•°çš„ç´ å› å­çš„ä¹˜ç§¯ã€‚ç„¶åï¼Œè‹¥ä¸¤ä¸ªæ•°ç›¸åŒï¼Œåˆ™å¯ä»¥ç»„æˆå¹³æ–¹æ•°ï¼Œå¦åˆ™ä¸å¯ä»¥ã€‚äºæ˜¯ï¼Œé—®é¢˜å°±è½¬åŒ–æˆäº†æ±‚è¿ç»­å­åºåˆ—ä¸­å‡ºç°ä¸åŒæ•°å­—çš„ä¸ªæ•°ï¼Œå®¹æ˜“æƒ³åˆ°ç”¨setæ¥ç»´æŠ¤ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬éœ€è¦ç”¨$ O(n^{2}) $çš„æ—¶é—´æ¥æšä¸¾è¿ç»­å­åºåˆ—çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œå†ç”¨ä¸Šä¸ªsetä¼šè¶…æ—¶ã€‚æ‰€ä»¥ï¼Œç»“åˆæ•°ç»„açš„å…ƒç´ å¾ˆå¤§ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶ç¦»æ•£åŒ–ï¼Œç„¶åç”¨ä¸€ä¸ªæ¡¶æ¥ç»´æŠ¤ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;vi pri;int n, a[N], ans[N];void pre() &#123; int up = 10000; bool vis[N]; memset(vis, 0, sizeof vis); for(int i = 2; i &lt;= up; i++) if(!vis[i]) for(int j = 2 * i; j &lt;= up; j += i) vis[j] = 1; for(int i = 2; i &lt;= up; i++) if(!vis[i]) pri.push_back(i);&#125;int fac(int d) &#123; if(d == 0) return d; int ans = 1; if(d &lt; 0) ans *= -1, d *= -1; int p = 0; while(d != 1 &amp;&amp; p &lt; pri.size()) &#123; int cnt = 0; while(d % pri[p] == 0) cnt++, d /= pri[p]; if(cnt &amp; 1) ans *= pri[p]; p++; &#125; if(d != 1) ans *= d; return ans;&#125;void lisanhua() &#123; set&lt;int&gt; se; map&lt;int, int&gt; m; for(int i = 0; i &lt; n; i++) se.insert(a[i]); int cnt = 1; for(auto i: se) &#123; if(i == 0) m[i] = 0; else m[i] = cnt++; &#125; for(int i = 0; i &lt; n; i++) a[i] = m[a[i]];&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; pre(); while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", a + i); a[i] = fac(a[i]); &#125; memset(ans, 0, sizeof ans); lisanhua(); for(int i = 0; i &lt; n; i++) &#123; int cnt = 0, zeroFlag = 0, b[N]; memset(b, 0, sizeof b); for(int j = i; j &lt; n; j++) &#123; if(a[j] == 0) zeroFlag = 1; if(b[a[j]]++ == 0) cnt++; if(zeroFlag &amp;&amp; cnt != 1) ans[cnt-1]++; else ans[cnt]++; &#125; &#125; for(int i = 1; i &lt;= n; i++) printf("%d%c", ans[i], i == n ? '\n': ' '); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ•°å­¦</tag>
        <tag>ç¦»æ•£åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 976E: Well played!]]></title>
    <url>%2F2018%2F05%2F05%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ä½ æ‹¥æœ‰nä¸ªæ€ªå…½ï¼Œæ¯ä¸ªæ€ªå…½å…·æœ‰hpå’Œdamè¿™ä¸¤ç§å±æ€§ã€‚ä½ å¯ä»¥è¿›è¡Œä¸¤ç§æ“ä½œï¼šç¬¬ä¸€ç§æ˜¯å°†æ€ªå…½çš„hpå€¼ç¿»å€ï¼›ç¬¬äºŒç§æ˜¯ä»¤æ€ªå…½çš„dam = hpã€‚ç¬¬ä¸€ç§æ“ä½œä½ æœ€å¤šå¯ä»¥è¿›è¡Œaæ¬¡ï¼Œç¬¬äºŒç§æ“ä½œä½ æœ€å¤šå¯ä»¥è¿›è¡Œbæ¬¡ï¼Œé—®æ‰€æœ‰æ€ªå…½çš„damå’Œæœ€å¤§æ˜¯å¤šå°‘ï¼Ÿ åˆ†æçœ‹åˆ°é¢˜ç›®ï¼Œå®¹æ˜“æƒ³åˆ°åŠ¨æ€è§„åˆ’ï¼Œä½†æ˜¯æƒ³äº†æŒºä¹…ï¼Œæ²¡æ€è·¯ã€‚çœ‹äº†å®˜æ–¹é¢˜è§£ï¼Œå‘ç°äº†ä¸€ä¸ªé‡è¦çš„æ€§è´¨ï¼šç¬¬ä¸€ç§æ“ä½œåº”è¯¥åªåˆ†é…ç»™æŸä¸€åªæ€ªå…½ï¼Œè¿™ä¸ªå¯ä»¥é€šè¿‡åè¯æ³•æ¥è¯æ˜ï¼ŒæŒºç®€å•çš„ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚aä¸ªç¬¬ä¸€ç§æ“ä½œå’Œ1ä¸ªç¬¬äºŒç§æ“ä½œåˆ†é…å®Œäº†ï¼Œé‚£ä¹ˆå‰©ä½™çš„b-1ä¸ªç¬¬äºŒç§æ“ä½œåº”è¯¥æ€ä¹ˆåˆ†é…ï¼Ÿè´ªå¿ƒï¼Œå³ä¼˜å…ˆåˆ†é…ç»™hp - damå€¼è¾ƒå¤§çš„æ€ªå…½ï¼ˆåœ¨è¿™ä¹‹å‰éœ€è¦æ’åºä¸€æ¬¡ï¼‰ã€‚æœ€ç»ˆæ­¤é¢˜çš„å¤æ‚åº¦æ˜¯O(nlogn)ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;ll n, aa, b, t, ans, sum;struct node &#123; ll hea, dam;&#125;a[N];bool cmp(node a, node b) &#123; return (a.hea - a.dam) &gt; (b.hea - b.dam);&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; aa &gt;&gt; b) &#123; t = 1; while(aa--) t *= 2; for(int i = 0; i &lt; n; i++) scanf("%lld%lld", &amp;a[i].hea, &amp;a[i].dam); sort(a, a + n, cmp); for(int i = 0; i &lt; n; i++) &#123; if(i &lt; b) sum += max(a[i].hea, a[i].dam); else sum += a[i].dam; &#125; if(b == 0) &#123; printf("%lld\n", sum); continue; &#125; for(int i = 0; i &lt; n; i++) &#123; if(i &lt; b) ans = max(ans, sum - max(a[i].hea, a[i].dam) + max(a[i].hea * t, a[i].dam)); else ans = max(ans, sum - max(a[b-1].hea, a[b-1].dam) + a[b-1].dam - a[i].dam + max(a[i].hea * t, a[i].dam)); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ€ç»´</tag>
        <tag>è´ªå¿ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 975E: Hag's Khashba]]></title>
    <url>%2F2018%2F05%2F04%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„æœ‰ä¸€ä¸ªå‡¸å¤šè¾¹å½¢ï¼Œåœ¨ä¸¤ä¸ªé’‰å­ï¼ˆä½ç½®åœ¨å‡¸å¤šè¾¹å½¢çš„ä¸¤ä¸ªé¡¶ç‚¹ä¸Šï¼‰çš„ä½œç”¨ä¸‹ï¼Œå›ºå®šåœ¨äº†å¢™ä¸Šã€‚ç°åœ¨æœ‰ä¸¤ç§æ“ä½œï¼Œç¬¬ä¸€ç§æ“ä½œæ˜¯å°†å…¶ä¸­ä¸€ä¸ªé’‰å­ç§»èµ°ï¼Œç­‰å¾…å‡¸å¤šè¾¹å½¢ç¨³å®šåï¼Œå†å°†é’‰å­é’‰åœ¨æŸä¸ªä½ç½®ä¸Šã€‚ç¬¬äºŒç§æ“ä½œæ˜¯è¯¢é—®æŸä¸ªç‚¹çš„åæ ‡ã€‚ åˆ†æè¿™é“é¢˜æ˜¯å…¸å‹çš„è®¡ç®—å‡ ä½•é¢˜ï¼Œæ¶‰åŠåˆ°çš„çŸ¥è¯†å¤§æ¦‚æœ‰ï¼š å¤šè¾¹å½¢é‡å¿ƒçš„è®¡ç®—ã€‚ å¤šè¾¹å½¢çš„æ—‹è½¬ã€‚ å¤šè¾¹å½¢é‡å¿ƒçš„å…¬å¼å¯ä»¥åœ¨ç½‘ä¸Šæœåˆ°ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ï¼ˆå…¶å®æ˜¯å› ä¸ºè´´ä¸äº†æ•°å­¦å…¬å¼ï¼‰ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œå‡å¦‚å¤šè¾¹å½¢æ²¡æœ‰äº§ç”Ÿå½¢å˜ï¼Œé‚£ä¹ˆå®ƒçš„é‡å¿ƒä¸æ‰€æœ‰é¡¶ç‚¹çš„è·ç¦»æ˜¯ä¸å˜çš„ã€‚å› æ­¤ï¼Œå‡å¦‚æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªå¤šè¾¹å½¢çš„é‡å¿ƒåæ ‡ä»¥åŠé‡å¿ƒä¸æ‰€æœ‰é¡¶ç‚¹çš„è·ç¦»ï¼Œå†åŠ ä¸Šé‡å¿ƒä¸æ‰€æœ‰é¡¶ç‚¹çš„è§’åº¦å·®ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç¡®å®šæ‰€æœ‰é¡¶ç‚¹çš„åæ ‡äº†ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé‡å¿ƒä¸å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„è§’åº¦å·®åœ¨é‡å¿ƒå˜æ›´æ—¶ä¼šäº§ç”Ÿå˜åŒ–ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œè§’åº¦å˜æ¢ã€‚æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n + q)ã€‚ ä¸‹é¢çš„ä»£ç é‡Œæœ‰äº›å½¢å¦‚coslè¿™æ ·å½¢å¼çš„ä¸‰è§’å‡½æ•°ï¼Œä¸cosè¿™ç§æ™®é€šä¸‰è§’å‡½æ•°çš„ä¸åŒæ˜¯ï¼šcoslçš„å‚æ•°è¦æ±‚ä¸ºlong doubleï¼Œè¿”å›å€¼ä¹Ÿä¸ºlong doubleï¼Œä»è€Œä¿è¯äº†ç²¾åº¦ã€‚è¿™é“é¢˜ä¸ç”¨coslä¹Ÿèƒ½è¿‡ï¼Œä½†ç”¨äº†æ›´ä¿é™©ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;typedef pair&lt;long double, long double&gt; point;point a[N], c;long double ang[N], angle, dist[N], bx, by;int n, q, t1, t2;point getC() &#123; long double area = 0, cx = 0, cy = 0; for(int i = 0; i &lt; n; i++) &#123; long double temp = a[i].x * a[(i+1)%n].y - a[i].y * a[(i+1)%n].x; area += temp; cx += (a[i].x + a[(i+1)%n].x) * temp; cy += (a[i].y + a[(i+1)%n].y) * temp; &#125; area /= 2; cx /= 6 * area; cy /= 6 * area; return point(cx, cy);&#125;point getPoint(int idx) &#123; return point(c.x + dist[idx] * cosl(angle + ang[idx]), c.y + dist[idx] * sinl(angle + ang[idx]));&#125;long double getDist(point a, point b) &#123; return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d%d", &amp;n, &amp;q); for(int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;t1, &amp;t2); a[i].x = t1; a[i].y = t2; &#125; bx = a[0].x, by = a[0].y; for(int i = 0; i &lt; n; i++) &#123; a[i].x -= bx; a[i].y -= by; &#125; c = getC(); for(int i = 0; i &lt; n; i++) &#123; dist[i] = getDist(a[i], c); ang[i] = atan2l(a[i].y - c.y, a[i].x - c.x); if(ang[i] &lt; 0) ang[i] += 2 * PI; &#125; angle = 0; int i = 0, j = 1, op, x, y; point top, nxt; while(q--) &#123; scanf("%d", &amp;op); if(op == 1) &#123; scanf("%d%d", &amp;x, &amp;y); x--, y--; if(x == i) &#123; i = y; top = getPoint(j); nxt = point(top.x, top.y - dist[j]); &#125; else &#123; j = y; top = getPoint(i); nxt = point(top.x, top.y - dist[i]); &#125; angle += -PI/2 - atan2l(c.y - top.y, c.x - top.x); while(angle &lt; 0) angle += 2 * PI; while(angle &gt;= 2 * PI) angle -= 2 * PI; c = nxt; &#125; else &#123; scanf("%d", &amp;x); point ans = getPoint(x-1); printf("%.10f %.10f\n", (double)(ans.x + bx), (double)(ans.y + by)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180429åä¸­ç§‘æŠ€å¤§å­¦ç¨‹åºè®¾è®¡ç«èµ›é¢˜è§£]]></title>
    <url>%2F2018%2F05%2F02%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜è§£æŒ‰ACæ•°é™åºæ’åˆ—ã€‚ Jé¢˜ï¼šVarious Treeç®€å•bfsã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+39;const int shift=1e3+9;const double Eps=1e-7;int cnt[N];void bfs(int u, int v) &#123; bool vis[N]; int dis[N]; queue&lt;int&gt; que; memset(vis, 0, sizeof vis); memset(dis, INF, sizeof dis); dis[u] = 0; vis[u] = 1; que.push(u); while(que.size()) &#123; int uu = que.front(); que.pop(); if(uu == v) &#123; printf("%d\n", dis[v]); break; &#125; if(uu + 1 &lt; N &amp;&amp; !vis[uu + 1]) &#123; dis[uu + 1] = dis[uu] + 1; vis[uu + 1] = 1; que.push(uu + 1); &#125; if(uu - 1 &gt;= 0 &amp;&amp; !vis[uu - 1]) &#123; dis[uu - 1] = dis[uu] + 1; vis[uu - 1] = 1; que.push(uu - 1); &#125; if(uu + cnt[uu] &lt; N &amp;&amp; !vis[uu + cnt[uu]]) &#123; dis[uu + cnt[uu]] = dis[uu] + 1; vis[uu + cnt[uu]] = 1; que.push(uu + cnt[uu]); &#125; if(uu - cnt[uu] &gt;= 0 &amp;&amp; !vis[uu - cnt[uu]]) &#123; dis[uu - cnt[uu]] = dis[uu] + 1; vis[uu - cnt[uu]] = 1; que.push(uu - cnt[uu]); &#125; &#125;&#125;void pre() &#123; memset(cnt, 0, sizeof cnt); for(int i = 1; i &lt; N; i++) &#123; int t = i; while(t) &#123; if(t &amp; 1) cnt[i]++; t &gt;&gt;= 1; &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; pre(); int a, b; while(cin &gt;&gt; a &gt;&gt; b) bfs(a, b); return 0;&#125; Ké¢˜ï¼šWalking in the Forestç®€å•äºŒåˆ†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int k, n, a[N];bool check(ll mid) &#123; ll sum = LINF, cnt = 0; for(int i = 0; i &lt; k; i++) &#123; if(a[i] &gt; mid) return false; if(sum + a[i] &gt; mid) sum = a[i], cnt++; else sum += a[i]; &#125; return cnt &lt;= n;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;k, &amp;n)) &#123; k--; for(int i = 0; i &lt; k; i++) scanf("%d", a + i); ll l = 0, r = 10000000000; while(l &lt; r) &#123; ll mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; printf("%lld\n", r); &#125; return 0;&#125; Bé¢˜ï¼šBeautiful Trees Cuttingç®€å•æ•°å­¦é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;const int mod = 1e9 + 7;char s[N];ll ans, m, n;vi v;ll ksm(ll a, ll b) &#123; ll ans = 1; while(b) &#123; if(b &amp; 1) (ans *= a) %= mod; (a *= a) %= mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; m &gt;&gt; s) &#123; v.clear(); n = strlen(s); for(int i = 0; i &lt; n; i++) if((s[i] - '0') % 5 == 0) v.push_back(i); ans = 0; for(int i = 0; i &lt; v.size(); i++) (ans += ksm(2, v[i])) %= mod; (ans *= ksm(2, n * m) - 1) %= mod; (ans *= ksm(ksm(2, n) - 1, mod - 2)) %= mod; printf("%lld\n", ans % mod); &#125; return 0;&#125; Fé¢˜ï¼šSorting Treesç®€å•æ€ç»´é¢˜ã€‚ä¹‹å‰åœ¨Codejamä¸Šåšè¿‡åœ¨k = 2æƒ…å†µä¸‹çš„ä¸€é“é¢˜ï¼Œè¿™é“é¢˜ç®—æ˜¯å¯¹é‚£é“é¢˜çš„æ¨å¹¿ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;vi v[N];int n, k, a[N], b[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; k) &#123; for(int i = 0; i &lt; n; i++) scanf("%d", a + i); if(k == 0) &#123; memcpy(b, a, sizeof a); sort(b, b + n); int i; for(i = 0; i &lt; n; i++) if(a[i] != b[i]) &#123; printf("%d\n", i + 1); break; &#125; if(i == n) printf("-1\n"); continue; &#125; for(int i = 0; i &lt; n; i++) v[i % k].push_back(a[i]); for(int i = 0; i &lt; k; i++) &#123; if(v[i].empty()) continue; sort(v[i].begin(), v[i].end()); &#125; for(int i = 0; i &lt; k; i++) for(int j = 0; j &lt; v[i].size(); j++) b[i + j * k] = v[i][j]; sort(a, a + n); int i; for(i = 0; i &lt; n; i++) if(a[i] != b[i]) &#123; printf("%d\n", i + 1); break; &#125; if(i == n) printf("-1\n"); &#125; return 0;&#125; Cé¢˜ï¼šProfessional Managerç•™å‘å¾…è¡¥ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[CF 967E: Big Secret]]></title>
    <url>%2F2018%2F05%2F01%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ªæ•°ç»„bï¼Œé—®å­˜ä¸å­˜åœ¨è¿™äº›æ•°çš„ä¸€ä¸ªæ’åˆ—ï¼Œä½¿å¾—è¿™äº›æ•°æ„é€ å‡ºæ¥çš„å¦ä¸€ä¸ªæ•°ç»„aä¸¥æ ¼ä¸Šå‡ã€‚aiç­‰äºbæ•°ç»„å‰iä¸ªå…ƒç´ çš„å¼‚æˆ–å€¼ã€‚ åˆ†æå‡å¦‚æ•°ç»„bä¸­æœ‰ä¸€äº›å€¼ä¸º1çš„å…ƒç´ ï¼Œé‚£ä¹ˆæŸä¸ª1å‰é¢åº”è¯¥æœ‰å¶æ•°ä¸ªå¥‡æ•°ï¼Œå¦åˆ™æ„é€ å‡ºæ¥çš„aæ•°ç»„å°±ä¼šä¸‹é™ã€‚åŒç†ï¼Œå‡å¦‚æ•°ç»„bä¸­æœ‰ä¸€äº›å€¼ä¸º[2^k, 2^(k+1))çš„å…ƒç´ ï¼Œé‚£ä¹ˆæŸä¸ªå€¼ä¸º[2^k, 2^(k+1))çš„å…ƒç´ å‰é¢åº”è¯¥æœ‰å¶æ•°ä¸ªå€¼å¤§äº2^(k+1) ä¸”äºŒè¿›åˆ¶å½¢å¼åœ¨ç¬¬kä½å€¼ä¸º1çš„å…ƒç´ ï¼Œå¦åˆ™ï¼Œæ„é€ å‡ºæ¥çš„aæ•°ç»„ä¹Ÿä¼šä¸‹é™ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‰å¯¼0çš„ä¸ªæ•°ç»™bæ•°ç»„ä¸­çš„å…ƒç´ åˆ†ç»„ï¼Œç„¶åï¼Œåœ¨ç¬¦åˆæ’å…¥æ¡ä»¶çš„æƒ…å†µä¸‹ï¼Œå‰å¯¼0ä½æ•°å¤šçš„å…ƒç´ ä¼˜å…ˆæ’å…¥å³å¯ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;vector&lt;ll&gt; ans;vector&lt;ll&gt; v[60];ll n, d, t;bool flag;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf("%I64d", &amp;d); for(int j = 59; j &gt;= 0; j--) if(d &gt;&gt; j &amp; 1) &#123; v[j].push_back(d); break; &#125; &#125; t = 0; flag = true; for(int j = 0; j &lt; n &amp;&amp; flag; j++) &#123; flag = false; for(int i = 0; i &lt; 60; i++) &#123; if(t &gt;&gt; i &amp; 1 || v[i].empty()) continue; ans.push_back(v[i].back()); t ^= v[i].back(); v[i].pop_back(); flag = true; break; &#125; &#125; if(ans.size() == n) &#123; printf("Yes\n"); for(int i = 0; i &lt; n; i++) printf("%I64d%c", ans[i], i == n - 1 ? '\n' : ' '); &#125; else printf("No\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ€ç»´</tag>
        <tag>æ„é€ </tag>
        <tag>ä½è¿ç®—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 967D: Resource Distribution]]></title>
    <url>%2F2018%2F04%2F30%2F1%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç•¥ åˆ†æè®¾ä¸¤ç§æœåŠ¡æ‰€éœ€æœåŠ¡å™¨æ•°é‡åˆ†åˆ«ä¸ºw1ã€w2ï¼Œå¯¹åº”ä¸‹é™åˆ†åˆ«ä¸ºp1ã€p2ã€‚å‡å¦‚p1 &gt; p2ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬åº”è¯¥å°†â€œä¼˜è´¨â€çš„æœåŠ¡å™¨ä¼˜å…ˆåˆ†ç»™ç¬¬ä¸€ç§æœåŠ¡ï¼Œç„¶åå†å°†å‰©ä½™çš„æœåŠ¡å™¨åˆ†ç»™ç¬¬äºŒç§æœåŠ¡ã€‚å¹¶ä¸”ï¼Œä¸ºäº†æ»¡è¶³ç¬¬äºŒç§æœåŠ¡ï¼Œp1åº”è¯¥è¶Šå¤§è¶Šå¥½ã€‚å› æ­¤ï¼Œæ’åºåï¼Œè´ªå¿ƒforä¸¤æ¬¡å°±è¡Œäº†ã€‚è¿™é“é¢˜çš„å…³é”®æ˜¯è¦æ„è¯†åˆ°â€œä¼˜è´¨â€æœåŠ¡å™¨åº”è¿ç»­åˆ†ç»™æŸä¸€ç§æœåŠ¡ï¼Œè€Œä¸èƒ½é—´æ–­ç€åˆ†ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=3e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, x1, x2, p;vi v[3];bool flag;struct node &#123; int val, id;&#125;a[N];bool cmp(node a, node b) &#123; return a.val &lt; b.val;&#125;int check(int mid) &#123; int t = ceil(1.0 * x1 / mid); if(t &lt;= a[p - mid + 1].val) return 0; return 1;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; x2) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].val); a[i].id = i; &#125; sort(a + 1, a + n + 1, cmp); flag = false; v[1].clear(); v[2].clear(); for(int i = 1; i &lt; n; i++) &#123; int t = ceil(1.0 * x2 / i); p = n - i; if(a[p + 1].val &gt;= t) &#123; int l; for(int i = p; i &gt;= 1; i--) &#123; if(check(i) == 0) &#123; l = i; flag = true; break; &#125; &#125; if(flag) &#123; printf("Yes\n%d %d\n", l, n - p); for(int i = p; i &gt;= p - l + 1; i--) printf("%d%c", a[i].id, i == p - l + 1 ? '\n' : ' '); for(int i = p + 1; i &lt;= n; i++) printf("%d%c", a[i].id, i == n ? '\n' : ' '); &#125; break; &#125; &#125; if(flag) continue; swap(x1, x2); for(int i = 1; i &lt; n; i++) &#123; int t = ceil(1.0 * x2 / i); p = n - i; if(a[p + 1].val &gt;= t) &#123; int l; for(int i = p; i &gt;= 1; i--) &#123; if(check(i) == 0) &#123; l = i; flag = true; break; &#125; &#125; if(flag) &#123; printf("Yes\n%d %d\n", n - p ,l); for(int i = p + 1; i &lt;= n; i++) printf("%d%c", a[i].id, i == n ? '\n' : ' '); for(int i = p; i &gt;= p - l + 1; i--) printf("%d%c", a[i].id, i == p - l + 1 ? '\n' : ' '); &#125; break; &#125; &#125; if(!flag) printf("No\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ€ç»´</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 967C: Stairs and Elevators]]></title>
    <url>%2F2018%2F04%2F30%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„é¢˜æ„å¾ˆç®€å•ï¼Œç•¥:) åˆ†æé¦–å…ˆæ³¨æ„åˆ°æ¥¼æ¢¯ã€ç”µæ¢¯æ˜¯å‚ç›´è¿é€šæ•´æ ‹æ¥¼çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬æ²¡å¿…è¦å¤šæ¬¡èµ°æ¥¼æ¢¯æˆ–ä¹˜åç”µæ¢¯ï¼Œæœ€å¤šåªè¦ä¸€æ¬¡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾ç¦»å‡ºå‘ç‚¹y1æœ€è¿‘çš„ä¸¤ä¸ªæ¥¼æ¢¯å’Œä¸¤ä¸ªç”µæ¢¯ï¼Œè¿™å¯ä»¥é€šè¿‡äºŒåˆ†æ¥å®ç°ï¼Œç„¶ååˆ†åˆ«è®¡ç®—æ—¶é—´ï¼Œå–minå³å¯ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¥¼å±‚ç›¸åŒæ—¶ä¸éœ€è¦èµ°æ¥¼æ¢¯æˆ–ä¹˜åç”µæ¢¯ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, m, cl, ce, v, a[N], b[N], q, x1, y_1, x2, y2;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; cl &gt;&gt; ce &gt;&gt; v) &#123; for(int i = 0; i &lt; cl; i++) scanf("%d", a + i); for(int i = 0; i &lt; ce; i++) scanf("%d", b + i); scanf("%d", &amp;q); while(q--) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y_1, &amp;x2, &amp;y2); if(x1 == x2) &#123; printf("%d\n", abs(y_1 - y2)); continue; &#125; int ans = INF; int p = lower_bound(a, a+cl, y_1) - a; if(p != cl) ans = min(ans, abs(a[p] - y_1) + abs(x2 - x1) + abs(a[p] - y2)); if(--p &gt;= 0) ans = min(ans, abs(a[p] - y_1) + abs(x2 - x1) + abs(a[p] - y2)); p = lower_bound(b, b+ce, y_1) - b; if(p != ce) ans = min(ans, abs(b[p] - y_1) + (int)ceil(1.0*abs(x2 - x1) / v) + abs(b[p] - y2)); if(--p &gt;= 0) ans = min(ans, abs(b[p] - y_1) + (int)ceil(1.0*abs(x2 - x1) / v) + abs(b[p] - y2)); printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>äºŒåˆ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 900E: Maximum Questions]]></title>
    <url>%2F2018%2F04%2F29%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ªé•¿åº¦ä¸ºnï¼ˆ1 â‰¤ n â‰¤ 100000ï¼‰çš„å­—ç¬¦ä¸²ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²åªåŒ…å«â€˜aâ€™ï¼Œâ€™bâ€™ï¼Œâ€˜?â€™ä¸‰ç§å­—ç¬¦ï¼Œå…¶ä¸­â€™?â€™å¯ä»¥å˜æˆâ€˜aâ€™æˆ–â€˜bâ€™ã€‚ç°åœ¨éœ€è¦æ±‚è¿™ä¸ªå­—ç¬¦ä¸²é‡ŒåŒ…å«æœ€å¤šä¸ªé•¿åº¦ä¸ºmï¼ˆm &lt;= n)çš„å­—ç¬¦ä¸²æ—¶çš„æœ€å°è½¬å˜æ¬¡æ•°æ˜¯å¤šå°‘ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ä¸¤ä¸ªé•¿åº¦ä¸ºmçš„å­—ç¬¦ä¸²ä¸èƒ½é‡å ã€‚è¿™ä¸ªé•¿åº¦ä¸ºmçš„å­—ç¬¦ä¸²çš„æ„é€ è§„åˆ™æ˜¯abababâ€¦å³å¥‡æ•°ä½ä¸ºaï¼Œå¶æ•°ä½ä¸ºbã€‚ åˆ†æçœ‹å®Œé¢˜æ„ï¼Œå®¹æ˜“å‘ç°åº”è¯¥ç”¨DPæ¥å†™ã€‚ä½†æ˜¯ï¼Œæ€ä¹ˆåˆ¤æ–­æŸä¸€ä¸ªé•¿åº¦ä¸ºmçš„å­ä¸²æ˜¯å¦ä¸ºåˆæ³•ä¸²ä»¥åŠæ„æˆåˆæ³•ä¸²æ‰€éœ€çš„èŠ±è´¹å‘¢ï¼Ÿè¿™éœ€è¦æˆ‘ä»¬ç”¨å‰ç¼€å’Œåˆ†å¥‡å¶ç»Ÿè®¡aï¼Œbå‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åå°±å¯ä»¥åœ¨O(1)çš„æ—¶é—´åˆ¤æ–­äº†ã€‚æ¥ç€ï¼Œè¿›è¡ŒDPï¼Œdp[i].cost è¡¨ç¤ºå‰é¢iä¸ªå­—ç¬¦æ„æˆæœ€å¤šåˆæ³•ä¸²æ—¶çš„æœ€å°èŠ±è´¹ï¼Œdp[i].maè¡¨ç¤ºå‰é¢iä¸ªå­—ç¬¦æ„æˆæœ€å¤šåˆæ³•ä¸²çš„ä¸ªæ•°ã€‚dp[i] å¯ä»¥ç”±dp[i-1]æˆ–dp[i-m]è½¬ç§»è¿‡æ¥ï¼Œè½¬ç§»çš„æ¡ä»¶æ˜¯æ„æˆçš„åˆæ³•ä¸²æ›´å¤šæˆ–è€…æ„æˆçš„åˆæ³•ä¸²ä¸€æ ·å¤šä½†æ˜¯èŠ±è´¹æ›´å°‘ã€‚æœ€åï¼Œdp[n].cost å³ä¸ºç­”æ¡ˆã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int a[N], b[N], c[N], d[N], n, m;string s;struct node &#123; int ma, cost;&#125;dp[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; s &gt;&gt; m) &#123; s = '0' + s; int len = s.length(); memset(a, 0, sizeof a); memset(b, 0, sizeof b); memset(c, 0, sizeof c); memset(d, -1, sizeof d); //æŒ‰ç…§å¥‡å¶ä¸‹æ ‡ç»Ÿè®¡aä»¥åŠ?å‡ºç°çš„æ¬¡æ•°ï¼Œå­˜å‚¨åˆ°a[] //æŒ‰ç…§å¥‡å¶ä¸‹æ ‡ç»Ÿè®¡bä»¥åŠ?å‡ºç°çš„æ¬¡æ•°ï¼Œå­˜å‚¨åˆ°b[] //ç»Ÿè®¡?å‡ºç°çš„æ¬¡æ•°ï¼Œå­˜å‚¨åˆ°c[] for(int i = 1; i &lt; len; i++) &#123; c[i] = c[i-1] + (s[i] == '?' ? 1 : 0); if(i &gt;= 2) &#123; a[i] = a[i-2] + (s[i] == '?' || s[i] == 'a' ? 1 : 0); b[i] = b[i-2] + (s[i] == '?' || s[i] == 'b' ? 1 : 0); &#125; else &#123; a[i] = (s[i] == '?' || s[i] == 'a' ? 1 : 0); b[i] = (s[i] == '?' || s[i] == 'b' ? 1 : 0); &#125; &#125; //åˆ¤æ–­ä»¥iç»“å°¾çš„å­—ç¬¦ä¸²æ˜¯å¦æœ‰å¯èƒ½åˆæ³•ï¼Œå‡å¦‚æœ‰å¯èƒ½ï¼Œd[]ä¸ºèŠ±è´¹ï¼Œå‡å¦‚ä¸å¯èƒ½ï¼Œd[]ä¸º-1 for(int i = m; i &lt; len; i++) &#123; if(m &amp; 1) &#123; int ta = a[i] - a[max(0, i - m - 1)]; int tb = max(0, b[i-1] - b[max(0, i - m)]); if(ta &gt;= (m+1)/2 &amp;&amp; tb &gt;= m/2) d[i] = c[i] - c[i-m]; &#125; else &#123; int ta = a[i-1] - a[max(0, i - m - 1)]; int tb = b[i] - b[i - m]; if(ta &gt;= (m+1)/2 &amp;&amp; tb &gt;= m/2) d[i] = c[i] - c[i-m]; &#125; &#125; memset(dp, 0, sizeof dp); //dp[i]å¯ä»¥ç”±dp[i-m]ä»¥åŠdp[i-1]è½¬ç§»è¿‡æ¥ï¼Œæ›´ä¼˜çš„æ ‡å‡†æ˜¯å‡‘å‡ºæ›´å¤šçš„åˆæ³•ä¸²æˆ–è€…è®©ä¸€æ ·å¤šçš„åˆæ³•ä¸²èŠ±è´¹æ›´å°‘ for(int i = m; i &lt; len; i++) &#123; if(d[i] == -1) dp[i] = dp[i-1]; else if(dp[i-m].ma + 1 &gt; dp[i-1].ma || (dp[i-m].ma + 1 == dp[i-1].ma &amp;&amp; dp[i-m].cost + d[i] &lt; dp[i-1].cost)) dp[i].ma = dp[i-m].ma + 1, dp[i].cost = dp[i-m].cost + d[i]; else dp[i] = dp[i-1]; &#125; printf("%d\n", dp[len-1].cost); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>æŠ€å·§</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2778: DNA Sequence]]></title>
    <url>%2F2018%2F04%2F21%2F1%2F</url>
    <content type="text"><![CDATA[é¢˜æ„æ±‚æ„é€ ä¸å«m(0 &lt;= m &lt;= 10)ä¸ªæ¨¡å¼ä¸²çš„é•¿åº¦ä¸ºn(1 &lt;= n &lt;= 2000000000)çš„å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•°ã€‚ åˆ†æé¦–å…ˆç”¨mä¸ªæ¨¡å¼ä¸²æ„é€ ACè‡ªåŠ¨æœºï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸ä»…è¦æŠŠå­—ç¬¦ä¸²æœ€åä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„é‚£ä¸€ç‚¹æ ‡è®°ä¸ºä¸åˆæ³•çŠ¶æ€ï¼Œè¿˜éœ€è¦æŠŠå…¶ä»–èƒ½è½¬ç§»åˆ°è¯¥ç‚¹çš„èŠ‚ç‚¹éƒ½æ ‡è®°ä¸ºä¸åˆæ³•çŠ¶æ€ã€‚ç„¶åï¼Œé—®é¢˜å°±è½¬åŒ–ä¸ºäº†ä»rootå‡ºå‘ï¼Œèµ°äº†næ­¥ï¼Œè¿™næ­¥éƒ½é¿å¼€ä¸åˆæ³•çŠ¶æ€çš„æ–¹æ¡ˆæ•°ã€‚è®¾ACè‡ªåŠ¨æœºçš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºLï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªL*Lçš„é‚»æ¥çŸ©é˜µï¼Œmat[i][j]ä»£è¡¨iåˆ°jçš„åˆæ³•æ–¹æ¡ˆæ•°ã€‚åˆ™matçŸ©é˜µçš„næ¬¡å¹‚å°±è¡¨ç¤ºèµ°äº†næ¬¡çš„æ–¹æ¡ˆæ•°ã€‚ç”±äºnå¾ˆå¤§ï¼Œæ‰€ä»¥è¦ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ–ã€‚è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œæ¯æ¬¡å¾ªç¯éƒ½è¦å°†ä¸åˆæ³•çš„é¡¹ç½®0ï¼Œå¦åˆ™ï¼Œæœ‰å¯èƒ½ä¼šå¤šç®—ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#pragma comment(linker, "/STACK:102400000,102400000") //æ‰‹åŠ¨æ‰©æ ˆ#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt; #include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;const int mod = 100000;map&lt;char, int&gt; m;int n, mm;char s[19];struct acAuto &#123; int next[109][4], fail[109], L, root; ll mat[109][109]; bool end[109]; void init() &#123; L = 0; m['A'] = 0; m['T'] = 1; m['C'] = 2; m['G'] = 3; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[L][i] = -1; end[L] = false; return L++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; int j = m[s[i]]; if(next[now][j] == -1) next[now][j] = newNode(); now = next[now][j]; &#125; end[now] = true; &#125; void build() &#123; fail[root] = root; queue&lt;int&gt; que; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void buildMatrix() &#123; memset(mat, 0, sizeof mat); for(int i = 0; i &lt; L; i++) &#123; int now = i, flag = false; while(now != root) &#123; if(end[now]) flag = true; now = fail[now]; &#125; if(flag) end[i] = true; &#125; for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; 4; j++) mat[i][next[i][j]]++; &#125; void ksm(int n) &#123; ll t[109][109]; ll t1[109][109]; ll t2[109][109]; memset(t, 0, sizeof t); for(int i = 0; i &lt; L; i++) t[i][i] = 1; while(n) &#123; for(int j = 0; j &lt; L; j++) if(end[j] == true) for(int i = 0; i &lt; L; i++) mat[i][j] = t[i][j] = 0; if(n &amp; 1) &#123; memcpy(t1, t, sizeof t); memset(t, 0, sizeof t); for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; L; j++) for(int k = 0; k &lt; L; k++) (t[i][j] += t1[i][k] * mat[k][j]) %= mod; &#125; n &gt;&gt;= 1; memcpy(t2, mat, sizeof mat); memset(mat, 0, sizeof mat); for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; L; j++) for(int k = 0; k &lt; L; k++) (mat[i][j] += t2[i][k] * t2[k][j]) %= mod; &#125; for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; L; j++) mat[i][j] = t[i][j]; &#125; void solve() &#123; buildMatrix(); ksm(n); ll ans = 0; for(int j = 0; j &lt; L; j++) (ans += mat[0][j]) %= mod; printf("%lld\n", ans); &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;mm, &amp;n)) &#123; ac.init(); for(int i = 0; i &lt; mm; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); ac.solve(); &#125;; return 0;&#125;]]></content>
      <tags>
        <tag>ACè‡ªåŠ¨æœº</tag>
        <tag>è®¡æ•°</tag>
        <tag>çŸ©é˜µå¿«é€Ÿå¹‚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6031: Innumerable Ancestors]]></title>
    <url>%2F2018%2F04%2F21%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€æ£µæ ‘ï¼Œè¯¢é—®ä¸¤ä¸ªç‚¹é›†é—´çš„LCAæœ€å¤§æ·±åº¦ã€‚ åˆ†æé¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡dfs+STè¡¨è¿›è¡Œé¢„å¤„ç†ï¼Œè®©æ¯æ¬¡LCAçš„æŸ¥è¯¢åªè¦O(1)å°±å¯ä»¥å®Œæˆã€‚æ¥ç€ï¼Œåˆ©ç”¨ä»¥ä¸‹è¿™ä¸ªæ€§è´¨ï¼š æ ¹æ® DFS åºï¼Œè‹¥ä¸¤ä¸ªç‚¹çš„ DFS åºè¶Šæ¥è¿‘ï¼Œåˆ™ä¸¤ä¸ªç‚¹çš„ LCA çš„æ·±åº¦è¶Šå¤§ã€‚ æˆ‘ä»¬å¯ä»¥å…ˆå°†å…¶ä¸­ä¸€ä¸ªç‚¹é›†Bä¸­çš„å…ƒç´ æŒ‰dfsåºæ’åºï¼Œç„¶åæšä¸¾å¦ä¸€ä¸ªç‚¹é›†Açš„å…ƒç´ ï¼Œä¸å¦¨è®¾ä¸ºaï¼Œåˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾åœ¨ç‚¹é›†Bä¸­æŸ¥æ‰¾åˆ°ä¸açš„dfsåºæœ€ç›¸è¿‘çš„ä¸¤ä¸ªå…ƒç´ ï¼Œä¸å¦¨è®¾ä¸ºb1ï¼Œb2ï¼Œæœ€åLCA(a, b1) çš„æ·±åº¦å’Œ LCA(a, b2)çš„æ·±åº¦å°±æ˜¯å¯èƒ½çš„ç­”æ¡ˆï¼Œå–maxå³å¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;/*************************************************************/// LCAåœ¨çº¿ç®—æ³•--dfs+STç®—æ³•int F[2*N]; //æ¬§æ‹‰åºåˆ—, é•¿åº¦ä¸º2*n-1, ä¸‹æ ‡ä»1å¼€å§‹int rmq[2*N]; //æ¬§æ‹‰åºåˆ—å¯¹åº”çš„æ·±åº¦åºåˆ—int P[N]; //P[i]è¡¨ç¤ºç‚¹iåœ¨Fä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®int tot, head[N], cnt, root, n;struct Edge&#123; int to, next;&#125;edge[2*N];//åŠ è¾¹, æ— å‘è¾¹éœ€è¦åŠ ä¸¤æ¬¡void addedge(int u, int v) &#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;//å»ºæ ‘å‰çš„åˆå§‹åŒ–void init() &#123; tot = 0; memset(head, -1, sizeof head);&#125;//è¾…åŠ©å‡½æ•°void dfs(int u, int pre, int dep) &#123; F[++cnt] = u; rmq[cnt] = dep; P[u] = cnt; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(v == pre) continue; dfs(v, u, dep+1); F[++cnt] = u; rmq[cnt] = dep; &#125;&#125;//æ„å»ºSTè¡¨struct ST&#123; int mm[2*N], dp[2*N][20]; void build(int root, int n) &#123; cnt = 0; dfs(root, root, 0); mm[0] = -1; for(int i = 1; i &lt;= 2 * n - 1; i++) &#123; mm[i] = (i&amp;(i-1)) == 0 ? mm[i-1]+1 : mm[i-1]; dp[i][0] = i; &#125; for(int j = 1; j &lt;= mm[2 * n - 1]; j++) for(int i = 1; i + (1 &lt;&lt; (j-1)) &lt;= 2 * n - 1; i++) dp[i][j] = rmq[dp[i][j-1]] &lt; rmq[dp[i+(1&lt;&lt;(j-1))][j-1]] ? dp[i][j-1] : dp[i+(1&lt;&lt;(j-1))][j-1]; &#125; int query(int a, int b) &#123; a = P[a], b = P[b]; if(a&gt;b) swap(a, b); int k = mm[b-a+1]; return F[rmq[dp[a][k]] &lt;= rmq[dp[b-(1&lt;&lt;k)+1][k]] ? dp[a][k] : dp[b-(1&lt;&lt;k)+1][k]]; &#125;&#125;st;/*************************************************************/int m, u, v, ta, tb, a[N], b[N];bool cmp(int a, int b) &#123; return P[a] &lt; P[b];&#125;bool check(int mid, int val) &#123; if(P[b[mid]] &gt;= P[val]) return true; return false;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; st.build(1, n); while(m--) &#123; scanf("%d", &amp;ta); for(int i = 0; i &lt; ta; i++) scanf("%d", a+i); scanf("%d", &amp;tb); for(int i = 0; i &lt; tb; i++) scanf("%d", b+i); sort(b, b + tb, cmp); int ans = -INF; for(int i = 0; i &lt; ta; i++) &#123; int l = -1, r = tb - 1; while(l + 1 != r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid, a[i])) r = mid; else l = mid; &#125; int rr = r; l = 0, r = tb; while(l + 1 != r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid, a[i])) r = mid; else l = mid; &#125; int ll = l; ans = max(ans, rmq[P[st.query(a[i], b[ll])]]); ans = max(ans, rmq[P[st.query(a[i], b[rr])]]); //printf("t: %d\n", ans); &#125; printf("%d\n", ans + 1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>äºŒåˆ†</tag>
        <tag>dfsåº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ¨ç‰©æœ‹å‹]]></title>
    <url>%2F2018%2F04%2F18%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ç•¥ åˆ†æ é¦–å…ˆæ„å»ºACè‡ªåŠ¨æœºï¼Œäºæ˜¯é¢˜ç›®è½¬åŒ–ä¸ºï¼šåœ¨è‡ªåŠ¨æœºä¸Šèµ°Læ­¥ï¼Œä¸ç¢°åˆ°ä»»ä½•ä¸€ä¸ªæˆåŠŸåŒ¹é…çš„èŠ‚ç‚¹ã€‚ä»¤DP[u][L]è¡¨ç¤ºå½“å‰çŠ¶æ€ä½äºçŠ¶æ€uï¼Œè¿˜éœ€è¦èµ°Læ­¥ï¼Œæ»¡è¶³æ¡ä»¶çš„æ¦‚ç‡ï¼Œè®°å¿†åŒ–æœç´¢å³å¯ã€‚ è¿™é“é¢˜çš„æ€è·¯å®˜æ–¹é¢˜è§£å·²ç»å†™å¾—å¾ˆæ¸…æ¥šäº†ï¼Œä¸å†èµ˜è¿°ã€‚ç›´æ¥ä¸Šä»£ç ï¼Œä»£ç ä¸­æ³¨é‡Šè›®æ¸…æ¥šçš„ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int T, L, n;char s[109], c[109];double p[109];struct acAuto &#123; int next[2009][128], fail[2009], root, L; bool end[2009]; double dp[2009][109]; //åˆå§‹åŒ– void init() &#123; L = 0; root = newNode(); &#125; //å»ºç«‹æ–°èŠ‚ç‚¹ int newNode() &#123; for(int i = 0; i &lt; 128; i++) next[L][i] = -1; end[L] = false; return L++; &#125; //å»ºç«‹Trie void insert(char s[]) &#123; int now = root, len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i]] == -1) next[now][s[i]] = newNode(); now = next[now][s[i]]; &#125; end[now] = true; &#125; //æ„å»ºACè‡ªåŠ¨æœºçš„failæ•°ç»„ï¼Œæˆ–è€…ç§°ä¸ºnextæ•°ç»„ void build() &#123; fail[root] = root; queue&lt;int&gt; que; for(int i = 0; i &lt; 128; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 128; i++) &#123; if(next[now][i] == -1) next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; //è®°å¿†åŒ–æœç´¢å®ç°DPï¼Œnowè¡¨ç¤ºç°åœ¨çš„çŠ¶æ€ï¼ŒLè¡¨ç¤ºåœ¨ACè‡ªåŠ¨æœºè¿˜éœ€è¦èµ°çš„æ­¥æ•° //åˆå§‹çŠ¶æ€ä¸ºACè‡ªåŠ¨æœºçš„rootèŠ‚ç‚¹ï¼Œè¡¨ç¤ºä¸€æ­¥éƒ½æ²¡èµ°ï¼Œä¸€ä¸ªå­—ç¬¦éƒ½æ²¡æœ‰ //è¾¹ç•Œæ¡ä»¶ä¸ºL=0ï¼Œè¡¨ç¤ºèµ°å®Œäº†ï¼Œè¿™æ—¶æˆåŠŸçš„æ¦‚ç‡æ˜¯1 //å¦åˆ™ï¼Œå°±éœ€è¦æšä¸¾æ‹¼æ¥åœ¨å½“å‰çŠ¶æ€åçš„å­—ç¬¦ï¼Œå¹¶åˆ¤æ–­æ‹¼æ¥åæ˜¯å¦åˆæ³•ï¼ˆåˆæ³•å°±æ˜¯å…¨éƒ¨æ¨¡å¼ä¸²éƒ½ä¸åŒ¹é…ï¼‰ï¼Œå¢åŠ è´¡çŒ®å€¼ //DP[u][L]ï¼Œå…¶ä¸­uè¡¨ç¤ºçŠ¶æ€ï¼ŒLè¡¨ç¤ºæ­¥æ•°ï¼Œå³çŠ¶æ€æ•°ä¸ºuLï¼ŒçŠ¶æ€è½¬ç§»æ˜¯åœ¨ACè‡ªåŠ¨æœºä¸Šè·‘çš„ï¼Œçœ‹è·³è½¬æ¬¡æ•°è€Œå®šï¼Œä¸å¤§ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦ä¸ºO(uL) double dfs(int now, int L) &#123; if(dp[now][L] != -1) return dp[now][L]; if(L == 0) return 1; double ans = 0; for(int i = 0; i &lt; n; i++) &#123; int temp = next[now][c[i]]; if(!pipei(temp)) ans += p[i] * dfs(temp, L-1); &#125; return dp[now][L] = ans; &#125; //è‹¥æœ‰ä¸€ä¸ªæ¨¡å¼ä¸²åŒ¹é…ï¼Œè¿”å›1ï¼Œè‹¥éƒ½ä¸åŒ¹é…ï¼Œè¿”å›0 bool pipei(int now) &#123; while(now != root) &#123; if(end[now]) return true; now = fail[now]; &#125; return false; &#125; double solve(int L) &#123; for(int i = 0; i &lt; 2009; i++) for(int j = 0; j &lt;= L; j++) dp[i][j] = -1; return dfs(0, L); &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; printf("Aonyx cinerea\n"); scanf("%d", &amp;T); while(T--) &#123; ac.init(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf(" %c%lf", &amp;c[i], &amp;p[i]); scanf("%d", &amp;L); printf("%.6f\n", ac.solve(L)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACè‡ªåŠ¨æœº</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gym 101755G: Underpalindromity]]></title>
    <url>%2F2018%2F04%2F02%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥Gym101755G åˆ†æé¦–å…ˆæ¥è€ƒè™‘ä¸€ä¸‹è¿™ä¸ªæ ·ä¾‹ï¼š8 48 8 7 6 9 5 8 2 æˆ‘ä»¬åˆ—å‡ºæ‰€æœ‰å¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®çš„å…ƒç´ å¯¹ï¼š 1-42-3, 2-53-2, 3-4, 3-64-1, 4-3, 4-5, 4-7â€¦ ç»è¿‡è§‚å¯Ÿï¼Œæˆ‘ä»¬å‘ç°å¯¹äºæŸä¸€ä¸ªå…ƒç´ ï¼Œå®ƒçš„è´¡çŒ®æ˜¯æœ‰è§„å¾‹çš„ã€‚ä»¤iè¡¨ç¤ºè¯¥å…ƒç´ çš„ä¸‹æ ‡ï¼Œåˆ™è¯¥å…ƒç´ å¯¹äº[i-k+1, i+k-1]è¿™ä¸ªåŒºé—´ï¼Œæ¯éš”ä¸¤ä¸ªæ•°å°±æœ‰ä¸€æ¬¡è´¡çŒ®ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°±å°†n*nä¸ªåŒºé—´çš„è´¡çŒ®å€¼è½¬åŒ–ä¸ºäº†nä¸ªç‚¹çš„è´¡çŒ®å€¼ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä¸Šé¢é‚£ä¸ªæ ·ä¾‹ä¸­ï¼Œç¬¬2ä¸ªå…ƒç´ çš„è´¡çŒ®å°±æ˜¯(8-7) + (9-8)ã€‚ ä¸ºäº†èƒ½å¤Ÿå¿«é€ŸæŸ¥è¯¢æŸä¸€ç‚¹çš„è´¡çŒ®å€¼ï¼Œæˆ‘ä»¬å¿…é¡»ç”¨åˆ°æŸç§æ•°æ®ç»“æ„æ¥ä¼˜åŒ–ï¼Œå¯¹äºåŒºé—´é—®é¢˜ï¼Œå®¹æ˜“æƒ³åˆ°ç”¨çº¿æ®µæ ‘æˆ–è€…æ ‘çŠ¶æ•°ç»„ã€‚ä¸ºäº†èƒ½å¤Ÿç”¨æ•°æ®ç»“æ„ä¼˜åŒ–ï¼Œæˆ‘ä»¬éœ€è¦å°†æ•°ç»„ä»å°åˆ°å¤§æ’åºã€‚æ’åºåï¼Œå½“æˆ‘ä»¬è®¡ç®—æŸä¸€ç‚¹çš„è´¡çŒ®æ—¶ï¼Œè¿™ä¸ªç‚¹å¯¹äºæ¯”è¿™ä¸ªç‚¹å°çš„å…ƒç´ çš„è´¡çŒ®ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä¸Šé¢ç¬¬2ä¸ªå…ƒç´ çš„è´¡çŒ®å°±æ˜¯(8-7)ï¼Œè‡³äº(9-8)ï¼Œå°±ç•™ç»™ç¬¬5ä¸ªå…ƒç´ æ‰è®¡ç®—ã€‚å› æ­¤ï¼Œæ ‘çŠ¶æ•°ç»„éœ€è¦çš„ç»´æŠ¤çš„ä¸œè¥¿æœ‰å…ƒç´ ä¸ªæ•°ä»¥åŠåŒºé—´å’Œã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;ll sum[4][N], n, k, ans;pii a[N];ll query(int p, int id) &#123; ll ans = 0; while(p &gt; 0) &#123; ans += sum[id][p]; p -= p &amp; -p; &#125; return ans;&#125;void add(int p, int v, int id) &#123; while(p &lt;= n) &#123; sum[id][p] += v; p += p &amp; -p; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; k) &#123; ans = 0; memset(sum, 0, sizeof sum); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].x); a[i].y = i; &#125; sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++) &#123; int id = a[i].y &amp; 1; int r = a[i].y + k - 1; int l = a[i].y - k + 1; //è¾¹ç•Œæƒ…å†µçš„å¤„ç† if(l &lt; 1) l = k - a[i].y + 1; if(r &gt; n) r = 2*n - a[i].y - k + 1; //è®¡ç®—æŸç‚¹å¯¹ç­”æ¡ˆçš„è´¡çŒ® if(k &amp; 1) ans += 1LL * a[i].x * (query(r, id+2) - query(l-1, id+2)) - (query(r, id) - query(l-1, id)); else ans += 1LL * a[i].x * (query(r, (id+2)^1) - query(l-1, (id+2)^1)) - (query(r, id^1) - query(l-1, id^1)); //ç”¨è¯¥ç‚¹æ›´æ–°æ ‘çŠ¶æ•°ç»„ add(a[i].y, a[i].x, id); add(a[i].y, 1, id + 2); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>æ ‘çŠ¶æ•°ç»„</tag>
        <tag>çº¿æ®µæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180329è®­ç»ƒèµ›é¢˜è§£]]></title>
    <url>%2F2018%2F03%2F29%2F0%2F</url>
    <content type="text"><![CDATA[è®­ç»ƒèµ›å¥—é¢˜é“¾æ¥ï¼š2018, XI Samara Regional Intercollegiate Programming Contest æ„Ÿè§‰é¢˜ç›®éš¾åº¦å¾ˆå‹å¥½ï¼Œå®˜æ–¹è¯´æ˜¯ç»™è“ç´«åé€‰æ‰‹åšçš„ã€‚ Aé¢˜æ®è¯´æ˜¯æ°´é¢˜ï¼Œç•¥ã€‚ Bé¢˜é˜Ÿå‹åšçš„ï¼Œç•™å‘å¾…å¡«ã€‚ Cé¢˜è¿™ç§åŒºé—´æ±‚æœ€ä¼˜è§£çš„é—®é¢˜ï¼Œä¸€ç§å¥—è·¯å°±æ˜¯æ’åº+è´ªå¿ƒã€‚å…·ä½“å¯¹è¿™é“é¢˜æ¥è¯´ï¼Œå³æŒ‰ç…§å³è¾¹ç•Œã€å·¦è¾¹ç•Œä»å°åˆ°å¤§æ’åºï¼Œç„¶åè´ªå¿ƒåœ°å–å³è¾¹ç•Œçš„ç‚¹ï¼ŒåŒæ—¶è·³è¿‡å·¦è¾¹ç•Œåœ¨è¯¥ç‚¹å·¦è¾¹çš„é‚£äº›åŒºé—´ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;bool cmp(pii a, pii b) &#123; if(a.y == b.y) return a.x &lt; b.x; return a.y &lt; b.y;&#125;int mark, n, ans;pii a[N];vi v;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) scanf("%d%d", &amp;a[i].x, &amp;a[i].y); sort(a, a+n, cmp); ans = 0; v.clear(); for(int i = 0; i &lt; n; ) &#123; mark = a[i].y; ans++; v.push_back(mark); while(i &lt; n &amp;&amp; a[i].x &lt;= mark) i++; &#125; printf("%d\n", ans); for(int i = 0; i &lt; v.size(); i++) printf("%d%c", v[i], i==v.size()-1?'\n':' '); &#125; return 0;&#125; Dé¢˜ä¸ä¼šï¼Œç•™å‘ã€‚ Eé¢˜å‡å¦‚ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒï¼Œé‚£ä¹ˆè¾“å‡ºâ€œYESâ€ã€‚ å¦åˆ™ï¼Œä»å·¦å¾€å³æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒï¼Œç„¶åä»å³å¾€å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒï¼Œç¿»è½¬è¿™ä¸ªåŒºé—´çš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­æ˜¯å¦èƒ½è®©ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒã€‚å¯ä»¥è¾“å‡ºâ€YESâ€ï¼Œä¸å¯ä»¥è¾“å‡ºâ€NOâ€ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;string s, t;int l, r, len, j;bool flag;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; s &gt;&gt; t) &#123; len = s.length(); l = r = -1; for(int i = 0; i &lt; len; i++) if(s[i] != t[i]) &#123; l = i; break; &#125; for(int i = len; i &gt; 0; i--) if(s[i] != t[i]) &#123; r = i; break; &#125; if(l == -1) printf("YES\n"); else &#123; flag = true; for(int i = l; i &lt;= r; i++) &#123; j = r - i + l; if(s[i] != t[j]) &#123; flag = false; break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; Fé¢˜ä¸ä¼šï¼Œç•™å‘ã€‚ Gé¢˜ä¸ä¼šï¼Œç•™å‘ã€‚ä¼ é€é—¨ Hé¢˜è¿™é“é¢˜ä¸»è¦çš„éš¾é¢˜åœ¨äºbanæ‰æ€ªå…½èƒ½æ”»å‡»åˆ°çš„åŒºåŸŸï¼Œèµ›åç»å¤§ä½¬æŒ‡ç‚¹ï¼Œå­¦ä¼šäº†å¤šæºbfsè¿™ç§æ“ä½œï¼Œæ–°æŠ€èƒ½get :) ç”±n*m&lt;=200000ï¼Œå¯å¾—1 &lt;= n &lt;= 200000ï¼Œ1 &lt;= ï½ &lt;= 200000ï¼Œæ‰€ä»¥ä¸èƒ½å¼€æ™®é€šçš„äºŒç»´æ•°ç»„ï¼Œè¦å¼€vectorã€‚æ¯”èµ›çš„æ—¶å€™æ²¡ç”¨vectorï¼Œè€Œæ˜¯å¼„äº†ä¸ªidæ¥å¤„ç†ï¼Œå†™å¾—å¥½ä¸‘(: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;int cnt, n, m, dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;, vis[N], ban[N], sx, sy, gx, gy, d, dis[N], b[N];string g[N];vector&lt;pii&gt; v;inline bool check(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m;&#125;inline int id(pii t) &#123; return t.x * m + t.y;&#125;inline int id(int x, int y) &#123; return x * m + y;&#125;//å¤šæºbfsvoid banbfs() &#123; queue&lt;pii&gt; que; for(int i = 0; i &lt; v.size(); i++) &#123; que.push(pii(v[i].x, v[i].y)); vis[id(v[i])] = 1; b[id(v[i])] = d; &#125; while(que.size()) &#123; pii u = que.front(); que.pop(); if(b[id(u)] == 0) break; for(int i = 0; i &lt; 4; i++) &#123; int nx = u.x + dx[i], ny = u.y + dy[i]; if(check(nx, ny) &amp;&amp; !vis[id(nx, ny)]) &#123; vis[id(nx, ny)] = 1; ban[id(nx, ny)] = 1; b[id(nx, ny)] = b[id(u)] - 1; que.push(pii(nx, ny)); &#125; &#125; &#125;&#125;void bfs() &#123; banbfs(); queue&lt;pii&gt; que; if(!ban[id(sx, sy)]) que.push(pii(sx, sy)); memset(dis, -1, sizeof dis); dis[id(pii(sx, sy))] = 0; vis[id(sx, sy)] = 1; while(que.size()) &#123; pii u = que.front(); que.pop(); if(u.x == gx &amp;&amp; u.y == gy) &#123; break; &#125; for(int i = 0; i &lt; 4; i++) &#123; int nx = u.x + dx[i], ny = u.y + dy[i]; if(check(nx, ny) &amp;&amp; !vis[id(nx, ny)] &amp;&amp; !ban[id(nx, ny)]) &#123; que.push(pii(nx, ny)); vis[id(nx, ny)] = 1; dis[id(pii(nx, ny))] = dis[id(u)] + 1; &#125; &#125; &#125; printf("%d\n", dis[id(pii(gx, gy))]);&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; d) &#123; for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) &#123; if(g[i][j] == 'S') sx = i, sy = j; else if(g[i][j] == 'M') v.push_back(pii(i, j)); else if(g[i][j] == 'F') gx = i, gy = j; &#125; bfs(); &#125; return 0;&#125; Ié¢˜ç»™äº†ä¸€äº›è¾¹ï¼Œæ¯æ¡è¾¹æœ€å¤šåªèƒ½ç”¨ä¸€æ¬¡ï¼Œç°åœ¨éœ€è¦åˆ¤æ–­æ‰€æœ‰çš„è¾¹èƒ½æœ€å¤šèƒ½ç»„æˆå¤šå°‘çš„å¹³è¡Œå››è¾¹å½¢ã€‚æ ¹æ®å¹³è¡Œå››è¾¹å½¢çš„æ€§è´¨ï¼Œç­”æ¡ˆå°±æ˜¯è¾¹é•¿ç›¸ç­‰çš„è¾¹çš„å¯¹æ•°é™¤ä»¥2 ã€‚ 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;int a[N], n, ans, d;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; memset(a, 0, sizeof a); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;d); a[d]++; &#125; ans = 0; for(int i = 0; i &lt; N; i++) ans += a[i]/2; printf("%d\n", ans/2); &#125; return 0;&#125; Jé¢˜ä¸ä¼šï¼Œç•™å‘ã€‚ Ké¢˜ä¸ä¼šï¼Œç•™å‘ã€‚ Lé¢˜é¦–å…ˆå¼€26ä¸ªsetï¼Œå°†ç›¸åŒå­—æ¯çš„ä½ç½®å‹è¿›åŒä¸€ä¸ªseté‡Œé¢ã€‚ å½“push æŸä¸ªå­—æ¯æ—¶ï¼Œå°±åœ¨è¿™ä¸ªå­—æ¯çš„seté‡Œé¢æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äºå½“å‰ä½ç½®çš„ä½ç½®ã€‚å‡å¦‚æ‰¾ä¸åˆ°ï¼Œé‚£ä¹ˆå°±æ˜¯NOï¼Œå‡å¦‚æ‰¾åˆ°äº†ï¼Œé‚£ä¹ˆå°±æ˜¯YESã€‚ä¸ç®¡æ˜¯YESè¿˜æ˜¯NOï¼Œéƒ½è¦å…ˆæŠŠæ—§ä½ç½®æ”¾è¿›æ ˆé‡Œé¢ï¼Œç„¶åæ›´æ–°å½“å‰ä½ç½®ï¼ˆNOæ—¶å°±æ›´æ–°ä¸ºINFï¼‰ã€‚ å½“popæŸä¸ªå­—æ¯æ—¶ï¼Œå°±å°†å½“å‰ä½ç½®æ›´æ–°ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œåˆ¤æ–­æ ˆé¡¶å…ƒç´ æ˜¯å¦ä¸ºINFï¼Œå‡å¦‚ä¸ºINFï¼Œé‚£å°±æ˜¯NOï¼Œå¦åˆ™ä¸ºYESã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;string s;char op[9], c;int m, t;set&lt;int&gt; se[29];stack&lt;int&gt; sta;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; s) &#123; for(int i = 0; i &lt; s.length(); i++) se[s[i]-'a'].insert(i); scanf("%d", &amp;m); int pp = -1; while(m--) &#123; scanf("%s", op); getchar(); if(op[1] == 'u') &#123; c = getchar(); t = c - 'a'; set&lt;int&gt;::iterator it = se[t].upper_bound(pp); sta.push(pp); if(it != se[t].end()) &#123; pp = *it; printf("YES\n"); &#125; else &#123; pp = INF; printf("NO\n"); &#125; &#125; else &#123; pp = sta.top(); sta.pop(); if(pp == INF) printf("NO\n"); else printf("YES\n"); &#125; &#125; &#125; return 0;&#125; Mé¢˜è¿™é“é¢˜è¦åˆ†æƒ…å†µè®¨è®ºã€‚ ä¸‰ä¸ªå­—ç¬¦ä¸²å®Œå…¨ç›¸åŒï¼ŒAmbiguousã€‚ å­˜åœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å·®å¼‚å€¼å¤§äº2ï¼ŒImpossibleã€‚ ç„¶åä¸¤ä¸¤æšä¸¾ä¸åŒçš„ä½ç½®ï¼Œå†ä¸å‰©ä½™çš„å¦ä¸€ä¸ªå­—ç¬¦ä¸²diffï¼Œå‡å¦‚å·®å¼‚å€¼å¤§äº1ï¼Œé‚£å°±ä¸æ˜¯å¯è¡Œè§£ï¼Œå¦åˆ™æ—¶å¯è¡Œè§£ã€‚æ ¹æ®å¯è¡Œè§£çš„ä¸ªæ•°å†åˆ†ä¸‰ç§æƒ…å†µå³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;string s1, s2, s3, t;vi v[3];set&lt;string&gt; se;bool flag;int len, cnt;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3) &#123; v[0].clear(); v[1].clear(); v[2].clear(); len = s1.length(); for(int i = 0; i &lt; len; i++) &#123; if(s1[i] != s2[i]) v[0].push_back(i); if(s2[i] != s3[i]) v[1].push_back(i); if(s1[i] != s3[i]) v[2].push_back(i); &#125; flag = true; for(int i = 0; i &lt; 3; i++) if(v[i].size() &gt; 2) flag = false; if(!flag) printf("Impossible\n"); else if(v[0].size() == 0 &amp;&amp; v[1].size() == 0 &amp;&amp; v[2].size() == 0) printf("Ambiguous\n"); else &#123; se.clear(); for(int i = 0; i &lt; v[0].size(); i++) &#123; t = s1; t[v[0][i]] = s2[v[0][i]]; cnt = 0; for(int j = 0; j &lt; len; j++) if(t[j] != s3[j]) cnt++; if(cnt &lt;= 1) se.insert(t); &#125; for(int i = 0; i &lt; v[1].size(); i++) &#123; t = s2; t[v[1][i]] = s3[v[1][i]]; cnt = 0; for(int j = 0; j &lt; len; j++) if(t[j] != s1[j]) cnt++; if(cnt &lt;= 1) se.insert(t); &#125; for(int i = 0; i &lt; v[2].size(); i++) &#123; t = s3; t[v[2][i]] = s1[v[2][i]]; cnt = 0; for(int j = 0; j &lt; len; j++) if(t[j] != s2[j]) cnt++; if(cnt &lt;= 1) se.insert(t); &#125; if(se.size() == 1) cout &lt;&lt; *se.begin() &lt;&lt; endl; else if(se.size() == 0) printf("Impossible\n"); else printf("Ambiguous\n"); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HrbustOJ 2375: easy math problem]]></title>
    <url>%2F2018%2F03%2F28%2F0%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ä¼ é€é—¨ åˆ†æé¢˜ç›®éœ€è¦æˆ‘ä»¬æ±‚içš„3æ¬¡æ–¹(1&lt;= i &lt;= n)çš„å’Œï¼Œç”±äºnå¾ˆå¤§ï¼Œæ— æ³•æš´åŠ›ç®—ã€‚ ä¸€èˆ¬è¿™ç§é¢˜çš„å¥—è·¯æ˜¯åˆ©ç”¨äºŒé¡¹å¼å®šç†+æ±‚å¯¼ï¼Œç”±äºæ±‚çš„æ˜¯içš„3æ¬¡æ–¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿ç»­â€äºŒé¡¹å¼æ–¹ç¨‹å·¦å³ä¸¤è¾¹æ±‚å¯¼ä¹˜xâ€3æ¬¡ï¼Œç„¶åä»¤x=1æ¥æ„é€ å‡ºé¢˜ç›®æ‰€æ±‚çš„å¼å­ï¼Œç„¶åé€šè¿‡å¿«é€Ÿå¹‚è®¡ç®—å³å¯ã€‚è®°å¾—CFä¸Šæœ‰ä¸€é“ç±»ä¼¼çš„é¢˜ï¼Œä»3å˜æˆäº†kï¼Œé¡ºä¾¿ç»™å‡ºCF932Eã€‚ ç”±äºä¸ä¼šLaTeXï¼Œæ‰€ä»¥æ— æ³•è´´å…¬å¼ï¼Œç•™å‘ã€‚ã€‚]]></content>
      <tags>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
</search>
