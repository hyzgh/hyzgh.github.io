<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《微习惯》读书笔记]]></title>
    <url>%2F2020%2F05%2F10%2Fnull%2F</url>
    <content type="text"><![CDATA[豆瓣链接 本书主要写了微习惯是什么，以及通过微习惯来培养好习惯的依据和规则。 第一章 微习惯是什么小决心优于大决心。许多人拥有大决心，但是却不去执行，效果是零。有小决心的人，更容易执行某件事情，虽然单次的收益比较小，但远大于不执行。日积月累，小决心产生的收益会很大。 拥有大决心而不执行，原因是大脑觉得这次行动很难，因此会选择逃避。拥有小决心，就不太会存在这个问题。小决心是为了让大脑接受这次行动。通常来讲，在开始后，会想花更多的时间在上面。 微习惯就是将较大的行动拆分成容易执行的小行动。比如，每天写3000字可以改成每天写50字，每天锻炼1小时可以改成每天锻炼5分钟。 养成一个习惯，需要的天数会受各种因素影响。我们假如想要养成一个习惯，不必在意需要的天数，因为重要的是坚持。当连续做某件事情时，大脑的抵触情绪会越来越低，会自然地养成习惯。当有某天没有坚持习惯时，不用气馁，一天的堕落从整个过程上看并不会影响习惯的养成，我们需要做的是克服心理上的自暴自弃。 第二章 大脑的工作原理可以将大脑粗分为潜意识部分和意识部分。从大脑的角度看，改变习惯的两个关键点是重复和回报。如果有回报，大脑会更愿意重复一件事情。重复是潜意识大脑使用的语言，潜意识大脑喜欢效率，这是我们能养成习惯的原因。 大脑是变化缓慢、状态稳定的，因此习惯的养成过程是缓慢的，习惯的保持是稳定的。 习惯改变涉及到大脑的两个部分：前额皮层和基底神经节。前额皮层是大脑的意识部分，是管理者，负责让大脑其他部分喜欢上自己想要的东西，用于习惯的执行。基底神经节是大脑的潜意识部分，没有思想，只会一味重复，能够探测都模式，用于新习惯的重复和养成。 第三章 动力VS意志力动力越高，做某件事情所需的意志力就越少。假如动力是满分，那么几乎不需要意志力就会去做某件事情。而假如动力为零，那么就需要很强的意志力才能去做某件事情。 有些人会使用“激发动力”策略来养成习惯。虽然动力确实有利于执行某件事情，但是它存在诸多问题。第一，动力难以永久保持高昂，容易导致习惯在养成的过程中断。第二，动力的影响因素多，不稳定。第三，不会每次都愿意激发动力。第四，根据热情递减原则，动力会减少，假如只依靠动力，那么会动力不足。 当连续执行某个行动后，我们会注意到心中不再充满动力。这可能是更稳定和自动的基底神经节正在夺取控制权，我们应该做的是利用微习惯继续执行下去，渡过这个艰难期，迎来新习惯。 动力并不是行动的唯一基础，我们还可以依靠意志力、习惯等。动力是好东西，只是不可靠。假如我们可以借助意志力，那么动力会变得更加可靠。如果先采取行动，动力会被迅速地激发。 使用意志力来采取行动远比努力激发动力靠谱。第一，意志力很可靠。第二，意志力可以被强化。第三，意志力策略可以通过计划执行。 意志力的工作原理是什么？意志力是有阈值的，并不是取之不尽用之不竭的。引起意志力损耗的五大主要因素有努力程度、感知程度、消极情绪、主观疲劳和血糖水平。抵抗诱惑，做决定等行为都会引起意志力的损耗。 我们需要克服这五大障碍，合理使用意志力，养成习惯。 第四章 微习惯策略微习惯策略就是强迫自己每天实施1到4个“小得到不可思议”的计划好的行动。这些运动小得到不会失败，小到不会因为特殊情况就被自己轻易放弃。它们有双重作用——激励自己继续做下去，并会成为微习惯。 以微习惯方式运用意志力，可以有效地减少意志力的损耗。因为微习惯的努力程度要求小、感知难度小、消极情绪低、主观疲劳小、血糖水平降低少。 微习惯能更科学地拓宽我们的舒适区。因为大脑是抗拒改变的，因此大幅度的改变会让大脑抗议，而微习惯因其微小而成之。 第五章 微习惯的独特之处微习惯能与现有习惯一较高下。大脑会抗拒大幅度改变，但是微习惯很小，被抗拒的程度会很小。 有些人在养成习惯的时候，会给自己设置一个期限。但是这是不科学的，因为习惯的形成因习惯、个体而定。微习惯策略没有截止时间，因为我们不知道需要多少时间，但是我们要寻找养成习惯的信号。 自我效能感是指对自己影响事件结果的能力的信念。微习惯能提升自我效能感。 微习惯能给我们更多的自主权，潜意识会恐惧控制，而微习惯通过将行动微小化，让潜意识意识到自己的控制权仍在，从而接受微小的变化。 微习惯能帮助自己远离恐惧、怀疑、胆怯或犹豫。行动是克服这些消极情绪的最佳武器，而微习惯能帮助自己行动。 正念是指对自己思维和行动有着清醒认识。正念是目标清晰地活着和敷衍地活着之间的区别。微习惯能让自己意识到在做什么，能培养自己的正念。 第六章 彻底改变只需八步 选择适合你的微习惯和计划 不超过四个 微习惯要小到即使精疲力尽也可以执行 写下来 挖掘每个微习惯的内在价值 不断问自己为什么要养成这个习惯，寻找依据 明确习惯依据，将其纳入日程 根据时间制定 根据行为方式制定 非具体习惯 创建奖励机制，以奖励提升成就感 奖励，关联美好事物，比如npy、大声微笑、唱歌、吃东西、休息一下等 奖励时间点：在取得一定里程碑时，给自己奖励。在坚持不下去时，给自己奖励 奖励能提升意志力 记录与追踪完成情况 研究表明，把想法写在纸上时，会让其在大脑中更加突出，而打字就不具备同样的效应 可以采用纸质日历、电子数据等方式来追踪，关注自己在意的数据，比如完成天数/总天数 微量开始，超额完成 强化意志力 当下就取得进步 不耗尽意志力 服从计划安排，摆脱高期待值 我们常常在执行的过程会超额完成目标，可以记录这些数据 要把期待值和精力放在坚持目标上，而不要对任务量抱有较高的期待 留意习惯养成的标志 没有抵触情绪，做起来容易，不做反而更难 认同身份，比如我常运动，我喜欢阅读 行动无需考虑，不再担心，常态化 很无聊，好的习惯并不会让人兴奋，它们只是对我们有好处而已 第七章 微习惯策略的八大规则 绝不要自欺欺人。不要偷偷要求自己做得更多，要真正的微习惯 满意每一个进步。要满意，但别满足 经常回报自己，尤其在完成微习惯之后 保持头脑清醒。不管情绪是兴奋的，还是低落的，都要记住，要完成微习惯 感到强烈抵触时，后退并缩小目标。缩小目标，有利于降低意志力损耗，有利于行动的执行，开始执行要优于不执行，执行的过程会带来动力，形成正反馈 提醒自己这件事很轻松、很有趣。大脑喜欢轻松、有趣的事情 绝不要小看微步骤。不积跬步无以至千里 用多余精力超额完成任务，而不是制定更大目标]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 每日一题6 Group Anagrams]]></title>
    <url>%2F2020%2F04%2F06%2Fleetcode-exercise-per-day-6-Group-Anagrams%2F</url>
    <content type="text"><![CDATA[题意给一个数组，起元素为只包含英文小写字母的单词。 要求分组输出使用了相同字符构造的单词，比如tea和eat就是同类单词。 思路将所有的单词遍历一遍，将同类单词放到同一个位置中去，关键是这个映射要怎么实现。对于一个长度为m的单词，我们可以用O(m)的时间遍历出各字符的使用次数。接着，我们将其转化成字符串，对于某个字符，其出现次数可以编码成cnt + char，然后按照英文字母表顺序连接起来。比如，teaa编码成2a1e1t。 上面的编码使用了一个优化，即对于出现次数的0的字母，不编码到字符串中。 假如追求极致，还可以对编码继续优化。 对于出现次数为1的字母，可以不写上cnt。比如teaa可以写成2aet。 当cnt很大时，可以使用整形来表示。比如250，使用char来表示需要3个字节，使用整形只要1个字节。 编码是个很有趣的知识点，上面的编码方式似乎都有专门的名称，以后有空的话专门写篇博客总结一下，这里留个坑:) 代码12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; v; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i: strs) &#123; m[hashWord(i)].push_back(i); &#125; for (auto it: m) &#123; v.push_back(it.second); &#125; return v; &#125; string hashWord(string s) &#123; vector&lt;int&gt; cnt(26, 0); for (int i = 0; i &lt; s.length(); i++) &#123; cnt[s[i] - 'a']++; &#125; string hash; for (int i = 0; i &lt; 26; i++) &#123; if (!cnt[i]) continue; hash += string(cnt[i], 'a' + i); &#125; return hash; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 每日一题5 Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2020%2F04%2F05%2Fleetcode-exercise-per-day-5-Best-Time-to-Buy-and-Sell-Stock-II%2F</url>
    <content type="text"><![CDATA[题意给一个数组，表示每天的股票股价。可以进行无数次交易，但同一时刻只能持有一股的股票。求最大收益。 思路假如股价在未来是涨的，那么就应该购买。假如是跌的，就不购买。 因此，我们扫描一遍数组，维护当前最低的股价，假如遇到较高的股价，就卖出，并更新最低股价。时间复杂度为O(n)，空间复杂度为O(1)。 代码123456789101112131415161718class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() == 0) &#123; return 0; &#125; int mi = prices[0]; int ans = 0; for (int i = 1; i &lt; prices.size(); i++) &#123; if (prices[i] - mi &gt; 0) &#123; ans += prices[i] - mi; mi = prices[i]; &#125; mi = min(mi, prices[i]); &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 每日一题4 Move Zeroes]]></title>
    <url>%2F2020%2F04%2F04%2Fleetcode-exercise-per-day-4-Move-Zeroes%2F</url>
    <content type="text"><![CDATA[题意 题目链接：Move Zeroes 给一个数组，通过交换将所有非零元素放置在前面，将所有零元素放置在后面。 要求In-place，即不能使用额外的空间存放数组元素。 另外还要求交换次数最少。 思路为了满足题目要求，我们可以使用双指针法，找到一个零元素，以及在它后面的非零元素，将两者交换，不断重复这个过程。 假如不需要交换次数最少，有种更简洁的写法，即两次for循环，第一个for循环将非零元素放在数组前面，第二次for循环将非零元素放在数组后面。 代码12345678910111213141516171819202122232425262728class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int pZero = findNextZeroIndex(nums, -1); int pNonZero = findNextNonZeroIndex(nums, pZero); while (pZero &lt; nums.size() &amp;&amp; pNonZero &lt; nums.size()) &#123; swap(nums[pNonZero], nums[pZero]); pZero = findNextZeroIndex(nums, pZero); pNonZero = findNextNonZeroIndex(nums, pZero); &#125; &#125; int findNextZeroIndex(vector&lt;int&gt; &amp;nums, int pZero) &#123; pZero++; while (pZero &lt; nums.size() &amp;&amp; nums[pZero] != 0) &#123; pZero++; &#125; return pZero; &#125; int findNextNonZeroIndex(vector&lt;int&gt; &amp;nums, int pNonZero) &#123; pNonZero++; while (pNonZero &lt; nums.size() &amp;&amp; nums[pNonZero] == 0) &#123; pNonZero++; &#125; return pNonZero; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 每日一题3 Maximum Subarray]]></title>
    <url>%2F2020%2F04%2F04%2Fleetcode-exercise-per-day-3-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[题意 题目链接：Maximum Subarray 给一个数组，求该数组的最大子数组和。 思路解法1：从左到右遍历一次，累加，若sum比现有的答案大，则更新。若sum为负数，则放弃这一段的元素，置为0。时间复杂度为O(n)，空间复杂度为O(1)。 解法2：分治法。若我们将一个数组从中间分隔成两个数组，则它的答案是max(左数组的答案, 右数组的答案, 左数组的最大后缀和+右数组的最大前缀和+中间元素)。时间复杂度为O(nlogn)，空间复杂度为O(logn)。 代码解法1： 123456789101112131415class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; long long ans = LONG_LONG_MIN; long long sum = 0; for (auto i: nums) &#123; sum += i; if (sum &gt; ans) ans = sum; if (sum &lt; 0) sum = 0; &#125; return ans; &#125;&#125;; 解法2： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size(); return maxSubArrayCore(nums, l, r); &#125;private: int maxSubArrayCore(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l &gt;= r) &#123; return INT_MIN; &#125; int mid = l + ((r - l) &gt;&gt; 1); int leftMax = 0; for (int i = mid - 1, sum = 0; i &gt;= l; i--) &#123; sum += nums[i]; leftMax = max(leftMax, sum); &#125; int rightMax = 0; for (int i = mid + 1, sum = 0; i &lt; r; i++) &#123; sum += nums[i]; rightMax = max(rightMax, sum); &#125; return max(leftMax + rightMax + nums[mid], max(maxSubArrayCore(nums, l, mid), maxSubArrayCore(nums, mid + 1, r))); &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 每日一题2 Happy Number]]></title>
    <url>%2F2020%2F04%2F02%2Fleetcode-exercise-per-day-2-Happy-Number%2F</url>
    <content type="text"><![CDATA[题意 题目链接：Happy Number 给一个数字，判断它是不是Happy Number。假如一个数是Happy Number，则可以通过不断取各数位的平方和得到1。而假如不是Happy Number，则会陷入循环，不会得到1。 思路这道题的关键在于怎么知道发生了循环，并在发生循环的时候及时结束。弗洛伊德判圈法(Floyd Cycle detection algorithm)是可以在O(1)的空间复杂度和O(n)的时间复杂度内，判断是否发生循环的一种算法，其中n是循环的次数。其思想是维护两个指针，令它们一开始都指向最开始的位置，然后进行do while循环，让其中一个指针一次走两步，另一个一次走一步，直到两者相等，就可以判定存在圈。 这道题一定存在循环，Happy Number在找到圈的时候，指向的数为1，而非Happy Number指向的数非1，得解。 代码12345678910111213141516171819202122class Solution &#123;public: bool isHappy(int n) &#123; int slow, fast; slow = fast = n; do &#123; slow = getSum(slow); fast = getSum(fast); fast = getSum(fast); &#125; while (slow != fast); return slow == 1; &#125; int getSum(int d) &#123; int sum = 0; while (d) &#123; int mod = d % 10; d /= 10; sum += mod * mod; &#125; return sum; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 每日一题01 Single Number]]></title>
    <url>%2F2020%2F04%2F01%2Fleetcode-exercise-per-day-1-Single-Number%2F</url>
    <content type="text"><![CDATA[最近Leetcode举办了一个为期一个月的活动，每天会推出一道题目。最近这段时间正好有空，所以打算跟着参加一下，顺便写一下题解。使用的语言为C++。 题意 题目链接：Single Number 给一个非空的数组，其中有1个元素出现了1次，其他的都出现2次。时间要求为线性，不允许使用额外内存，求出现1次的元素。 思路题目保证数组非空，所以不需要特殊处理。 两个相同的数异或等于0，因此我们可以将数组所有元素异或起来，最后得到的值即为出现1次的元素。 代码123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); i++) &#123; nums[0] ^= nums[i]; &#125; return nums[0]; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Lang slice 学习笔记]]></title>
    <url>%2F2020%2F01%2F27%2Fgo-slice-learning-note%2F</url>
    <content type="text"><![CDATA[切片的数据结构切片，本身不存储实际数据。切片的数据结构，也被称为slice header，包含指向首元素的指针、切片长度、切片容量： 当将切片作为实参时，只会传递slice header。这个传递是值传递，这意味着： 假如在函数里面对slice的元素作赋值操作，由于有指针指着元素，所以原有slice指向的元素也会被改变。 假如在函数里面reslice，并不会影响原slice。 假如想要改变原有slice，有两种写法： 1234567891011121314// 第一种，将返回值赋值给原slice，这种方式也就是append的实现func SubtractOneFromLength(slice []byte) []byte &#123; slice = slice[0 : len(slice)-1] return slice&#125;func main() &#123; newSlice := SubtractOneFromLength(slice)&#125;// 第二种，用slice指针func PtrSubtractOneFromLength(slicePtr *[]byte) &#123; slice := *slicePtr *slicePtr = slice[0 : len(slice)-1]&#125; 这引发了另一个需要注意的点，对于slice的方法，假如需要reslice，要用slice指针： 1234567891011121314type path []bytefunc (p *path) TruncateAtFinalSlash() &#123; i := bytes.LastIndex(*p, []byte("/")) if i &gt;= 0 &#123; *p = (*p)[0:i] &#125;&#125;func main() &#123; pathName := path("/usr/bin/tso") // Conversion from string to path. pathName.TruncateAtFinalSlash() fmt.Printf("%s\n", pathName)&#125; 切片，可以改变指向的范围，这是成本很低的操作： 123456789func main() &#123; r := []bool&#123;true, true, true, false, false, false&#125; fmt.Println(r) r = r[1:2] fmt.Println(r) r = r[0:3] fmt.Println(r) # 输出[true true false]，即最开始的[1,4]&#125; 切片，可以切片，即s := s[[begin]:[end]]，其中begin和end可以省略。当end超过实际cap时，会panic。 cap() 查看容量，即从下界到数组最后一个元素的个数 len()查看长度，即从下界到上界的个数 切片的零值为nil，此时cap和len都为0 1var a []int // nil 切片的append可使用append函数向切片添加元素，对nil切片进行append是正确的。 当append超过切片容量时，会将容量翻倍，且利用内置函数copy进行数据的拷贝，该函数在切片重叠的情况下也可以保证正确拷贝。注意只有被append的slice的指针会指向这块新的区域，基于这个slice的其他slice并不会更新指针。 12345func main() &#123; var s []int s = append(s, 2, 3, 4) fmt.Println(s)&#125; 还可以使用append函数向切片中添加切片： 1234x := []int&#123;1,2,3&#125;y := []int&#123;4,5,6&#125;x = append(x, y...)fmt.Println(x) 切片的内存管理注意只要有一个slice使用着底层slice，即使这个上层slice只包含了很少的元素，底层slice的内存也不会被释放掉。这时候假如为了释放不必要的内存占用，需要将上层slice指向的数据拷贝到新的区域： 12345678910111213141516var digitRegexp = regexp.MustCompile("[0-9]+")// 整个文件的字节都被加载进去了，且不释放func FindDigits(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) return digitRegexp.Find(b)&#125;// 拷贝到c，释放多余的占用func CopyDigits(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c&#125; 切片的创建使用make来创建一维切片 12a := make([]int, 5) // len(a) == cap(a) == 5b := make([]int, 0, 5) // len(b) == 0, cap(b) == 5 使用make创建二维切片 第一种方式，该方式允许第二维大小有所变化： 12345// 创建一个位数为[dx][dy]的切片a := make([][]uint8, dx)for i := range a &#123; a[i] = make([]uint8, dy)&#125; 第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖： 12345678// Allocate the top-level slice, the same as before.picture := make([][]uint8, YSize) // One row per unit of y.// Allocate one large slice to hold all the pixels.pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.// Loop over the rows, slicing each row from the front of the remaining pixels slice.for i := range picture &#123; picture[i], pixels = pixels[:XSize], pixels[XSize:]&#125; 切片的遍历可使用range遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用_忽略其中一个。 1234567891011func main() &#123; pow := []int&#123;4, 1, 5&#125; for _, value := range pow &#123; fmt.Printf("%d\n", value) &#125; // 只有一个值只会得到下标 for idx := range pow &#123; fmt.Printf("%d\n", pow[idx]) &#125;&#125; 切片的技巧优雅地往slice插入一个value： 12345678910111213// Insert inserts the value into the slice at the specified index,// which must be in range.// The slice must have room for the new element.func Insert(slice []int, index, value int) []int &#123; // Grow the slice by one element. slice = slice[0 : len(slice)+1] // Use copy to move the upper part of the slice out of the way and open a hole. copy(slice[index+1:], slice[index:]) // Store the new value. slice[index] = value // Return the result. return slice&#125; 优雅地合并两个切片： 1234a := []string&#123;"John", "Paul"&#125;b := []string&#123;"George", "Ringo", "Pete"&#125;a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])"// a == []string&#123;"John", "Paul", "George", "Ringo", "Pete"&#125; 优雅地copy： 1234b = make([]T, len(a))copy(b, a)// orb = append([]T(nil), a...) cut，优雅地删除掉slice中的某一个区间： 123456789// 普通版，对于元素为指针或者结构中含有指针，会存在内存泄漏，因为被删掉的元素仍属于slicea = append(a[:i], a[j:]...)// 升级版，将指针设为nil，减少了内存泄漏，但是还是有元素属于slicecopy(a[i:], a[j:])for k, n := len(a)-j+i, len(a); k &lt; n; k++ &#123; a[k] = nil // or the zero value of T&#125;a = a[:len(a)-j+i] filter： 12345678910func filter(a []int) []int &#123; n := 0 for _, x := range a &#123; if keep(x) &#123; a[n] = x n++ &#125; &#125; a = a[:n]&#125; reverse: 1234for i := len(a)/2-1; i &gt;= 0; i-- &#123; opp := len(a)-1-i a[i], a[opp] = a[opp], a[i]&#125; shuffling: 1234567for i := len(a) - 1; i &gt; 0; i-- &#123; j := rand.Intn(i + 1) a[i], a[j] = a[j], a[i]&#125;// 或者直接用math/rand.Shuffle// 使用了Fisher–Yates算法]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Lang GC 学习笔记]]></title>
    <url>%2F2020%2F01%2F11%2Fgo-garbage-collector-learning-note%2F</url>
    <content type="text"><![CDATA[GC的具体实现一直在改变，但是其模型是相对稳定的。 collection的三个阶段： Mark Setup - STW Marking - Concurrent Mark Termination - STW Mark Setup：当进行gc时，为了保证数据完整性，需要设置Write Barrier，这要求将所有的goroutine停止，正常情况下这个时间平均为10-30ms。但是当goroutine停止不下时，会让这个时间变长。调度器目前停止goroutine的时机是在goroutine执行函数调用的时候，因为这样做才能保证安全。假如某个goroutine一直在执行循环，而不执行函数调用，它就无法被停止，这不仅会耽误gc第一个阶段的完成，还会造成其他goroutine停止着。将在Go1.14引入 preemptive techniques 尝试对此进行优化。 Marking - Concurrent：当设置好Write Barrier后，collector会拿走25%可用的CPU，用于mark操作。mark操作，会遍历所有goroutine的栈，寻找指针指向的heap内存，将仍在使用的内存标记一下。这个时候，goroutine是可以并发执行的。在mark的过程，其他正在运行的goroutine可以分配内存，这可能导致内存不够用，这时候需要Mark Assits。Mark Assits，是指短暂停止正在运行的goroutine，让它们来帮忙mark，加快mark的进度。当然，这会影响这些goroutine的执行，collector的目标是尽可能减少Mark Assits的需要。 Mark Termination - STW：Mark完成后，需要关闭Write Barrier，进行多项清理工作，设定下次collection的目标。在进行这些工作前，仍要求所有的goroutine停止。这些工作平均持续60~90ms。虽然也可以设计成边Termination边正常运行一些gorutine的模式，但是设计者认为这样得到的收益很小，而增加的复杂性较高，所以选择了这种STW的实现方式。当Termination工作完成后，回到正常状态。 在collection完成后，会进行sweeping。 sweep是指将那些没有标记为使用的heap内存回收，它不是发生在一次collection中，而是被均摊到每次分配内存的时候。 以上所有行为只有在GC开始且正在进行的时候发生，GC Percentage对collection有很大影响。GC Pencentage，默认是100%。将GC Pencentage设置为100%，意味着下次GC会在heap达到当前GC的mark live内存的2倍时进行。 GC trace可用于追踪collection。GODEBUG=gctrace=1 ./app可查看GC信息，输出到stderr。 GC trace： 12345678910111213141516171819202122232425262728293031323334353637# 通过设置环境变量查看GC traceGODEBUG=gctrace=1 ./appgc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 Pgc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8-&gt;11-&gt;6 MB, 13 MB goal, 12 Pgc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8-&gt;14-&gt;8 MB, 13 MB goal, 12 P# GC trace含义gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P// Generalgc 1404 : The 1404 GC run since the program started@6.068s : Six seconds since the program started11% : Eleven percent of the available CPU so far has been spent in GC// Wall-Clock0.058ms : STW : Mark Start - Write Barrier on1.2ms : Concurrent : Marking0.083ms : STW : Mark Termination - Write Barrier off and clean up// CPU Time0.70ms : STW : Mark Start2.5ms : Concurrent : Mark - Assist Time (GC performed in line with allocation)1.5ms : Concurrent : Mark - Background GC time0ms : Concurrent : Mark - Idle GC time0.99ms : STW : Mark Term// Memory7MB : Heap memory in-use before the Marking started11MB : Heap memory in-use after the Marking finished6MB : Heap memory marked as live after the Marking finished10MB : Collection goal for heap memory in-use after Marking finished// Threads12P : Number of logical processors or threads used to run Goroutines （全文完）]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[perl 学习笔记]]></title>
    <url>%2F2019%2F12%2F18%2Fnull%2F</url>
    <content type="text"><![CDATA[Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。 Perl的强大之处，在于它具有sed和awk的全部功能，以及众多语言的语法特性，以及非常强大的正则表达式，等等。 Hello, WorldPerl的Hello, World： 1perl -e 'print("Hello, World\n")' 在安装了perl的计算机上，直接执行上述代码，即可输出Hello, World。 也可以将perl代码写在文件，以重复执行，具体可以这样写： 1234#!/usr/bin/perl# 输出 "Hello, World"print("Hello, World\n"); 将上述代码保存成learn.pl后，加下执行权限，然后执行./learn.pl，可输出Hello, World。 正则表达式Perl的正式表达式非常强大，是常用编程语言里最顶尖的之一。下面来看几个例子。 例子1echo box.svc.content | perl -p -e &#39;s/\.+/\//g&#39; 将会输出box/svc/content。 解析： -p参数会将结果输出出来。 这里用到了一个常用的替换句型，s/old/new/parameters，表示将old替换成new。 s/\.+/\//g的s表示替换，\.+表示至少一个.，\/表示一个/，g表示全局匹配。 例子2123456#!/usr/bin/perl $string = 'welcome to w3cschool site.';$string =~ tr/a-z/A-z/;print "$string\n"; 上面的代码将会输出WELCOME TO W3CSCHOOL SITE.。 这里用到了一个常用的转化句型，tr/old/new/parameters。表示将old转化成new。 参考Perl 正则表达式 - W3Cschool]]></content>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片文件格式 学习笔记]]></title>
    <url>%2F2019%2F12%2F07%2Fnull%2F</url>
    <content type="text"><![CDATA[在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。 一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过ImageMagick这个程序来解析图片文件。 分辨率，比如1920x1080，是指图片的一行具有1920个像素，一列具有1080个像素。 色彩空间，是指描述一个像素点的方式。比如RGB，是指一个像素点用red, green, blue各8bit一共24bit来描述。而YUV，是指Y表示亮度，U和V一起表示色调和饱和度。 在互联网上最常见的大概是jpeg类的文件。jpeg文件之所以适合在互联网上传播，是因为它的压缩比较高，且能在压缩和图片还原度上保持平衡，使得一张图片既有小巧的体积，又能在肉眼级别上有良好的清晰度。 但是jpeg文件并不适合保存图标等图像内容，因为它不具有alpha通道，不能用来表示透明的背景。一般会用png来保存图标。由于png是无损压缩存储图片的，所以会比jpeg文件要大一些，也适合对于图像质量要求较高的情况。 bmp文件，它也是无损不压缩的，所以会比较大，比较少见。 git文件，可以存储动图，但是由于它只用了8bit来描述一个像素点，所以可用的色彩并不多，色彩丰富度低。 （全文完）]]></content>
      <tags>
        <tag>文件格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 6]]></title>
    <url>%2F2019%2F10%2F21%2FCSAPP-learning-note-6%2F</url>
    <content type="text"><![CDATA[最近看了CSAPP的第八章——异常控制流。 异常在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。异常有不同的种类，有中断、陷阱、故障、终止。 中断，是在CPU执行某条指令的时候，其他部件异步产生的，比如定时器芯片、磁盘控制器、网络适配器等。CPU检测到中断后，会把当前指令执行完，然后转去执行异常处理程序，接着再返回来执行下一条指令。 陷阱，是有意的异常，最常见的陷阱是系统调用。系统调用，是指从用户模式转为内核模式，以执行一些特殊的指令，比如操作I/O设备。执行完系统调用后，会返回来执行下一条指令。 故障，是指执行指令的时候遇到了意外，比如遇到了缺页、访问了未定义的虚拟内存区域等。根据故障的不同，异常处理程序执行完后可能会返回执行当前指令，也有可能会终止程序。在写程序时常常遇到的Floating point exception和Segmentation fault就属于故障，且在Linux中的处理是程序被终止。 终止，是指遇到了致命的硬件错误，必须结束程序。 因为异常种类繁多，所以计算机中有一张异常表，用来记录不同的异常及对应的异常处理程序。在CPU中，有一个特殊的寄存器——异常表基址寄存器，用来存放异常表在内存中的基址。当CPU遇到一种异常的时候，会拿到一个异常号。CPU拿着这个异常号及寄存器中的基址，便可以找到对应的异常处理程序了。 进程进程，是执行中的程序实例，是操作系统对于程序的一种抽象。这种抽象，使得看起来进程是独占cpu和内存的。为了实现这种抽象，需要操作系统保存好进程的上下文，进行进程调度。 进程的上下文，是指进程执行的状态，包括CPU中的状态、用户模式中的状态、内核模式中的状态。具体来说，cpu中的状态，包括各种寄存器，比如通用寄存器，用来保存指令执行用到的数据，还有程序计数器，用来指明程序执行的进度。用户模式下的状态，包括用户栈等。内核模式中的状态，包括内核栈、进程已打开文件的信息的文件表、有关当前进程的信息的进程表等。 什么时候会触发进程调度呢？主要有两种情况。一种是进程执行了系统调用，阻塞住了，比如读写文件、sleep等。另一种是中断，包括IO操作完成以及时钟中断等。 操作进程的工具 PS：列出当前系统中的进程。 TOP：打印出关于当前进程资源使用的进程。 PMAP：显示进程的内存映射。 STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。-static是个实用的参数。 /proc：一个虚拟文件系统，以ASCII文件格式输出大量内核数据结构的内容。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 5]]></title>
    <url>%2F2019%2F10%2F18%2FCSAPP-learning-note-5%2F</url>
    <content type="text"><![CDATA[这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。 存储技术存储器有着很多的种类，比如CPU的寄存器、高速缓存，主存（内存）的DRAM，机械硬盘、固态硬盘、U盘、SD卡、磁带等。不同的存储器，会用到不同的存储技术。其中寄存器的存储技术从性能上看是最好的，同时价格也最昂贵的，因此寄存器的大小相比于其他存储器，少得可怜，比如一般来说，通用寄存器只有16个，而1个寄存器只能存储64个bit。高速缓存采用的是SRAM，而主存用的是DRAM。SRAM用到了多个晶体管，比DRAM要快得多，会更加稳定，同时成本也更高。一般来说，高速缓存是几M的量级，而主存是以几G的量级，可见两者的价格差异。RAM有一个特点是断电后内容会丢失。 我们常用的U盘、SD卡等，并不是基于RAM，而是基于ROM。所谓ROM，翻译成中文便是只读存储器。个人觉得这个名字有点歧义，容易让人误解成数据不可更改。但实际上，ROM也有多个种类，我们常用的U盘基于EEPROM（电子可擦写只读存储器），是可以进行擦写的。而固态硬盘，基于闪存，它也是可擦写的。以前给手机刷机的时候，常常会听到ROM和固件这两个名词。所谓固件，是指写入到ROM中的程序。 机械硬盘，常常会听到一个参数叫转数。这个参数表示盘片旋转速度的速度。这个参数虽然重要，但却非影响硬盘随机IO时间的最重要因素。磁盘访问数据，由三个部分的时间组成，即寻道时间、旋转时间、传送时间。寻道时间是磁头定位到对应磁道的时间，这个时间平均占比是最大的，通常可占到整体时间的1/2以上，所以我们可以用两倍寻道时间来估计总时间。磁头定位到对应磁道，有专门的寻道算法，比如电梯算法。 固态硬盘，是近些年流行起来的存储器。其性能、价格皆介于主存和机械硬盘之间。由于固态硬盘采用了闪存，避免了机械硬盘缓慢的寻道和旋转，所以速度更快，特别是在随机IO的表现上。 根据历史趋势，存储器将会访问速度越来越快，越来越大，且会越来越便宜。但是，由于CPU的性能提升要比SRAM、DRAM、磁盘的速度快，所以两者的差距在增大，这将成为计算机的瓶颈。也因此，各级缓存的必要性就体现出来了，利用局部性原理，我们可以减弱这种差距。 局部性局部性分为空间局部性及时间局部性。空间局部性指的是某个位置的数据被访问后，其附近的数据将可能被访问。时间局部性指的是某个位置的数据被访问后，这个位置还将可能被再次访问。 以前对于这个概念的认识有点模糊，对其带来的性能差异没有明确的认知。我们下面通过一个程序来看一下空间局部性带来的影响。 12345678910111213141516171819int sum1(int a[N][N]) &#123; int i, j, sum = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; sum += a[i][j]; &#125; &#125; return sum;&#125;int sum2(int a[N][N]) &#123; int i, j, sum = 0; for (int j = 0; j &lt; N; j++) &#123; for (int i = 0; i &lt; N; i++) &#123; sum += a[i][j]; &#125; &#125; return sum;&#125; 当N = 20000时，在我的机器上，sum1执行的时间为2.1s，而sum2执行的时间为5.6s，两者差距两倍多。 sum1之所以性能表现比sum2优秀，是因为它访问数据时的步长为1，让计算机能更好地利用空间局部性原理。 存储器层次结构计算机的存储器层次结构从快到慢分为寄存器、L1高速缓存、L2高速缓存、L3高速缓存、主存、本地二级磁盘（本地磁盘）、远程二级存储（分布式文件系统、Web服务器）等。通过这样的层次结构，在大小、访问速度、价格等因素之间取得了折衷，让计算机的价格合理、访问速度较快、存储空间较大。 缓存无处不在，其目的是降低不同存储器之间速度差异带来的影响。计算机各级存储器之间，上层是下层的缓存。浏览器访问网页时，在本地磁盘有缓存，能提高用户打开同一网页的速度。Web服务器被访问的时候，本地磁盘也有缓存，能提高不同用户访问同一网页的速度。磁盘也有缓存，用于缓存磁盘扇区，提高计算机访问磁盘的速度。代理服务器，也可用来做缓存，能降低网络延迟。业务上，redis用作MySQL的缓存，是用内存来缓存磁盘的内容，缓解了随机I/O带来的性能问题。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 4]]></title>
    <url>%2F2019%2F10%2F15%2FCSAPP-learning-note-4%2F</url>
    <content type="text"><![CDATA[这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。 在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。 在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即CMP和TEST，也会设置条件码，但它们不会改变其他寄存器。 那么怎么访问这些条件寄存器呢？CPU中提供了SET指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应SETE指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应SETL，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。 要实现像C语言中的for语句，还需要一类指令JMP。它可以根据条件跳转到其他语句，而不是一直顺序执行。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 3]]></title>
    <url>%2F2019%2F09%2F29%2FCSAPP-learning-note-3%2F</url>
    <content type="text"><![CDATA[这两周看了第三章的前面五节，对机器指令有了更进一步的认识。 历史观点Intel处理器系列俗称x86，它有着一段进化之旅。从最初的8086到i386，再到i5和i7。那么它究竟有哪些方面的提升呢？ 晶体管数量增加。Core i7的1.4G个晶体管，是8086芯片29K个晶体管的4.8万倍。晶体管越多，意味着芯片的电路越复杂，能力越强。 指令集变大，支持更多指令。8087在8086的基础上，建立了浮点模型。 更多的位数。Pentium 4E是Intel对AMD提出的对IA32的64位拓展的实现，我们称之为x86-64。 更多的核数。Core 2是Intel的第一个多核微处理器。 更多的技术。Pentium 4E增加了超线程，允许一个处理器上同时运行两个程序。 AMD等产商的大多处理器与Intel处理器兼容，能够运行完全相同的机器级程序。 程序编码什么是机器代码呢？我们知道，C语言会经过预处理、编译、汇编、链接这些过程。 预编译：拓展源代码，主要处理对象是#include及#define。 编译：产生源文件的汇编代码，拓展名为.s。 汇编：产生二进制目标代码，拓展名为.o。 链接：将多个.o文件转化成一个可执行文件。 所谓机器代码，第一种是指.o文件中的代码，第二种是指可执行文件中的代码。它们的区别在于前者还没有填入全局值的地址。 机器代码是一些二进制代码，不具有可读性。汇编代码非常接近机器代码，我们可通过学习汇编代码来认识机器代码。 数据格式Intel的体系结构一直在变化，从16位到32位，再到64位，可能以后还会拓展到128位。 Intel用以下术语来表示不同的数据类型。 Intel数据类型 汇编代码后缀 大小（字节） 字节 b 1 字 w 2 双字 l 4 四字 q 8 单精度 s 4 双精度 l 8 访问信息一个CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。 我们知道，程序运行时，其数据存放在内存中。CPU需要一些指令来进行内存与寄存器间的数据转移，称为数据转移指令。 我们也知道，程序运行时，在内存中有一个对应的程序栈。CPU有专门指令进行入栈、出栈操作。可否将这些指令去掉呢？可以，存在代替指令。但是这样做，会让机器代码增多，考虑到入栈出栈操作是非常常见的，所以提供专门的指令会缩减机器代码的大小。这也就是在精简指令集上编译出来的机器代码比复杂指令集庞大的原因。 算术和逻辑操作所谓算术操作，指的是加减乘除等操作。所谓逻辑操作，是指与或移位等操作。 通过学习汇编代码的算术和逻辑操作，对于高级语言的便利性有了更具体的认识。一条C语言简单的算术表达式，转化成汇编代码，会变成多条。对于一些更复杂的循环控制语句，就更复杂了。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 2]]></title>
    <url>%2F2019%2F09%2F15%2FCSAPP-learning-note-2%2F</url>
    <content type="text"><![CDATA[这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。 整数运算整数运算的分类主要有两个维度，一个是无符号数、有符号数，另一个是加法、乘法。 之前知道编译器会将乘法转化成加减法/移位，但始终不知所以然。这次通过阅读CSAPP，深入理解了它的原理，另外知道了还可以将除法转化为加减法/移位。 这一节讲得都是规律和证明，这里不再赘述。贴一张图进行总结，以方便以后回忆。 浮点数阅读完这一节后，对于浮点数的表示、运算、舍入等有了更深入的理解。 其中，有的地方一开始不是很理解，当弄懂后，觉得这些设计很优雅、很聪明。 比如，对于IEEE非规范值得设计不是很理解，为什么要增加复杂性呢。后来，明白了非规格值的设计，使得0的表示很加自然且靠近0的浮点数分布得更均匀。 比如，一开始不太明白为什么要有偶数舍入法，直接四舍五入不行吗。后来，明白了偶数舍入法是对四舍五入的一种改进，避免了舍入所造成的统计误差。 还有浮点的运算，不遵循结合律，这是之前没有注意到但也是十分重要的知识点。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 1]]></title>
    <url>%2F2019%2F09%2F08%2FCSAPP-learning-note-1%2F</url>
    <content type="text"><![CDATA[前言上一周看完了第一章，这一周继续看第二章。本章的内容和信息的表示和处理有关，这部分内容之前修计算机组成原理时有学习到，所以阅读起来比较顺利，预计下周能顺利读完此章。 正文这一章的内容分为四小节，分别是： 信息存储 整数表示 整数运算 浮点数 信息存储上篇笔记谈到了信息，什么是信息？信息是数据+上下文。 在不同的上下文中，数据会有不同的含义。一个字节，既可表示一个字符，也可表示范围在[0, 256)的无符号整数，也可表示范围在[-128, 128)的有符号整数，还可以表示具有8个元素的集合，等等。 大多数机器使用8位的块，称为字节，作为最小的可寻址的内存单位，而不是直接访问内存中单独的位。字长为32位的机器，寻址的最大空间是$2^{32}$字节，而字长为64位的机器，寻址的最大空间就是$2^{64}$字节。什么是字长呢，字长用于指明指针数据的标称大小。 因为一个字节有8个位，用二进制表示起来有点冗长，而用十进制表示法的话，与位模式的互相转化会很麻烦。于是就有了十六进制数来表示位模式，在二进制和十进制取了折中，既方便表示，又不那么难读。 假如我们想要访问跨越多字节的对象，需要建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。对象地址的寻址范围根据字长而定，当字长为$w$时，可寻址空间为$2^{w}$。确定好对象的起始地址，还需要知道它有多少个字节以及如何排列这些字节。假设读取对象为int，有四个字节，且在内存中从低址到高址的内容为0x00000001，采用大端法读取就是$1$，采用小端法读取就是$2^{24}$。大端表示法比较符合人类的习惯，而小端法需要将数据按字节倒序排列。这些数据在机器中的字节排列通常对我们没有影响，但当涉及到网络编程时，就需要关注网络传输数据和机器存储数据的区别了。 整数表示整数在计算机中有多种表示形式，比如原码、补码、反码等。 而编程语言中遇到的整数类型，比如short, int, long long等，是对整数大小的限制。 而常说的有符号数、无符号数，则是在人类限制整数能否表示负数而产生。我认为有符号数和无符号数的设计其实意义不大，只用一种有符号数来表示整数就足够了。有了无符号数和有符号数，就需要用户去关注无符号数和有符号数的转化，一些隐式转化很容易引起出人意料的隐蔽错误。在Java中，并没有无符号数的概念，而在C语言中，有符号数和无符号数的转化，其实整数在底层的位表示中是不变的，只是C语言在不同的上下文中对它进行了不同的解释。 无符号数，采用简单的原码编码即可。而有符号数，一般采用补码编码，因为相对于源码、反码，它能表示更多一个数，更重要的是，机器中的位表示与整数是一个双射关系，很优雅。 无符号数和有符号数的转化，在理解了机器的位表示始终不变以及补码的相关知识后，我们可以总结出规律。我们这里假设两者的位数都为$w$。将无符号数转化为有符号数，当超过其表示范围时，需要减去$2^w$。将有符号数转化为无符号数时，负数需要加上$2^w$。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP 学习笔记 0]]></title>
    <url>%2F2019%2F08%2F30%2FCSAPP-learning-note-0%2F</url>
    <content type="text"><![CDATA[前言CSAPP（深入理解计算机系统）这本书豆瓣评分接近满分，是学习计算机系统的经典教材之一。这一周开始阅读此书，并计划以后每周写一篇学习笔记。 正文信息数据和信息是两个含义不同的词。数据是“死”的，而信息是“活”的。举个例子，阿拉伯数字8，在不同的情景下，可传递不同的信息。当电梯中可表示第8层，在桌球桌上可表示黑球8，而在聊天中可表示”拜拜”的意思。是什么赋予了它内涵？是情景，也称作上下文。在计算机系统中，数据就是比特串，是一个一个的位，再加上具体的上下文，就成为了信息。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 编译一个C语言程序，需要经过预处理器、编译器、汇编器、链接器的翻译，才能转化成可执行目标程序。 编译是个转化数据的过程。转化前是源代码，是人类可以理解的信息。而转化后，变成了机器语言，变成了人类无法理解的信息，而机器在一定的上下文中，能够理解这些数据。机器语言是机器能够理解的信息。 学习编译系统，可以帮助我们优化程序性能、理解链接时出现的错误、避免安全漏洞等。 指令编译后产生的可执行文件在磁盘里。当我们执行该文件时，计算机系统是怎么运作的呢？ 假设我们是在shell执行该程序的。键盘是一个外部设备，通过系统I/O总线和其他硬件连接在一起。当我们通过键盘输入可执行文件的文件名时，字符串会通过总线被逐一读入CPU中的寄存器并送入内存，且会输出到图形适配器（所以我们才可以在屏幕上看到输入的字符）。当输入回车后，shell就会通过一系列的指令来执行该程序，将程序的文件内容装载进内存，开始子进程，将CPU让给它执行。这个过程中，不同的指令，会让数据在CPU、内存、I/O设备间流动，比如输出文字到屏幕、通过网络下载文件等。 高速缓存所谓高速缓存，是为了解决CPU从寄存器读取数据与从内存读取数据的速度差异问题。CPU从寄存器读取数据比从内存读取数据要高几个数量级。所以一个自然的想法是提高寄存器的容量，这是一个解决思路，但是因为寄存器的价格要比内存贵得多，大幅提高容量从经济的角度考虑不太现实。另一个解决思路是提高主存的读取速度，这很接近现在大部分计算机系统采用的方法了。根据计算机组成原理的知识，我们知道SRAM的读取性能比DRAM的快得多，且SRAM也分多种，不同的SRAM实现会有不同的性能表现，价格也有差异。因为SRAM的价格还是要比DRAM高，大量采用SRAM作为主存也不现实。因此形成了一种折中的方案，采用DRAM作为主存，SRAM作为CPU的高速缓存。当CPU执行指令时，首先会从寄存器取数据，假如取不到，再到高速缓存取，假如还取不到，才到主存取。通过引进高速缓存，缓解了CPU执行速度与从内存读取数据速度不匹配的问题。 利用局部性原理，可提高高速缓存的命中率，让CPU尽可能快地取到指令去执行，提高整体效率。至于高速缓存中的数据与内存中的数据的映射，则涉及到了计算机组成原理，这里不再深入讲述。 抽象所谓抽象，在生活中其实随处可见。记得《人类简史》中写到，人类区别于其他生物的重要原因便是想象力丰富。人类之间通过讲述各种故事，塑造各种抽象概念，诸如宗族、城市、国家等概念，让原本互不认识的人有了联系的纽带，共同合作，诞生了各种文明。计算机系统中也有各种抽象概念，诸如文件、虚拟内存、进程。这些抽象，在我看来，是人类设计冯诺依曼计算机的基础，没有这些概念，计算机系统便不知道从何说起。 文件时什么？文件是一些二进制位在I/O设备中的抽象。 虚拟内存是什么？虚拟内存是程序的在主存和I/O设备中的空间的抽象。 进程是什么？进程是程序在CPU、主存、I/O设备活动的抽象。 （全文完）]]></content>
      <tags>
        <tag>计算机系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 学习笔记]]></title>
    <url>%2F2019%2F07%2F31%2FGo-learning-note%2F</url>
    <content type="text"><![CDATA[常用packagesfmtPrintf verb 描述 %v 输出值 %+v 输出键-值 %#v 输出包名、类型名、键-值 %T 类型 %% 百分号 %t 布尔值 %b 二进制的值 %c Unicode编码的字符 %d 十进制的值 %o 八进制的值 %x或%X 十六进制的值 %U 十六进制表示的Unicode值 %s 字符串 %p 地址 %f 浮点数，默认精度是小数点后6位 %e 浮点数，科学计数法，默认精度是小数点后6位 %g 浮点数，有效数字，尽可能地输出所有位数 + 添加正负号 - 设置宽度时默认在左边补全空格，该符号可设置在右边补全空格 0 用0代替空格进行补全 # 对于八进制，十六进制等，加上提示符，如八进制为0，十六进制为0x %f 可指定浮点数的宽度和精度 12345%f default width, default precision%9f width 9, default precision%.2f default width, precision 2%9.2f width 9, precision 2%9.f width 9, precision 0 %g 可指定浮点数的有效数字位数，对于12.345，%.3g 将输出 12.3 若要能对某个自定义类型输出，只要对它定义String() string方法即可： 123456func (t *T) String() string &#123; return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)&#125;// 只有当t是*T类型时，才会调用上面那个函数// 若要当t是T类型和*T类型都都调用上面那个函数，需要将上面的*T改成Tfmt.Printf("%v\n", t) log会将内容输出到stderr，且会增加一些信息（如日期时间）。 json注意只有当结构体内的成员是公开时，才能在Marshal的时候被识别，成为json文件的一部分。 进行Unmarshal时，假如json中有的字段而结构体没有，则这个字段会被忽略，不影响解析。也就是说，可进行json文件的部分解析。同理，假如Marshal时，结构体中的字段不想转到JSON文件中，可以将其tag设置为”-“。 解析时，结构体的某个字段的匹配优先级为tag -&gt; 导出名精确匹配 -&gt; 导出名模糊匹配。 omitempty表示当字段为零值时忽略它，而tag为”-“表示直接忽略它。 UnmarshalText函数和UnmarshalJSON函数的区别是什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 当不知道json文件的格式时，可这样解析b := []byte(`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`)var f interface&#123;&#125;err := json.Unmarshal(b, &amp;f)if err == nil &#123; m := f.(map[string]interface&#123;&#125;) for k, v := range m &#123; switch vv := v.(type) &#123; case string: fmt.Println(k, "is string", vv) case float64: fmt.Println(k, "is float64", vv) case []interface&#123;&#125;: fmt.Println(k, "is an array:") for i, u := range vv &#123; fmt.Println(i, u) &#125; default: fmt.Println(k, "is of a type I don't know how to handle") &#125; &#125;&#125;// 若将结构体的成员设置为指针类型，则若json不存在相应的字段，则为niltype IncomingMessage struct &#123; Cmd *Command Msg *Message&#125;// 对于流的Encoders和Decodersde := json.NewDecoder(os.Stdin)enc := json.NewEncoder(os.Stdout)for &#123; var v map[string]interface&#123;&#125; if err := dec.Decode(&amp;v); err != nil &#123; log.Println(err) return &#125; for k := range v &#123; if k != "Name" &#123; delete(v, k) &#125; &#125; if err := enc.Encode(&amp;v); err != nil &#123; log.Println(err) &#125;&#125; Basic componentpackage | import1234567891011// 任何go程序都是由package组成，首个非空单词必须是packagepackage main// 单个importimport "os"// 多个importimport ( "fmt" "math") functions形式：形参的标识符在前，类型在后；返回值放在最后面 123func add(x int, y int) int &#123; return x + y&#125; 这样做的主要原因是为了提高易读性，特别是在涉及函数变量（函数指针）的时候 12f func(func(int,int) int, int) intf func(func(int,int) int, int) func(int, int) int 同类型的形参可简写 123func add(x, y int) int &#123; return x + y&#125; 返回值可有多个 12345678func swap(x, y string) (string, string) &#123; return y, x&#125;func main() &#123; a, b := swap("hello", "world") fmt.Println(a, b)&#125; 可给返回值命名，且return可简写，注意不要在长函数中简写，因为这样会降低可读性 12345func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125; variables | constants | types首字母大写的变量称为exported name 1234type A struct &#123; Address string // exported name cost int&#125; 申明格式 12345678910111213// 单句var c, python, java bool// 有赋初值时，可省略类型名var c, python, java = true, false, "no!"d := 3// 块var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i)) 当省略类型名时，编译器会自动推测，推测规则为： 右边是变量，则和变量的类型相同 右边是常量，则有可能是int, float64, complex128 基础类型 123456789101112131415boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // alias for uint8rune // alias for int32 // represents a Unicode code pointfloat32 float64complex64 complex128 申明的变量假如没有被显式赋初值，则会被赋zero value，即数值为0，布尔类型为false，字符串为””，指针为nil 申明常量，用const，不能用:=，因为:=是和var关联的，而var代表变量。 1234func main() &#123; const World = "世界" fmt.Println("Hello", World)&#125; 没有隐式类型转换，必须显式类型转换。 类型断言，用于将空接口转换为普通类型。类型断言又分为安全类型断言和非安全类型断言。 &lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.(目标类型) // 安全类型断言 &lt;目标类型的值&gt; := &lt;表达式&gt;.(目标类型) // 非安全类型断言 在函数体内，变量申明了但不使用会报错。同理，import的package没用的话也会报错。 Go在函数体中定义了一个变量，然后将它的指针返回是合法的，比如： 123456789func NewFile(fd int, name string) *File &#123; if fd &lt; 0 &#123; return nil &#125; f := File&#123;fd, name, nil, 0&#125; return &amp;f // 或者将上面两行简写成return &amp;File&#123;fd: fd, name: name&#125; // 不难发现new(File)和&amp;File&#123;&#125;是等价的&#125; More typesPointers指针，和C不一样，Go没有指针的算术运算，即不支持p = p + 10这样的语句 Structs结构体，可将(*p).X写成p.X 1234567891011type Vertex struct &#123; X int Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // has type Vertex v2 = Vertex&#123;X: 1&#125; // Y:0 is implicit v3 = Vertex&#123;&#125; // X:0 and Y:0 p = &amp;Vertex&#123;1, 2&#125; // has type *Vertex) ArraysIn Go： Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct. 12345678910func main() &#123; var a [2]string a[0] = "Hello" a[1] = "World" fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(primes)&#125; 假如想要像C那样只传数组的地址，可以这样写： 123456789func Sum(a *[3]float64) (sum float64) &#123; for _, v := range *a &#123; sum += v &#125; return&#125;array := [...]float64&#123;7.0, 8.5, 9.1&#125;x := Sum(&amp;array) // Note the explicit address-of operator 虽然可以这么写，但不推荐，因为更优雅的方法是使用slices。 Slices切片，本身不存储实际数据，类似于引用 123456func main() &#123; primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; var s []int = primes[1:4] fmt.Println(s)&#125; 切片数组，可以改变指向的范围 123456789101112func main() &#123; r := []bool&#123;true, true, true, false, false, false&#125; t := []bool&#123;true, true, true, false, false, false&#125; fmt.Println(r) r = r[1:2] fmt.Println(r) r = r[0:3] fmt.Println(r) # 输出[true true false]，即最开始的[1,4] r = t fmt.Println(r)&#125; 切片，可省略下界或上界 cap() 查看容量，即从下界到数组最后一个元素的个数 len()查看长度，即从下界到上界的个数 切片为nil时，cap和len都为0 使用make来创建一维切片 123456789101112131415161718func main() &#123; a := make([]int, 5) printSlice("a", a) b := make([]int, 0, 5) // len(b)=0, cap(b)=5 printSlice("b", b) c := b[:2] printSlice("c", c) d := c[2:5] printSlice("d", d)&#125;func printSlice(s string, x []int) &#123; fmt.Printf("%s len=%d cap=%d %v\n", s, len(x), cap(x), x)&#125; 使用make创建二维切片，第一种方式，该方式允许第二维大小有所变化： 12345// 创建一个位数为[dx][dy]的切片a := make([][]uint8, dx)for i := range a &#123; a[i] = make([]uint8, dy)&#125; 第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖： 12345678// Allocate the top-level slice, the same as before.picture := make([][]uint8, YSize) // One row per unit of y.// Allocate one large slice to hold all the pixels.pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.// Loop over the rows, slicing each row from the front of the remaining pixels slice.for i := range picture &#123; picture[i], pixels = pixels[:XSize], pixels[XSize:]&#125; 可使用append函数向切片添加元素，假如切片容量不足，则容量会翻倍。 12345func main() &#123; var s []int s = append(s, 2, 3, 4) fmt.Println(s)&#125; 还可以使用append函数向切片中添加切片： 1234x := []int&#123;1,2,3&#125;y := []int&#123;4,5,6&#125;x = append(x, y...)fmt.Println(x) 可使用range遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用_忽略其中一个。 1234567891011func main() &#123; pow := []int&#123;4, 1, 5&#125; for _, value := range pow &#123; fmt.Printf("%d\n", value) &#125; // 只有一个值只会得到下标 for idx := range pow &#123; fmt.Printf("%d\n", pow[idx]) &#125;&#125; 缩减切片的大小： 12345678910111213141516var digitRegexp = regexp.MustCompile("[0-9]+")// uglyfunc FindDigits(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) return digitRegexp.Find(b)&#125;// elegant，缩减了切片的cap，释放内存func CopyDigits(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c&#125; Mapsmaps的零值为nil，可通过make创建map。 12345678910type Vertex struct &#123; Lat, Long float64&#125;func main() &#123; m := make(map[string]Vertex) m["Bell Labs"] = Vertex&#123; 40.68433, -74.39967, &#125; fmt.Println(m["Bell Labs"])&#125; 初始化 12345678var m = map[string]Vertex&#123; "Bell Labs": Vertex&#123; 40.68433, -74.39967, &#125;, "Google": Vertex&#123; 37.42202, -122.08408, &#125;,&#125; 初始化时，值的类型名可省略 1234var m = map[string]Vertex&#123; "Bell Labs": &#123;40.68433, -74.39967&#125;, "Google": &#123;37.42202, -122.08408&#125;,&#125; 插入键值对，取键的值，删除键值对（可多次删除，可删除不存在的键） 123456789101112131415func main() &#123; m := make(map[string]int) m["Answer"] = 42 fmt.Println("The value:", m["Answer"]) m["Answer"] = 48 fmt.Println("The value:", m["Answer"]) delete(m, "Answer") fmt.Println("The value:", m["Answer"]) v, ok := m["Answer"] fmt.Println("The value:", v, "Present?", ok)&#125; map被函数调用，可被修改。 Function values函数也可以作为值，可以像其他数据类型一样赋值给变量，作为实参等。 12345678910111213func compute(fn func(float64, float64) float64) float64 &#123; return fn(3, 4)&#125;func main() &#123; hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y) &#125; fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))&#125; Function closures函数闭包，不同变量可以绑定不同的函数闭包，相互之间不影响 1234567891011121314151617func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; Flow control statementsifif，可以没有()，但一定要有{} 123if x &lt; 0 &#123; return sqrt(-x) + "i"&#125; if可以像for那样先带个statement。假如申明了变量，则只能在if或后续的else中使用。 123456789func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf("%g &gt;= %g\n", v, lim) &#125; // can't use v here, though return lim&#125; forfor，可以没有()，但一定要有{} 123456789101112131415for i := 0; i &lt; 10; i++ &#123; sum += i&#125;// 相当于while(condition)i := 0for i &lt; 10 &#123; DoSomething(); i++;&#125;// 相当于while(true)for &#123; DoSomething();&#125; switchswitch, 满足其中一个case即执行其中的语句，不会再执行其他case的语句，可看成自带break。此外，case不一定要接整数常量，它可以不是整数，可以不是常量。但要注意case后接的类型和switch比较的类型相同。 switch同样可以像for那样先带个statement，且default的位置可放在首位，因为它总是会在所有条件都不匹配的时候才执行。 12345678910111213func main() &#123; fmt.Print("Go runs on ") switch os := runtime.GOOS; os &#123; default: // freebsd, openbsd, // plan9, windows... fmt.Printf("%s.\n", os) case "darwin": fmt.Println("OS X.") case "linux": fmt.Println("Linux.") &#125;&#125; switch还可以这样写： 1234567891011func unhex(c byte) byte &#123; switch &#123; case '0' &lt;= c &amp;&amp; c &lt;= '9': return c - '0' case 'a' &lt;= c &amp;&amp; c &lt;= 'f': return c - 'a' + 10 case 'A' &lt;= c &amp;&amp; c &lt;= 'F': return c - 'A' + 10 &#125; return 0&#125; deferdefer 推迟执行，具有LIFO的性质 123456func main() &#123; defer fmt.Printf("1 ") defer fmt.Printf("2 ") fmt.Printf("3 ") // 将输出3 2 1&#125; defer还可以这样写，参数部分的函数是会先执行的： 12345678910111213141516171819202122232425262728293031func trace(s string) string &#123; fmt.Println("entering:", s) return s&#125;func un(s string) &#123; fmt.Println("leaving:", s)&#125;func a() &#123; defer un(trace("a")) fmt.Println("in a")&#125;func b() &#123; defer un(trace("b")) fmt.Println("in b") a()&#125;func main() &#123; b()&#125;/* 输出：entering: bin bentering: ain aleaving: aleaving: b*/ Methods and interfacesMethodsGo没有class，但可以给方法（函数）指定适用的类型。method是指定类型的function。 123456789101112type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125; methord指定的类型可以是基本类型，但所指定的类型必须在本package出现。 12345678910111213type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125; methord指定的类型可以是指针，则我们可以修改指针指向的内容，并且不用产生拷贝开销。 123456789101112131415161718type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(10) fmt.Println(v.Abs())&#125; Interfaces接口，要求使用接口的类型实现了接口中方法 1234567891011121314151617181920212223242526272829303132333435type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. // a = v fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 实现接口中的方法不需要像其他语言那样使用显式的关键字，如implement。 这样做可以让申明和实现分离，不需要特殊处理就可以让他们放在不同的包中。 接口可以看成是一个二元组(value, type)，对于一个value，它会调用接收了type的方法。 假如一个变量是接口类型的，那么它有可能value和type都为nil，这种情况下会RE。而当type不为nil时，它是非空的，但是value可能会空，因此我们需要在实现接口的方法里处理好这种情况。 空接口，用于存储任何类型的数据 1234567891011121314func main() &#123; var i interface&#123;&#125; describe(i) i = 42 describe(i) i = "hello" describe(i)&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf("(%v, %T)\n", i, i)&#125; 类型断言，在断言不成立的时候应该用两个变量存储结果，否则会报错 123456789101112131415func main() &#123; var i interface&#123;&#125; = "hello" s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f)&#125; type switch 可以依次进行多个类型断言 12345678910111213141516func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf("Twice %v is %v\n", v, v*2) case string: fmt.Printf("%q is %v bytes long\n", v, len(v)) default: fmt.Printf("I don't know about type %T!\n", v) &#125;&#125;func main() &#123; do(21) do("hello") do(true)&#125; Stringer 用于输出自定义类型的接口 123type Stringer interface &#123; String() string&#125; 1234567891011121314type Person struct &#123; Name string Age int&#125;func (p Person) String() string &#123; return fmt.Sprintf("%v (%v years)", p.Name, p.Age)&#125;func main() &#123; a := Person&#123;"Arthur Dent", 42&#125; z := Person&#123;"Zaphod Beeblebrox", 9001&#125; fmt.Println(a, z)&#125; Error 用于输出错误信息的接口 123type error interface &#123; Error() string&#125; 12345678910111213141516171819202122type MyError struct &#123; When time.Time What string&#125;func (e *MyError) Error() string &#123; return fmt.Sprintf("at %v, %s", e.When, e.What)&#125;func run() error &#123; return &amp;MyError&#123; time.Now(), "it didn't work", &#125;&#125;func main() &#123; if err := run(); err != nil &#123; fmt.Println(err) &#125;&#125; Reader 用于读取数据的接口 func (T) Read(b []byte) (n int, err error) 12345678910111213func main() &#123; r := strings.NewReader("Hello, Reader!") b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf("n = %v err = %v b = %v\n", n, err, b) fmt.Printf("b[:n] = %q\n", b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125; Images 用于处理图像的接口 12345type Image interface &#123; ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color&#125; ConcurrencyGoroutines 轻型线程，它们共享同一地址的内存，需要同步控制 go f(x, y, z) 创建一个新Goroutine运行函数f Channels 可用于传递数据的一种数据类型，需要用到运算符&lt;- 123456789101112131415161718func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // send sum to c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y)&#125; Buffered Channels 可理解为大小的Channel，满了还往里面添加的话会报错 可使用range来取出channel中的所有数据，注意channel要close &lt;-ch实际上会返回两个值，第二个值代表是否还有数据，即false 表示channel close了 12345678910111213141516func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x+y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125; select用于多个channel的选择，哪个channel有数据就执行哪一个，假如同时有数据来了，就随机先执行其中一个 select中的default在没有收到任何channel数据的时候执行 sync.Mutex 用于互斥 12345678910111213141516171819202122232425262728293031323334353637import ( "fmt" "sync" "time")// SafeCounter is safe to use concurrently.type SafeCounter struct &#123; v map[string]int mux sync.Mutex&#125;// Inc increments the counter for the given key.func (c *SafeCounter) Inc(key string) &#123; c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mux.Unlock()&#125;// Value returns the current value of the counter for the given key.func (c *SafeCounter) Value(key string) int &#123; c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mux.Unlock() return c.v[key]&#125;func main() &#123; c := SafeCounter&#123;v: make(map[string]int)&#125; for i := 0; i &lt; 1000; i++ &#123; go c.Inc("somekey") &#125; time.Sleep(time.Second) fmt.Println(c.Value("somekey"))&#125; Diagnostics | 诊断pprof1234// 起手式cpuProfile, _ := os.Create("cpu_profile")pprof.StartCPUProfile(cpuProfile)defer pprof.StopCPUProfile() go tool pprof &lt;file&gt; web 启动可视化界面 top 列出cpu占比最高的函数 list &lt;function&gt; 列出指定函数的数据 Go Commandgo build假如想要玩一下go build命令，注意加上-a重新全部编译，否则会因为有缓存而跳过编译过程。 假如是main，则会编译生成可执行文件。 否则，只会编译，不产生文件，用于验证代码能否编译。 go install假如是main，则会在$GOPATH/bin下生成可执行文件。 否则，会在$GOPATH/pkg下生成*.a文件。 go get12# 升级包go get -u &lt;package&gt; go clean删除编译生成的文件等等。 依赖管理工具Dep1234567891011# 初始化，-v参数代表输出详细信息dep init -v# 解决依赖的BUGdep ensure -v# 更新依赖，假如总是更新失败，先dep ensure -v一下，并选择在网络空闲的时候更新dep ensure -update -v# 添加一条依赖dep ensure -add github.com/bitly/go-simplejson Go Mod拉取速度比Dep要快很多。 1234567891011121314# 设置环境变量export GO111MODULE=on# 初始化，生成go.mod文件go mod init# 之后即可使用go build或go test拉取依赖go build/test# 升级所有依赖到最新go get -u# 将依赖放在项目的vendor中go mod vendor 假如遇到某个依赖有问题，更把那个依赖删掉，然后再go get -u升级所有依赖。]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财入门]]></title>
    <url>%2F2019%2F07%2F13%2Ffinancial-management%2F</url>
    <content type="text"><![CDATA[背景前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理财，同时也是提高自我认知的过程。此博文记录了自己的理财学习之路，希望能对读者有些帮助。 正文管理好自己的财产的第一步，是要对自己的支出收入情况有所了解。假如一个人对自己的收支情况一点不了解，就算中了百万彩票，挥金如土，也会很快被挥霍完。而假如一个人对于自己的收支情况了然于胸，量入为出，才能过得很踏实。 在这里，通过一番比较后，我选择了复式记账法，并采用了beancount和fava这两个工具。网上介绍这两个工具的好文章已有不少，这里不再赘述使用方法，而只提一下它的优点。beancount，它是开源的，它可以让你以纯文本的形式记账，并将数据保存在自己的电脑上，保证了数据的可移植性和安全性，无需支付额外费用，使用成本低。另外，利用fava可将数据可视化，可以直观地看到自己的财务情况，非常方便。 很多人之所以不能坚持记账，大多数是因为记账太过繁琐，且记账产生的数据像一潭死水，无法产生实际的指导价值。而用beancount+fava，可以克服这两个缺点。现在大多数网站，比如支付宝和微信支付，都可以导出账单，我们不难写个脚本将其转化成符合beancount语法的文本数据。fava将数据可视化后，含有损益表、资产负债表、试算表、资产、统计等界面，可以很直观地看到自己的收支情况、资产负债情况等。这些东西需要一些财务知识才能理解，我主要通过搜索引擎+看书来学习，这里推荐一本书，书名叫《给创业小白的财报书》，豆瓣评分9.0，值得一读。 我认为实现财务自由最关键的是增加收入以及通过投资来增加净资产。增加净资产，可以通过购买债券、基金、股票、房地产等方式。待所购资产实现增值后，我们的净资产也就增加了。现在我对于存款的处理方式是直接购买基金，因为比较方便。但是购买基金是一种低风险低收益的投资活动，虽然可以实现财富增长，但若想尽快实现财务自由这个目标，依靠此方式是行不通的。所以有必要去学习其他投资方式，这里挖个坑，以后学了再补上。 虽然财务自由听起来很虚幻很遥远，但是我觉得通过一定的努力是能够达到的。当然，每个人对于财务自由的定义会有所不同，我自己的要求比较低，资产所产生的收益能超过日常开销即算财务自由。共勉。]]></content>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 简明手册 | 学习笔记]]></title>
    <url>%2F2019%2F07%2F02%2Fgit-book%2F</url>
    <content type="text"><![CDATA[迭代记录 190702 首次提交 文件 全局配置文件：~/.gitconfig 项目配置文件：&lt;project&gt;/.git/config 命令git add12345678# 添加文件到仓库git add &lt;FILE&gt;# 把当前所有位置的所有文件都添加到仓库中git add .# 允许指定add具体哪些内容，使用?查看选项的解释git add -p git branch12345678910111213141516171819202122232425# 查看本地分支git branch# 查看远程分支git branch -r# 查看本地分支+远程分支git branch -a# 创建分支git branch &lt;name&gt;# 删除分支git branch -d &lt;name&gt;# 删除远程分支git branch -dr [remote/branch]# 新建一个分支，与指定的分支建立追踪关系，一般是对远程分支建立追踪关系git branch --track [newBranch] [remote/branch]# eggit branch --track mage origin/mage# 建立追踪关系，在现有分支与指定的远程分支之间 | 已经弃用git branch --set-upstream [branch] [remote/branch] git checkout1234567891011121314# 切换到上一个分支git checkout -# 撤销对当前工作区文件的修改。其中--的作用是表明后面的参数是文件名，而不是分支名。git checkout -- FILE# 切换分支git checkout &lt;name&gt;# 创建+切换分支git checkout -b &lt;name&gt;# 在origin/master的基础上，创建一个新分支。git checkout -b &lt;name&gt; origin/master git cherry-pick12# 选择一个commit，合并进当前分支git cherry-pick [commit] git clone12345# 只克隆仓库的最新一个版本，对于多次提交的仓库可明显提高clone速度git clone --depth=1 仓库地址# 使用-o指定远程分支名，假如不指定，默认是origingit clone -o jQuery https://github.com/jquery/jquery.git git commit123456789101112# 把文件提交到仓库git commit# 可以选择部分文件commitgit commit &lt;file1&gt; &lt;file2&gt;...# 使用一次新的commit，替代上一次提交# 它一般适用于还未提交到远程仓库的提交，也适用于gerrit，不适用于Githubgit commit --amend# 不更改评论信息git commit --amend --no-edit git config123456789# 设置提交代码时的用户信息。git config [--global] user.name "Username"git config [--global] user.email "email@example.com"# 显示当前的git配置。git config --list# 编辑Git配置文件。git config -e [—global] git diff12# 可以将FILE现在的状态和最近一次add到仓库的状态进行一次diff。git diff FILE git fetch123456789101112# 取回分支，但是并不合并。git fetch &lt;远程主机名&gt; &lt;分支名&gt; # 指定取哪个分支，默认情况下会取所有分支。git fetch &lt;分支名&gt;# 取回远程分支到本地某个分支，假如本地分支不存在，则创建。不会切换到该分支。git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git fetch origin :branch2# 等价于git fetch origin master:branch2 git init12# 初始化仓库git init git log12# 查看commit日志git log git merge12# 合并指定分支到当前分支git merge [branch] git mv12# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] git pull1234567891011121314# 某些部分可省略。git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 上面命令表示，取回origin/next分支，再与当前分支合并。git pull origin next# 上面命令指定master分支追踪origin/next分支。git branch --set-upstream master origin/next# 上面命令表示，本地的当前分支自动与对应的origin主机"追踪分支"进行合并。git pull origin# 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。git pull git push1234567891011121314# 标准格式git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。git push -u origin master# 将本地分支推送到远程主机。gut push origin &lt;本地分支名&gt;# 删除远程分支。git push origin --delete &lt;name&gt;# 提交所有taggit push [remote] --tags git rebase12 git reflog12# 查看引用日志，可以回到“未来”。git reflog git remote1234567891011121314151617# 列出所有远程主机。git remote# 可以参看远程主机的网址。git remote -v# 查看主机的详细信息。git remote show &lt;主机名&gt;# 用于删除远程主机。git remote rm &lt;主机名&gt;# 用于远程主机的改名。git remote rename &lt;原主机名&gt; &lt;新主机名&gt;# 将仓库连接到远程服务器。一般是在git init后使用，绑定远程主机。git remote add origin &lt;server&gt; git reset12345678# 撤销对当前缓存区的修改，相当于`git add`的反操作。git reset -- &lt;file&gt;# 撤销对当前缓存区的修改。git reset HEAD &lt;file&gt;# 让HEAD指针指到commit_id代表的状态。顺便一提，HEAD^表示上一个状态，HEAD^^表示上上个状态。git reset --hard commit_id git revert12# 远程分支git revert git rm12345# 删除工作区文件，并且将这次删除放入暂存区。即删除远程文件和本地文件。git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区。即删除远程文件，但不删除本地文件。git rm --cached [file] git status12# 查看仓库当前的状态git status git tag1234567891011121314# 添加了tag的commit就会将源码添加到打包，一般用版本号为tag命名# 在Github上看到的release不是git提供的，而是代码托管网站出于满足开发者发布二进制文件的需求而开发的# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 题解 C++ 链表总结]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-linked-list%2F</url>
    <content type="text"><![CDATA[总结 有时候加个冗余头节点会大大降低实现难度，让代码变得更简洁。 做与链表相关的题目一定要在写代码前就想清楚算法的各个步骤，想好要保存哪些指针。否则很容易写乱。 要注意delete掉删除掉的节点，避免内存泄露。 Leetcode 2 Add Two Numbers题意用链表存储十进制数字的各位，现在给这样的两个链表，求和。 分析由于链表头存的是最低位，所以我们可以同时扫描两个链表，模拟一下加法就行了。假如用C++写的话，可以先开一个冗余头指针，方便实现。注意申请或释放内存时，应该要用new和delete而不要用malloc和free，养成良好的编程习惯。假设两个链表的长度分别为n和m，那么时间复杂度和空间复杂度都是$O(n + m)$，显然空间复杂度可以优化到$O(1)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *dummy = new ListNode(0); ListNode *p = dummy; int carry = 0; while (l1 || l2) &#123; int x = l1 ? l1-&gt;val : 0; int y = l2 ? l2-&gt;val : 0; int sum = x + y + carry; carry = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; &#125; if (carry) p-&gt;next = new ListNode(1); p = dummy-&gt;next; delete dummy; return p; &#125;&#125;; Leetcode 19 Remove Nth Node From End of List题意给一个链表，要求删除倒数第n个节点。 分析这道题的边界情况是删除链表首个节点。我们用两个指针指向表头，然后让其中一个指针先走n步，假如走完n步后指向了空指针，说明删除的是表头。假如走完不是空指针，则让另外一个指针开始和它一步一步走，直到前面的指针指到了最后一个节点时，后面的指针刚好指向待删除节点的前一个节点。这样做的时间复杂度是$O(n)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int k) &#123; if (head == nullptr || k &lt;= 0) return nullptr; ListNode *behind = head, *ahead = head; for (int i = 0; i &lt; k; i++) &#123; ahead = ahead-&gt;next; &#125; if (ahead == nullptr) &#123; ListNode *temp = head; head = head-&gt;next; delete(temp); return head; &#125; while (ahead-&gt;next != nullptr) &#123; ahead = ahead-&gt;next; behind = behind-&gt;next; &#125; ListNode *temp = behind-&gt;next; behind-&gt;next = behind-&gt;next-&gt;next; delete(temp); return head; &#125;&#125;; Leetcode 21 Merge Two Sorted Lists题意合并两个有序链表。 分析直接写就行了，时间复杂度为$O(n+m)$，其中n和m为两个链表的长度。 代码1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummy = new ListNode(0); ListNode *p = dummy; while(l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; p-&gt;next = l1 ? l1 : l2; p = dummy-&gt;next; delete(dummy); return p; &#125;&#125;; Leetcode 23 Merge k Sorted Lists题意合并k个有序链表。 分析我们需要一种数据结构来较快地插入一个数，取出最小的数，删除最小的数。不难想到优先队列可以满足这些要求。假设k个链表的节点个数和为n，则时间复杂度为$O(nlogk)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;private: struct Node &#123; ListNode *p; int idx; Node(ListNode *p, int idx) &#123; this-&gt;p = p; this-&gt;idx = idx; &#125; bool operator &lt; (const Node &amp;rhs) const &#123; return p-&gt;val &gt; rhs.p-&gt;val; &#125; &#125;;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; priority_queue&lt;Node&gt; que; for (int i = 0; i &lt; lists.size(); i++) &#123; if (lists[i]) &#123; que.push(Node(lists[i], i)); lists[i] = lists[i]-&gt;next; &#125; &#125; ListNode *dummy = new ListNode(0); ListNode *p = dummy; while(!que.empty()) &#123; Node node = que.top(); que.pop(); if (lists[node.idx] != nullptr) &#123; int idx = node.idx; que.push(Node(lists[idx], idx)); lists[idx] = lists[idx]-&gt;next; &#125; p-&gt;next = node.p; p = p-&gt;next; &#125; p = dummy-&gt;next; delete(dummy); return p; &#125;&#125;; Leetcode 24 Swap Nodes in Pairs题意两两交换链表的相邻节点。 分析递归来写，分三种情况，当前节点是空节点，当前节点没有后继，当前节点有后继。 代码12345678910111213141516class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (head == nullptr) &#123; return nullptr; &#125; if (head-&gt;next == nullptr) &#123; return head; &#125; ListNode *newHead = head-&gt;next; ListNode *nex = head-&gt;next-&gt;next; newHead-&gt;next = head; head-&gt;next = swapPairs(nex); return newHead; &#125;&#125;; Leetcode 25 Reverse Nodes in k-Group题意是Leetcode 24的升级版，需要将链表的每k个节点翻转。 分析用迭代来写，先加个冗余头节点，方便实现。需要记录k节点组的前一个节点p，第一个节点head，最后一个节点tail。然后，我们不断地将p的后一个节点扔到tail的后面即可。 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (head == nullptr || head-&gt;next == nullptr || k &lt; 2) return head; ListNode *dummy = new ListNode(0); dummy-&gt;next = head; ListNode *p = dummy, *tail = dummy, *temp = nullptr; while (true) &#123; int count = 0; while (count != k &amp;&amp; tail != nullptr) &#123; tail = tail-&gt;next; count++; &#125; if (tail == nullptr) &#123; break; &#125; head = p-&gt;next; while (p-&gt;next != tail) &#123; temp = p-&gt;next; p-&gt;next = temp-&gt;next; temp-&gt;next = tail-&gt;next; tail-&gt;next = temp; &#125; p = tail = head; &#125; p = dummy-&gt;next; delete(dummy); return p; &#125;&#125;; Leetcode 61 Rotate List题意回转链表，注意不是反转链表。 分析分三步，首先求出链表长度以及最后一个节点，然后找到回转后的首个节点的前继，最后修改一下它们的指针即可。 代码1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if (head == nullptr) return nullptr; ListNode *p = head, *lastNode; int len = 1; while (p-&gt;next) &#123; len++; p = p-&gt;next; lastNode = p; &#125; k %= len; if (k == 0) return head; k = len - k - 1; ListNode *pre = head; while (k--) &#123; pre = pre-&gt;next; &#125; lastNode-&gt;next = head; head = pre-&gt;next; pre-&gt;next = nullptr; return head; &#125;&#125;; Leetcode 82 Remove Duplicates from Sorted List II题意删除有序链表中的重复元素。 分析申请个冗余节点会比较好实现点。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *dummy = new ListNode(0); ListNode *p = dummy; while (head) &#123; ListNode *p2 = head; while (p2-&gt;next &amp;&amp; p2-&gt;next-&gt;val == head-&gt;val) &#123; p2 = p2-&gt;next; &#125; if (head != p2) &#123; while (head != p2) &#123; ListNode *temp = head-&gt;next; delete(head); head = temp; &#125; head= p2-&gt;next; delete(p2); &#125; else &#123; p-&gt;next = head; p = p-&gt;next; head = head-&gt;next; p-&gt;next = nullptr; &#125; &#125; ListNode *temp = dummy-&gt;next; delete(dummy); return temp; &#125;&#125;; Leetcode 83 Remove Duplicates from Sorted List题意删除有序链表中的多余的重复元素，即要保证每个元素最多出现一次。 分析直接扫一遍就行了，注意delete掉删掉的节点。 代码12345678910111213141516class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *cur = head; while (cur &amp;&amp; cur-&gt;next) &#123; if (cur-&gt;next-&gt;val == cur-&gt;val) &#123; ListNode *temp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete(temp); &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return head; &#125;&#125;; Leetcode 86 Partition List留坑待填。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 题解 C++ Two Sum | 3Sum | 4Sum]]></title>
    <url>%2F2019%2F03%2F01%2Fleetcode-sum%2F</url>
    <content type="text"><![CDATA[Leetcode 1 Two Sum题意给一个vector，从中找出两个不同下标的元素，使得它们的值等于某一个值。 分析 法一：先排序，然后双指针扫一遍。时间复杂度是$O(nlogn)$，空间复杂度是$O(logn)$。 法二：哈希，空间换时间。时间复杂度$O(n)$，空间复杂度是$O(n)$。 下面给出法二的代码。 代码123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); i++) &#123; int diff = target - nums[i]; auto it = m.find(diff); if (it != m.end()) &#123; vector&lt;int&gt; ans; ans.push_back(it-&gt;second); ans.push_back(i); return ans; &#125; m[nums[i]] = i; &#125; return vector&lt;int&gt;(-1, -1); &#125;&#125;; Leetcode 15 3Sum题意给一个vector，从中找出所有三个不同下标的元素，使得它们的值等于0。另外要求三元组不能重复。 分析先排序，然后利用有序性，将原本需要三层循环的遍历用一层循环 + 双指针来做。时间复杂度是$O(n^2)$。用C++写的话，需要注意vector的size()函数返回的是vector::size_type，一般是unsigned int。因此，假如传进来的vector的元素个数少于2，那么num.size() - 2运算后得到的是一个很大的正数，造成运行错误。所以，我们可以先判断一下nums.size()的大小，假如小于3，那么就直接返回了。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if (nums.size() &lt; 3) return ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (i == 0 || (nums[i] != nums[i-1])) &#123; int need = 0 - nums[i]; int lo = i + 1; int hi = nums.size() - 1; while (lo &lt; hi) &#123; if (nums[lo] + nums[hi] == need) &#123; ans.push_back(vector&lt;int&gt; &#123;nums[i], nums[lo], nums[hi]&#125;); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+1]) &#123; lo++; &#125; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi-1]) &#123; hi--; &#125; lo++, hi--; &#125; else if (nums[lo] + nums[hi] &lt; need) &#123; lo++; &#125; else &#123; hi--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; Leetcode 18 4Sum题意给一个vector，从中找出所有四个不同下标的元素，使得它们的值等于某个值。另外要求四元组不能重复。 分析先排序，然后利用有序性，将原本需要四层循环的遍历用两层循环 + 双指针来做。时间复杂度是$O(n^3)$。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i &lt; n - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int lo = j + 1; int hi = n - 1; while (lo &lt; hi) &#123; int sum = nums[i] + nums[j] + nums[lo] + nums[hi]; if (sum == target) &#123; ans.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[lo], nums[hi]&#125;); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) &#123; lo++; &#125; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) &#123; hi--; &#125; lo++, hi--; &#125; else if (sum &gt; target) &#123; hi--; &#125; else &#123; lo++; &#125; &#125; &#125; &#125; return ans; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 题解 C++ Single Number I II III]]></title>
    <url>%2F2019%2F01%2F13%2Fleetcode-single-number%2F</url>
    <content type="text"><![CDATA[在Leetcode上做了Single Number系列的三道题，都是与位运算有关的，感觉都挺巧妙。 Leetcode 136 Single Number I题意一组数中只有一个数字是出现一次的，其他的数字都恰好出现两次，现在求只出现一次的数是多少。 分析根据异或的性质，答案是所有的数字的异或和。 代码12345678class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); i++) nums[0] ^= nums[i]; return nums[0]; &#125;&#125;; Leetcode 137 Single Number II题意一组数中只有一个数字是出现一次的，其他的数字恰好都出现三次，现在求只出现一次的数是多少。 分析显然，假如还是用上一题的做法，直接将数字异或起来，是得不到答案的。为什么上一题的答案直接异或起来就可以，因为出现两次的数字异或后等于出现零次，具体对于某一位来说，它会经过0-&gt;1-&gt;0这么个过程。而对于这道题，假如某个数字出现了三次，那么对于具体某一位来说，它会经过0-&gt;1-&gt;0-&gt;1这个过程。因此，我们应用两个位来表示具体某一位的状态变化，即让它经过00-&gt;10-&gt;01-&gt;00这么个过程。 代码123456789101112class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ones = 0; int twos = 0; for (auto i: nums) &#123; ones = (ones ^ i) &amp; ~twos; twos = (twos ^ i) &amp; ~ones; &#125; return ones; &#125;&#125;; Leetcode 260 Single Number III题意一组数中只有两个数字是出现一次的，其他的数字恰好都出现两次，现在求只出现一次的数是哪两个。 分析我们先将所有数字异或起来，得到c。设答案为a和b，那么c = a ^ b。 对于这个c的各个位，有的是0，有的是1。值为1的位，意味着只属于a或b。因此，我们可以任意取c中一个值为1的位，将所有数字划分为两个可重集合，这两个集合的数字分别异或起来就是答案。 代码12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (auto i: nums) &#123; sum ^= i; &#125; sum &amp;= -sum; vector&lt;int&gt; ans = &#123;0, 0&#125;; for (auto i: nums) &#123; if (sum &amp; i) &#123; ans[0] ^= i; &#125; else &#123; ans[1] ^= i; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>位运算</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机学习笔记]]></title>
    <url>%2F2018%2F10%2F06%2Fsam-learning%2F</url>
    <content type="text"><![CDATA[后缀自动机(SAM)是一种用于处理字符串的高效数据结构，时间复杂度为$O(|S| * CHARSET_SIZE)$。其应用一般与子串有关，比如求解最长公共子串、求解不同子串的个数、求字典序第k小的子串。 题目传送门 SPOJ LCS Longest Common Substring题意给两个字符串，求它们的最长公共子串。 分析由于字符串长度上限250000，所以$O(n^2)$的算法是行不通的。我们可以考虑给其中一个字符串建立后缀自动机，该自动机保存了这个字符串的所有子串。接着，我们在这个自动机上跑另一个字符串，假如匹配，就走下一步，假如不匹配，就走失配指针，直到匹配或者回到了根节点。在这个过程中，维护一下匹配的长度，不断取max即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 250009;/************************************************************//* 后缀自动机(Tested 4 times) * 数组实现，效率较高 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; 26; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s) &#123; int ans = 0, now = 1, le = strlen(s), cnt = 0; for(int i = 0; i &lt; le; i++) &#123; int to = s[i] - 'a'; if(ch[now][to]) &#123; ans = max(ans, ++cnt); now = ch[now][to]; &#125; else &#123; while(now &amp;&amp; !ch[now][to]) now = fail[now]; if(now) &#123; cnt = len[now] + 1; now = ch[now][to]; ans = max(ans, cnt); &#125; else &#123; now = 1; cnt = 0; &#125; &#125; &#125; printf("%d\n", ans); &#125;&#125;sam;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; sam.init(); scanf("%s", s); int len = strlen(s); for(int i = 0; i &lt; len; i++) sam.insert(s[i]); scanf("%s", s); sam.solve(s); return 0;&#125; SPOJ LCS2 Longest Common Substring II题意给n($2 &lt;= n &lt;= 10$)个字符串，求它们的最长公共子串。 分析这一题在上一题的基础上进行了一定的拓展。我们还是给其中一个字符串建立后缀自动机，然后将其余字符串在自动机上跑一遍。在每个节点上，我们需要维护一个$f$，表示所有字符串到达该结点时的最大匹配长度，初始化为第一个字符串的在该点的$len$。当其余字符串进来匹配的时候，用当前最大匹配长度来更新这个$f$，不断取min。这里需要注意的是，某个结点$u$被访问到，但其后缀链指向的结点$v$可能没被访问到，但是，根据SAM后缀树的性质，$v$结点表示的最大子串是会被完全匹配的。所以，我们将字符串在自动机跑完一遍后，还需要根据拓扑序再反向更新一下。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 后缀自动机(Tested 4 times) * 数组实现，效率较高 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], mat[MAXN], f[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; 26; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void pre() &#123; for(int i = 1; i &lt; sz; i++) mat[i] = INF; &#125; void update(char *s) &#123; int le = strlen(s), lenn = 0, now = 1; for(int i = 1; i &lt; sz; i++) &#123; f[i] = 0; &#125; for(int i = 0; i &lt; le; i++) &#123; int ne = s[i] - 'a'; while(now != 1 &amp;&amp; !ch[now][ne]) now = fail[now], lenn = len[now]; if(ch[now][ne]) &#123; now = ch[now][ne]; f[now] = max(f[now], ++lenn); &#125; &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; // 这一句非常精髓啊 if(f[topo[i]]) f[fail[topo[i]]] = len[fail[topo[i]]]; &#125; for(int i = 1; i &lt; sz; i++) &#123; mat[i] = min(mat[i], f[i]); &#125; &#125; void solve() &#123; int ans = 0; for(int i = 1; i &lt; sz; i++) ans = max(ans, mat[i]); printf("%d\n", ans); &#125;&#125;sam;/************************************************************/char s[N];int len;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", s); sam.init(); len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.topoSort(); sam.pre(); while(~scanf("%s", s)) &#123; sam.update(s); &#125; sam.solve(); return 0;&#125; SPOJ NSUBSTR Substrings题意根据子串的长度，可将一个长为$|S|$的字符串的所有子串分到$|S|$个集合中。问在各个集合中，在母串中出现次数最多的子串的出现次数？ 分析要统计某一子串出现的次数，需要按照拓扑序逆着更新。当访问到某一节点时，我们把最大长度子串所属集合的答案更新一下，然后传递一下$cntPos$给失配指针所指的结点。我们知道，一个结点表示了多个子串，为什么只更新最大长度子串所属的集合就行了呢？可以这样理解，假设某一节点的最大长度子串为$S[L…R]$，根据SAM的性质，$S[L..(R-1)]$一定不与S[L…R]$在同一结点，且它出现的次数不少于$S[L…R]$，因此，后续访问到该结点时会更新$(R-1)$的答案，而长度更短的同理，也是会被更新到。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 250009;char s[N];/************************************************************//* 后缀自动机(Tested 2 times) * 数组实现，效率较高 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;-1&#125;, fail[MAXN], sz = 2, last = 1, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; memset(ch, 0, sizeof ch); memset(fail, 0, sizeof fail); memset(len, 0, sizeof len); memset(tong, 0, sizeof tong); memset(cntPos, 0, sizeof cntPos); last = 1; sz = 2; tong[0] = 1; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = last = sz++; cntPos[u] = 1; len[u] = len[v] + 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = sz++; len[n] = len[v] + 1; cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s) &#123; int ans[MAXN]; int le = strlen(s); memset(ans, 0, sizeof ans); for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; ans[len[u]] = max(ans[len[u]], cntPos[u]); // ? cntPos[fail[u]] += cntPos[u]; &#125; for(int i = 1; i &lt;= le; i++) &#123; printf("%d\n", ans[i]); &#125; &#125;&#125;sam;/************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%s", s)) &#123; sam.init(); int len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.topoSort(); &#125; sam.solve(s); return 0;&#125; SPOJ SUBLEX Lexicographical Substring Search题意给一个字符串，求字典序第k小的子串。 分析首先给字符串建立SAM，该SAM保存该字符串的所有子串。接着，从根出发，dfs一遍，对各个结点统计从该结点出发的子串数。然后，我们再从根出发，贪心地走字符较小的边。假如一条边到达的结点的子串数大于等于k，那么这条边就可以走。否则，我们减去该结点的子串数，然后找另一条边。一直做下去，直到k等于0了就停止。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 后缀自动机(Tested 3 times) * 数组实现，效率较高 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点pii G[MAXN][26];int ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;-1&#125;, fail[MAXN], sz = 2, last = 1, cntPos[MAXN];int tong[MAXN], topo[MAXN];int path[MAXN], p[MAXN];struct SuffixAutomaton &#123; void init() &#123; last = 1; sz = 2; tong[0] = 1; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = last = sz++; cntPos[u] = 1; len[u] = len[v] + 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = sz++; len[n] = len[v] + 1; cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; int cntPath(int u) &#123; if(path[u]) return path[u]; p[u] = 0; for(int i = 0; i &lt; 26; i++) &#123; if(ch[u][i]) &#123; path[u] += cntPath(ch[u][i]); G[u][p[u]++] = pii(ch[u][i], i); &#125; &#125; path[u]++; return path[u]; &#125; // 注意用递归写法会超时 void findK(int u, int k) &#123; while(k) &#123; for(int i = 0; i &lt; p[u]; i++) &#123; int v = G[u][i].x; if(v &amp;&amp; path[v] &gt;= k) &#123; printf("%c", G[u][i].y + 'a'); k--; u = v; break; &#125; else &#123; k -= path[v]; &#125; &#125; &#125; printf("\n"); &#125;&#125;sam;/************************************************************/char ss[N];int q, lenn, k;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", ss); sam.init(); lenn = strlen(ss); for(int i = 0; i &lt; lenn; i++) sam.insert(ss[i]); scanf("%d", &amp;q); sam.cntPath(1); while(q--) &#123; scanf("%d", &amp;k); sam.findK(1, k); &#125; return 0;&#125; SPOJ COT4 Count on a trie留坑待填。 HDU 4416 Good Article Good sentence题意给一个字符串，可以有很多子串，记为集合A。然后再给一些字符串，同样可以有很多子串，记为集合B。现在需要求集合A和集合B的差的大小，即在A集合里出现但不在B集合里出现的元素个数。 分析首先给第一个字符串建立SAM，然后依次将其余的字符串取更新这个SAM。SAM中的各个结点需要保存一个值f，表示被其余字符串匹配到最大长度。对于某一结点u，f初始化为len[fail[u]]。这里需要注意的是，同多个字符串的最长公共子串问题一样，在匹配完整个字符串后，还需要根据拓扑序逆着更新f一下。最后，所有节点的len - f的和即为答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 后缀自动机(Tested 4 times) * 数组实现，效率较高 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;-1&#125;, fail[MAXN], sz = 2, last = 1, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; int f[MAXN]; bool vis[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; 26; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; MAXN; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void pre() &#123; memset(vis, 0, sizeof vis); for(int i = 1; i &lt; sz; i++) &#123; f[i] = len[fail[i]]; &#125; &#125; void update(char *s) &#123; int up = strlen(s), now = 1, le = 0; for(int i = 0; i &lt; up; i++) &#123; int v = s[i] - 'a'; while(now != 1 &amp;&amp; !ch[now][v]) now = fail[now], le = len[now]; if(ch[now][v]) &#123; now = ch[now][v]; vis[now] = true; le++; f[now] = max(f[now], le); &#125; &#125; &#125; void solve() &#123; for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; if(vis[u]) &#123; vis[fail[u]] = true; f[fail[u]] = len[fail[u]]; &#125; &#125; ll ans = 0; for(int i = 1; i &lt; sz; i++) &#123; ans += len[i] - f[i]; &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/int T, n, kase;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; printf("Case %d: ", ++kase); scanf("%d", &amp;n); scanf("%s", s); sam.init(); int len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.pre(); sam.topoSort(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); sam.update(s); &#125; sam.solve(); &#125; return 0;&#125; POJ 3415 Common Substrings题意给两个字符串，求所有长度大于k的公共子串的对数。 分析我们知道，SAM中某个节点代表的是长度连续的数个后缀，不妨设长度为$[L, R]$。在匹配的过程中，长度会落在$[L, R]$之间，我们只需要加上$[k, R]$的这段（可能为空）。另外，还需要按照拓扑序逆着更新一下，这里的更新需要是需要计数的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;int k;char s[N], t[N];/************************************************************//* 后缀自动机(Tested 5 times) * 数组实现，效率较高 * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 59;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; int sum[MAXN], vis[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; CHARSET_SIZE; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'A'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; sz; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s) &#123; topoSort(); for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; cntPos[fail[u]] += cntPos[u]; vis[i] = sum[i] = 0; &#125; int now = 1, le = 0; ll ans = 0; for(int i = 0, up = strlen(s); i &lt; up; i++) &#123; int v = s[i] - 'A'; while(now != 1 &amp;&amp; !ch[now][v]) now = fail[now], le = len[now]; if(ch[now][v]) &#123; now = ch[now][v]; le++; vis[now]++; if(le &gt;= k) &#123; ans += 1LL * cntPos[now] * (le - max(len[fail[now]] + 1, k) + 1); &#125; &#125; &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; if(vis[u]) &#123; sum[fail[u]] += vis[u]; vis[fail[u]] += vis[u]; &#125; &#125; for(int i = 1; i &lt; sz; i++) &#123; if(len[i] &gt;= k) &#123; ans += 1LL * sum[i] * cntPos[i] * (len[i] - max(len[fail[i]] + 1, k) + 1); &#125; &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d", &amp;k) &amp;&amp; k) &#123; scanf("%s%s", s, t); sam.init(); for(int i = 0, len = strlen(s); i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.solve(t); &#125; return 0;&#125; HDU 3518 Boring counting题意分析首先给字符串建立SAM，对于各个结点，需要额外维护最长子串首先出现的位置以及最后出现的位置。最后出现的位置需要按照拓扑序逆着来更新。然后扫一遍，根据某个结点代表的最短字符串、最长字符串与最长子串首先出现、最后出现位置，分情况讨论一下即可。一开始没有注意到出现次数大于等于2这个条件，多想了一下。假如要求出现次数大于等于k的话，那么我们可能需要维护的是各个节点的最长子串出现的具体位置，这可能需要就需要用到LCT来维护了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 后缀自动机(Tested 6 times) * 数组实现，效率较高 * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], l[MAXN], r[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); memset(l, -1, sizeof l); memset(r, -1, sizeof r); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; CHARSET_SIZE; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c, int po) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; l[u] = r[u] = po; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; l[n] = r[n] = l[o]; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; sz; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve() &#123; topoSort(); for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; r[fail[u]] = max(r[fail[u]], r[u]); &#125; ll ans = 0; for(int i = 1; i &lt; sz; i++) &#123; if(len[i] &lt;= r[i] - l[i]) &#123; ans += len[i] - len[fail[i]]; &#125; else &#123; ans += max(0, r[i] - l[i] - len[fail[i]]); &#125; &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%s", s) &amp;&amp; s[0] != '#') &#123; sam.init(); for(int i = 0, up = strlen(s); i &lt; up; i++) &#123; sam.insert(s[i], i); &#125; sam.solve(); &#125; return 0;&#125; HDU 4622 Reincarnation题意给一个字符串，然后有$Q$次询问，求该字符串$[L, R]$本质不同的字符串个数。 分析首先建立SAM，然后对于每次询问，分别处理，维护的是最大匹配长度。然后，扫一遍各个节点，累加最大匹配长度 - 最小字符串 + 1 即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;#define okd(d) cout &lt;&lt; "ok " &lt;&lt; d &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 2009;/************************************************************//* 后缀自动机(Tested 7 times) * 数组实现，效率较高 * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416 * 时间复杂度：O(n * CHARSET_SIZE) * used variables: N, */const int CHARSET_SIZE = 26;const int MAXN = N &lt;&lt; 1; // 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点struct SuffixAutomaton &#123; int ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN]; int tong[MAXN], topo[MAXN]; void init() &#123; len[0] = 0; sz = 1; last = newnode(0); &#125; int newnode(int le) &#123; len[sz] = le; fail[sz] = 0; for(int i = 0; i &lt; CHARSET_SIZE; i++) ch[sz][i] = 0; return sz++; &#125; void insert(int c) &#123; c -= 'a'; int v = last, u = newnode(len[v] + 1); last = u; cntPos[u] = 1; for(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u; if(!v)&#123;fail[u] = 1; return;&#125; int o = ch[v][c]; if(len[v] + 1 == len[o]) fail[u] = o; else &#123; int n = newnode(len[v] + 1); cntPos[n] = 0; memcpy(ch[n], ch[o], sizeof(ch[0])); fail[n] = fail[o]; fail[u] = fail[o] = n; for(; ch[v][c] == o; v = fail[v]) ch[v][c] = n; &#125; &#125; void topoSort() &#123; memset(tong, 0, sizeof tong); tong[0] = 1; for(int i = 1; i &lt; sz; i++) tong[len[i]]++; for(int i = 1; i &lt; sz; i++) tong[i] += tong[i - 1]; for(int i = sz - 1; i &gt;= 1; i--) topo[--tong[len[i]]] = i; &#125; void solve(char *s, int l, int r) &#123; int now = 1, le = 0, f[MAXN]; ll ans = 0; memset(f, 0, sizeof f); for(int i = l; i &lt;= r; i++) &#123; int v = s[i] - 'a'; now = ch[now][v]; le++; f[now] = max(f[now], le); &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; int u = topo[i]; if(f[u]) &#123; f[fail[u]] = len[fail[u]]; &#125; &#125; for(int i = sz - 1; i &gt;= 1; i--) &#123; ans += max(0, f[i] - len[fail[i]]); &#125; printf("%lld\n", ans); &#125;&#125;sam;/************************************************************/int n, T, l, r;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%s", s); sam.init(); for(int i = 0, len = strlen(s); i &lt; len; i++) &#123; sam.insert(s[i]); &#125; sam.topoSort(); scanf("%d", &amp;n); while(n--) &#123; scanf("%d%d", &amp;l, &amp;r); sam.solve(s, l - 1, r - 1); &#125; &#125; return 0;&#125; HDU 4436 str2int留坑待填。]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四则运算项目折腾笔记]]></title>
    <url>%2F2018%2F09%2F30%2Farithmetic-problems-generator%2F</url>
    <content type="text"><![CDATA[Github项目地址传送门 项目相关要求 (完成)使用 -n 参数控制生成题目的个数。 (完成)使用 -r 参数控制题目中数值（自然数、真分数和真分数分母）的范围。该参数可以设置为1或其他自然数。该参数必须给定，否则程序报错并给出帮助信息。 (完成)生成的题目中计算过程不能产生负数，也就是说算术表达式中如果存在形如e1 − e2的子表达式，那么e1 ≥ e2。 (完成)生成的题目中如果存在形如e1 ÷ e2的子表达式，那么其结果应是真分数。 (完成)每道题目中出现的运算符个数不超过3个。 (完成)程序一次运行生成的题目不能重复，即任何两道题目不能通过有限次交换+和×左右的算术表达式变换为同一道题目。例如，23 + 45 = 和45 + 23 = 是重复的题目，6 × 8 = 和8 × 6 = 也是重复的题目。3+(2+1)和1+2+3这两个题目是重复的，由于+是左结合的，1+2+3等价于(1+2)+3，也就是3+(1+2)，也就是3+(2+1)。但是1+2+3和3+2+1是不重复的两道题，因为1+2+3等价于(1+2)+3，而3+2+1等价于(3+2)+1，它们之间不能通过有限次交换变成同一个题目。生成的题目存入执行程序的当前目录下的Exercises.txt文件。 (完成)在生成题目的同时，计算出所有题目的答案，并存入执行程序的当前目录下的Answers.txt文件。 (完成)程序应能支持一万道题目的生成。 (完成)程序支持对给定的题目文件和答案文件，判定答案中的对错并进行数量统计， 统计结果输出到文件Grade.txt。 代码规范本次项目的代码遵循了谷歌代码规范(C++)，但由于谷歌代码规范篇幅太多，所以我们目前只遵循了其中的部分规范，具体如下： 禁止使用宏 分号以前不加空格 行宽原则上不超过80 一行只定义一个变量 左大括号前保留一个空格 if, else前后都要一个空格 for, while后要有一个空格 return 后面的数值不加 ( ) 每个文件应该含有版权信息及作者 左圆括号之后和右圆括号之前无空格 函数参数过多时，每行的参数变量对齐 一目运算符与变量之间不加空格符隔开 禁止使用 using 指示（using-directive） 禁止使用C++的流，而是用printf之类的替代 要么函数名与参数同行，要么所有参数并排分行 换行代码缩进2个空格，并且使用两个空格符取代制表符 二目以上的运算符与变量，常量之间用空格隔开（各类括号除外） 不论控制语句，循环语句后面的循环体有多少行，都必须使用花括号 普通函数，类型（含类与结构体，枚举类型），常量等使用大小写混合，不含下划线 除函数定义的左大括号可置于行首以外，包括函数/类/结构体/枚举声明，各种语句的左大括号必须置于行末，所有右大括号独立成行 设计思路 具体设计&amp;关键代码ImproperFraction类构建一个ImproperFraction的类，然后重载这个类的四种运算 +-x÷ 以及以及六种逻辑关系‘&lt;’ ‘==’ ‘&lt;=’ ‘!=’ ‘&gt;’ ‘&gt;=’判断，在后续的代码编写之中都是基于这个类进行运算 核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ImproperFraction &#123; public : ImproperFraction()&#123;&#125; ImproperFraction (int Mole, int Deno, int Coef = 0) &#123; int g = std::__gcd (Mole, Deno); g = std::max(g, 1); mole = (Mole + Coef * Deno) / g; deno = Deno / g; &#125; ImproperFraction operator + (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.deno; int MOLE = mole * rhs.deno + rhs.mole * deno; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; ImproperFraction operator - (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.deno; int MOLE = mole * rhs.deno - rhs.mole * deno; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; ImproperFraction operator * (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.deno; int MOLE = mole * rhs.mole; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; ImproperFraction operator / (const ImproperFraction &amp; rhs ) const &#123; int DENO = deno * rhs.mole; int MOLE = mole * rhs.deno; ImproperFraction res = ImproperFraction (MOLE, DENO); return res; &#125; bool operator &lt; (const ImproperFraction &amp; rhs ) const &#123; return mole * rhs.deno &lt; rhs.mole * deno; &#125; bool operator == (const ImproperFraction &amp; rhs ) const &#123; return mole * rhs.deno == rhs.mole * deno; &#125; bool operator != (const ImproperFraction &amp; rhs ) const &#123; return !(mole * rhs.deno == rhs.mole * deno); &#125; bool operator &lt;= (const ImproperFraction &amp; rhs ) const &#123; return (*this) &lt; rhs || (*this) == rhs; &#125; bool operator &gt; (const ImproperFraction &amp; rhs ) const &#123; return !((*this) &lt;= rhs); &#125; bool operator &gt;= (const ImproperFraction &amp; rhs ) const &#123; return (*this) &gt; rhs || (*this) == rhs; &#125; private : int mole = 0; // 分子 int deno = 1; // 分母 &#125;; 题集的生成表达式的生成在这里选择的是rand() 随机生成 运算符个数，类型以及每个被运算的数值。 表达式的合法性判断 在生成过程之中，有两个要点会导致表达式非法1.运算过程中出现负值2.在÷运算后面出现0 解决办法：两个特殊判断即可 表达式的去重表达式的重复有两种情况:1.完完全全的重复，如出现两个1 + 2 + 3 的表达式2.运算顺序上的重复，如: 1 + 2 + 3 和 2 + 1 + 3重复2 + 3 x 4 和 4 x 3 + 2重复 解决办法：对于(1)的情况只需要将生成的表达式保存进C++STL的set之中即可自动去重。对于(2)的情况，则是按照一定规则生成表达式来避免这一情况，规则如下： 1.默认左边的运算符的优先度高于右边2.第一个数字一定不小于第二个数值因此1 + 2 + 3和2 + 3 x 4不会被生成，而只会生成2 + 1 + 3和4 x 3 + 2 题集无法生成要求的数量 例如：传入的参数是 -n 10000 -r 1 的时候，很明显无法生成10000道题目，因此陷入死循环的生成中 解决办法：设置一个时间戳time，当生成表达式的部分循环了1000000次之后自动跳出循环，终止生成表达式 答案的生成 在表的是合法性判断的时候，会判断最终的数值是否小于0，在这里就已经计算标准答案，保存并打印到answer.txt即可 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void questionSetGenerate (int limit, int number) &#123; std::set&lt;std::string&gt;expressions; std::vector&lt;std::string&gt;exercise; std::vector&lt;ImproperFraction&gt;answer; ImproperFraction zero = ImproperFraction(0, 1); // 时间戳 int time = 0; while (expressions.size() &lt; number &amp;&amp; time &lt; 1000000) &#123; time ++; int sz = expressions.size(); // 运算符的个数 int opnumber = rand() % 3 + 1; ImproperFraction a[5]; ImproperFraction res = ImproperFraction(0, 1); const ImproperFraction zero = ImproperFraction(0, 1); char op[4]; // 随机生成数值和运算符 for (int i = 0; i &lt;= opnumber; i++) &#123; a[i] = ImproperFraction(rand() % (limit * limit), std::max(1, rand() % limit)); if (i) &#123; op[i] = oper[rand() % 4]; &#125; &#125; std::string exp = ""; bool flag = true; if (a[0] &lt; a[1]) &#123; std::swap (a[0], a[1]); &#125; // 计算答案,并检查中途出现非法情况 for (int i = 0; i &lt;= opnumber; i++) &#123; if (i) &#123; if (op[i] == '+') &#123; res = res + a[i]; &#125; else if (op[i] == '*') &#123; res = res * a[i]; &#125; else if (op[i] == '-') &#123; res = res - a[i]; &#125; else &#123; if (a[i] == zero) &#123; flag = false; break; &#125; res = res / a[i]; &#125; exp = exp + ' '; exp = exp + op[i]; exp = exp + ' '; &#125; else &#123; res = res + a[i]; &#125; // 将分数转化为字符串 fractionToString(a[i], exp); if (res.getdeno() &lt; 0 || res.getmole() &lt; 0) &#123; flag = false; break; &#125; &#125; if (flag) &#123; expressions.insert(exp); if (expressions.size() &gt; sz) &#123; //保存题集和答案 exercise.push_back(addbrackets(exp)); answer.push_back(res); &#125; &#125; &#125;&#125; 答案正确性的检测用户通过参数-e exercises.txt -a answers.txt，传进来了题目文件的名称和答案文件的名称。首先，由于文件可能不存在或者没有访问的权限，我们需要对此进行检查，假如有错误，则进行报错，没有异常才进行下一步。第二步，我们需要对exercises.txt文件中的题目计算一遍，然后再和answers.txt文件中的答案进行比较。题目的计算分两步进行，即先将中缀表达式转化为后缀表达式，然后计算后缀表达式的答案。对于这个函数，我们考虑了exercises.txt行数和answers.txt行数不相等的情况，此时我们将以exercises.txt的行数为准，假如answers.txt行数过少，那么将视为错误答案，假如过多，那么将被忽略。 12345678910111213141516171819202122232425262728293031323334// 检查答案void checkAnswer(FILE *exerciseFile, FILE *answerFile) &#123; FILE *pFile = getPointerToGradeFile(); int problemID = 0; char answer[256]; char exercise[256]; std::vector&lt;int&gt; wrongID; std::vector&lt;int&gt; correctID; // 答案的行数可能不等于题目的行数 while (fgets(answer, 256, answerFile)) &#123; if (!fgets(exercise, 256, exerciseFile)) &#123; break; &#125; problemID++; removeRedundantPart(answer, exercise); handleDivideEncoding(exercise); if (getInfixExpressionAnswer(exercise) == stringToImproperFraction(answer) ) &#123; correctID.push_back(problemID); &#125; else &#123; wrongID.push_back(problemID); &#125; &#125; while (fgets(exercise, 256, exerciseFile)) &#123; problemID++; wrongID.push_back(problemID); &#125; printID(pFile, const_cast&lt;char*&gt;("Correct"), correctID); printID(pFile, const_cast&lt;char*&gt;("Wrong"), wrongID); fclose(pFile); printf("Check answer done!\n");&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 将中缀表达式转化为后缀表达式std::queue&lt;std::string&gt; transformInfixExprToSuffixExpr( const std::string &amp;InfixExpression) &#123; std::stack&lt;char&gt; temp; std::queue&lt;std::string&gt; result; for (int i = 0; i &lt; InfixExpression.length(); i++) &#123; char cc = InfixExpression[i]; if (cc == ' ') &#123; // 假如遇到空格就跳过 continue; &#125; else if (cc == '(') &#123; // 遇到左括号就直接入栈 temp.push(cc); &#125; else if (cc == ')') &#123; // 遇到右括号就弹出栈里面的所有运算符，直到遇到左括号 char c; do &#123; c = temp.top(); temp.pop(); if (c != '(') &#123; result.push(charToString(c)); &#125; &#125; while (c != '('); &#125; else if (cc == '+' || cc == '-') &#123; // 遇到加号减号也弹出栈顶的所有运算符，直到遇到左括号或者为栈为空 while (!temp.empty()) &#123; char c = temp.top(); if (c != '(') &#123; result.push(charToString(c)); temp.pop(); &#125; else &#123; break; &#125; &#125; temp.push(cc); // 然后将加号入栈 &#125; else if (cc == 'x' || cc == '\xc3') &#123; // 假如遇到所有乘号除号，就弹出栈顶的乘号除号，知道遇到加号减号或者左括号或者栈为空 i += cc == '\xc3'; while (!temp.empty()) &#123; char c = temp.top(); if (c == 'x') &#123; result.push(charToString(c)); temp.pop(); &#125; else if (c == '\xc3') &#123; result.push(charToString(c)); temp.pop(); &#125; else &#123; break; &#125; &#125; temp.push(cc); &#125; else &#123; // 假如遇到数字，那就直接输出 std::string s; while (i &lt; InfixExpression.length()) &#123; char c = InfixExpression[i]; if (isdigit(c) || c == '/' || c == '\'') &#123; s += c; i++; &#125; else &#123; i--; break; &#125; &#125; result.push(s); &#125; &#125; // 把栈里面剩余的东西输出 while (!temp.empty()) &#123; char c = temp.top(); temp.pop(); result.push(charToString(c)); &#125; return result;&#125; 1234567891011121314151617181920212223242526272829// 计算后缀表达式的答案ImproperFraction getSuffixExpressionAnswer( std::queue&lt;std::string&gt; suffixExpression) &#123; std::stack&lt;ImproperFraction&gt; sta; while (!suffixExpression.empty()) &#123; std::string s = suffixExpression.front(); suffixExpression.pop(); if (isOperator(s)) &#123; // 假如遇到运算符，就取出栈顶元素进行计算 ImproperFraction a = sta.top(); sta.pop(); ImproperFraction b = sta.top(); sta.pop(); if (s[0] == 'x') &#123; sta.push(a * b); &#125; else if (s[0] == '\xc3') &#123; sta.push(b / a); &#125; else if (s[0] == '+') &#123; sta.push(a + b); &#125; else &#123; sta.push(b - a); &#125; &#125; else &#123; // 假如遇到数字，就直接进栈 sta.push(stringToImproperFraction(s)); &#125; &#125; return sta.top();&#125; 测试报告首先是各种参数错误的测试 接着是传入正确的参数的测试生成题集的测试： 给定的题目文件和答案文件，判定答案中的对错测试： 效能分析本程序主要由生成运算题目和检查答案正确性两个模块，因此效能分析也主要针对这两个模块进行。1. 生成运算题目生成一百万条题目时候的时间占比情况： 由上图看出了，占用时间最多的前五个函数为 questionSetGenerate gcd addbrackets digToString ImproperFraction 其中，questionSetGenerate是生成运算题目的函数入口，占用时间最长。gcd是在题目运算过程，分数通分时进行调用的，具体实现是辗转相除法。addbrackets是在生成题目的过程给表达式添加括号。digTostring是在生成题目的过程将数字转化为字符串。ImproperFraction是真分数的类名，由于生成的表达式中普遍含有真分数，所以多次调用了它的构造函数。 2. 检查答案正确性检查五十万条题目时的时间占比情况： 由上图可以看出，占用时间最多的前五个函数为： gcd stringToImproperFraction __deque_buf_size transformInfixExprToSuffixExpr _Deque_base 其中，gcd用于运算过程的通分，stringToImproperFraction用于将字符串转化为真分数， transformInfixExprToSuffixExpr用于将中缀表达式转化为后缀表达式。另外两个函数是系统函数。 因此，假如要优化效能的话，可以优先在源代码追踪一下上述函数，看能否减少这些函数的调用或者优化其实现方式。 PSP PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟） Planning 计划 60 50 · Estimate · 估计这个任务需要多少时间 60 50 Development 开发 965 1545 · Analysis · 需求分析 (包括学习新技术) 50 100 · Design Spec · 生成设计文档 25 35 · Design Review · 设计复审 (和同事审核设计文档) 25 35 · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 25 65 · Design · 具体设计 60 80 · Coding · 具体编码 360 415 · Code Review · 代码复审 60 150 · Test · 测试（自我测试，修改代码，提交修改） 360 665 Reporting 报告 110 130 · Test Report · 测试报告 60 80 · Size Measurement · 计算工作量 25 25 · Postmortem &amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 25 25 合计 1135 1725 项目小结有待改进的地方 溢出问题：当给定r过大的时候，将会导致最终运算结构的分母溢出，而造成的数据错误 目前方案：检查溢出，将发生了溢出的表达式删除 更佳方案：使用大数的运算，就可以完美避免数据溢出的问题 生成题目不够友好：当给定数据范围r稍稍有点大的时候，最终答案的分母可能超过一亿 目前方案：不处理 更佳方案: 暂无 死循环生成题目: 当给定题数过大且给定限制太小时,无法生成要求的题目数量, 导致进入死循环 目前方案: 设置时间戳time,只生成1000000次表达式,再进行合法性判断,但也导致有可能无法生成要求题目数量 更佳方案: 暂无 开发项目中发生的问题 一开始的时候是选择暴力深搜生成题集,再随机选取表达式输出,但是生成的效果来看,题目并不是很随机,例如前两个数字是固定死的,思前想后,觉得还是使用rand()随机生成效果更佳 在最开始设计方案的时候,还是思虑的不够多,以至于后面的代码复审(Debug)工作做了很多,远超过代码编写部分 还有各种人性化的设置,如参数错误提示,程序运行结果显示之类话语并没有想到,但是一个软件,一个项目最终都是面向于人群大众,人性化的设置是必须的 团队之中的闪光点 良好的代码风格: 在一开始我们就约束好了团队的代码风格,在后续的代码编写之中我们也能够很好的参照代码风格进行书写,因此在代码复审的时候我们也能够很好的查阅对方的代码 不错的代码能力: 想定思路学习知识之后,可直接进行代码的实现,基本上不会出现一些逻辑错误.后面出现的bug也是因为设计的时候稍稍不够考虑细节,一旦出现bug,都能够立马找到bug和想到相应的修复方案 互帮互助: 在一开始我们就进行了分工,一个人主要负责对给定的题目文件和答案文件进行答案校对、参数组合正确性的检测，另一个人负责了题集的生成部分。并且在最后，一起测试并撰写了博客。通过这次项目，我们实践了结对编程，提高了沟通能力，加强了团队合作的能力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[wc项目折腾笔记]]></title>
    <url>%2F2018%2F09%2F07%2Fword-count%2F</url>
    <content type="text"><![CDATA[Github项目地址传送门 项目相关要求 基本功能 统计C语言源文件的字符数（完成） 统计C语言源文件的词的数目（完成） 统计C语言源文件的行数（完成） 拓展功能 递归处理目录下符合条件的文件（完成） 返回更复杂的数据（代码行 / 空行 / 注释行）（完成） 支持各种文件的通配符（*,?）（完成） 高级功能 实现图形界面（待完成） 首先，我们需要明确一下“字符”，“词”，“行”，“代码行”，“空行”，“注释行”的定义。字符：一个ASCII字符，包括控制字符和可打印字符。词：一个由空白字符（不仅指空格，还指’\f’,’\v’,’\n’,’\r’这些控制字符）分隔的非空字符串。行：一个由换行符分隔的字符串，可以为空。一行结束的标志是换行符。 代码行：本行包括多于一个字符的代码。空行：本行全部是空格或格式控制字符，如果包括代码，则只有不超过一个可显示的字符，例如“{”。注释行：本行不是代码行，并且本行包括注释。 以上代码行、空行、注释行的说明摘自项目说明。 为了消除歧义，特提出以下补充说明：1.项目说明指出了下面第一行是注释行，类似的，第二行和第三行也是项目行。 123&#125; //注释&#123; //注释; //注释 2.按照定义，下面这一行是代码行，但不是注释行。 1printf("Hello, world"); //say "Hello, world" 3.按照定义，第一行是代码行，但不是注释行。第二行和第三行是注释行。 123printf("Hello, world"); /*say "Hello, world" */ 4.第二行不是空白行。第一行到第三行都是注释行。 123/* The next line is a comment line. */ 思路对于字符数的统计，每读取一个字符，让chracters加一即可。对于词数的统计，需要一个标记，用于记录前面一个字符是不是空白字符，假如前面一个字符是空白字符且当前字符是可显示字符，那么让words加一。对于行数的统计，每读取到一个换行符，让lines加一即可。对于空白行、代码行、注释行的统计，需要用到一个块注释标记和一些正则表达式，具体如下： 123456bool blockCommentFlag = false;string blankLineRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)";string lineCommentRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)";string blockCommentStartFlagRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)";string blockCommentStartFlag1Regex = "(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)";string blockCommentCloseFlagRegex = "(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"; 每读取一行，首先需要判断当前行是不是位于块注释中，假如是，让注释行加一，否则进行2 使用blankLineRegex这个正则表达式判断当前行是不是空白行，假如是，让空白行加一，否则进行3 使用lineCommentRegex判断当前行是不是行注释，假如是，让注释行加一，否则进行4 使用blockCommentStartFlagRegex判断当前行是不是含有块注释开始的标志且为注释行，假如是，把blockCommentFlag改为true，并将注释行加一，否则进行5 使用blockCommentStartFlag1Regex判断当前行是不是含有块注释开始的标志且为代码行，假如是，把blockCommentFlag改为true，并将代码行加一，否则进行6 假如以上情况都不是，那么说明该行是代码行，让代码行加一，并结束该行的判断 设计File类： 变量：characters, words, lines, blankLines, codeLines, commentLines. 方法： countBasic：统计字符数、词数、行数。 countSpecialLines：统计空白行、代码行、注释行。 print：输出统计结果。 setMode函数：根据输入参数设置模式。readFile函数：处理一个文件。recursiveReadFiles函数：处理一个目录。 主要流程就是读取命令行参数，然后调用setMode设置参数，接着根据对象是文件还是目录，分别调用readFile或recursiveReadFiles。 readFile接着又会调用countBasic和countSpecialLines，执行程序的核心部分，进行统计。接着调用print输出结果。 关键代码1.统计字符、词、行 123456789101112void countBasic(FILE *pFile) &#123; char c; bool spaceFlag = true; while((c = fgetc(pFile)) != EOF) &#123; characters++; words += (spaceFlag == true &amp;&amp; isgraph(c)); spaceFlag = isspace(c); lines += c == '\n'; &#125;&#125; 2.统计空白行、代码行、注释行 12345678910111213141516171819202122232425262728293031323334353637383940/* 要确定一行是不是空白行，只要通过判断该行的可打印字符个数是否不超过1个即可。另外还要注意，该行不能在块注释中。 * 要确定一行是不是代码行，只要判断该行的可打印字符个数是否超过1个即可。另外还要注意，改行不在块注释中。 * 假如一行是注释行，那么该行首先必须不是代码行，其次，需要有注释标志。 * 根据以上信息，可写出正则表达式进行匹配。 */void countSpecialLines() &#123; string line; ifstream file(fileName); bool blockCommentFlag = false; string blankLineRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)"; string lineCommentRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)"; string blockCommentStartFlagRegex = "(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"; string blockCommentStartFlag1Regex = "(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"; string blockCommentCloseFlagRegex = "(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"; while (getline(file, line)) &#123; if(blockCommentFlag) &#123; commentLines++; if(regex_match(line, regex(blockCommentCloseFlagRegex))) &#123; blockCommentFlag = false; &#125; &#125; else if(regex_match(line, regex(blankLineRegex))) &#123; blankLines++; &#125; else if(regex_match(line, regex(lineCommentRegex))) &#123; commentLines++; &#125; else if(regex_match(line, regex(blockCommentStartFlagRegex))) &#123; commentLines++; blockCommentFlag = true; &#125; else if(regex_match(line, regex(blockCommentStartFlag1Regex))) &#123; codeLines++; blockCommentFlag = true; &#125; else &#123; codeLines++; &#125; &#125; file.close();&#125; 3.根据参数输出统计结果，注意输出顺序是有规律的，依次为字符数 词数 行数 空白行数 代码行数 注释行数。 1234567891011void print(map&lt;char, bool&gt; mode) &#123; if(mode['c']) printf("%6d", characters); if(mode['w']) printf("%6d", words); if(mode['l']) printf("%6d", lines); if(mode['a']) printf("%6d%6d%6d", blankLines, codeLines, commentLines); putchar('\n');&#125; 测试报告首先我制作了几个经典的测试样例以及对应的参考统计结果，另外，为了节省测试时间，我还写了一个脚本来进行自动化测试。假如所有的测试样例都通过了，则会提示ok，如下：假如有些样例没有通过，则会提示wrong，并指出错在哪里，如下：我构造的测试样例及测试结果如下： 空文件 这里输出的依次是字符数、词数、行数、空行数、代码行数、注释行数。下面的也一样。之所以这么输出，是模仿了Linux系统下自带的wc命令。一开始我也不太理解wc命令输出的东西哪个是字符数、哪个是单词数，所以阅读了一下文档，找到了输出的规则，理解了输出的含义。所以，我这里也用了这种实现方式，这样做能减少输出冗余信息，减少用户的阅读负担，让用户更快地获得想要的信息。 一个字符的文件 一个单词的文件 一行的文件 典型的C源文件 另一个典型的C源文件 除了测试这些样例，我还测试了非法输入的情况，如下： 没有输入参数 参数非法 文件或目录不存在 在未输入s参数的情况下查询目录 拓展功能的查询更复杂信息和查询目录的测试： 支持各种文件的通配符（*,?）的测试： 代码覆盖率博主使用了gcov与lcov进行代码覆盖率的测试。经过测试发现，行覆盖率为91.5%，函数覆盖率为100%。 遇到的困难及解决方法 之前很少用C++写与文件操作相关的代码，所以对于实现-s这个参数的时候无从下手，最后，通过搜索引擎，查阅官方文档和他人的博客，学习到了新知识，顺利地解决了这个问题。 实现-a这个参数，需要统计空行、代码行、注释行。一开始，我的想法是逐个读取字符，进行相关变量的更新，并进行状态转化。但是，这样实现的话，会需要很多的标记，让代码晦涩难懂。而且由于这个状态机的状态很多，状态之间的转化也相当复杂。所以，最后我放弃了这种实现方式，改用正则表达式来实现，这样会简单很多。这启发我，在具体实现前，最好先比较一下各种实现方式的难易程度，再选择一种比较容易的来写。 PSP PSP2.1 Personal Software Process Stages 预估耗时（分钟） 实际耗时（分钟） Planning 计划 25 50 · Estimate · 估计这个任务需要多少时间 25 50 Development 开发 525 600 · Analysis · 需求分析 (包括学习新技术) 75 75 · Design Spec · 生成设计文档 25 0 · Design Review · 设计复审 (和同事审核设计文档) 0 0 · Coding Standard · 代码规范 (为目前的开发制定合适的规范) 25 0 · Design · 具体设计 25 50 · Coding · 具体编码 325 425 · Code Review · 代码复审 25 25 · Test · 测试（自我测试，修改代码，提交修改） 25 25 Reporting 报告 100 100 · Test Report · 测试报告 50 50 · Size Measurement · 计算工作量 25 25 · Postmortem &amp; Process Improvement Plan · 事后总结, 并提出过程改进计划 25 25 合计 650 750 总结一开始没有认真分析需求，没有想好就开始动手编码实现，中途停停顿顿，浪费了不少时间。从上面的PSP也可以看出，我花了很少时间在“生成设计文档”、“设计复审”、“代码规范”这三个环节上，导致我后面“具体编码”的环节花的时间比预估的时间长了很多。后来，我重新阅读了项目文件，明确了需求，并进行了相关设计，然后就实现得比较顺利了。这启发我，在开始动手编码前，应该先想好思路，并设计好模块，磨刀不误砍柴工嘛。 参考 C/C++代码覆盖工具gcov与lcov入门]]></content>
  </entry>
  <entry>
    <title><![CDATA[回文自动机学习笔记]]></title>
    <url>%2F2018%2F09%2F04%2Fpalindromic-tree-learning%2F</url>
    <content type="text"><![CDATA[回文自动机是一种可以处理回文符问题的优雅高效的数据结构。 URAL 1960 Palindromes and Super Abilities题意求各前缀的所有子串中的回文串种类。 分析依次插入字符，每插入完一个字符，假如last指针所指的节点是新增的，那么答案加一。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 回文自动机：解决一类回文字符串问题(Tested 0 times) * 时间复杂度：O(|S| * log(字符集个数)) */const int MAXN = 1e5 + 9;const int NN = 26;struct Palindromic_Tree &#123; int next[MAXN][NN] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN] ; //cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次 int num[MAXN] ; //num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身） int len[MAXN] ;//len[i]表示节点i表示的回文串的长度 int S[MAXN] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; NN ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125;pt;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", s); int len = strlen(s); pt.init(); int ans = 0; for(int i = 0; i &lt; len; i++) &#123; pt.add(s[i]); if(pt.cnt[pt.last] == 1) ans++; printf("%d%c", ans, " \n"[i == len - 1]); &#125; return 0;&#125; Tsinsen A1280 最长双回文串题意一个字符串，在中间某个位置切开，能形成两个回文串，则称这个回文串为双回文串。现在需要求最长双回文串。 分析令a[i]表示以i结束的最长回文串长度，b[i]表示从i开始的最长回文串长度。每插入一个字符，就更新这两个数组，最后扫一遍，取a[i] + b[i+1]的最大值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;int a[N], b[N];/************************************************************//* 回文自动机：解决一类回文字符串问题(Tested 2 times) * 时间复杂度：O(|S| * log(字符集个数)) */const int MAXN = 1e5 + 9;const int NN = 26;struct Palindromic_Tree &#123; int next[MAXN][NN] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN] ; //cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次 int num[MAXN] ; //num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身） int len[MAXN] ;//len[i]表示节点i表示的回文串的长度 int S[MAXN] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; NN ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; // 插入的是字符 void add (int id, int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; a[id] = len[last]; b[id - len[last] + 1] = max(b[id - len[last] + 1], len[last]); cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125;pt;/************************************************************/char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%s", s); int len = strlen(s); pt.init(); for(int i = 0; i &lt; len; i++) &#123; pt.add(i, s[i]); &#125; int ans = 2; for(int i = 0; i &lt; len - 1; i++) &#123; ans = max(ans, a[i] + b[i + 1]); &#125; printf("%d\n", ans); return 0;&#125; Tsinsen A1255 拉拉队排练题意求前k大奇数长度的回文串的乘积。 分析先建回文自动机，然后dfs奇根节点，找出奇数长度的回文串的长度和个数，放到容器，排个序贪心取出来即可。注意不能直接递归dfs，会爆栈，需要用stack。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#pragma comment(linker, "/STACK:1024000000,1024000000") #include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e6+9;const int mod = 19930726;/************************************************************//* 回文自动机：解决一类回文字符串问题(Tested 4 times) * 时间复杂度：O(|S| * log(字符集个数)) */const int MAXN = 1e6 + 9;const int NN = 26; //字符集个数struct Palindromic_Tree &#123; int next[MAXN][NN];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN];//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN]; //cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次 int num[MAXN]; //num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身） int len[MAXN];//len[i]表示节点i表示的回文串的长度 int S[MAXN];//存放添加的字符 int last;//指向上一个字符所在的节点，方便下一次add int n;//字符数组指针 int p;//节点指针 int newnode(int l) &#123;//新建节点 for(int i = 0; i &lt; NN; i++) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123;//初始化 p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1; &#125; int get_fail(int x) &#123;//和KMP一样，失配后找一个尽量最长的 while(S[n - len[x] - 1] != S[n]) x = fail[x]; return x ; &#125; // 插入的是字符 void add(int c) &#123; c -= 'a'; S[++ n] = c; int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置 if(!next[cur][c]) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode(len[cur] + 2);//新建节点 fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = next[cur][c]; cnt[last]++; &#125; void count () &#123; for(int i = p - 1; i &gt;= 0; i--) cnt[fail[i]] += cnt[i]; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125;pt;/************************************************************/char s[N];int n;ll k;pii a[N];vector&lt;pii&gt; v;ll sum;queue&lt;int&gt;que;void dfs(int u) &#123; que.push(u); while(!que.empty()) &#123; int u = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; int t = pt.next[u][i]; if(t) &#123; sum += pt.cnt[t]; que.push(t); //cout &lt;&lt; t &lt;&lt; endl; v.push_back(pii(pt.len[t], pt.cnt[t])); //dfs(t); &#125; &#125; &#125;&#125;bool cmp(pii a, pii b) &#123; return a.x &gt; b.x;&#125;ll ksm(ll x, ll y) &#123; ll ans = 1; while(y) &#123; if(y &amp; 1) (ans *= x) %= mod; (x *= x) %= mod; y &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d%lld", &amp;n, &amp;k); scanf("%s", s); n = strlen(s); pt.init(); for(int i = 0; i &lt; n; i++) &#123; pt.add(s[i]); &#125; pt.count(); dfs(1); if(sum &lt; k) &#123; printf("-1\n"); &#125; else &#123; sort(v.begin(), v.end(), cmp); ll ans = 1; for(auto i: v) &#123; ll num = min(1LL * i.y, k); (ans *= ksm(i.x, num)) %= mod; k -= i.y; if(k &lt;= 0) break; &#125; printf("%lld\n", ans); &#125; return 0;&#125; Tsinsen A1393 Palisection题意求相交回文串的对数。 分析直接求相交回文串的对数的话，不好求。经过思考，发现所有回文串对数以及不相交回文串的对数比较好求，而这两者相减就是答案，得解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 2e6+9;const int mod = 51123987;/************************************************************//* 回文自动机：解决一类回文字符串问题(Tested 5 times) * 时间复杂度：O(|S| * log(字符集个数)) */const int MAXN = 2e6 + 9;const int NN = 26; //字符集个数struct Palindromic_Tree &#123; int next[MAXN][NN];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN];//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN]; //cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次 int num[MAXN]; //num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身） int len[MAXN];//len[i]表示节点i表示的回文串的长度 int S[MAXN];//存放添加的字符 int last;//指向上一个字符所在的节点，方便下一次add int n;//字符数组指针 int p;//节点指针 int newnode(int l) &#123;//新建节点 for(int i = 0; i &lt; NN; i++) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123;//初始化 p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1; &#125; int get_fail(int x) &#123;//和KMP一样，失配后找一个尽量最长的 while(S[n - len[x] - 1] != S[n]) x = fail[x]; return x ; &#125; // 插入的是字符 int add(int c) &#123; c -= 'a'; S[++ n] = c; int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置 if(!next[cur][c]) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode(len[cur] + 2);//新建节点 fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = next[cur][c]; cnt[last]++; return num[last]; &#125; void count () &#123; for(int i = p - 1; i &gt;= 0; i--) cnt[fail[i]] += cnt[i]; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125;pt;/************************************************************/char s[N];int n;ll sum[N], ans;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d%s", &amp;n, s); pt.init(); for(int i = 0; i &lt; n; i++) &#123; (sum[i+1] = sum[i] + pt.add(s[i])) %= mod; &#125; (ans = 1LL * sum[n] * (sum[n] - 1) / 2) %= mod; reverse(s, s + n); pt.init(); ll t = 0; for(int i = 0; i &lt; n; i++) &#123; t = pt.add(s[i]); ans -= t * sum[n - i - 1]; (ans += mod) %= mod; &#125; printf("%lld\n", ans); return 0;&#125; Gym 100548G The Problem to Slow Down You题意给两个字符串，求两个字符串中相同回文串的对数。 分析首先分别给两个字符串建立回文自动机，然后分别dfs一下奇偶根节点，累加两个回文自动机相同位置的节点的cnt乘积即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 2e5+9;/************************************************************//* 回文自动机：解决一类回文字符串问题(Tested 4 times) * 时间复杂度：O(|S| * log(字符集个数)) */const int MAXN = 2e5 + 9;const int NN = 26; //字符集个数struct Palindromic_Tree &#123; int next[MAXN][NN];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN];//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN]; //cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次 int num[MAXN]; //num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身） int len[MAXN];//len[i]表示节点i表示的回文串的长度 int S[MAXN];//存放添加的字符 int last;//指向上一个字符所在的节点，方便下一次add int n;//字符数组指针 int p;//节点指针 int newnode(int l) &#123;//新建节点 for(int i = 0; i &lt; NN; i++) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123;//初始化 p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1; &#125; int get_fail(int x) &#123;//和KMP一样，失配后找一个尽量最长的 while(S[n - len[x] - 1] != S[n]) x = fail[x]; return x ; &#125; // 插入的是字符 void add(int c) &#123; c -= 'a'; S[++ n] = c; int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置 if(!next[cur][c]) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode(len[cur] + 2);//新建节点 fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = next[cur][c]; cnt[last]++; &#125; void count () &#123; for(int i = p - 1; i &gt;= 0; i--) cnt[fail[i]] += cnt[i]; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125;pt[2];/************************************************************/char s[2][N];int len[2], kase;ll ans;void dfs(int u0, int u1) &#123; for(int i = 0; i &lt; 26; i++) &#123; int t0 = pt[0].next[u0][i]; int t1 = pt[1].next[u1][i]; if(t0 &amp;&amp; t1) &#123; ans += 1LL * pt[0].cnt[t0] * pt[1].cnt[t1]; dfs(t0, t1); &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%s%s", s[0], s[1]); for(int k = 0; k &lt; 2; k++) &#123; len[k] = strlen(s[k]); pt[k].init(); for(int i = 0; i &lt; len[k]; i++) &#123; pt[k].add(s[k][i]); &#125; pt[k].count(); &#125; ans = 0; dfs(0, 0); dfs(1, 1); printf("Case #%d: %lld\n", ++kase, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbin带你飞 专题十七 AC自动机 题解]]></title>
    <url>%2F2018%2F08%2F23%2Fac-auto-machine-learning%2F</url>
    <content type="text"><![CDATA[kuangin带你飞专题十七 AC自动机 传送门AC自动机是著名的多模匹配算法，在ACM中通常会结合计数问题、动态规划问题等一起出现。 A. HDU 2222 Keywords Search统计字符串出现的个数，AC自动机模板题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=5e5+9;const int shift=1e3+9;const double Eps=1e-7;/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Untested) */struct AC &#123; int next[N][26], fail[N], end[N], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now]++; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; int query(char s[]) &#123; int ans = 0, len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; now = next[now][s[i] - 'a']; int temp = now; while(temp != root) &#123; ans += end[temp]; end[temp] = 0; temp = fail[temp]; &#125; &#125; return ans; &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int T, n;char s[N * 2];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); ac.init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); scanf("%s", s); int ans = ac.query(s); printf("%d\n", ans); &#125; return 0;&#125; B.HDU 2896 病毒侵袭和上道题差不多，但这道题要求输出出现的字符串，修改一下节点保存的信息即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 模式串之间可以重叠#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, total;char s[10009];//写AC自动机等树状数据结构一定要注意空间！//比如这道题，多申请个set&lt;int&gt; se[N] 就会MLE struct acAuto &#123; int next[N][128], fail[N], root, L; vi end[N]; void init() &#123; L = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 128; i++) next[L][i] = -1; end[L].clear(); return L++; &#125; void insert(char s[], int id) &#123; int now = root, len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i]] == -1) next[now][s[i]] = newNode(); now = next[now][s[i]]; &#125; end[now].push_back(id); &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; //! for(int i = 0; i &lt; 128; i++) &#123; if(next[root][i] == -1) next[root][i] = root; // else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 128; i++) &#123; if(next[now][i] == -1) next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; bool query(char s[], int id) &#123; int now = root, len = strlen(s); set&lt;int&gt; se; bool flag[N]; memset(flag, 0, sizeof flag); for(int i = 0; i &lt; len; i++) &#123; now = next[now][s[i]]; int temp = now; while(temp != root) &#123; if(!flag[temp]) &#123; for(auto j: end[temp]) se.insert(j); flag[temp] = true; &#125; if(se.size() &gt;= 3) break; temp = fail[temp]; &#125; &#125; if(se.size()) &#123; printf("web %d:", id); for(auto i: se) printf(" %d", i); printf("\n"); return true; &#125; return false; &#125; void debug() &#123; printf("%27c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; L;i++) &#123; printf("id = %3d,fail = %3d,chi = [",i,fail[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;n); ac.init(); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); ac.insert(s, i); &#125; ac.build(); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); if(ac.query(s ,i)) total++; &#125; printf("total: %d\n", total); return 0;&#125; C. HDU 3065 病毒侵袭持续中需要统计各字符串出现的次数，使用vector来维护节点上出现的字符串即可。注意是多组样例，初始化要处理好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//题目有点坑啊，没有说多组样例，WA了一发:(#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n;char s[2000009];char ss[1009][59];struct acAuto &#123; int next[N][26], fail[N], root, L; vi end[N]; void init() &#123; L = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[L][i] = -1; end[L].clear(); return L++; &#125; void insert(char s[], int id) &#123; int now = root, len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'A'] == -1) next[now][s[i] - 'A'] = newNode(); now = next[now][s[i] - 'A']; &#125; end[now].push_back(id); &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(char s[]) &#123; int now = root, len = strlen(s); int cnt[N]; bool flag[N]; memset(flag, 0, sizeof flag); memset(cnt, 0, sizeof cnt); set&lt;int&gt;se; for(int i = 0; i &lt; len; i++) &#123; now = isupper(s[i]) ? next[now][s[i] - 'A'] : root; int temp = now; while(temp != root) &#123; for(auto id: end[temp]) &#123; cnt[id]++; if(!flag[id]) &#123; se.insert(id); flag[id] = true; &#125; &#125; temp = fail[temp]; &#125; &#125; for(auto i: se) &#123; printf("%s: %d\n", ss[i], cnt[i]); &#125; &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d", &amp;n)) &#123; ac.init(); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", ss[i]); ac.insert(ss[i], i); &#125; ac.build(); scanf("%s", s); ac.query(s); &#125; return 0;&#125; D. ZOJ 3430 Detect the Virus题目有点难懂，留坑待填。 E. POJ 2778 DNA Sequence求不含模式串的字符串总数。该计数问题可用AC自动机+矩阵快速幂解决，很经典。详细题解传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt; #include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;const int mod = 100000;map&lt;char, int&gt; m;int n, mm;char s[19];/************************************************************//* 矩阵快速幂：根据递推式快速计算第n项 * 矩阵构造、时间复杂度参考白书P201 */typedef vector&lt;vi&gt; mat;mat mul(mat A, mat B)&#123; mat C(A.size(), vi(B[0].size())); for(int i=0; i&lt;A.size(); i++) for(int k=0; k&lt;A[0].size(); k++) for(int j=0; j&lt;B[0].size(); j++) C[i][j]=(1LL * C[i][j]+1LL * A[i][k]*B[k][j])%mod; return C;&#125;mat pow(mat A, int n)&#123; mat B(A.size(), vi(A.size())); for(int i=0; i&lt;B.size(); i++) B[i][i]=1; while(n)&#123; if(n&amp;1) B=mul(B, A); A=mul(A, A); n&gt;&gt;=1; &#125; return B;&#125;/************************************************************/struct acAuto &#123; int next[109][4], fail[109], L, root; bool end[109]; void init() &#123; L = 0; m['A'] = 0; m['T'] = 1; m['C'] = 2; m['G'] = 3; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[L][i] = -1; end[L] = false; return L++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; int j = m[s[i]]; if(next[now][j] == -1) next[now][j] = newNode(); now = next[now][j]; &#125; end[now] = true; &#125; void build() &#123; fail[root] = root; queue&lt;int&gt; que; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]]) //假如fail转移到的状态不合法，那么该状态也不合法！ end[now] = true; for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void buildMatrix(::mat &amp;a) &#123; for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; 4; j++) if(end[next[i][j]] == false) a[i][next[i][j]]++; &#125; void solve() &#123; ::mat a(L, vi(L)); buildMatrix(a); a = pow(a, n); ll ans = 0; for(int j = 0; j &lt; L; j++) (ans += a[0][j]) %= mod; printf("%lld\n", ans); &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;mm, &amp;n)) &#123; ac.init(); for(int i = 0; i &lt; mm; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); ac.solve(); &#125;; return 0;&#125; F. HDU 2243 考研路茫茫――单词情结求含模式串的字符串总数，注意这道题的字符串长度是可变的，所以矩阵构造需要有所变化。同样是计数问题，还是AC自动机+矩阵快速幂的套路。详细题解传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 矩阵快速幂：根据递推式快速计算第n项(Untested) * 矩阵构造、时间复杂度参考白书P201 */// 定义矩阵元素为long long的矩阵：typedef vector&lt;ull&gt; vll;typedef vector&lt;vll&gt; mat;mat mul(mat A, mat B)&#123; mat C(A.size(), vll(B[0].size(), 0)); for(int i = 0; i &lt; A.size(); i++) for(int k = 0; k &lt; A[0].size(); k++) for(int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]); return C;&#125;mat pow(mat A, ll n) &#123; mat B(A.size(), vll(A.size(), 0)); for(int i = 0; i &lt; B.size(); i++) B[i][i] = 1; while(n) &#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;/************************************************************//********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 1 times) */struct AC &#123; int next[39][26], fail[39], end[39], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = false; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = true; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]] == true) end[now] = true; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; ull cntIllegal(ll L) &#123; mat a(idx + 1, vll(idx + 1, 0)); for(int i = 0; i &lt; idx; i++) for(int j = 0; j &lt; 26; j++) if(end[next[i][j]] == false) a[i][next[i][j]]++; for(int i = 0; i &lt; idx + 1; i++) a[i][idx] = 1; a = pow(a, L); ull ans = 0; for(int i = 0; i &lt; idx + 1; i++) ans += a[0][i]; return ans - 1; &#125;&#125;ac;/********************************************************************************/int n;ll L;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%lld", &amp;n, &amp;L)) &#123; ac.init(); while(n--) &#123; scanf("%s", s); ac.insert(s); &#125; mat a(2, vll(2, 0)), b(2, vll(1, 0)); a[0][0] = 26, a[0][1] = 1; a[1][0] = 0, a[1][1] = 1; b[0][0] = 1; b[1][0] = 1; a = pow(a, L); a = mul(a, b); ull ans = a[0][0] - 1; ac.build(); ans -= ac.cntIllegal(L); printf("%llu\n", ans); &#125; return 0;&#125; G. POJ 1625 Censored!求不含模式串的字符串总数，需要使用大数，但是不能使用矩阵快速幂，因为会MLE。注意到m挺小，所以考虑用DP解决，而且还需要用滚动数组优化一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;int chr = 0;char c, s[59];map&lt;char, int&gt; m;int n, mm, p;/* * 高精度，支持乘法和加法(Tested 0 times) */struct BigInt&#123; const static int mod = 10000; const static int DLEN = 4; int a[90],len; BigInt()&#123; memset(a,0,sizeof(a)); len = 1; &#125; BigInt(int v)&#123; memset(a,0,sizeof(a)); len = 0; do&#123; a[len++] = v%mod; v /= mod; &#125;while(v); &#125; BigInt(const char s[])&#123; memset(a,0,sizeof(a)); int L = strlen(s); len = L/DLEN; if(L%DLEN)len++; int index = 0; for(int i = L-1;i &gt;= 0;i -= DLEN)&#123; int t = 0; int k = i - DLEN + 1; if(k &lt; 0)k = 0; for(int j = k;j &lt;= i;j++) t = t*10 + s[j] - '0'; a[index++] = t; &#125; &#125; BigInt operator +(const BigInt &amp;b)const&#123; BigInt res; res.len = max(len,b.len); for(int i = 0;i &lt;= res.len;i++) res.a[i] = 0; for(int i = 0;i &lt; res.len;i++)&#123; res.a[i] += ((i &lt; len)?a[i]:0)+((i &lt; b.len)?b.a[i]:0); res.a[i+1] += res.a[i]/mod; res.a[i] %= mod; &#125; if(res.a[res.len] &gt; 0)res.len++; return res; &#125; BigInt operator *(const BigInt &amp;b)const&#123; BigInt res; for(int i = 0; i &lt; len;i++)&#123; int up = 0; for(int j = 0;j &lt; b.len;j++)&#123; int temp = a[i]*b.a[j] + res.a[i+j] + up; res.a[i+j] = temp%mod; up = temp/mod; &#125; if(up != 0) res.a[i + b.len] = up; &#125; res.len = len + b.len; while(res.a[res.len - 1] == 0 &amp;&amp;res.len &gt; 1)res.len--; return res; &#125; void output()&#123; printf("%d",a[len-1]); for(int i = len-2;i &gt;=0 ;i--) printf("%04d",a[i]); printf("\n"); &#125;&#125;;/* 矩阵快速幂：根据递推式快速计算第n项(Tested 1 times) * 矩阵构造、时间复杂度参考白书P201 */typedef vector&lt;BigInt&gt; vll;typedef vector&lt;vll&gt; mat;mat mul(mat A, mat B) &#123; mat C(A.size(), vll(B[0].size(), 0)); // 假如为long long，vi需要修改为vll for(int i = 0; i &lt; A.size(); i++) for(int k = 0; k &lt; A[0].size(); k++) for(int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]); return C;&#125;mat pow(mat A, ll n) &#123; mat B(A.size(), vll(A.size(), 0)); // 假如为long long，vi需要修改为vll for(int i = 0; i &lt; B.size(); i++) B[i][i] = 1; while(n) &#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;/* AC自动机：解决多个模式串匹配问题(Tested 3 times) */struct AC &#123; int next[109][50], fail[109], end[109], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; chr; i++) next[idx][i] = -1; end[idx] = false; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; int c = m[s[i]]; if(next[now][c] == -1) next[now][c] = newNode(); now = next[now][c]; &#125; end[now] = true; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; chr; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]] == true) end[now] = true; for(int i = 0; i &lt; chr; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query() &#123; mat a(idx, vll(idx, 0)); for(int i = 0; i &lt; idx; i++) for(int j = 0; j &lt; chr; j++) if(end[next[i][j]] == false) a[i][next[i][j]] = a[i][next[i][j]] + 1; mat dp(2, vll(idx, 0)); dp[0][0] = 1; int now = 0; for(int i = 0; i &lt; mm; i++) &#123; now ^= 1; for(int j = 0; j &lt; idx; j++) dp[now][j] = 0; for(int j = 0; j &lt; idx; j++) for(int k = 0; k &lt; idx; k++) dp[now][k] = dp[now][k] + dp[now ^ 1][j] * a[j][k]; &#125; BigInt ans = 0; for(int i = 0; i &lt; idx; i++) ans = ans + dp[now][i]; ans.output(); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;mm, &amp;p)) &#123; chr = 0; getchar(); m.clear(); for(int i = 0; i &lt; n; i++) &#123; c = getchar(); m[c] = chr++; &#125; ac.init(); while(p--) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); ac.query(); &#125; return 0;&#125; H. HDU 2825 Wireless PasswordAC自动机+动态规划详细题解传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;const int mod = 20090717;char s[19];int n, m, k, dp[26][109][1029];struct node &#123; int idx, status; node() &#123;&#125; node(int idx, int status): idx(idx), status(status)&#123;&#125;&#125;;/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 3 times) */struct AC &#123; int next[109][26], fail[109], end[109], idx, root; // 可以修改下数组大小，以防MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[], int id) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = 1 &lt;&lt; id; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query() &#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt; idx; j++) for(int k = 0; k &lt; (1 &lt;&lt; m); k++) dp[i][j][k] = 0; dp[0][0][0] = 1; queue&lt;node&gt; que; que.push(node&#123;0, 0&#125;); bool vis[259][1029]; for(int i = 1; i &lt;= n; i++) &#123; queue&lt;node&gt; nextque; memset(vis, 0, sizeof vis); while(que.size()) &#123; node t = que.front(); que.pop(); for(int o = 0; o &lt; 26; o++) &#123; int j = t.idx; int k = t.status; int newj = next[j][o]; int newk = t.status | end[newj]; dp[i][newj][newk] += dp[i - 1][j][k]; if(dp[i][newj][newk] &gt;= mod) dp[i][newj][newk] -= mod; if(!vis[newj][newk]) &#123; vis[newj][newk] = true; nextque.push(&#123;newj, newk&#125;); &#125; &#125; &#125; que = nextque; &#125; ll ans = 0; for(int i = 0; i &lt; idx; i++) &#123; for(int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; // 可以把__builtin_popcount(j)预处理掉，这样更快 if(__builtin_popcount(j) &gt;= k) &#123; ans += dp[n][i][j]; if(ans &gt;= mod) ans -= mod; &#125; &#125; &#125; printf("%lld\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;k) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%s", s); ac.insert(s, i); &#125; ac.build(); ac.query(); &#125; return 0;&#125; I. HDU 2296 RingAC自动机+动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e3+9;string min(string s, string t) &#123; if(s.length() &lt; t.length()) return s; return s &lt; t ? s : t;&#125;/* AC自动机：解决多个模式串匹配问题(Tested 4 times) */struct AC &#123; int next[N][26], fail[N], end[N], idx, root; // 可以修改下数组大小，以防MLE string c[N]; int dp[59][N]; string s[59][N]; void init() &#123; idx = 0; root = newNode(""); &#125; int newNode(string cc) &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; c[idx] = cc; return idx++; &#125; void insert(char s[], int d) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; string t; t += s[i]; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(t); now = next[now][s[i] - 'a']; &#125; end[now] += d; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] += end[fail[now]]; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(int n) &#123; string ans; int ma = -1; memset(dp, -1, sizeof dp); dp[0][0] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int u = 0; u &lt; idx; u++) &#123; if(dp[i-1][u] == -1) continue; for(int k = 0; k &lt; 26; k++) &#123; int v = next[u][k]; if(dp[i-1][u] + end[v] &gt; dp[i][v]) &#123; dp[i][v] = dp[i-1][u] + end[v]; s[i][v] = s[i-1][u] + c[v]; &#125; else if(dp[i-1][u] + end[v] == dp[i][v] &amp;&amp; s[i-1][u] + c[u] &lt; s[i][v]) &#123; s[i][v] = s[i-1][u] + c[v]; &#125; &#125; &#125; for(int j = 0; j &lt; idx; j++) ma = max(ma, dp[i][j]); &#125; if(ma &lt;= 0) cout &lt;&lt; "" &lt;&lt; endl; else &#123; for(int i = 1; i &lt;= n; i++) &#123; bool flag = false; string ans = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"; for(int j = 0; j &lt; idx; j++) &#123; if(dp[i][j] == ma) &#123; ans = min(ans, s[i][j]); //重载了min函数 flag = true; &#125; &#125; if(flag) &#123; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; &#125; &#125; &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;int T, n, m, d;char s[109][19];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; T; while(T--) &#123; scanf("%d%d", &amp;n, &amp;m); ac.init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%s", s[i]); &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d); ac.insert(s[i], d); &#125; ac.build(); ac.query(n); &#125; return 0;&#125; J. HDU 2457 DNA repairAC自动机+动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e3+9;int dp[1009][1009];map&lt;char, int&gt; m;int kase;/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 5 times) */struct AC &#123; int next[N][4], fail[N], idx, root; // 可以修改下数组大小，以防MLE bool end[N]; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[idx][i] = -1; end[idx] = true; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][m[s[i]]] == -1) next[now][m[s[i]]] = newNode(); now = next[now][m[s[i]]]; &#125; end[now] = false; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(!end[fail[now]]) end[now] = end[fail[now]]; for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(char s[]) &#123; memset(dp, INF, sizeof dp); dp[0][0] = 0; int len = strlen(s); int ans = INF; for(int i = 0; i &lt; len; i++) &#123; bool flag = false; for(int u = 0; u &lt; idx; u++) &#123; if(dp[i][u] == INF) continue; int v = next[u][m[s[i]]]; if(end[v]) &#123; flag = true; dp[i+1][v] = min(dp[i+1][v], dp[i][u]); &#125; for(int j = 0; j &lt; 4; j++) &#123; if(j == m[s[i]]) continue; v = next[u][j]; if(end[v]) &#123; dp[i+1][v] = min(dp[i+1][v], dp[i][u] + 1); flag = true; &#125; &#125; &#125; if(!flag) &#123; printf("Case %d: %d\n", ++kase, -1); return; &#125; &#125; for(int j = 0; j &lt; idx; j++) ans = min(ans, dp[len][j]); printf("Case %d: %d\n", ++kase, ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/char s[1009];int n;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; m['A'] = 0; m['C'] = 1; m['G'] = 2; m['T'] = 3; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); scanf("%s", s); ac.query(s); &#125; return 0;&#125; K. ZOJ 3228 Searching the StringAC自动机+计数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 6e5+9;char s[N], t[9];int n, ty[N], pos[N], cnt[N][2]; //改用pos记录位置，避免在ac自动机里面使用end集合，妙/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 6 times) */struct AC &#123; int next[N][26], fail[N], deep[N], idx, root; void init() &#123; idx = 0; root = newNode(); deep[root] = 0; &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; cnt[idx][0] = cnt[idx][1] = 0; return idx++; &#125; int insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) &#123; next[now][s[i] - 'a'] = newNode(); deep[next[now][s[i] - 'a']] = i + 1; &#125; now = next[now][s[i] - 'a']; &#125; return now; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query(char s[]) &#123; int len = strlen(s), now = root; int last[N]; memset(last, -1, sizeof last); for(int i = 0; i &lt; len; i++) &#123; now = next[now][s[i] - 'a']; int temp = now; while(temp != root) &#123; cnt[temp][0]++; if(i - last[temp] &gt;= deep[temp]) &#123; cnt[temp][1]++; last[temp] = i; &#125; temp = fail[temp]; &#125; &#125; for(int i = 0; i &lt; n; i++) printf("%d\n", cnt[pos[i]][ty[i]]); puts(""); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; //printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; int kase = 0; while(~scanf("%s", s)) &#123; printf("Case %d\n", ++kase); scanf("%d", &amp;n); ac.init(); for(int i = 0; i &lt; n; i++) &#123; scanf("%d%s", &amp;ty[i], t); pos[i] = ac.insert(t); &#125; ac.build(); ac.query(s); &#125; return 0;&#125; L. HDU 3341 Lost’s revengeAC自动机+动态规划为了不MLE，动态规划过程中的状态要巧妙设计下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 509;map&lt;char, int&gt; m;int dp[509][11*11*11*11+9];/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 7 times)*/struct AC &#123; int next[N][26], fail[N], idx, root, end[N]; // 可以修改下数组大小，以防MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][m[s[i]]] == -1) next[now][m[s[i]]] = newNode(); now = next[now][m[s[i]]]; &#125; end[now]++; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] += end[fail[now]]; for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; int bit[4]; int func(int i, int j, int k, int l) &#123; return i * bit[3] + j * bit[2] + k * bit[1] + l * bit[0]; &#125; void query(char s[]) &#123; int cnt[4]; int len = strlen(s); memset(cnt, 0, sizeof cnt); for(int i = 0; i &lt; len; i++) cnt[m[s[i]]]++; bit[3] = (cnt[2] + 1) * (cnt[1] + 1) * (cnt[0] + 1); bit[2] = (cnt[1] + 1) * (cnt[0] + 1); bit[1] = cnt[0] + 1; bit[0] = 1; memset(dp, -1, sizeof dp); dp[0][0] = 0; for(int i = 0; i &lt;= cnt[3]; i++) &#123; for(int j = 0; j &lt;= cnt[2]; j++) &#123; for(int k = 0; k &lt;= cnt[1]; k++) &#123; for(int l = 0; l &lt;= cnt[0]; l++) &#123; for(int u = 0; u &lt; idx; u++) &#123; if(dp[u][func(i, j, k, l)] &lt; 0) continue; for(int o = 0; o &lt; 4; o++) &#123; int v = next[u][o]; if(o == 0 &amp;&amp; l == cnt[0]) continue; if(o == 1 &amp;&amp; k == cnt[1]) continue; if(o == 2 &amp;&amp; j == cnt[2]) continue; if(o == 3 &amp;&amp; i == cnt[3]) continue; int id = func(i, j, k, l); dp[v][id + bit[o]] = max(dp[v][id + bit[o]], dp[u][id] + end[v]); &#125; &#125; &#125; &#125; &#125; &#125; int ans = -1; for(int i = 0; i &lt; idx; i++) ans = max(ans, dp[i][func(cnt[3], cnt[2], cnt[1], cnt[0])]); printf("%d\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/char s[49];int n, kase;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; m['A'] = 0; m['C'] = 1; m['G'] = 2; m['T'] = 3; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; printf("Case %d: ", ++kase); ac.init(); while(n--) &#123; scanf("%s", s); ac.insert(s); &#125; scanf("%s", s); ac.build(); ac.query(s); &#125; return 0;&#125; M. HDU 3247 Resource Archiver留坑待填。 N. ZOJ 3494 BCD Code留坑待填。 O. HDU 4758 Walk Through SquaresAC自动机+动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;const int mod = 1000000007;map&lt;char, int&gt; m;/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 8 times) */struct AC &#123; int next[N][26], fail[N], idx, root, end[N]; // 可以修改下数组大小，以防MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 2; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[], int id) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][m[s[i]]] == -1) next[now][m[s[i]]] = newNode(); now = next[now][m[s[i]]]; &#125; end[now] |= id; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 2; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; 2; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; int bit[2], dp[209][101 * 101 + 9][4]; int get(int i, int j) &#123; return bit[1] * i + bit[0] * j; &#125; void query(int down, int right) &#123; bit[1] = right + 1; bit[0] = 1; memset(dp, 0, sizeof dp); dp[0][0][0] = 1; for(int i = 0; i &lt;= down; i++) &#123; for(int j = 0; j &lt;= right; j++) &#123; for(int u = 0; u &lt; idx; u++) &#123; for(int k = 0; k &lt; 4; k++) &#123; if(dp[u][get(i, j)][k] == 0) continue; for(int o = 0; o &lt; 2; o++) &#123; int v = next[u][o]; if(i == down &amp;&amp; o == 0) continue; if(j == right &amp;&amp; o == 1) continue; (dp[v][get(i + (o == 0), j + (o == 1))][k | end[v]] += dp[u][get(i, j)][k]) %= mod; &#125; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 0; i &lt; idx; i++) &#123; (ans += dp[i][down * bit[1] + right][3]) %= mod; &#125; printf("%d\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int T, n, mm;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); m['D'] = 0; m['R'] = 1; while(T--) &#123; scanf("%d%d", &amp;mm, &amp;n); ac.init(); for(int i = 0; i &lt; 2; i++) &#123; scanf("%s", s); ac.insert(s, i + 1); &#125; ac.build(); ac.query(n, mm); &#125; return 0;&#125; P. HDU 4511 小明系列故事――女友的考验AC自动机+动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 509;int n, m, k, b[9];pair&lt;double, double&gt; a[59];/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 9 times)*/struct AC &#123; int next[N][50], fail[N], idx, root; bool end[N]; // 可以修改下数组大小，以防MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; n; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(int b[], int k) &#123; int now = root; for(int i = 0; i &lt; k; i++) &#123; b[i]--; if(next[now][b[i]] == -1) next[now][b[i]] = newNode(); now = next[now][b[i]]; &#125; end[now] = 1; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; n; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; n; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; inline double get(pair&lt;double, double&gt; a, pair&lt;double, double&gt; b) &#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); &#125; void query(int n) &#123; double dp[50][509]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; idx; j++) dp[i][j] = LINF; dp[0][next[root][0]] = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; idx; j++) &#123; if(dp[i][j] &gt;= LINF - Eps) continue; for(int k = i + 1; k &lt; n; k++) &#123; int v = next[j][k]; if(end[v]) continue; dp[k][v] = min(dp[k][v], dp[i][j] + get(a[i], a[k])); &#125; &#125; &#125; double ans = LINF; for(int i = 0; i &lt; idx; i++) ans = min(ans, dp[n-1][i]); if(ans &gt;= LINF - Eps) printf("Can not be reached!\n"); else printf("%.2f\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; n; i++) scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;k); for(int j = 0; j &lt; k; j++) scanf("%d", b + j); ac.insert(b, k); &#125; ac.build(); ac.query(n); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1025D Recovering BST 题解]]></title>
    <url>%2F2018%2F08%2F21%2F0%2F</url>
    <content type="text"><![CDATA[题意给一个升序序列，问能否构造任意相邻节点的gcd都大于1的二叉排序树。 分析注意到n最大只有700，可考虑$n^3$的做法。令dp[i][j][0]表示$i$ ~ $j$的元素能否构造出以$i - 1$为根的二叉排序树，令dp[i][j][1]表示$i$ ~ $j$的元素能否构造出以$j + 1$为根的二叉排序树。至于转移方程，以dp[i][j][0]为例，它的根为$i - 1$，右儿子可以是下标为$i$ ~ $j$中某个数组元素，我们枚举这个右儿子，不妨设下标为$k$，判断根与它能否连边，以及$i$ ~ $k - 1$能否作为$k$的左子树，$k + 1$ ~ $j$ 能否于作为$k$的右子树。另外需要注意处理好dp边界。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 700+9;int a[N], dp[N][N][2], n, link[N][N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", a + i); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; if(__gcd(a[i], a[j]) &gt;= 2) link[i][j] = link[j][i] = 1; &#125; link[0][i] = link[i][n+1] = 1; dp[i][i-1][0] = dp[i+1][i][1] = 1; &#125; for(int len = 1; len &lt;= n; len++) &#123; for(int i = 1, j = i + len - 1; j &lt;= n; i++, j++) &#123; for(int k = i; k &lt;= j; k++) &#123; if(link[i-1][k]) dp[i][j][1] |= dp[i][k-1][0] &amp; dp[k+1][j][1]; if(link[k][j+1]) dp[i][j][0] |= dp[i][k-1][0] &amp; dp[k+1][j][1]; &#125; &#125; &#125; printf("%s\n", dp[1][n][0]?"Yes":"No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2825 Wireless Password 题解]]></title>
    <url>%2F2018%2F08%2F18%2F1%2F</url>
    <content type="text"><![CDATA[题意已知有m个单词，问有多少个长度为n的、且至少含有m个单词中的k个的WIFI密码，注意单词可以重叠。 分析注意到是多模式串匹配问题，考虑用AC自动机建状态转移图。节点上标记下该节点覆盖了哪些单词，用一个int表示即可，注意要或上fail指针指向节点的标记。然后以dp[i][j][k]表示从单词长度为i、当前节点为j、覆盖单词为k的方案数，转移途径为j的下一个节点。最终答案就是单词长度为n、图上各节点、覆盖单词数不小于k的dp和。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;const int mod = 20090717;char s[19];int n, m, k, dp[26][109][1029];struct node &#123; int idx, status; node() &#123;&#125; node(int idx, int status): idx(idx), status(status)&#123;&#125;&#125;;/********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 3 times) */struct AC &#123; int next[109][26], fail[109], end[109], idx, root; // 可以修改下数组大小，以防MLE void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = 0; return idx++; &#125; void insert(char s[], int id) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = 1 &lt;&lt; id; &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); end[now] |= end[fail[now]]; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void query() &#123; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt; idx; j++) for(int k = 0; k &lt; (1 &lt;&lt; m); k++) dp[i][j][k] = 0; dp[0][0][0] = 1; queue&lt;node&gt; que; que.push(node&#123;0, 0&#125;); bool vis[259][1029]; for(int i = 1; i &lt;= n; i++) &#123; queue&lt;node&gt; nextque; memset(vis, 0, sizeof vis); while(que.size()) &#123; node t = que.front(); que.pop(); for(int o = 0; o &lt; 26; o++) &#123; int j = t.idx; int k = t.status; int newj = next[j][o]; int newk = t.status | end[newj]; dp[i][newj][newk] += dp[i - 1][j][k]; if(dp[i][newj][newk] &gt;= mod) dp[i][newj][newk] -= mod; if(!vis[newj][newk]) &#123; vis[newj][newk] = true; nextque.push(&#123;newj, newk&#125;); &#125; &#125; &#125; que = nextque; &#125; ll ans = 0; for(int i = 0; i &lt; idx; i++) &#123; for(int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; // 可以把__builtin_popcount(j)预处理掉，这样更快 if(__builtin_popcount(j) &gt;= k) &#123; ans += dp[n][i][j]; if(ans &gt;= mod) ans -= mod; &#125; &#125; &#125; printf("%lld\n", ans); &#125; void debug() &#123; printf("%37c", ' '); for(int i = 0; i &lt; 26; i++) printf("%2c", i + 'a'); printf("\n"); for(int i = 0;i &lt; idx;i++) &#123; printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],end[i]); for(int j = 0;j &lt; 26;j++) printf("%2d",next[i][j]); printf("]\n"); &#125; &#125;&#125;ac;/********************************************************************************/int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;k) &amp;&amp; n) &#123; ac.init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%s", s); ac.insert(s, i); &#125; ac.build(); ac.query(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1023E Down or Right 题解]]></title>
    <url>%2F2018%2F08%2F18%2F0%2F</url>
    <content type="text"><![CDATA[题意已知一个n×n$(2 &lt;= n &lt;= 500)$的迷宫中存在一条(1, 1)到达(n, n)的路径，行走方向只能是向下或向右。现在需要你通过不超过$4*n$次的询问找出这条路径，注意每次询问的两个点曼哈顿距离不能小于$n-1$。具体交互规则请参考原题。 分析注意到次对角线一定存在一点可同时到达(1, 1)和(n, n)，因此，问题转化成了找(1, 1)到达这一点的路径以及这一点到达(n, n)的路径的问题。具体来说，我们首先固定(n, n)，然后从(1, 1)出发，不断询问下边一点和右边一点能否到达(n, n)，通过$n-1$次询问即可到达次对角线上的一点。同理，我们可以再找出从(n, n)到次对角线上一点的路线。为了保证(1, 1)和(n, n)到达的次对角线的位置是相同的，我们需要让从(1, 1)出发的路线尽可能往下走，然后从(n, n)出发的路线尽可能地往左走。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;int n, a[509][509], x, y;pii pre[509][509];string s;bool ask(int x, int y, int xx, int yy) &#123; cout &lt;&lt; "? " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; xx &lt;&lt; " " &lt;&lt; yy &lt;&lt; endl; cin &gt;&gt; s; return s[0] == 'Y';&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; x = 1, y = 1; for(int i = 1; i &lt; n; i++) &#123; if(ask(x + 1, y, n, n)) &#123; x++; a[x][y]++; pre[x][y] = pii(x - 1, y); &#125; else &#123; y++; a[x][y]++; pre[x][y] = pii(x, y - 1); &#125; &#125; string ans; while(!(x == 1 &amp;&amp; y == 1)) &#123; if(pre[x][y].x == x) &#123; y--; ans += 'R'; &#125; else &#123; x--; ans += 'D'; &#125; &#125; reverse(ans.begin(), ans.end()); x = n, y = n; for(int i = 1; i &lt; n; i++) &#123; if(ask(1, 1, x, y - 1)) &#123; y--; a[x][y]++; pre[x][y] = pii(x, y + 1); &#125; else &#123; x--; a[x][y]++; pre[x][y] = pii(x + 1, y); &#125; &#125; while(!(x == n &amp;&amp; y == n)) &#123; if(pre[x][y].x == x) &#123; y++; ans += 'R'; &#125; else &#123; x++; ans += 'D'; &#125; &#125; cout &lt;&lt; "! " &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2243 考研路茫茫――单词情结 题解]]></title>
    <url>%2F2018%2F08%2F16%2F0%2F</url>
    <content type="text"><![CDATA[题意给了n($0 &lt; n &lt; 6$)个模式串，需要求至少包含一个模式串、长度最长为L($ 0 &lt; L &lt; 2^{31} $)的字符串数。 分析注意到是多模式串匹配问题，所以考虑用AC自动机。又因为至少包含一个模式串的问题不太好直接求解，因此我们将其转化为求一个模式串都不包含的问题。我们用模式串建立AC自动机，每个模式串最终走到的节点是不合法的，且假如它的失配指针指向的节点是不合法的话，它也是不合法的，因为它指向的节点是它的一个后缀。然后，假设AC自动机的节点个数为$L$，那么我们就可以建立一个$ L * L $的方案矩阵，这个矩阵的$mat[i][j]$表示$i$到$j$的合法方案数，将这个矩阵求$n$次幂，就得到了走$n$步的方案矩阵。但是由于我们需要求走了$1$ ~ $n$步的方案数，所以需要求和，需要给矩阵最右端增加一列，全置为1，那么第一行最后一列的值减去1就是走了$1$ ~ $n-1$步的方案数。至于字符串总数，也是可以通过构造矩阵求解的，具体构造方法请参考代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* 矩阵快速幂：根据递推式快速计算第n项(Untested) * 矩阵构造、时间复杂度参考白书P201 */// 定义矩阵元素为long long的矩阵：typedef vector&lt;ull&gt; vll;typedef vector&lt;vll&gt; mat;mat mul(mat A, mat B)&#123; mat C(A.size(), vll(B[0].size(), 0)); for(int i = 0; i &lt; A.size(); i++) for(int k = 0; k &lt; A[0].size(); k++) for(int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]); return C;&#125;mat pow(mat A, ll n) &#123; mat B(A.size(), vll(A.size(), 0)); for(int i = 0; i &lt; B.size(); i++) B[i][i] = 1; while(n) &#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;/************************************************************//********************************************************************************//* AC自动机：解决多个模式串匹配问题(Tested 1 times) */struct AC &#123; int next[39][26], fail[39], end[39], idx, root; void init() &#123; idx = 0; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 26; i++) next[idx][i] = -1; end[idx] = false; return idx++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i] - 'a'] == -1) next[now][s[i] - 'a'] = newNode(); now = next[now][s[i] - 'a']; &#125; end[now] = true; //根据实际情况可能需要保存不同的信息 &#125; void build() &#123; queue&lt;int&gt; que; fail[root] = root; for(int i = 0; i &lt; 26; i++) &#123; if(next[root][i] == -1) &#123; next[root][i] = root; &#125; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); if(end[fail[now]] == true) end[now] = true; for(int i = 0; i &lt; 26; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; ull cntIllegal(ll L) &#123; mat a(idx + 1, vll(idx + 1, 0)); for(int i = 0; i &lt; idx; i++) for(int j = 0; j &lt; 26; j++) if(end[next[i][j]] == false) a[i][next[i][j]]++; for(int i = 0; i &lt; idx + 1; i++) a[i][idx] = 1; a = pow(a, L); ull ans = 0; for(int i = 0; i &lt; idx + 1; i++) ans += a[0][i]; return ans - 1; &#125;&#125;ac;/********************************************************************************/int n;ll L;char s[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%lld", &amp;n, &amp;L)) &#123; ac.init(); while(n--) &#123; scanf("%s", s); ac.insert(s); &#125; mat a(2, vll(2, 0)), b(2, vll(1, 0)); a[0][0] = 26, a[0][1] = 1; a[1][0] = 0, a[1][1] = 1; b[0][0] = 1; b[1][0] = 1; a = pow(a, L); a = mul(a, b); ull ans = a[0][0] - 1; ac.build(); ans -= ac.cntIllegal(L); printf("%llu\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>计数</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1020E Sergey's problem]]></title>
    <url>%2F2018%2F08%2F14%2F1%2F</url>
    <content type="text"><![CDATA[题意给一个可能有环（但肯定没有自环）的有向图，n($1 &lt;= n &lt;= 1e6$)个点，m($1 &lt;= m &lt;= 1e6$)条边，现在需要你选择一个点集，使得这些点之间没有连边，且这些点到点集之外的点的距离不超过2。 分析首先任意选择一点A放到点集里面，则这个点指向的点都不能放到点集里面，我们从原图中删掉这些点，然后再从残余图中找点集，假设这个点集为M。假如点集M中存在一点B有指向A的边，为了处理掉这个冲突，我们删掉A，因为B到A指向的点的距离不超过2，所以保证覆盖了全图。假如不存在，那么我们就将点集M和A合并，也保证了覆盖全图。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 2e6+9;int head[2][N], tot, n, m, u, v;bool vis[N], used[N];;void init() &#123; tot = 0; memset(head, -1, sizeof head);&#125;struct node &#123; int to, nex;&#125;edge[N];void addedge(int u, int v, int id) &#123; edge[tot] = node&#123;v, head[id][u]&#125;; head[id][u] = tot++;&#125;void dfs(int u) &#123; while(u &lt;= n &amp;&amp; vis[u]) u++; if(u == n + 1) return; used[u] = vis[u] = true; for(int i = head[0][u]; ~i; i = edge[i].nex) &#123; v = edge[i].to; vis[v] = true; &#125; dfs(u + 1); for(int i = head[1][u]; ~i; i = edge[i].nex) &#123; v = edge[i].to; if(used[v]) &#123; used[u] = false; break; &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v, 0); addedge(v, u, 1); &#125; dfs(1); vi ans; for(int i = 1; i &lt;= n; i++) if(used[i]) ans.push_back(i); printf("%d\n", (int)ans.size()); for(int i = 0; i &lt; ans.size(); i++) printf("%d%c", ans[i], " \n"[ans.size() - 1 == i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1020D The hat]]></title>
    <url>%2F2018%2F08%2F14%2F0%2F</url>
    <content type="text"><![CDATA[题意有n($2 &lt;= n &lt;= 1e5, n 为偶数$)个人围成一个圈，每个人有一个身上有一个号码，且相邻两人的号码差值为1，现在需要求是否存在一对对侧的人的号码相同，假如存在，输出下标，假如不存在，输出-1。最多询问60次，具体交互规则请参考原题。 分析首先注意到假如对侧两人的差值为奇数，那么一定不存在答案，输出-1。否则，因为差值是从负数渐变到正数的，所以肯定存在答案，二分即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3f;const double Eps = 1e-7;const int N = 1e5+9;int ask(int id) &#123; int ans; printf("? %d\n", id); fflush(stdout); scanf("%d", &amp;ans); return ans;&#125;int n, m, d[N], l, r;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; n; m = n / 2; d[1] = ask(1) - ask(1 + m); if(d[1] &amp; 1) &#123; printf("! -1\n"); fflush(stdout); return 0; &#125; if(d[1] == 0) &#123; printf("! 1\n"); fflush(stdout); return 0; &#125; l = 1, r = n / 2; while(true &amp;&amp; l + 1 != r) &#123; int mid = (l + r) &gt;&gt; 1; d[mid] = ask(mid) - ask(mid + m); if(d[mid] == 0) &#123; printf("! %d\n", mid); fflush(stdout); return 0; &#125; if((d[l] &lt; 0 &amp;&amp; d[mid] &lt; 0) || (d[l] &gt; 0 &amp;&amp; d[mid] &gt; 0)) l = mid; else r = mid; &#125; d[l] = ask(l) - ask(l + m); if(d[l] == 0) printf("! %d\n", l); else printf("! %d\n", r); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbin带你飞 专题十一 网络流 题解]]></title>
    <url>%2F2018%2F08%2F12%2F1%2F</url>
    <content type="text"><![CDATA[kuangin带你飞专题十一 网络流 传送门网络流问题 = 建模 + 高效模板 A. POJ 3436 ACM Computer Factory最大流问题，需要拆点、打印路径。 B. POJ 3281 Dining最大流问题，需要拆点。经典建模思路：将牛拆点放在中间，然后左边连食物，右边连饮料。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// 经测试，ISAP比dinic快了不少#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;/************************************************************/const int MAXN = 409;//点数的最大值const int MAXM = N;//边数的最大值struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, f, d, start, en, ff, dd, t;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;f, &amp;d)) &#123; start = 0, en = f + 2 * n + d + 1; init(); for(int i = 1; i &lt;= f; i++) addedge(0, i, 1); for(int i = 1; i &lt;= d; i++) addedge(f + 2 * n + i, en, 1); for(int i = 1; i &lt;= n; i++) addedge(f + i, f + n + i, 1); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;ff, &amp;dd); for(int j = 0; j &lt; ff; j++) &#123; scanf("%d", &amp;t); addedge(t, f + i, 1); &#125; for(int j = 0; j &lt; dd; j++) &#123; scanf("%d", &amp;t); addedge(f + n + i, f + 2 * n + t, 1); &#125; &#125; int ans = sap(start, en, en + 1); printf("%d\n", ans); &#125; return 0;&#125; C. POJ 1087 A Plug for UNIX最大流问题，很容易想，但是需要细心，理解好题意，计算好节点个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;/************************************************************************************//* dinic算法：解决最大流问题。 * 时间复杂度为O(|E| * |V| * |V|)，不过，该算法在实际应用中速度非常快。 * */const int MAX_V = 509;struct edge&#123;int to, cap, rev; &#125;;vector&lt;edge&gt; G[MAX_V];int level[MAX_V];int iter[MAX_V];void add_edge(int from, int to, int cap)&#123; G[from].push_back((edge)&#123;to, cap, static_cast&lt;int&gt;(G[to].size())&#125;); G[to].push_back((edge)&#123;from, 0, static_cast&lt;int&gt;(G[from].size()-1)&#125;);&#125;void bfs(int s)&#123; memset(level, -1, sizeof level); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty())&#123; int v=que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++)&#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[e.to]&lt;0)&#123; level[e.to]=level[v]+1; que.push(e.to); &#125; &#125; &#125;&#125;int dfs(int v, int t, int f)&#123; if(v==t) return f; for(int &amp;i=iter[v]; i&lt;G[v].size(); i++)&#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])&#123; int d=dfs(e.to, t, min(f, e.cap)); if(d&gt;0)&#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int max_flow(int s, int t)&#123; int flow=0; while(1)&#123; bfs(s); if(level[t]&lt;0) return flow; memset(iter, 0, sizeof iter); int f; while((f=dfs(s, t, INF))&gt;0) flow+=f; &#125;&#125;/************************************************************************************/int start, en, n, m, k, tot;string s, t, s1, s2;map&lt;string, int&gt; ms, mt;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; start = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; if(!ms[s]) ms[s] = ++tot; add_edge(0, ms[s], 1); &#125; scanf("%d", &amp;m); en = 400 + m + 1; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; t &gt;&gt; s; if(!mt[t]) mt[t] = ++tot; if(!ms[s]) ms[s] = ++tot; add_edge(ms[s], mt[t], 1); add_edge(mt[t], en, 1); &#125; scanf("%d", &amp;k); for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2; if(!ms[s1]) ms[s1] = ++tot; if(!ms[s2]) ms[s2] = ++tot; add_edge(ms[s2], ms[s1], INF); &#125; int ans = m - max_flow(start, en); printf("%d\n", ans); return 0;&#125; D. POJ 2195 Going Home最小费用最大流问题，也可以当成二分图最小权匹配问题来写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;/************************************************************//* SPFA版最小费用最大流算法(Untested) * 最小费用最大流,求最大费用只需要取相反数,结果取相反数即可。 * 点的总数为 N,点的编号 0 ~ N-1 */const int MAXN = 10000;const int MAXM = 100000;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int N;//节点总个数,节点编号从 0 ∼ N-1void init(int n)&#123; N = n; tol = 0; memset(head, -1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; N;i++)&#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge [i].cost ) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;//返回的是最大流,cost 存的是最小费用int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t))&#123; int Min = INF; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow;&#125;/************************************************************/vector&lt;pii&gt; vm, vh;int n, m, start, en, id, id1, cost;char g[109][109];int ID(int i, int j) &#123; return i * m + j + 1;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; if(!n &amp;&amp; !m) break; start = 0; en = n * m + 1; init(en + 1); vm.clear(); vh.clear(); for(int i = 0; i &lt; n; i++) scanf("%s", g[i]); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(g[i][j] == 'm') vm.push_back(pii(i, j)); else if(g[i][j] == 'H') vh.push_back(pii(i, j)); &#125; &#125; for(vector&lt;pii&gt;::iterator it = vm.begin(); it != vm.end(); it++) &#123; pii i = *it; id = ID(i.x, i.y); addedge(start, id, 1, 0); for(vector&lt;pii&gt;::iterator it1 = vh.begin(); it1 != vh.end(); it1++) &#123; pii j = *it1; id1 = ID(j.x, j.y); cost = abs(i.x - j.x) + abs(i.y - j.y); addedge(id, id1, 1, cost); &#125; &#125; for(vector&lt;pii&gt;::iterator it = vh.begin(); it != vh.end(); it++) &#123; pii i = *it; id = ID(i.x, i.y); addedge(id, en, 1, 0); &#125; minCostMaxflow(start, en, cost); printf("%d\n", cost); &#125; return 0;&#125; E. POJ 2516 Minimum Cost最小费用最大流问题，需要将每个物品分别处理，最后累加。假如直接将所有物品一起建图处理的话，不仅麻烦，而且会超时。套路：把一个问题分成几个子问题来求解，可降低时间复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;/************************************************************//* SPFA版最小费用最大流算法(Tested 1 times) * 最小费用最大流,求最大费用只需要取相反数,结果取相反数即可。 * 点的总数为 N,点的编号 0 ~ N-1 */const int MAXN = 10000;const int MAXM = 100000;struct Edge&#123; int to,next,cap,flow,cost;&#125;edge[MAXM];int head[MAXN],tol;int pre[MAXN],dis[MAXN];bool vis[MAXN];int NN;//节点总个数,节点编号从 0 ∼ NN-1void init(int n)&#123; NN = n; tol = 0; memset(head, -1,sizeof(head));&#125;void addedge(int u,int v,int cap,int cost)&#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;bool spfa(int s,int t)&#123; queue&lt;int&gt;q; for(int i = 0;i &lt; NN;i++)&#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge [i].cost ) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true;&#125;//返回的是最大流,cost 存的是最小费用int minCostMaxflow(int s,int t,int &amp;cost)&#123; int flow = 0; cost = 0; while(spfa(s,t))&#123; int Min = INF; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != - 1;i = pre[edge[i^1].to])&#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow;&#125;/************************************************************/int n, m, k, need, ans, cost, a[109][109], start, en, b[109][109], d, tot;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; if(!n) break; need = 0, tot = 0, ans = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; scanf("%d", a[i] + j); need += a[i][j]; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; scanf("%d", b[i] + j); &#125; &#125; start = 0, en = n + m + 1; for(int o = 0; o &lt; k; o++) &#123; init(en + 1); for(int i = 0; i &lt; m; i++) &#123; addedge(start, i + 1, b[i][o], 0); &#125; for(int i = 0; i &lt; n; i++) &#123; addedge(m + i + 1, en, a[i][o], 0); &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;d); addedge(j + 1, m + i + 1, INF, d); &#125; &#125; tot += minCostMaxflow(start, en, cost); ans += cost; &#125; if(tot != need) printf("-1\n"); else printf("%d\n", ans); &#125; return 0;&#125; F. POJ 1459 Power Network最大流问题，题意有点难懂，输入需要点处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;const int N=1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题 * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 */const int MAXN = 109;//点数的最大值const int MAXM = 20409;//边数的最大值struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, np, nc, m, start, en, u, v, cap;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d%d", &amp;n, &amp;np, &amp;nc, &amp;m)) &#123; init(); start = 0, en = n + 1; for(int i = 0; i &lt; m; i++) &#123; scanf(" (%d,%d)%d", &amp;u, &amp;v, &amp;cap); addedge(u + 1, v + 1, cap); &#125; for(int i = 0; i &lt; np; i++) &#123; scanf(" (%d)%d", &amp;u, &amp;cap); addedge(start, u + 1, cap); &#125; for(int i = 0; i &lt; nc; i++) &#123; scanf(" (%d)%d", &amp;u, &amp;cap); addedge(u + 1, en, cap); &#125; int ans = sap(start, en, en + 1); printf("%d\n", ans); &#125; return 0;&#125; G. HDU 4280 Island Transport最大流问题，很裸，但是直接上dinic算法的话，会超时，需要用带优化的ISPA算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;const int MAXN = 100010;//点数的最大值const int MAXM = 400010;//边数的最大值struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;int start, en, mifix, mafix, T, n, m, x, u, v, cap;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; T; while(T--) &#123; scanf("%d%d", &amp;n, &amp;m); init(); start = -1, mifix = INF, en = -1, mafix = -INF; for(int i = 0; i &lt; n; i++) &#123; scanf("%d%*d", &amp;x); if(x &lt; mifix) &#123; start = i; mifix = x; &#125; if(x &gt; mafix) &#123; en = i; mafix = x; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;cap); u--, v--; addedge(u, v, cap); addedge(v, u, cap); &#125; int ans = sap(start, en, n); printf("%d\n", ans); &#125; return 0;&#125; H. HDU 4292 Food最大流问题，是POJ 3281的升级版，灵活修改一下边权即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;const int N=1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题 * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 */const int MAXN = 1009;//点数的最大值const int MAXM = 400010;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, f, d, start, en, t;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;f, &amp;d)) &#123; init(); start = 0, en = f + 2 * n + d + 1; for(int i = 1; i &lt;= f; i++) &#123; scanf("%d", &amp;t); addedge(start, i, t); &#125; for(int i = 1; i &lt;= d; i++) &#123; scanf("%d", &amp;t); addedge(f + 2 * n + i, en, t); &#125; for(int i = 1; i &lt;= n; i++) &#123; addedge(f + i, f + n + i, 1); &#125; for(int i = 1; i &lt;= n; i++) &#123; getchar(); for(int j = 1; j &lt;= f; j++) &#123; if(getchar() == 'Y') &#123; addedge(j, f + i, 1); &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; getchar(); for(int j = 1; j &lt;= d; j++) &#123; if(getchar() == 'Y') &#123; addedge(f + n + i, f + 2 * n + j, 1); &#125; &#125; &#125; int ans = sap(start, en, en + 1); printf("%d\n", ans); &#125; return 0;&#125; I. HDU 4289 Control最小割问题，需要拆点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const double Eps=1e-7;const int N=1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题 * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 */const int MAXN = 409;//点数的最大值const int MAXM = 400010;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, m, start, en, d, u, v;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); scanf("%d%d", &amp;start, &amp;en); en += n; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;d); addedge(i, i + n, d); &#125; while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u + n, v, INF); addedge(v + n, u, INF); &#125; int ans = sap(start, en, 2 * n + 1); printf("%d\n", ans); &#125; return 0;&#125; J. UVA 10480 Sabotage最小割问题，要求输出割边。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* EK算法：解决最大流问题，使用邻接矩阵，可打印路径(Tested 0 times) * 初始化：g[][], start, end, nn * 时间复杂度：O(|V| * |E| * |E|) */const int MAXN = 110;int g[MAXN][MAXN];//存边的容量，没有边的初始化为0int path[MAXN], flow[MAXN], start, en;int nn;//点的个数，编号0-nn.nn包括了源点和汇点queue&lt;int&gt;q;int bfs() &#123; int i,t; memset(flow, 0, sizeof flow); while(!q.empty()) q.pop();//把清空队列 memset(path, -1, sizeof path);//每次搜索前都把路径初始化成-1 path[start] = 0; flow[start] = INF;//源点可以有无穷的流流进 q.push(start); while(!q.empty()) &#123; t = q.front(); q.pop(); if(t == en) break; //枚举所有的点，如果点的编号起始点有变化可以改这里 for(i = 1;i &lt;= nn; i++) &#123; if(i != start &amp;&amp; path[i] == -1 &amp;&amp; g[t][i]) &#123; flow[i] = min(flow[t], g[t][i]); q.push(i); path[i] = t; &#125; &#125; &#125; if(path[en] == -1) return -1;//找不到增广路径了 return flow[en];&#125;int max_flow() &#123; int max_flow = 0; int step, now, pre; while((step = bfs()) != -1) &#123; max_flow += step; now = en; while(now != start) &#123; pre = path[now]; g[pre][now] -= step; g[now][pre] += step; now = pre; &#125; &#125; return max_flow;&#125;/************************************************************/pii a[N];int n, m, w;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n) &#123; memset(g, 0, sizeof g); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;a[i].x, &amp;a[i].y, &amp;w); g[a[i].x][a[i].y] = g[a[i].y][a[i].x] = w; &#125; start = 1, en = 2, nn = n; max_flow(); for(int i = 0; i &lt; m; i++) &#123; if((flow[a[i].x] &amp;&amp; !flow[a[i].y]) || (flow[a[i].y] &amp;&amp; !flow[a[i].x])) printf("%d %d\n", a[i].x, a[i].y); &#125; printf("\n"); &#125; return 0;&#125; K. HDU 2732 Leapin’ Lizards最大流问题，需要拆点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 3+ times) * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 */const int MAXN = 1001;//点数的最大值const int MAXM = 20009;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/char g[29][29];int n, m, d, start, en, T, kase;int ID(int i, int j) &#123; return (i - 1) * m + j;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;n, &amp;d); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", g[i] + 1); &#125; m = strlen(g[1] + 1); init(); start = 0, en = 2 * n * m + 1; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(g[i][j] == '0') continue; addedge(ID(i, j), n * m + ID(i, j), g[i][j] - '0'); for(int x = -d; x &lt;= d; x++) &#123; for(int y = -d; y &lt;= d; y++) &#123; if(!x &amp;&amp; !y) continue; if(abs(x) + abs(y) &gt; d) continue; int nx = i + x, ny = j + y; if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) &#123; addedge(n * m + ID(i, j), en, 3); &#125; else addedge(n * m + ID(i, j), ID(nx, ny), 3); &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", g[i] + 1); for(int j = 1; j &lt;= m; j++) &#123; if(g[i][j] == 'L') &#123; ans++; addedge(start, ID(i, j), 1); &#125; &#125; &#125; ans -= sap(start, en, en + 1); if(ans == 0) &#123; printf("Case #%d: no lizard was left behind.\n", ++kase); &#125; else if(ans == 1) &#123; printf("Case #%d: %d lizard was left behind.\n", ++kase, ans); &#125; else &#123; printf("Case #%d: %d lizards were left behind.\n", ++kase, ans); &#125; &#125; return 0;&#125; L. HDU 3338 Kakuro Extension行列模型的最大流问题，比较神奇。还需要处理一下最小下界流量的限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 6 times) * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 * 时间复杂度：O(|E| * |V| * |V|) */const int MAXN = 100010;//点数的最大值const int MAXM = 400010;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];// start起点，end为终点，nodeNum为顶点数，一般为en+1，注意en不为最后一个顶点的情况！int sap(int start,int end,int nodeNum) &#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, m, lx[109][109], ly[109][109], num[10009], cnt, id[109][109];char s[109][109][9];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; cnt = 0; memset(lx, 0, sizeof lx); memset(ly, 0, sizeof ly); memset(num, 0, sizeof num); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; scanf("%s", s[i][j]); if(strcmp(s[i][j], ".......") == 0) &#123; if(j == 0 || lx[i][j - 1] == 0) lx[i][j] = ++cnt; else lx[i][j] = cnt; num[cnt]++; &#125; &#125; &#125; for(int j = 0; j &lt; m; j++) &#123; for(int i = 0; i &lt; n; i++) &#123; if(strcmp(s[i][j], ".......") == 0) &#123; if(i == 0 || lx[i - 1][j] == 0) ly[i][j] = ++cnt; else ly[i][j] = cnt; num[cnt]++; &#125; &#125; &#125; init(); int start = 0, en = cnt + 1, nodeNum = en + 1; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(strcmp(s[i][j], ".......") == 0) &#123; id[i][j] = tol; addedge(lx[i][j], ly[i][j], 8); &#125; if(s[i][j][3] != '\\') continue; if(s[i][j][0] != 'X') &#123; int t = (s[i][j][0] - '0') * 100 + (s[i][j][1] - '0') * 10 + (s[i][j][2] - '0'); addedge(ly[i + 1][j], en, t - num[ly[i + 1][j]]); &#125; if(s[i][j][4] != 'X') &#123; int t = (s[i][j][4] - '0') * 100 + (s[i][j][5] - '0') * 10 + (s[i][j][6] - '0'); addedge(start, lx[i][j + 1], t - num[lx[i][j + 1]]); &#125; &#125; &#125; sap(start, en, nodeNum); //cout &lt;&lt; t &lt;&lt; endl; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(j) putchar(' '); if(strcmp(s[i][j], ".......") == 0) &#123; putchar('0' + edge[id[i][j]].flow + 1); &#125; else &#123; putchar('_'); &#125; &#125; putchar('\n'); &#125; &#125; return 0;&#125; M. HDU 3605 Escape最大流问题，直接建流量为1的图会TLE，需要把同种类型的人看做一个点，然后建流量等于人数的边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 4 times) * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 */const int MAXN = 100029;//点数的最大值const int MAXM = MAXN * 23;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init(int t)&#123; tol = 0; memset(head,-1,sizeof(int) * t);&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int n, m, start, en, d, cnt[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; start = 0, en = (1 &lt;&lt; m) + m; memset(cnt, 0, sizeof(int) * (1 &lt;&lt; m)); init(en + 1); for(int i = 0; i &lt; n; i++) &#123; int sum = 0; for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;d); if(d) sum += 1 &lt;&lt; j; &#125; cnt[sum]++; &#125; int up = 1 &lt;&lt; m; for(int i = 1; i &lt; up; i++) &#123; addedge(start, i, cnt[i]); for(int j = 0; j &lt; m; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; addedge(i, up + j, cnt[i]); &#125; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d); addedge(up + i, en, d); &#125; int ans = sap(start, en, en + 1); if(ans == n) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; N. HDU 3081 Marriage Match II最大流问题 + 二分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;/************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 4 times) * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 */const int MAXN = 209;//点数的最大值const int MAXM = 20409;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge&#123; int to,next,cap,flow;&#125;edge[MAXM], edget[MAXM];//注意是 MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow)&#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next)&#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int fa[N];int find(int u) &#123; return fa[u] == u ? u : fa[u] = find(fa[u]);&#125;void uf(int u, int v) &#123; fa[find(u)] = fa[find(v)];&#125;int T, n, m, k, u, v;int headt[N];vi to[N], too[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); init(); int start = 0, en = 2 * n + 1; for(int i = 1; i &lt;= n; i++) &#123; to[i].clear(); too[i].clear(); fa[i] = i; &#125; while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); to[u].push_back(v); &#125; while(k--) &#123; scanf("%d%d", &amp;u, &amp;v); uf(u, v); &#125; for(int i = 1; i &lt;= n; i++) &#123; int fa = find(i); for(auto j: to[i]) &#123; too[fa].push_back(j); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; sort(too[i].begin(), too[i].end()); too[i].resize(unique(too[i].begin(), too[i].end()) - too[i].begin()); &#125; for(int i = 1; i &lt;= n; i++) &#123; int fa = find(i); for(auto j: too[fa]) &#123; addedge(i, n + j, 1); &#125; &#125; int tolt = tol; memcpy(headt, head, sizeof head); memcpy(edget, edge, sizeof edge); int l = 0, r = n + 1; while(l + 1 != r) &#123; int mid = l + (r - l) / 2; memcpy(head, headt, sizeof(int) * (en + 1)); memcpy(edge, edget, sizeof(Edge) * (tol + 1)); tol = tolt; for(int i = 1; i &lt;= n; i++) &#123; addedge(start, i, mid); addedge(n + i, en, mid); &#125; int t = sap(start, en, en + 1); if(t == n * mid) l = mid; else r = mid; &#125; printf("%d\n", l); &#125; return 0;&#125; O. HDU 3416 Marriage Match IV最大流问题 + 最短路问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const long double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const ll LINF = 9223372036854775807;const double Eps = 1e-7;const int N = 1e5+9;int head[2][1009], tot;struct Edge &#123; int v, c, next; Edge () &#123;&#125; Edge (int v, int c, int next): v(v), c(c), next(next) &#123;&#125;&#125;edge[2 * N];void addedge(int u, int v, int c, int ty) &#123; edge[tot] = Edge&#123;v, c, head[ty][u]&#125;; head[ty][u] = tot++;&#125;void init() &#123; memset(head, -1, sizeof head); tot = 0;&#125;/************************************************************//* dijkstra算法：解决最短路问题(Tested 0 times) * 前向心存图 */const int MAX_V=10009;int d[2][MAX_V];void dijkstra(int s, int ty) &#123; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; que; d[ty][s] = 0; que.push(pii(0, s)); while(!que.empty()) &#123; pii p = que.top(); que.pop(); int u = p.second; if(d[ty][u] &lt; p.first) continue; for(int i = head[ty][u]; ~i; i = edge[i].next) &#123; Edge e = edge[i]; if(d[ty][e.v] &gt; d[ty][u] + e.c) &#123; d[ty][e.v] = d[ty][u] + e.c; que.push(pii(d[ty][e.v], e.v)); &#125; &#125; &#125;&#125;/************************************************************//************************************************************//* ISAP + bfs初始化 + 栈优化：超高效地解决最大流问题(Tested 5 times) * 注意修改MAXN和MAXM成适合的大小，以提高时间效率 * 时间复杂度：O(|E| * |V| * |V|) */const int MAXN = 1009;//点数的最大值const int MAXM = 200009;//边数的最大值，注意反向边也要算进去，也就是说要乘以2struct Edge1&#123; int to,next,cap,flow;&#125;edge1[MAXM];//注意是 MAXMint tol;int head1[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init1()&#123; tol = 0; memset(head1,-1,sizeof(head1));&#125;void addedge1(int u,int v,int w,int rw = 0)&#123; edge1[tol].to = v; edge1[tol].cap = w; edge1[tol].flow = 0; edge1[tol].next = head1[u]; head1[u] = tol++; edge1[tol].to = u; edge1[tol].cap = rw; edge1[tol].flow = 0; edge1[tol].next = head1[v]; head1[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear)&#123; int u = Q[front++]; for(int i = head1[u]; i != -1; i = edge1[i].next)&#123; int v = edge1[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head1,sizeof(head1)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N)&#123; if(u == end)&#123; int Min = INF; int inser; for(int i = 0;i &lt; top;i++) if(Min &gt; edge1[S[i]].cap - edge1[S[i]].flow)&#123; Min = edge1[S[i]].cap - edge1[S[i]].flow; inser = i; &#125; for(int i = 0;i &lt; top;i++)&#123; edge1[S[i]].flow += Min; edge1[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge1[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge1[i].next)&#123; v = edge1[i].to; if(edge1[i].cap - edge1[i].flow &amp;&amp; dep[v]+1 == dep[u])&#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag)&#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head1[u]; i != -1; i = edge1[i].next) if(edge1[i].cap - edge1[i].flow &amp;&amp; dep[edge1[i].to] &lt; Min) &#123; Min = dep[edge1[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge1[S[--top]^1].to; &#125; return ans;&#125;/************************************************************/int T, n, m, u, v, c[N];pii a[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d", &amp;T); while(T--) &#123; init(); scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, c + i); a[i] = pii(u, v); addedge(u, v, c[i], 0); addedge(v, u, c[i], 1); &#125; scanf("%d%d", &amp;u, &amp;v); memset(d, INF, sizeof d); dijkstra(u, 0); dijkstra(v, 1); init1(); int start = 0, en = v; for(int i = 0; i &lt; m; i++) &#123; if(d[0][a[i].x] + c[i] + d[1][a[i].y] == d[0][v]) &#123; addedge1(a[i].x, a[i].y, 1); &#125; &#125; addedge1(start, u, INF); printf("%d\n", sap(start, en, n + 1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1016E Rest In The Shades]]></title>
    <url>%2F2018%2F08%2F12%2F0%2F</url>
    <content type="text"><![CDATA[题意有一个光源在x轴下方且平行于x轴的某条线段AB上作匀速直线运动，x轴上有n($$1 &lt;= n &lt;= 210^5$$)条会阻挡光线的线段，现在有q($$1 &lt;= n &lt;= 210^5$$)个在x轴上方的点，问这q个点没有被光线照射到的时间分别是多少。 分析经过观察发现，到达某个点的光假如会被多条线段阻挡，那么这些线段大部分是完整且相邻的，最多只有两条线段是不完整的，因此，我们可以用前缀和来处理完整的线段，然后用二分搜索来处理不完整的线段，求和。接着，由相似三角形的相关定理可计算出在x轴上线段在AB上投影，进而求得答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const double Eps=1e-7;double sum[N];int n, l, r, q, x, y, vis, idx1, idx2;double sy, xa, xb;struct node &#123; double l, r, id; node() &#123;&#125; node(double l, double r, int id): l(l), r(r), id(id) &#123;&#125; bool operator &lt; (const node &amp;rhs) const &#123; if(l != rhs.l) return l &lt; rhs.l; if(r != rhs.r) return r &lt; rhs.r; return id &lt; rhs.id; &#125;&#125;;set&lt;node&gt; se;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%lf%lf%lf", &amp;sy, &amp;xa, &amp;xb)) &#123; scanf("%d", &amp;n); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;l, &amp;r); sum[i] = sum[i-1] + r - l; se.insert(node(l, r, i)); &#125; scanf("%d", &amp;q); while(q--) &#123; scanf("%d%d", &amp;x, &amp;y); double ans = 0; double x1 = (y * xa - sy * x) / (y - sy); double x2 = (y * xb - sy * x) / (y - sy); auto it = se.lower_bound(node(x1, -1, -1)); vis = -1; idx1 = (it == se.end() ? INF : it-&gt;id); if(it != se.begin()) &#123; it--; if(x1 &lt; it-&gt;r) &#123; ans += min(it-&gt;r, x2) - x1; vis = it-&gt;id; &#125; &#125; it = se.lower_bound(node(x2, -1, -1)); if(it != se.begin()) &#123; it--; if(x2 &lt; it-&gt;r &amp;&amp; vis != it-&gt;id) &#123; ans += x2 - max(it-&gt;l, x1); &#125; if(x2 &lt; it-&gt;r) &#123; if(it != se.begin()) &#123; it--; idx2 = it-&gt;id; &#125; else &#123; idx2 = -INF; &#125; &#125; else &#123; idx2 = it-&gt;id; &#125; &#125; else &#123; idx2 = -INF; &#125; if(idx1 &lt;= idx2) &#123; ans += sum[idx2] - sum[idx1-1]; &#125; ans *= 1.0 * (y - sy) / y; printf("%.10f\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6356 Glad You Came]]></title>
    <url>%2F2018%2F08%2F09%2F0%2F</url>
    <content type="text"><![CDATA[题意给一个长度为n$ (1 &lt;= n &lt;= 10^5 $)的数组，所有元素的初始值为0，然后有m$ (1 &lt;= m &lt;= 5*10^6 $)个操作，更新某段区间的最大值。 分析 官方题解：如果有两个操作覆盖相同的区间，我们可以保留最大的那个。 对于每个操作$(l, r, v)$，令d等于$\lfloor log_2(r - l + 1) \rfloor$，我们可以用两个操作 $(l, l + 2^d - 1, v)$ 和$(r - 2^d + 1, r, v)$ 替换此操作。这样做之后，每个操作所覆盖的区间长度均为 2 的幂，这意味着长度仅有 $O(logn)$种。剩下的只不过是，按长度递减的顺序枚举操作，将每个操作分成两个相等长度的操作，直到区间长度为一。这样做的时间复杂度为$O(m + nlogn)$，空间复杂度为$O(nlogn)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;unsigned X, Y, Z;int T, Log[N], n, m, mx, l, r, v, d, a[19][N];unsigned int rng61() &#123; X ^= X &lt;&lt; 11; X ^= X &gt;&gt; 4; X ^= X &lt;&lt; 5; X ^= X &gt;&gt; 14; unsigned int tmp = X ^ Y ^ Z; X = Y; Y = Z; Z = tmp; return Z;&#125;void upd(int &amp;d, int v) &#123; d &lt; v &amp;&amp; (d = v);&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; // 2^k &lt;= i &lt; 2^(k+1)，预处理出i对应的k for(int i = 2; i &lt; N; i++) Log[i] = Log[i &gt;&gt; 1] + 1; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%u%u%u", &amp;n, &amp;m, &amp;X, &amp;Y, &amp;Z); while(m--) &#123; l = rng61() % n + 1, r = rng61() % n + 1; if(l &gt; r) swap(l, r); v = rng61() % (1 &lt;&lt; 30); d = Log[r - l + 1]; // 逆用ST表 upd(a[d][l], v); upd(a[d][r - (1 &lt;&lt; d) + 1], v); &#125; // 求出满足2^mx &gt; n 的最小mx mx = 0; while(1 &lt;&lt; mx &lt;= n) mx++; // O(nlogn) 从大区间推到小区间，直到1 for(int i = mx - 1; i &gt; 0; i--) &#123; for(int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) &#123; upd(a[i - 1][j], a[i][j]); upd(a[i - 1][j + (1 &lt;&lt; (i - 1))], a[i][j]); a[i][j] = 0; &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans ^= 1LL * i * a[0][i]; a[0][i] = 0; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018杭电多校第四场B题 Harvest of Apples]]></title>
    <url>%2F2018%2F08%2F01%2F0%2F</url>
    <content type="text"><![CDATA[题意有n个苹果，编号为1到n，求从中最多选取m个苹果的方案数。测试组数有T组。($$ 1≤T≤10^5, 1≤m≤n≤10^5 $$) 分析 官方题解:定义 $$ S(n, m) = \sum_{i = 0} ^ {m} {n \choose i} $$，不难发现$$ S(n,m)=S(n,m−1)+{n \choose m} $$, $$ S(n,m)=2S(n−1,m)−{n-1 \choose m} $$.也就是说，如果我们知道 S(n, m)，就能以 O(1) 的代价计算出S(n−1,m), S(n,m−1), S(n+1,m), S(n,m+1)，可以采用莫队算法。 水题，直接实现就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;const int p = 1e9 + 7;ll fac[N], ni[N], ans, an[N], ni2;int len, n, m, T;ll pow_mod(ll a, ll b, ll p) &#123; //辅助函数 ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;ll inv_Fermat(ll a, ll p) &#123; //费马小定理求a关于p的逆元 return pow_mod(a, p-2, p);&#125;void init() &#123; fac[0] = 1; len = sqrt(100000); ni2 = inv_Fermat(2, p); for(int i = 1; i &lt;= 100005; i++) fac[i] = fac[i-1] * i % p; ni[100005] = inv_Fermat(fac[100005], p); for(int i = 100004; i &gt;= 0; i--) ni[i] = ni[i+1] * (i + 1) % p;&#125;struct Node &#123; int n, m, block, id; Node() &#123;&#125; Node(int n, int m, int id):n(n), m(m), id(id) &#123; block = n / len; &#125; bool operator &lt; (Node &amp;rhs) const &#123; if(block == rhs.block) return m &lt; rhs.m; return block &lt; rhs.block; &#125;&#125;q[N];ll C(int n, int m) &#123; return fac[n] * ni[m] % p * ni[n-m] % p;&#125;int main(void) &#123; init(); scanf("%d", &amp;T); for(int i = 0; i &lt; T; i++) &#123; scanf("%d%d", &amp;n, &amp;m); q[i]= Node&#123;n, m, i&#125;; &#125; sort(q, q + T); n = 1, m = 1; ans = 2; for(int i = 0; i &lt; T; i++) &#123; Node &amp;t = q[i]; while(n &lt; t.n) &#123; ++n; (ans = ans * 2 - C(n-1, m)) %= p; &#125; while(m &lt; t.m) &#123; ++m; (ans = ans + C(n, m)) %= p; &#125; while(n &gt; t.n) &#123; (ans = (ans + C(n-1, m)) * ni2) %= p; n--; &#125; while(m &gt; t.m) &#123; (ans = ans - C(n, m)) %= p; m--; &#125; ans = (ans + p) % p; an[t.id] = ans; &#125; for(int i = 0; i &lt; T; i++) &#123; printf("%lld\n", an[i]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018牛客多校第二场J题 farm]]></title>
    <url>%2F2018%2F07%2F30%2F0%2F</url>
    <content type="text"><![CDATA[题意有一个$$ nm(nm&lt;=1e6) $$的矩形,每个位置有一个数。有$$ T(T&lt;=1e6) $$次操作,每次往一个子矩形的每个格子中放入一个数。求有多少个格子中被放入了至少一个与对应位置不相同的数。 分析 官方题解：先考虑一个特殊的情况:矩形中的数和T次操作放的数都为0或1。对于这种情况,我们只需要用矩阵前缀和统计一下每个格子被多少个0覆盖,被多少个1覆盖。如果一个格子的数为0且被放入了至少一个1或这个格子的数位1且被放入了至少一个0则就会对答案产生贡献。然后考虑原问题。如果某个格子的数是i,而它被放入了至少一个j,且i!=j,则需要统计进入答案。注意到,i!=j则i和j至少有一个二进制位不相同。我们枚举0~19的每一个二进制位,然后把所有数字按照这一位是0还是1划分成两个集合,就变成了上述特殊情况的问题。一个格子只要至少在某一个二进制位的子问题时被统计进入答案,就加到总答案中去。复杂度 $O((nm+T)log(nm)) $ 官方题解说得很清楚了，直接实现就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const double Eps=1e-7; int n, m, T, a[N], x, y, xx, yy, k, num[N][20][2], ans; int id(int x, int y) &#123; if(x == 0 || y == 0) return 0; return (x - 1) * m + y;&#125; int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;T)) &#123; ans = 0; memset(num, 0, sizeof num); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[id(i, j)]); while(T--) &#123; scanf("%d%d%d%d%d", &amp;x, &amp;y, &amp;xx, &amp;yy, &amp;k); for(int bit = 0; bit &lt; 20; bit++) &#123; num[id(x, y)][bit][k &gt;&gt; bit &amp; 1]++; if(yy + 1 &lt;= m) num[id(x, yy + 1)][bit][k &gt;&gt; bit &amp; 1]--; if(xx + 1 &lt;= n) num[id(xx + 1, y)][bit][k &gt;&gt; bit &amp; 1]--; if(xx + 1 &lt;= n &amp;&amp; yy + 1 &lt;= m) num[id(xx + 1, yy + 1)][bit][k &gt;&gt; bit &amp; 1]++; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; bool flag = false; for(int bit = 0; bit &lt; 20; bit++) &#123; num[id(i, j)][bit][0] += num[id(i - 1, j)][bit][0] + num[id(i, j - 1)][bit][0] - num[id(i - 1, j - 1)][bit][0]; num[id(i, j)][bit][1] += num[id(i - 1, j)][bit][1] + num[id(i, j - 1)][bit][1] - num[id(i - 1, j - 1)][bit][1]; if((a[id(i, j)] &gt;&gt; bit &amp; 1 &amp;&amp; num[id(i, j)][bit][0]) || (!(a[id(i, j)] &gt;&gt; bit &amp; 1) &amp;&amp; num[id(i, j)][bit][1])) flag = true; &#125; if(flag) ans++; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法学习笔记（二）]]></title>
    <url>%2F2018%2F07%2F27%2F0%2F</url>
    <content type="text"><![CDATA[介绍上一篇莫队算法学习笔记主要写了普通莫队算法的应用，这次来写一写树上莫队和带修改莫队。树上莫队，就是将树转化为序列，然后应用莫队算法来解决。带修改莫队，相比于普通莫队，增加了单点修改的操作，时间复杂度由$ O(n\sqrt{n}) $ 上升到了$ O(n^{\frac{5}{3}}) $。所以，在没有其他特殊条件的情况下，对于$ n = 1e5 $次询问，一般需要2秒的处理时间。经过实战发现，莫队算法很适合处理需要统计元素出现次数的问题，而这类问题用其他数据结构，如线段树，不太好解决（神犇请无视）。而且，莫队算法实现起来相对容易，空间消耗小。但是，莫队算法也有它的局限性，即时间复杂度偏高，且不能处理区间修改的问题。 题目1：CodeForces - 375D - Tree and Queries题意给一颗具有n个节点的有根树，每个节点染有一种颜色。然后有m个询问，询问的是某个节点子树的颜色数。 分析假如我们知道了从根出发的dfs序，那么一颗子树就对应dfs序的一个区间，因此，原问题就转化成了求某个区间的颜色数，应用普通莫队即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const double Eps=1e-7;int len, cnt, in[N], out[N], c[N], nc[N], u, k, v, n, m, f[N], sum[N], ans[N];vi G[N];struct node &#123; int l, r, k, id, block; node() &#123;&#125; node(int l, int r, int k, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;k = k; this-&gt;id = id; this-&gt;block = l / len ; &#125; bool operator &lt; (const node t) const &#123; if(block == t.block) return r &lt; t.r; return block &lt; t.block; &#125;&#125;q[N];void dfs(int u, int fa) &#123; in[u] = ++cnt; nc[cnt] = c[u]; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if(v == fa) continue; dfs(v, u); &#125; out[u] = cnt;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", c + i); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;k); q[i] = node&#123;in[u], out[u], k, i&#125;; &#125; sort(q, q + m); int l = 1, r = 0; for(int i = 0; i &lt; m; i++) &#123; node t = q[i]; while(r &lt; t.r) &#123; ++f[nc[++r]]; ++sum[f[nc[r]]]; &#125; while(l &gt; t.l) &#123; ++f[nc[--l]]; ++sum[f[nc[l]]]; &#125; while(r &gt; t.r) &#123; --sum[f[nc[r]]]; --f[nc[r--]]; &#125; while(l &lt; t.l) &#123; --sum[f[nc[l]]]; --f[nc[l++]]; &#125; ans[t.id] = sum[t.k]; &#125; for(int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); &#125; return 0;&#125; 题目2：UVA - 12345 - Dynamic len题意给一个具有n个元素的数列，然后有m个修改或查询。查询的是某个区间的不同数子个数，修改的是某个元素的值。 分析带修改莫队模板题，需要注意的点有： 分块大小为$ O( n^{\frac{2}{3}}) $ 。 排序时以左端点所在区块为第一关键字，右端点所在区块为第二关键字，时间戳为第三关键字。 每个时间戳都意味着状态的改变，所以需要保存更新到新状态和撤销回旧状态的相关信息。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const double Eps=1e-7;int len, n, m, x, y, last[N], tot, timer, a[N], l, r, ans, an[N], cnt[10*N];bool flag[N];char op[N];struct node1 &#123; int last, x, val;&#125;chg[N];struct node &#123; int l, r, id, lblock, rblock, timer; node() &#123;&#125; node(int l, int r, int id, int timer):l(l), r(r), id(id), timer(timer) &#123; this-&gt;lblock = l / len; this-&gt;rblock = r / len; &#125; bool operator &lt; (const node t) const &#123; if(lblock != t.lblock) return lblock &lt; t.lblock; else if(rblock != t.rblock) return rblock &lt; t.rblock; return timer &lt; t.timer; &#125;&#125;q[N];void sub(int x) &#123; if(cnt[a[x]] == 1) ans--; cnt[a[x]]--; flag[x] = 0;&#125;void add(int x) &#123; if(cnt[a[x]] == 0) ans++; cnt[a[x]]++; flag[x] = 1;&#125;void modify(int x, int val) &#123; if(!flag[x]) a[x] = val; else &#123; sub(x); a[x] = val; add(x); &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = pow(n, 2.0/3); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", a + i); last[i] = a[i]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%s%d%d", op, &amp;x, &amp;y); ++x; if(op[0] == 'Q') &#123; q[tot] = node&#123;x, y, tot, timer&#125;; ++tot; &#125; else &#123; chg[++timer].last = last[x]; chg[timer].x = x; chg[timer].val = last[x] = y; &#125; &#125; sort(q, q + tot); l = 1, r = 0, ans = 0, timer = 0; for(int i = 0; i &lt; tot; i++) &#123; node t = q[i]; while(timer &lt; q[i].timer) &#123; timer++; modify(chg[timer].x, chg[timer].val); &#125; while(timer &gt; q[i].timer) &#123; modify(chg[timer].x, chg[timer].last); timer--; &#125; while(r &lt; t.r) add(++r); while(l &gt; t.l) add(--l); while(r &gt; t.r) sub(r--); while(l &lt; t.l) sub(l++); an[t.id] = ans; &#125; for(int i = 0; i &lt; tot; i++) printf("%d\n", an[i]); &#125; return 0;&#125; 题目3：CodeForces - 940F - Machine Learning 题意给一个具有n个元素的数列，然后有q次修改或查询。修改，即让某个元素的值改变。查询的是区间[L, R]的Mex，Mex的定义是最小的元素出现次数的次数为0的次数（不懂可以看原题）。 分析由数学知识得，一个长度为n的数列，答案最大为$ \sqrt{2n} $，所以，假如我们维护了元素出现的次数的次数，那么我们就可以在 $ O(\sqrt{n})$得到某个区间的答案。假如没有修改操作，可以直接用普通莫队维护。但是这里有了单点的修改操作，所以我们可以考虑用带修改的莫队来实现。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const double Eps=1e-7;set&lt;int&gt; s;map&lt;int, int&gt; ma;int len, n, m, a[N], cnt[N], se[N], x, y, tot, timer, l, r, last[N], an[N], op, flag[N], dis, up;struct node &#123; int l, r, id, lblock, rblock, timer; node() &#123;&#125; node(int l, int r, int id, int timer): l(l), r(r), id(id), timer(timer) &#123; this-&gt;lblock = l / len; this-&gt;rblock = r / len; &#125; bool operator &lt; (const node t) const &#123; if(lblock != t.lblock) return lblock &lt; t.lblock; if(rblock != t.rblock) return rblock &lt; t.rblock; return timer &lt; t.timer; &#125;&#125;q[N];struct node1 &#123; int x, val, last; node1() &#123;&#125; node1(int x, int val, int last): x(x), val(val), last(last) &#123;&#125;&#125;chg[N];void sub(int x) &#123; int &amp;t = cnt[a[x]]; se[t]--; se[--t]++; flag[x] = 0;&#125;void add(int x) &#123; int &amp;t = cnt[a[x]]; se[t]--; se[++t]++; flag[x] = 1;&#125;void modify(int x, int val) &#123; if(!flag[x]) a[x] = val; else &#123; sub(x); a[x] = val; add(x); &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = pow(n, 2.0/3); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", a + i); s.insert(a[i]); last[i] = a[i]; &#125; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if(op == 1) &#123; q[tot] = node&#123;x, y, tot, timer&#125;; tot++; &#125; else &#123; timer++; chg[timer] = node1&#123;x, y, last[x]&#125;; s.insert(y); last[x] = y; &#125; &#125; // 离散化 for(auto i: s) ma[i] = dis++; for(int i = 1; i &lt;= n; i++) a[i] = ma[a[i]]; for(int i = 1; i &lt;= timer; i++) chg[i].val = ma[chg[i].val], chg[i].last = ma[chg[i].last]; // 莫队 l = 1, r = 0, timer = 0; up = sqrt(2 * n); sort(q, q + tot); for(int i = 0; i &lt; tot; i++) &#123; node t = q[i]; while(timer &lt; t.timer) &#123; timer++; modify(chg[timer].x, chg[timer].val); &#125; while(timer &gt; t.timer) &#123; modify(chg[timer].x, chg[timer].last); timer--; &#125; while(r &lt; t.r) add(++r); while(l &gt; t.l) add(--l); while(r &gt; t.r) sub(r--); while(l &lt; t.l) sub(l++); for(int j = 1; j &lt;= up; j++) if(se[j] == 0) &#123; an[t.id] = j; break; &#125; &#125; for(int i = 0; i &lt; tot; i++) &#123; printf("%d\n", an[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lindström-Gessel-Vienot-Lemma学习笔记]]></title>
    <url>%2F2018%2F07%2F21%2F0%2F</url>
    <content type="text"><![CDATA[介绍Lindström-Gessel-Vienot Lemma可以用来解决一类路径计数问题。要想将这个引理用于解决计数问题，首先需要令图的所有边的权值等于1。接着需要说明的是，从起点 $$ A={a_{1},\ldots ,a_{n}} $$ 到终点 $$ B={b_{1},\ldots ,b_{n}} $$ 的所有不相交路径，并不是指$$ {a_{i} } $$一定到$$ {b_{i} } $$，它包括得更广，起点A中的某点到达终点B中的任意一点即可，但由于严格不相交，所以它们是一个“双射”。公式的右边，计算的是所有路径的有符号权值和，这里的符号由排列的逆序对个数决定，假如逆序对的个数是奇数，那么符号为负，否则为正。假如我们要求从起点 $$ A={a_{1},\ldots ,a_{n}} $$ 到终点 $$ B={b_{1},\ldots ,b_{n}} $$ ，且$$ {a_{i} } $$一定到$$ {b_{i} } $$的所有不相交路径，那么等式的右边就恰好等于这个方案数。 题目题意详情请看Monotonic Matrix。 分析 官方题解：考虑 01 和 12 的分界线是 (n, 0) 到 (0, m) 的两条不相交(可重合)路径平移其中一条变成 (n-1, -1) 到 (-1, m-1)变成起点 (n, 0) 和 (n-1, -1),终点 (0, m) 和 (-1, m-1) 的严格不相交路径套 Lindström–Gessel–Viennot lemma答案是 $$ {C_{n+m}^n}^2 - C_{n+m}^{m - 1} C_{n+m}^{n-1} $$ 我们设左下角的两点为起点a1, a2，右上角的两点为终点b1, b2，我们需要求的是从a1到b1、a2到b2的路径方案数，由于题目的限制，a1到b2、a2到b1的路径是不合法的，所以，公式的右边恰好就不包含a1到b2、a2到b1的路径方案数了。因此，我们就可以通过计算矩阵行列式来计算答案了。 推广留坑待填。 参考资料 Lindström–Gessel–Viennot lemma - Wikipedia Determinants and the Lindström-Gessel-Vienot Lemma]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法学习笔记（一）]]></title>
    <url>%2F2018%2F07%2F19%2F0%2F</url>
    <content type="text"><![CDATA[介绍莫队算法主要用于可以离线处理的、不带修改的、只有查询的一类区间问题。升级版的莫队算法可以解决带修改的区间问题。我看过的比较好的教程：莫队算法 (Mo’s Algorithm)。 题目1: HYSBZ - 2038题意给一个具有n个元素的数列，然后有m个询问，查询的是某个区间任取两个数，这两个数相同的概率。 分析莫队算法的核心是要找到[L, R]转移到[L-1, R], [L+1, R], [L, R-1], [L, R+1]时答案是怎么改变的。具体到这道题，以[L, R]转移到[L, R+1]的情况为例，由于增加了一个元素，所以凑成两个相同的数的方案数以及总的组合数都会改变，因此我们需要维护的是各数字出现的次数以及区间大小。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, m, a[N], b[N], l, r, len;ll up[N], down[N];struct node &#123; int l, r, id, block; node() &#123;&#125; node(int l, int r, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;id = id; block = l / len; &#125; bool operator &lt; (const node b) const &#123; if(block == b.block) return r &lt; b.r; return block &lt; b.block; &#125;&#125;q[N];void cal(ll &amp;ans, int pos, int fix) &#123; ans -= 1LL * b[a[pos]] * (b[a[pos]] - 1) / 2; b[a[pos]] += fix; ans += 1LL * b[a[pos]] * (b[a[pos]] - 1) / 2;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; m) &#123; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;l, &amp;r); q[i] = node&#123;l, r, i&#125;; &#125; sort(q, q + m); ll ans = 0; l = r = 1; b[a[l]]++; for(int i = 0; i &lt; m; i++) &#123; node &amp;t = q[i]; while(r &lt; t.r) cal(ans, ++r, 1); while(l &gt; t.l) cal(ans, --l, 1); while(r &gt; t.r) cal(ans, r--, -1); while(l &lt; t.l) cal(ans, l++, -1); ll t0 = ans; ll t1 = 1LL * (t.r - t.l + 1) * (t.r - t.l) / 2; ll g = __gcd(t0, t1); t0 /= g; t1 /= g; up[t.id] = t0; down[t.id] = t1; &#125; for(int i = 0; i &lt; m; i++) printf("%lld/%lld\n", up[i], down[i]); &#125; return 0;&#125; 题目2: SPOJ - DQUERY题意给一个具有n个元素的数列，然后有q个询问，查询的是某个区间不同数字的个数。 分析我们只需要维护各数字出现的次数即可，假如在区间改变的过程，某一个数字出现的次数由1变成0，那么答案应该减1，而假如由0变成1，那么答案应该加1。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const int shift=1e3+9;const double Eps=1e-7;int n, m, len, a[N], b[N], l, r, sum, ans[N];struct node &#123; int l, r, id, block; node() &#123;&#125; node(int l, int r, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;id = id; block = l / len; &#125; bool operator &lt; (const node b) const &#123; if(block == b.block) return r &lt; b.r; return block &lt; b.block; &#125;&#125;q[N];inline void cal(int &amp;sum, int pos, int fix) &#123; int &amp;t = b[a[pos]]; t += fix; if(fix == 1 &amp;&amp; t == 1) sum++; else if(fix == -1 &amp;&amp; t == 0) sum--;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; n; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", a + i); cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;l, &amp;r); q[i] = node&#123;l, r, i&#125;; &#125; sort(q, q + m); l = r = sum = 1; b[a[1]]++; for(int i = 0; i &lt; m; i++) &#123; node &amp;t = q[i]; while(r &lt; t.r) cal(sum, ++r, 1); while(l &gt; t.l) cal(sum, --l, 1); while(r &gt; t.r) cal(sum, r--, -1); while(l &lt; t.l) cal(sum, l++, -1); ans[t.id] = sum; &#125; for(int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); return 0;&#125; 题目3: Powerful array题意给一个具有n个元素的数列，然后有t个询问，查询的是某一区间Ks·Ks·s的和，其中s表示的是某一个数字，Ks表示的是该数字出现的次数。 分析我们只需要维护各数字出现的次数即可。维护前，先减去该数字的贡献值，维护后，再加上该数字的贡献值。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const double Eps=1e-7;int n, m, a[N], l, r, len, cnt[N];ll ans, an[N];struct node &#123; int l, r, id, block; node() &#123;&#125; node(int l, int r, int id) &#123; this-&gt;l = l; this-&gt;r = r; this-&gt;id = id; this-&gt;block = l / len; &#125; bool operator &lt; (const node t) const &#123; if(t.block == block) return r &lt; t.r; return block &lt; t.block; &#125;&#125;q[N];void cal(ll &amp;ans, int pos, int fix) &#123; int &amp;t = cnt[a[pos]]; ans -= 1LL * t * t * a[pos]; t += fix; ans += 1LL * t * t * a[pos];&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; len = sqrt(n); for(int i = 1; i &lt;= n; i++) scanf("%d", a + i); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;l, &amp;r); q[i] = node&#123;l, r, i&#125;; &#125; sort(q, q + m); l = 1, r = 1; cnt[a[1]]++; ans = a[1]; for(int i = 0; i &lt; m; i++) &#123; node t = q[i]; while(r &lt; t.r) cal(ans, ++r, 1); while(l &gt; t.l) cal(ans, --l, 1); while(r &gt; t.r) cal(ans, r--, -1); while(l &lt; t.l) cal(ans, l++, -1); an[t.id] = ans; &#125; for(int i = 0; i &lt; m; i++) printf("%I64d\n", an[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[截止于180718的AOBO补题汇总]]></title>
    <url>%2F2018%2F07%2F18%2F0%2F</url>
    <content type="text"><![CDATA[待补题目按AC数降序排列。 180429（浙江省赛）补题传送门待补：D题：Sequence SwappingE题：LISI题：Magic Points 180426（2017杭州亚洲区域赛）补题传送门待补： K题：Master of Sequence B题：Master of Phi 180422（2018 ACM-ICPC 中国大学生程序设计竞赛线上赛）补题传送门待补： G题：Trouble of Tyrant F题：Clever King H题：Rock Paper Scissors Lizard Spock 180419（2017中国大学生程序设计竞赛 - 女生专场）补题传送门待补： J题：Judicious Strategy I题：Innumerable Ancestors 180412（OI题目）补题传送门待补： H题：以撒 I题：永恒 A题：动物朋友 D题：永恒的史诗 E题：中二病也要浪漫!]]></content>
  </entry>
  <entry>
    <title><![CDATA[CF 980E: The Number Games]]></title>
    <url>%2F2018%2F05%2F09%2F1%2F</url>
    <content type="text"><![CDATA[题意给一棵树，节点标记为$1$~$n$，节点$i$的点权为为$2^i$，现在需要删去k个点，使得剩余的点相互联通，且点权的和最大。 分析看完这道题，首先想到的是贪心，即尽量删去点权小的节点，但是经过仔细思考，容易找到一些反例，因此这个思路是行不通的。这道题的思维难点在于将删去节点转化为选取节点。由数学知识得，$2^{i} = 2^{i-1} + 2^{i-2} + … + 2^{0} + 1 $，所以，我们应该尽量选取标号大的节点。首先，标号为$n$ 的节点是一定可以选取的，把它放到联通块里面，然后我们从大到小，不断往这个联通块添加节点。判断某点能否放进联通块里面，需要看这点与联通块的最短距离是否小于剩余可放的节点数，我们可以使用ST表，在$O(logn)$的时间内来完成。总的时间复杂度就是$O(nlogn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+9;const int shift=1e3+9;const double Eps=1e-7;int u, v, n, k, fa[N][29], vis[N], mm[N];vi G[N], v1;set&lt;int&gt; se;void dfs(int u) &#123; vis[u] = 1; for(int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if(vis[v]) continue; fa[v][0] = u; dfs(v); &#125;&#125;void buildST() &#123; mm[0] = 0; for(int i = 1; i &lt;= n; i++) mm[i] = ((i &amp; (i-1)) == 0 ? mm[i-1] + 1 : mm[i-1]); for(int j = 1; j &lt;= mm[n]; j++) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(fa[i][j-1] == -1) fa[i][j] = -1; else fa[i][j] = fa[fa[i][j-1]][j-1]; &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; memset(fa, -1, sizeof fa); dfs(n); buildST(); k = n - k; memset(vis, 0, sizeof vis); vis[n] = true; v1.push_back(n); k--; u = n - 1; while(k &gt; 0 &amp;&amp; u &gt; 0) &#123; if(vis[u]) &#123; u--; continue; &#125; int t = u, dis = 0; for(int i = 20; i &gt;= 0; i--) &#123; if(fa[u][i] == -1 || vis[fa[u][i]] == true) continue; else &#123; dis += 1 &lt;&lt; i; u = fa[u][i]; &#125; &#125; u = t; dis++; if(dis &lt;= k) &#123; vis[u] = true; v1.push_back(u); k--; while(vis[fa[u][0]] != true) &#123; k--; u = fa[u][0]; vis[u] = true; v1.push_back(u); &#125; &#125; u = t - 1; &#125; for(int i = 1; i &lt;= n; i++) se.insert(i); for(auto i: v1) se.erase(i); for(auto i: se) printf("%d ", i); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 980D: Perfect Groups]]></title>
    <url>%2F2018%2F05%2F09%2F0%2F</url>
    <content type="text"><![CDATA[题意给一个数组，让你给这个数组分组，使得组内的元素两两相乘都是平方数，记最少分组数为d。 现在给你一个数组a，求出它所有连续子序列的d，然后输出每个d(1&lt;= d &lt;= n)的计数。 分析用唯一分解定理分解平方数，可以发现它的某一素因子的个数为偶数个。若两个数相乘是平方数，则两者的所有素因子中，要么两个数都具有偶数个，要么都具有奇数个。因此，我们可以将一个数表示成它那些奇数个数的素因子的乘积。然后，若两个数相同，则可以组成平方数，否则不可以。于是，问题就转化成了求连续子序列中出现不同数字的个数，容易想到用set来维护，但是由于我们需要用$ O(n^{2}) $的时间来枚举连续子序列的起点和终点，再用上个set会超时。所以，结合数组a的元素很大，我们需要将其离散化，然后用一个桶来维护。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;vi pri;int n, a[N], ans[N];void pre() &#123; int up = 10000; bool vis[N]; memset(vis, 0, sizeof vis); for(int i = 2; i &lt;= up; i++) if(!vis[i]) for(int j = 2 * i; j &lt;= up; j += i) vis[j] = 1; for(int i = 2; i &lt;= up; i++) if(!vis[i]) pri.push_back(i);&#125;int fac(int d) &#123; if(d == 0) return d; int ans = 1; if(d &lt; 0) ans *= -1, d *= -1; int p = 0; while(d != 1 &amp;&amp; p &lt; pri.size()) &#123; int cnt = 0; while(d % pri[p] == 0) cnt++, d /= pri[p]; if(cnt &amp; 1) ans *= pri[p]; p++; &#125; if(d != 1) ans *= d; return ans;&#125;void lisanhua() &#123; set&lt;int&gt; se; map&lt;int, int&gt; m; for(int i = 0; i &lt; n; i++) se.insert(a[i]); int cnt = 1; for(auto i: se) &#123; if(i == 0) m[i] = 0; else m[i] = cnt++; &#125; for(int i = 0; i &lt; n; i++) a[i] = m[a[i]];&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; pre(); while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", a + i); a[i] = fac(a[i]); &#125; memset(ans, 0, sizeof ans); lisanhua(); for(int i = 0; i &lt; n; i++) &#123; int cnt = 0, zeroFlag = 0, b[N]; memset(b, 0, sizeof b); for(int j = i; j &lt; n; j++) &#123; if(a[j] == 0) zeroFlag = 1; if(b[a[j]]++ == 0) cnt++; if(zeroFlag &amp;&amp; cnt != 1) ans[cnt-1]++; else ans[cnt]++; &#125; &#125; for(int i = 1; i &lt;= n; i++) printf("%d%c", ans[i], i == n ? '\n': ' '); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 976E: Well played!]]></title>
    <url>%2F2018%2F05%2F05%2F0%2F</url>
    <content type="text"><![CDATA[题意你拥有n个怪兽，每个怪兽具有hp和dam这两种属性。你可以进行两种操作：第一种是将怪兽的hp值翻倍；第二种是令怪兽的dam = hp。第一种操作你最多可以进行a次，第二种操作你最多可以进行b次，问所有怪兽的dam和最大是多少？ 分析看到题目，容易想到动态规划，但是想了挺久，没思路。看了官方题解，发现了一个重要的性质：第一种操作应该只分配给某一只怪兽，这个可以通过反证法来证明，挺简单的，这里不再赘述。a个第一种操作和1个第二种操作分配完了，那么剩余的b-1个第二种操作应该怎么分配？贪心，即优先分配给hp - dam值较大的怪兽（在这之前需要排序一次）。最终此题的复杂度是O(nlogn)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;ll n, aa, b, t, ans, sum;struct node &#123; ll hea, dam;&#125;a[N];bool cmp(node a, node b) &#123; return (a.hea - a.dam) &gt; (b.hea - b.dam);&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; aa &gt;&gt; b) &#123; t = 1; while(aa--) t *= 2; for(int i = 0; i &lt; n; i++) scanf("%lld%lld", &amp;a[i].hea, &amp;a[i].dam); sort(a, a + n, cmp); for(int i = 0; i &lt; n; i++) &#123; if(i &lt; b) sum += max(a[i].hea, a[i].dam); else sum += a[i].dam; &#125; if(b == 0) &#123; printf("%lld\n", sum); continue; &#125; for(int i = 0; i &lt; n; i++) &#123; if(i &lt; b) ans = max(ans, sum - max(a[i].hea, a[i].dam) + max(a[i].hea * t, a[i].dam)); else ans = max(ans, sum - max(a[b-1].hea, a[b-1].dam) + a[b-1].dam - a[i].dam + max(a[i].hea * t, a[i].dam)); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 975E: Hag's Khashba]]></title>
    <url>%2F2018%2F05%2F04%2F0%2F</url>
    <content type="text"><![CDATA[题意有一个凸多边形，在两个钉子（位置在凸多边形的两个顶点上）的作用下，固定在了墙上。现在有两种操作，第一种操作是将其中一个钉子移走，等待凸多边形稳定后，再将钉子钉在某个位置上。第二种操作是询问某个点的坐标。 分析这道题是典型的计算几何题，涉及到的知识大概有： 多边形重心的计算。 多边形的旋转。 多边形重心的公式可以在网上搜到，这里就不再赘述了（其实是因为贴不了数学公式）。 我们知道，假如多边形没有产生形变，那么它的重心与所有顶点的距离是不变的。因此，假如我们知道一个多边形的重心坐标以及重心与所有顶点的距离，再加上重心与所有顶点的角度差，我们就可以确定所有顶点的坐标了。需要注意的是，重心与其他所有顶点的角度差在重心变更时会产生变化，因此，我们需要进行角度变换。总的时间复杂度是O(n + q)。 下面的代码里有些形如cosl这样形式的三角函数，与cos这种普通三角函数的不同是：cosl的参数要求为long double，返回值也为long double，从而保证了精度。这道题不用cosl也能过，但用了更保险。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;typedef pair&lt;long double, long double&gt; point;point a[N], c;long double ang[N], angle, dist[N], bx, by;int n, q, t1, t2;point getC() &#123; long double area = 0, cx = 0, cy = 0; for(int i = 0; i &lt; n; i++) &#123; long double temp = a[i].x * a[(i+1)%n].y - a[i].y * a[(i+1)%n].x; area += temp; cx += (a[i].x + a[(i+1)%n].x) * temp; cy += (a[i].y + a[(i+1)%n].y) * temp; &#125; area /= 2; cx /= 6 * area; cy /= 6 * area; return point(cx, cy);&#125;point getPoint(int idx) &#123; return point(c.x + dist[idx] * cosl(angle + ang[idx]), c.y + dist[idx] * sinl(angle + ang[idx]));&#125;long double getDist(point a, point b) &#123; return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; scanf("%d%d", &amp;n, &amp;q); for(int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;t1, &amp;t2); a[i].x = t1; a[i].y = t2; &#125; bx = a[0].x, by = a[0].y; for(int i = 0; i &lt; n; i++) &#123; a[i].x -= bx; a[i].y -= by; &#125; c = getC(); for(int i = 0; i &lt; n; i++) &#123; dist[i] = getDist(a[i], c); ang[i] = atan2l(a[i].y - c.y, a[i].x - c.x); if(ang[i] &lt; 0) ang[i] += 2 * PI; &#125; angle = 0; int i = 0, j = 1, op, x, y; point top, nxt; while(q--) &#123; scanf("%d", &amp;op); if(op == 1) &#123; scanf("%d%d", &amp;x, &amp;y); x--, y--; if(x == i) &#123; i = y; top = getPoint(j); nxt = point(top.x, top.y - dist[j]); &#125; else &#123; j = y; top = getPoint(i); nxt = point(top.x, top.y - dist[i]); &#125; angle += -PI/2 - atan2l(c.y - top.y, c.x - top.x); while(angle &lt; 0) angle += 2 * PI; while(angle &gt;= 2 * PI) angle -= 2 * PI; c = nxt; &#125; else &#123; scanf("%d", &amp;x); point ans = getPoint(x-1); printf("%.10f %.10f\n", (double)(ans.x + bx), (double)(ans.y + by)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180429华中科技大学程序设计竞赛题解]]></title>
    <url>%2F2018%2F05%2F02%2F0%2F</url>
    <content type="text"><![CDATA[题解按AC数降序排列。 J题：Various Tree简单bfs。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e6+39;const int shift=1e3+9;const double Eps=1e-7;int cnt[N];void bfs(int u, int v) &#123; bool vis[N]; int dis[N]; queue&lt;int&gt; que; memset(vis, 0, sizeof vis); memset(dis, INF, sizeof dis); dis[u] = 0; vis[u] = 1; que.push(u); while(que.size()) &#123; int uu = que.front(); que.pop(); if(uu == v) &#123; printf("%d\n", dis[v]); break; &#125; if(uu + 1 &lt; N &amp;&amp; !vis[uu + 1]) &#123; dis[uu + 1] = dis[uu] + 1; vis[uu + 1] = 1; que.push(uu + 1); &#125; if(uu - 1 &gt;= 0 &amp;&amp; !vis[uu - 1]) &#123; dis[uu - 1] = dis[uu] + 1; vis[uu - 1] = 1; que.push(uu - 1); &#125; if(uu + cnt[uu] &lt; N &amp;&amp; !vis[uu + cnt[uu]]) &#123; dis[uu + cnt[uu]] = dis[uu] + 1; vis[uu + cnt[uu]] = 1; que.push(uu + cnt[uu]); &#125; if(uu - cnt[uu] &gt;= 0 &amp;&amp; !vis[uu - cnt[uu]]) &#123; dis[uu - cnt[uu]] = dis[uu] + 1; vis[uu - cnt[uu]] = 1; que.push(uu - cnt[uu]); &#125; &#125;&#125;void pre() &#123; memset(cnt, 0, sizeof cnt); for(int i = 1; i &lt; N; i++) &#123; int t = i; while(t) &#123; if(t &amp; 1) cnt[i]++; t &gt;&gt;= 1; &#125; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; pre(); int a, b; while(cin &gt;&gt; a &gt;&gt; b) bfs(a, b); return 0;&#125; K题：Walking in the Forest简单二分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int k, n, a[N];bool check(ll mid) &#123; ll sum = LINF, cnt = 0; for(int i = 0; i &lt; k; i++) &#123; if(a[i] &gt; mid) return false; if(sum + a[i] &gt; mid) sum = a[i], cnt++; else sum += a[i]; &#125; return cnt &lt;= n;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;k, &amp;n)) &#123; k--; for(int i = 0; i &lt; k; i++) scanf("%d", a + i); ll l = 0, r = 10000000000; while(l &lt; r) &#123; ll mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; printf("%lld\n", r); &#125; return 0;&#125; B题：Beautiful Trees Cutting简单数学题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;const int mod = 1e9 + 7;char s[N];ll ans, m, n;vi v;ll ksm(ll a, ll b) &#123; ll ans = 1; while(b) &#123; if(b &amp; 1) (ans *= a) %= mod; (a *= a) %= mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; m &gt;&gt; s) &#123; v.clear(); n = strlen(s); for(int i = 0; i &lt; n; i++) if((s[i] - '0') % 5 == 0) v.push_back(i); ans = 0; for(int i = 0; i &lt; v.size(); i++) (ans += ksm(2, v[i])) %= mod; (ans *= ksm(2, n * m) - 1) %= mod; (ans *= ksm(ksm(2, n) - 1, mod - 2)) %= mod; printf("%lld\n", ans % mod); &#125; return 0;&#125; F题：Sorting Trees简单思维题。之前在Codejam上做过在k = 2情况下的一道题，这道题算是对那道题的推广。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;vi v[N];int n, k, a[N], b[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; k) &#123; for(int i = 0; i &lt; n; i++) scanf("%d", a + i); if(k == 0) &#123; memcpy(b, a, sizeof a); sort(b, b + n); int i; for(i = 0; i &lt; n; i++) if(a[i] != b[i]) &#123; printf("%d\n", i + 1); break; &#125; if(i == n) printf("-1\n"); continue; &#125; for(int i = 0; i &lt; n; i++) v[i % k].push_back(a[i]); for(int i = 0; i &lt; k; i++) &#123; if(v[i].empty()) continue; sort(v[i].begin(), v[i].end()); &#125; for(int i = 0; i &lt; k; i++) for(int j = 0; j &lt; v[i].size(); j++) b[i + j * k] = v[i][j]; sort(a, a + n); int i; for(i = 0; i &lt; n; i++) if(a[i] != b[i]) &#123; printf("%d\n", i + 1); break; &#125; if(i == n) printf("-1\n"); &#125; return 0;&#125; C题：Professional Manager留坑待补。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CF 967E: Big Secret]]></title>
    <url>%2F2018%2F05%2F01%2F0%2F</url>
    <content type="text"><![CDATA[题意给一个数组b，问存不存在这些数的一个排列，使得这些数构造出来的另一个数组a严格上升。ai等于b数组前i个元素的异或值。 分析假如数组b中有一些值为1的元素，那么某个1前面应该有偶数个奇数，否则构造出来的a数组就会下降。同理，假如数组b中有一些值为[2^k, 2^(k+1))的元素，那么某个值为[2^k, 2^(k+1))的元素前面应该有偶数个值大于2^(k+1) 且二进制形式在第k位值为1的元素，否则，构造出来的a数组也会下降。因此，我们可以通过前导0的个数给b数组中的元素分组，然后，在符合插入条件的情况下，前导0位数多的元素优先插入即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;vector&lt;ll&gt; ans;vector&lt;ll&gt; v[60];ll n, d, t;bool flag;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf("%I64d", &amp;d); for(int j = 59; j &gt;= 0; j--) if(d &gt;&gt; j &amp; 1) &#123; v[j].push_back(d); break; &#125; &#125; t = 0; flag = true; for(int j = 0; j &lt; n &amp;&amp; flag; j++) &#123; flag = false; for(int i = 0; i &lt; 60; i++) &#123; if(t &gt;&gt; i &amp; 1 || v[i].empty()) continue; ans.push_back(v[i].back()); t ^= v[i].back(); v[i].pop_back(); flag = true; break; &#125; &#125; if(ans.size() == n) &#123; printf("Yes\n"); for(int i = 0; i &lt; n; i++) printf("%I64d%c", ans[i], i == n - 1 ? '\n' : ' '); &#125; else printf("No\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 967D: Resource Distribution]]></title>
    <url>%2F2018%2F04%2F30%2F1%2F</url>
    <content type="text"><![CDATA[题意略 分析设两种服务所需服务器数量分别为w1、w2，对应下限分别为p1、p2。假如p1 &gt; p2，那么，我们应该将“优质”的服务器优先分给第一种服务，然后再将剩余的服务器分给第二种服务。并且，为了满足第二种服务，p1应该越大越好。因此，排序后，贪心for两次就行了。这道题的关键是要意识到“优质”服务器应连续分给某一种服务，而不能间断着分。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=3e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, x1, x2, p;vi v[3];bool flag;struct node &#123; int val, id;&#125;a[N];bool cmp(node a, node b) &#123; return a.val &lt; b.val;&#125;int check(int mid) &#123; int t = ceil(1.0 * x1 / mid); if(t &lt;= a[p - mid + 1].val) return 0; return 1;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; x2) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].val); a[i].id = i; &#125; sort(a + 1, a + n + 1, cmp); flag = false; v[1].clear(); v[2].clear(); for(int i = 1; i &lt; n; i++) &#123; int t = ceil(1.0 * x2 / i); p = n - i; if(a[p + 1].val &gt;= t) &#123; int l; for(int i = p; i &gt;= 1; i--) &#123; if(check(i) == 0) &#123; l = i; flag = true; break; &#125; &#125; if(flag) &#123; printf("Yes\n%d %d\n", l, n - p); for(int i = p; i &gt;= p - l + 1; i--) printf("%d%c", a[i].id, i == p - l + 1 ? '\n' : ' '); for(int i = p + 1; i &lt;= n; i++) printf("%d%c", a[i].id, i == n ? '\n' : ' '); &#125; break; &#125; &#125; if(flag) continue; swap(x1, x2); for(int i = 1; i &lt; n; i++) &#123; int t = ceil(1.0 * x2 / i); p = n - i; if(a[p + 1].val &gt;= t) &#123; int l; for(int i = p; i &gt;= 1; i--) &#123; if(check(i) == 0) &#123; l = i; flag = true; break; &#125; &#125; if(flag) &#123; printf("Yes\n%d %d\n", n - p ,l); for(int i = p + 1; i &lt;= n; i++) printf("%d%c", a[i].id, i == n ? '\n' : ' '); for(int i = p; i &gt;= p - l + 1; i--) printf("%d%c", a[i].id, i == p - l + 1 ? '\n' : ' '); &#125; break; &#125; &#125; if(!flag) printf("No\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 967C: Stairs and Elevators]]></title>
    <url>%2F2018%2F04%2F30%2F0%2F</url>
    <content type="text"><![CDATA[题意题意很简单，略:) 分析首先注意到楼梯、电梯是垂直连通整栋楼的，所以，我们没必要多次走楼梯或乘坐电梯，最多只要一次。因此，我们可以找离出发点y1最近的两个楼梯和两个电梯，这可以通过二分来实现，然后分别计算时间，取min即可。需要注意的是，楼层相同时不需要走楼梯或乘坐电梯。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int n, m, cl, ce, v, a[N], b[N], q, x1, y_1, x2, y2;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; cl &gt;&gt; ce &gt;&gt; v) &#123; for(int i = 0; i &lt; cl; i++) scanf("%d", a + i); for(int i = 0; i &lt; ce; i++) scanf("%d", b + i); scanf("%d", &amp;q); while(q--) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y_1, &amp;x2, &amp;y2); if(x1 == x2) &#123; printf("%d\n", abs(y_1 - y2)); continue; &#125; int ans = INF; int p = lower_bound(a, a+cl, y_1) - a; if(p != cl) ans = min(ans, abs(a[p] - y_1) + abs(x2 - x1) + abs(a[p] - y2)); if(--p &gt;= 0) ans = min(ans, abs(a[p] - y_1) + abs(x2 - x1) + abs(a[p] - y2)); p = lower_bound(b, b+ce, y_1) - b; if(p != ce) ans = min(ans, abs(b[p] - y_1) + (int)ceil(1.0*abs(x2 - x1) / v) + abs(b[p] - y2)); if(--p &gt;= 0) ans = min(ans, abs(b[p] - y_1) + (int)ceil(1.0*abs(x2 - x1) / v) + abs(b[p] - y2)); printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 900E: Maximum Questions]]></title>
    <url>%2F2018%2F04%2F29%2F0%2F</url>
    <content type="text"><![CDATA[题意给一个长度为n（1 ≤ n ≤ 100000）的字符串，这个字符串只包含‘a’，’b’，‘?’三种字符，其中’?’可以变成‘a’或‘b’。现在需要求这个字符串里包含最多个长度为m（m &lt;= n)的字符串时的最小转变次数是多少，需要注意的是两个长度为m的字符串不能重叠。这个长度为m的字符串的构造规则是ababab…即奇数位为a，偶数位为b。 分析看完题意，容易发现应该用DP来写。但是，怎么判断某一个长度为m的子串是否为合法串以及构成合法串所需的花费呢？这需要我们用前缀和分奇偶统计a，b出现的次数，然后就可以在O(1)的时间判断了。接着，进行DP，dp[i].cost 表示前面i个字符构成最多合法串时的最小花费，dp[i].ma表示前面i个字符构成最多合法串的个数。dp[i] 可以由dp[i-1]或dp[i-m]转移过来，转移的条件是构成的合法串更多或者构成的合法串一样多但是花费更少。最后，dp[n].cost 即为答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int a[N], b[N], c[N], d[N], n, m;string s;struct node &#123; int ma, cost;&#125;dp[N];int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; s &gt;&gt; m) &#123; s = '0' + s; int len = s.length(); memset(a, 0, sizeof a); memset(b, 0, sizeof b); memset(c, 0, sizeof c); memset(d, -1, sizeof d); //按照奇偶下标统计a以及?出现的次数，存储到a[] //按照奇偶下标统计b以及?出现的次数，存储到b[] //统计?出现的次数，存储到c[] for(int i = 1; i &lt; len; i++) &#123; c[i] = c[i-1] + (s[i] == '?' ? 1 : 0); if(i &gt;= 2) &#123; a[i] = a[i-2] + (s[i] == '?' || s[i] == 'a' ? 1 : 0); b[i] = b[i-2] + (s[i] == '?' || s[i] == 'b' ? 1 : 0); &#125; else &#123; a[i] = (s[i] == '?' || s[i] == 'a' ? 1 : 0); b[i] = (s[i] == '?' || s[i] == 'b' ? 1 : 0); &#125; &#125; //判断以i结尾的字符串是否有可能合法，假如有可能，d[]为花费，假如不可能，d[]为-1 for(int i = m; i &lt; len; i++) &#123; if(m &amp; 1) &#123; int ta = a[i] - a[max(0, i - m - 1)]; int tb = max(0, b[i-1] - b[max(0, i - m)]); if(ta &gt;= (m+1)/2 &amp;&amp; tb &gt;= m/2) d[i] = c[i] - c[i-m]; &#125; else &#123; int ta = a[i-1] - a[max(0, i - m - 1)]; int tb = b[i] - b[i - m]; if(ta &gt;= (m+1)/2 &amp;&amp; tb &gt;= m/2) d[i] = c[i] - c[i-m]; &#125; &#125; memset(dp, 0, sizeof dp); //dp[i]可以由dp[i-m]以及dp[i-1]转移过来，更优的标准是凑出更多的合法串或者让一样多的合法串花费更少 for(int i = m; i &lt; len; i++) &#123; if(d[i] == -1) dp[i] = dp[i-1]; else if(dp[i-m].ma + 1 &gt; dp[i-1].ma || (dp[i-m].ma + 1 == dp[i-1].ma &amp;&amp; dp[i-m].cost + d[i] &lt; dp[i-1].cost)) dp[i].ma = dp[i-m].ma + 1, dp[i].cost = dp[i-m].cost + d[i]; else dp[i] = dp[i-1]; &#125; printf("%d\n", dp[len-1].cost); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2778: DNA Sequence]]></title>
    <url>%2F2018%2F04%2F21%2F1%2F</url>
    <content type="text"><![CDATA[题意求构造不含m(0 &lt;= m &lt;= 10)个模式串的长度为n(1 &lt;= n &lt;= 2000000000)的字符串的方案数。 分析首先用m个模式串构造AC自动机，这里需要注意的是，不仅要把字符串最后一个字符所在的那一点标记为不合法状态，还需要把其他能转移到该点的节点都标记为不合法状态。然后，问题就转化为了从root出发，走了n步，这n步都避开不合法状态的方案数。设AC自动机的节点个数为L，我们可以构造一个L*L的邻接矩阵，mat[i][j]代表i到j的合法方案数。则mat矩阵的n次幂就表示走了n次的方案数。由于n很大，所以要用矩阵快速幂优化。这里要注意的是，每次循环都要将不合法的项置0，否则，有可能会多算。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#pragma comment(linker, "/STACK:102400000,102400000") //手动扩栈#include&lt;set&gt;#include&lt;map&gt;#include&lt;ctime&gt; //CLOCKS_PER_SEC;clock_t t=clock();#include&lt;cmath&gt; #include&lt;queue&gt;#include&lt;bitset&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt; //getline(cin, line);#include&lt;sstream&gt; //stringstream ss(line);(ss is a stream like cin).#include&lt;cstdlib&gt;#include&lt;cstring&gt; #include&lt;cfloat&gt; //X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON#include&lt;climits&gt; //INT_MAX,LLONG_MAX#include&lt;iostream&gt; //ios_base::sync_with_stdio(false);#include&lt;algorithm&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;const int mod = 100000;map&lt;char, int&gt; m;int n, mm;char s[19];struct acAuto &#123; int next[109][4], fail[109], L, root; ll mat[109][109]; bool end[109]; void init() &#123; L = 0; m['A'] = 0; m['T'] = 1; m['C'] = 2; m['G'] = 3; root = newNode(); &#125; int newNode() &#123; for(int i = 0; i &lt; 4; i++) next[L][i] = -1; end[L] = false; return L++; &#125; void insert(char s[]) &#123; int len = strlen(s), now = root; for(int i = 0; i &lt; len; i++) &#123; int j = m[s[i]]; if(next[now][j] == -1) next[now][j] = newNode(); now = next[now][j]; &#125; end[now] = true; &#125; void build() &#123; fail[root] = root; queue&lt;int&gt; que; for(int i = 0; i &lt; 4; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 4; i++) &#123; if(next[now][i] == -1) &#123; next[now][i] = next[fail[now]][i]; &#125; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; void buildMatrix() &#123; memset(mat, 0, sizeof mat); for(int i = 0; i &lt; L; i++) &#123; int now = i, flag = false; while(now != root) &#123; if(end[now]) flag = true; now = fail[now]; &#125; if(flag) end[i] = true; &#125; for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; 4; j++) mat[i][next[i][j]]++; &#125; void ksm(int n) &#123; ll t[109][109]; ll t1[109][109]; ll t2[109][109]; memset(t, 0, sizeof t); for(int i = 0; i &lt; L; i++) t[i][i] = 1; while(n) &#123; for(int j = 0; j &lt; L; j++) if(end[j] == true) for(int i = 0; i &lt; L; i++) mat[i][j] = t[i][j] = 0; if(n &amp; 1) &#123; memcpy(t1, t, sizeof t); memset(t, 0, sizeof t); for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; L; j++) for(int k = 0; k &lt; L; k++) (t[i][j] += t1[i][k] * mat[k][j]) %= mod; &#125; n &gt;&gt;= 1; memcpy(t2, mat, sizeof mat); memset(mat, 0, sizeof mat); for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; L; j++) for(int k = 0; k &lt; L; k++) (mat[i][j] += t2[i][k] * t2[k][j]) %= mod; &#125; for(int i = 0; i &lt; L; i++) for(int j = 0; j &lt; L; j++) mat[i][j] = t[i][j]; &#125; void solve() &#123; buildMatrix(); ksm(n); ll ans = 0; for(int j = 0; j &lt; L; j++) (ans += mat[0][j]) %= mod; printf("%lld\n", ans); &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;mm, &amp;n)) &#123; ac.init(); for(int i = 0; i &lt; mm; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); ac.solve(); &#125;; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>计数</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6031: Innumerable Ancestors]]></title>
    <url>%2F2018%2F04%2F21%2F0%2F</url>
    <content type="text"><![CDATA[题意给一棵树，询问两个点集间的LCA最大深度。 分析首先，我们通过dfs+ST表进行预处理，让每次LCA的查询只要O(1)就可以完成。接着，利用以下这个性质： 根据 DFS 序，若两个点的 DFS 序越接近，则两个点的 LCA 的深度越大。 我们可以先将其中一个点集B中的元素按dfs序排序，然后枚举另一个点集A的元素，不妨设为a，利用二分查找在点集B中查找到与a的dfs序最相近的两个元素，不妨设为b1，b2，最后LCA(a, b1) 的深度和 LCA(a, b2)的深度就是可能的答案，取max即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;/*************************************************************/// LCA在线算法--dfs+ST算法int F[2*N]; //欧拉序列, 长度为2*n-1, 下标从1开始int rmq[2*N]; //欧拉序列对应的深度序列int P[N]; //P[i]表示点i在F中第一次出现的位置int tot, head[N], cnt, root, n;struct Edge&#123; int to, next;&#125;edge[2*N];//加边, 无向边需要加两次void addedge(int u, int v) &#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;//建树前的初始化void init() &#123; tot = 0; memset(head, -1, sizeof head);&#125;//辅助函数void dfs(int u, int pre, int dep) &#123; F[++cnt] = u; rmq[cnt] = dep; P[u] = cnt; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(v == pre) continue; dfs(v, u, dep+1); F[++cnt] = u; rmq[cnt] = dep; &#125;&#125;//构建ST表struct ST&#123; int mm[2*N], dp[2*N][20]; void build(int root, int n) &#123; cnt = 0; dfs(root, root, 0); mm[0] = -1; for(int i = 1; i &lt;= 2 * n - 1; i++) &#123; mm[i] = (i&amp;(i-1)) == 0 ? mm[i-1]+1 : mm[i-1]; dp[i][0] = i; &#125; for(int j = 1; j &lt;= mm[2 * n - 1]; j++) for(int i = 1; i + (1 &lt;&lt; (j-1)) &lt;= 2 * n - 1; i++) dp[i][j] = rmq[dp[i][j-1]] &lt; rmq[dp[i+(1&lt;&lt;(j-1))][j-1]] ? dp[i][j-1] : dp[i+(1&lt;&lt;(j-1))][j-1]; &#125; int query(int a, int b) &#123; a = P[a], b = P[b]; if(a&gt;b) swap(a, b); int k = mm[b-a+1]; return F[rmq[dp[a][k]] &lt;= rmq[dp[b-(1&lt;&lt;k)+1][k]] ? dp[a][k] : dp[b-(1&lt;&lt;k)+1][k]]; &#125;&#125;st;/*************************************************************/int m, u, v, ta, tb, a[N], b[N];bool cmp(int a, int b) &#123; return P[a] &lt; P[b];&#125;bool check(int mid, int val) &#123; if(P[b[mid]] &gt;= P[val]) return true; return false;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; st.build(1, n); while(m--) &#123; scanf("%d", &amp;ta); for(int i = 0; i &lt; ta; i++) scanf("%d", a+i); scanf("%d", &amp;tb); for(int i = 0; i &lt; tb; i++) scanf("%d", b+i); sort(b, b + tb, cmp); int ans = -INF; for(int i = 0; i &lt; ta; i++) &#123; int l = -1, r = tb - 1; while(l + 1 != r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid, a[i])) r = mid; else l = mid; &#125; int rr = r; l = 0, r = tb; while(l + 1 != r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid, a[i])) r = mid; else l = mid; &#125; int ll = l; ans = max(ans, rmq[P[st.query(a[i], b[ll])]]); ans = max(ans, rmq[P[st.query(a[i], b[rr])]]); //printf("t: %d\n", ans); &#125; printf("%d\n", ans + 1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>二分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动物朋友]]></title>
    <url>%2F2018%2F04%2F18%2F0%2F</url>
    <content type="text"><![CDATA[题目链接略 分析 首先构建AC自动机，于是题目转化为：在自动机上走L步，不碰到任何一个成功匹配的节点。令DP[u][L]表示当前状态位于状态u，还需要走L步，满足条件的概率，记忆化搜索即可。 这道题的思路官方题解已经写得很清楚了，不再赘述。直接上代码，代码中注释蛮清楚的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok cout &lt;&lt; "ok" &lt;&lt; endl;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;int T, L, n;char s[109], c[109];double p[109];struct acAuto &#123; int next[2009][128], fail[2009], root, L; bool end[2009]; double dp[2009][109]; //初始化 void init() &#123; L = 0; root = newNode(); &#125; //建立新节点 int newNode() &#123; for(int i = 0; i &lt; 128; i++) next[L][i] = -1; end[L] = false; return L++; &#125; //建立Trie void insert(char s[]) &#123; int now = root, len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; if(next[now][s[i]] == -1) next[now][s[i]] = newNode(); now = next[now][s[i]]; &#125; end[now] = true; &#125; //构建AC自动机的fail数组，或者称为next数组 void build() &#123; fail[root] = root; queue&lt;int&gt; que; for(int i = 0; i &lt; 128; i++) &#123; if(next[root][i] == -1) next[root][i] = root; else &#123; fail[next[root][i]] = root; que.push(next[root][i]); &#125; &#125; while(que.size()) &#123; int now = que.front(); que.pop(); for(int i = 0; i &lt; 128; i++) &#123; if(next[now][i] == -1) next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; que.push(next[now][i]); &#125; &#125; &#125; &#125; //记忆化搜索实现DP，now表示现在的状态，L表示在AC自动机还需要走的步数 //初始状态为AC自动机的root节点，表示一步都没走，一个字符都没有 //边界条件为L=0，表示走完了，这时成功的概率是1 //否则，就需要枚举拼接在当前状态后的字符，并判断拼接后是否合法（合法就是全部模式串都不匹配），增加贡献值 //DP[u][L]，其中u表示状态，L表示步数，即状态数为uL，状态转移是在AC自动机上跑的，看跳转次数而定，不大，所以总时间复杂度为O(uL) double dfs(int now, int L) &#123; if(dp[now][L] != -1) return dp[now][L]; if(L == 0) return 1; double ans = 0; for(int i = 0; i &lt; n; i++) &#123; int temp = next[now][c[i]]; if(!pipei(temp)) ans += p[i] * dfs(temp, L-1); &#125; return dp[now][L] = ans; &#125; //若有一个模式串匹配，返回1，若都不匹配，返回0 bool pipei(int now) &#123; while(now != root) &#123; if(end[now]) return true; now = fail[now]; &#125; return false; &#125; double solve(int L) &#123; for(int i = 0; i &lt; 2009; i++) for(int j = 0; j &lt;= L; j++) dp[i][j] = -1; return dfs(0, L); &#125;&#125;ac;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; printf("Aonyx cinerea\n"); scanf("%d", &amp;T); while(T--) &#123; ac.init(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", s); ac.insert(s); &#125; ac.build(); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf(" %c%lf", &amp;c[i], &amp;p[i]); scanf("%d", &amp;L); printf("%.6f\n", ac.solve(L)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gym 101755G: Underpalindromity]]></title>
    <url>%2F2018%2F04%2F02%2F0%2F</url>
    <content type="text"><![CDATA[题目链接Gym101755G 分析首先来考虑一下这个样例：8 48 8 7 6 9 5 8 2 我们列出所有对答案产生贡献的元素对： 1-42-3, 2-53-2, 3-4, 3-64-1, 4-3, 4-5, 4-7… 经过观察，我们发现对于某一个元素，它的贡献是有规律的。令i表示该元素的下标，则该元素对于[i-k+1, i+k-1]这个区间，每隔两个数就有一次贡献。因此，我们就将n*n个区间的贡献值转化为了n个点的贡献值。举个例子，上面那个样例中，第2个元素的贡献就是(8-7) + (9-8)。 为了能够快速查询某一点的贡献值，我们必须用到某种数据结构来优化，对于区间问题，容易想到用线段树或者树状数组。为了能够用数据结构优化，我们需要将数组从小到大排序。排序后，当我们计算某一点的贡献时，这个点对于比这个点小的元素的贡献。举个例子，上面第2个元素的贡献就是(8-7)，至于(9-8)，就留给第5个元素才计算。因此，树状数组需要的维护的东西有元素个数以及区间和。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;ll sum[4][N], n, k, ans;pii a[N];ll query(int p, int id) &#123; ll ans = 0; while(p &gt; 0) &#123; ans += sum[id][p]; p -= p &amp; -p; &#125; return ans;&#125;void add(int p, int v, int id) &#123; while(p &lt;= n) &#123; sum[id][p] += v; p += p &amp; -p; &#125;&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; k) &#123; ans = 0; memset(sum, 0, sizeof sum); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i].x); a[i].y = i; &#125; sort(a+1, a+n+1); for(int i = 1; i &lt;= n; i++) &#123; int id = a[i].y &amp; 1; int r = a[i].y + k - 1; int l = a[i].y - k + 1; //边界情况的处理 if(l &lt; 1) l = k - a[i].y + 1; if(r &gt; n) r = 2*n - a[i].y - k + 1; //计算某点对答案的贡献 if(k &amp; 1) ans += 1LL * a[i].x * (query(r, id+2) - query(l-1, id+2)) - (query(r, id) - query(l-1, id)); else ans += 1LL * a[i].x * (query(r, (id+2)^1) - query(l-1, (id+2)^1)) - (query(r, id^1) - query(l-1, id^1)); //用该点更新树状数组 add(a[i].y, a[i].x, id); add(a[i].y, 1, id + 2); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180329训练赛题解]]></title>
    <url>%2F2018%2F03%2F29%2F0%2F</url>
    <content type="text"><![CDATA[训练赛套题链接：2018, XI Samara Regional Intercollegiate Programming Contest 感觉题目难度很友好，官方说是给蓝紫名选手做的。 A题据说是水题，略。 B题队友做的，留坑待填。 C题这种区间求最优解的问题，一种套路就是排序+贪心。具体对这道题来说，即按照右边界、左边界从小到大排序，然后贪心地取右边界的点，同时跳过左边界在该点左边的那些区间，时间复杂度是O(n)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;bool cmp(pii a, pii b) &#123; if(a.y == b.y) return a.x &lt; b.x; return a.y &lt; b.y;&#125;int mark, n, ans;pii a[N];vi v;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) scanf("%d%d", &amp;a[i].x, &amp;a[i].y); sort(a, a+n, cmp); ans = 0; v.clear(); for(int i = 0; i &lt; n; ) &#123; mark = a[i].y; ans++; v.push_back(mark); while(i &lt; n &amp;&amp; a[i].x &lt;= mark) i++; &#125; printf("%d\n", ans); for(int i = 0; i &lt; v.size(); i++) printf("%d%c", v[i], i==v.size()-1?'\n':' '); &#125; return 0;&#125; D题不会，留坑。 E题假如两个字符串相同，那么输出“YES”。 否则，从左往右找到第一个不同，然后从右往左找到第一个不同，翻转这个区间的字符串，判断是否能让两个字符串相同。可以输出”YES”，不可以输出”NO”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;string s, t;int l, r, len, j;bool flag;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; s &gt;&gt; t) &#123; len = s.length(); l = r = -1; for(int i = 0; i &lt; len; i++) if(s[i] != t[i]) &#123; l = i; break; &#125; for(int i = len; i &gt; 0; i--) if(s[i] != t[i]) &#123; r = i; break; &#125; if(l == -1) printf("YES\n"); else &#123; flag = true; for(int i = l; i &lt;= r; i++) &#123; j = r - i + l; if(s[i] != t[j]) &#123; flag = false; break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; F题不会，留坑。 G题不会，留坑。传送门 H题这道题主要的难题在于ban掉怪兽能攻击到的区域，赛后经大佬指点，学会了多源bfs这种操作，新技能get :) 由n*m&lt;=200000，可得1 &lt;= n &lt;= 200000，1 &lt;= ｍ &lt;= 200000，所以不能开普通的二维数组，要开vector。比赛的时候没用vector，而是弄了个id来处理，写得好丑(: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;int cnt, n, m, dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;, vis[N], ban[N], sx, sy, gx, gy, d, dis[N], b[N];string g[N];vector&lt;pii&gt; v;inline bool check(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m;&#125;inline int id(pii t) &#123; return t.x * m + t.y;&#125;inline int id(int x, int y) &#123; return x * m + y;&#125;//多源bfsvoid banbfs() &#123; queue&lt;pii&gt; que; for(int i = 0; i &lt; v.size(); i++) &#123; que.push(pii(v[i].x, v[i].y)); vis[id(v[i])] = 1; b[id(v[i])] = d; &#125; while(que.size()) &#123; pii u = que.front(); que.pop(); if(b[id(u)] == 0) break; for(int i = 0; i &lt; 4; i++) &#123; int nx = u.x + dx[i], ny = u.y + dy[i]; if(check(nx, ny) &amp;&amp; !vis[id(nx, ny)]) &#123; vis[id(nx, ny)] = 1; ban[id(nx, ny)] = 1; b[id(nx, ny)] = b[id(u)] - 1; que.push(pii(nx, ny)); &#125; &#125; &#125;&#125;void bfs() &#123; banbfs(); queue&lt;pii&gt; que; if(!ban[id(sx, sy)]) que.push(pii(sx, sy)); memset(dis, -1, sizeof dis); dis[id(pii(sx, sy))] = 0; vis[id(sx, sy)] = 1; while(que.size()) &#123; pii u = que.front(); que.pop(); if(u.x == gx &amp;&amp; u.y == gy) &#123; break; &#125; for(int i = 0; i &lt; 4; i++) &#123; int nx = u.x + dx[i], ny = u.y + dy[i]; if(check(nx, ny) &amp;&amp; !vis[id(nx, ny)] &amp;&amp; !ban[id(nx, ny)]) &#123; que.push(pii(nx, ny)); vis[id(nx, ny)] = 1; dis[id(pii(nx, ny))] = dis[id(u)] + 1; &#125; &#125; &#125; printf("%d\n", dis[id(pii(gx, gy))]);&#125;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; d) &#123; for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) &#123; if(g[i][j] == 'S') sx = i, sy = j; else if(g[i][j] == 'M') v.push_back(pii(i, j)); else if(g[i][j] == 'F') gx = i, gy = j; &#125; bfs(); &#125; return 0;&#125; I题给了一些边，每条边最多只能用一次，现在需要判断所有的边能最多能组成多少的平行四边形。根据平行四边形的性质，答案就是边长相等的边的对数除以2 。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=2e5+9;const int shift=1e3+9;const double Eps=1e-7;int a[N], n, ans, d;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; n) &#123; memset(a, 0, sizeof a); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;d); a[d]++; &#125; ans = 0; for(int i = 0; i &lt; N; i++) ans += a[i]/2; printf("%d\n", ans/2); &#125; return 0;&#125; J题不会，留坑。 K题不会，留坑。 L题首先开26个set，将相同字母的位置压进同一个set里面。 当push 某个字母时，就在这个字母的set里面查找第一个大于当前位置的位置。假如找不到，那么就是NO，假如找到了，那么就是YES。不管是YES还是NO，都要先把旧位置放进栈里面，然后更新当前位置（NO时就更新为INF）。 当pop某个字母时，就将当前位置更新为栈顶元素，判断栈顶元素是否为INF，假如为INF，那就是NO，否则为YES。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;string s;char op[9], c;int m, t;set&lt;int&gt; se[29];stack&lt;int&gt; sta;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; s) &#123; for(int i = 0; i &lt; s.length(); i++) se[s[i]-'a'].insert(i); scanf("%d", &amp;m); int pp = -1; while(m--) &#123; scanf("%s", op); getchar(); if(op[1] == 'u') &#123; c = getchar(); t = c - 'a'; set&lt;int&gt;::iterator it = se[t].upper_bound(pp); sta.push(pp); if(it != se[t].end()) &#123; pp = *it; printf("YES\n"); &#125; else &#123; pp = INF; printf("NO\n"); &#125; &#125; else &#123; pp = sta.top(); sta.pop(); if(pp == INF) printf("NO\n"); else printf("YES\n"); &#125; &#125; &#125; return 0;&#125; M题这道题要分情况讨论。 三个字符串完全相同，Ambiguous。 存在两个字符串的差异值大于2，Impossible。 然后两两枚举不同的位置，再与剩余的另一个字符串diff，假如差异值大于1，那就不是可行解，否则时可行解。根据可行解的个数再分三种情况即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define x first#define y second#define ok puts("ok");using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const double PI = acos(-1.0);const int INF=0x3f3f3f3f;const ll LINF=0x3f3f3f3f3f3f3f3f;const int N=1e5+9;const int shift=1e3+9;const double Eps=1e-7;string s1, s2, s3, t;vi v[3];set&lt;string&gt; se;bool flag;int len, cnt;int main(void) &#123; if(fopen("in", "r")!=NULL) &#123;freopen("in", "r", stdin); freopen("out", "w", stdout);&#125; while(cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3) &#123; v[0].clear(); v[1].clear(); v[2].clear(); len = s1.length(); for(int i = 0; i &lt; len; i++) &#123; if(s1[i] != s2[i]) v[0].push_back(i); if(s2[i] != s3[i]) v[1].push_back(i); if(s1[i] != s3[i]) v[2].push_back(i); &#125; flag = true; for(int i = 0; i &lt; 3; i++) if(v[i].size() &gt; 2) flag = false; if(!flag) printf("Impossible\n"); else if(v[0].size() == 0 &amp;&amp; v[1].size() == 0 &amp;&amp; v[2].size() == 0) printf("Ambiguous\n"); else &#123; se.clear(); for(int i = 0; i &lt; v[0].size(); i++) &#123; t = s1; t[v[0][i]] = s2[v[0][i]]; cnt = 0; for(int j = 0; j &lt; len; j++) if(t[j] != s3[j]) cnt++; if(cnt &lt;= 1) se.insert(t); &#125; for(int i = 0; i &lt; v[1].size(); i++) &#123; t = s2; t[v[1][i]] = s3[v[1][i]]; cnt = 0; for(int j = 0; j &lt; len; j++) if(t[j] != s1[j]) cnt++; if(cnt &lt;= 1) se.insert(t); &#125; for(int i = 0; i &lt; v[2].size(); i++) &#123; t = s3; t[v[2][i]] = s1[v[2][i]]; cnt = 0; for(int j = 0; j &lt; len; j++) if(t[j] != s2[j]) cnt++; if(cnt &lt;= 1) se.insert(t); &#125; if(se.size() == 1) cout &lt;&lt; *se.begin() &lt;&lt; endl; else if(se.size() == 0) printf("Impossible\n"); else printf("Ambiguous\n"); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HrbustOJ 2375: easy math problem]]></title>
    <url>%2F2018%2F03%2F28%2F0%2F</url>
    <content type="text"><![CDATA[题目链接传送门 分析题目需要我们求i的3次方(1&lt;= i &lt;= n)的和，由于n很大，无法暴力算。 一般这种题的套路是利用二项式定理+求导，由于求的是i的3次方，所以我们可以通过连续”二项式方程左右两边求导乘x”3次，然后令x=1来构造出题目所求的式子，然后通过快速幂计算即可。记得CF上有一道类似的题，从3变成了k，顺便给出CF932E。 由于不会LaTeX，所以无法贴公式，留坑。。]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
