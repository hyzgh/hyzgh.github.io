<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hyz&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-11T15:51:57.048Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go Lang GC 学习笔记</title>
    <link href="http://yoursite.com/2020/01/11/go-garbage-collector-learning-note/"/>
    <id>http://yoursite.com/2020/01/11/go-garbage-collector-learning-note/</id>
    <published>2020-01-11T15:42:50.000Z</published>
    <updated>2020-01-11T15:51:57.048Z</updated>
    
    <content type="html"><![CDATA[<p>GC的具体实现一直在改变，但是其模型是相对稳定的。</p><p>collection的三个阶段：</p><ul><li>Mark Setup - STW</li><li>Marking - Concurrent</li><li>Mark Termination - STW</li></ul><p>Mark Setup：当进行gc时，为了保证数据完整性，需要设置Write Barrier，这要求将所有的goroutine停止，正常情况下这个时间平均为10-30ms。但是当goroutine停止不下时，会让这个时间变长。调度器目前停止goroutine的时机是在goroutine执行函数调用的时候，因为这样做才能保证安全。假如某个goroutine一直在执行循环，而不执行函数调用，它就无法被停止，这不仅会耽误gc第一个阶段的完成，还会造成其他goroutine停止着。将在Go1.14引入 <a href="https://github.com/golang/go/issues/24543" target="_blank" rel="noopener">preemptive</a> techniques 尝试对此进行优化。</p><p>Marking - Concurrent：当设置好Write Barrier后，collector会拿走25%可用的CPU，用于mark操作。mark操作，会遍历所有goroutine的栈，寻找指针指向的heap内存，将仍在使用的内存标记一下。这个时候，goroutine是可以并发执行的。在mark的过程，其他正在运行的goroutine可以分配内存，这可能导致内存不够用，这时候需要Mark Assits。Mark Assits，是指短暂停止正在运行的goroutine，让它们来帮忙mark，加快mark的进度。当然，这会影响这些goroutine的执行，collector的目标是尽可能减少Mark Assits的需要。</p><p>Mark Termination - STW：Mark完成后，需要关闭Write Barrier，进行多项清理工作，设定下次collection的目标。在进行这些工作前，仍要求所有的goroutine停止。这些工作平均持续60~90ms。虽然也可以设计成边Termination边正常运行一些gorutine的模式，但是设计者认为这样得到的收益很小，而增加的复杂性较高，所以选择了这种STW的实现方式。当Termination工作完成后，回到正常状态。</p><p>在collection完成后，会进行sweeping。</p><p>sweep是指将那些没有标记为使用的heap内存回收，它不是发生在一次collection中，而是被均摊到每次分配内存的时候。</p><p>以上所有行为只有在GC开始且正在进行的时候发生，GC Percentage对collection有很大影响。GC Pencentage，默认是100%。将GC Pencentage设置为100%，意味着下次GC会在heap达到当前GC的mark live内存的2倍时进行。</p><p>GC trace可用于追踪collection。<code>GODEBUG=gctrace=1 ./app</code>可查看GC信息，输出到<code>stderr</code>。</p><p>GC trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设置环境变量查看GC trace</span></span><br><span class="line">GODEBUG=gctrace=1 ./app</span><br><span class="line"></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8-&gt;11-&gt;6 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8-&gt;14-&gt;8 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC trace含义</span></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">// General</span><br><span class="line">gc 1404     : The 1404 GC run since the program started</span><br><span class="line">@6.068s     : Six seconds since the program started</span><br><span class="line">11%         : Eleven percent of the available CPU so far has been spent <span class="keyword">in</span> GC</span><br><span class="line"></span><br><span class="line">// Wall-Clock</span><br><span class="line">0.058ms     : STW        : Mark Start       - Write Barrier on</span><br><span class="line">1.2ms       : Concurrent : Marking</span><br><span class="line">0.083ms     : STW        : Mark Termination - Write Barrier off and clean up</span><br><span class="line"></span><br><span class="line">// CPU Time</span><br><span class="line">0.70ms      : STW        : Mark Start</span><br><span class="line">2.5ms       : Concurrent : Mark - Assist Time (GC performed <span class="keyword">in</span> line with allocation)</span><br><span class="line">1.5ms       : Concurrent : Mark - Background GC time</span><br><span class="line">0ms         : Concurrent : Mark - Idle GC time</span><br><span class="line">0.99ms      : STW        : Mark Term</span><br><span class="line"></span><br><span class="line">// Memory</span><br><span class="line">7MB         : Heap memory <span class="keyword">in</span>-use before the Marking started</span><br><span class="line">11MB        : Heap memory <span class="keyword">in</span>-use after the Marking finished</span><br><span class="line">6MB         : Heap memory marked as live after the Marking finished</span><br><span class="line">10MB        : Collection goal <span class="keyword">for</span> heap memory <span class="keyword">in</span>-use after Marking finished</span><br><span class="line"></span><br><span class="line">// Threads</span><br><span class="line">12P         : Number of logical processors or threads used to run Goroutines</span><br></pre></td></tr></table></figure><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GC的具体实现一直在改变，但是其模型是相对稳定的。&lt;/p&gt;
&lt;p&gt;collection的三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mark Setup - STW&lt;/li&gt;
&lt;li&gt;Marking - Concurrent&lt;/li&gt;
&lt;li&gt;Mark Termination -
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>perl 学习笔记</title>
    <link href="http://yoursite.com/2019/12/18/null/"/>
    <id>http://yoursite.com/2019/12/18/null/</id>
    <published>2019-12-18T15:09:06.000Z</published>
    <updated>2019-12-18T15:58:07.610Z</updated>
    
    <content type="html"><![CDATA[<p>Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。</p><p>Perl的强大之处，在于它具有sed和awk的全部功能，以及众多语言的语法特性，以及非常强大的正则表达式，等等。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h1><p>Perl的Hello, World：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'print("Hello, World\n")'</span></span><br></pre></td></tr></table></figure><p>在安装了perl的计算机上，直接执行上述代码，即可输出<code>Hello, World</code>。</p><p>也可以将perl代码写在文件，以重复执行，具体可以这样写：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 "Hello, World"</span></span><br><span class="line"><span class="keyword">print</span>(<span class="string">"Hello, World\n"</span>);</span><br></pre></td></tr></table></figure><p>将上述代码保存成<code>learn.pl</code>后，加下执行权限，然后执行<code>./learn.pl</code>，可输出<code>Hello, World</code>。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Perl的正式表达式非常强大，是常用编程语言里最顶尖的之一。下面来看几个例子。</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p><code>echo box.svc.content | perl -p -e &#39;s/\.+/\//g&#39;</code></p><p>将会输出<code>box/svc/content</code>。</p><p>解析：</p><p><code>-p</code>参数会将结果输出出来。</p><p>这里用到了一个常用的<strong>替换</strong>句型，<code>s/old/new/parameters</code>，表示将<code>old</code>替换成<code>new</code>。</p><p><code>s/\.+/\//g</code>的<code>s</code>表示替换，<code>\.+</code>表示至少一个<code>.</code>，<code>\/</code>表示一个<code>/</code>，<code>g</code>表示全局匹配。</p><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"></span><br><span class="line">$string = <span class="string">'welcome to w3cschool site.'</span>;</span><br><span class="line">$string =~ <span class="regexp">tr/a-z/A-z/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$string\n"</span>;</span><br></pre></td></tr></table></figure><p>上面的代码将会输出<code>WELCOME TO W3CSCHOOL SITE.</code>。</p><p>这里用到了一个常用的<strong>转化</strong>句型，<code>tr/old/new/parameters</code>。表示将<code>old</code>转化成<code>new</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.w3cschool.cn/perl/perl-regular-expressions.html" target="_blank" rel="noopener">Perl 正则表达式 - W3Cschool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。&lt;/p&gt;
&lt;p&gt;Perl的强大之处，在于它具有sed和a
      
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>图片文件格式 学习笔记</title>
    <link href="http://yoursite.com/2019/12/07/null/"/>
    <id>http://yoursite.com/2019/12/07/null/</id>
    <published>2019-12-07T08:07:02.000Z</published>
    <updated>2019-12-07T08:32:39.020Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。</p><p>一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过<code>ImageMagick</code>这个程序来解析图片文件。</p><p>分辨率，比如1920x1080，是指图片的一行具有1920个像素，一列具有1080个像素。</p><p>色彩空间，是指描述一个像素点的方式。比如RGB，是指一个像素点用red, green, blue各8bit一共24bit来描述。而YUV，是指Y表示亮度，U和V一起表示色调和饱和度。</p><p>在互联网上最常见的大概是jpeg类的文件。jpeg文件之所以适合在互联网上传播，是因为它的压缩比较高，且能在压缩和图片还原度上保持平衡，使得一张图片既有小巧的体积，又能在肉眼级别上有良好的清晰度。</p><p>但是jpeg文件并不适合保存图标等图像内容，因为它不具有alpha通道，不能用来表示透明的背景。一般会用png来保存图标。由于png是无损压缩存储图片的，所以会比jpeg文件要大一些，也适合对于图像质量要求较高的情况。</p><p>bmp文件，它也是无损不压缩的，所以会比较大，比较少见。</p><p>git文件，可以存储动图，但是由于它只用了8bit来描述一个像素点，所以可用的色彩并不多，色彩丰富度低。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。&lt;/p&gt;
&lt;p&gt;一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过&lt;code&gt;ImageMagick&lt;/code&gt;这个程序来解析图片文件。&lt;/p&gt;
&lt;p&gt;分辨率，比如1920x1080，是指图
      
    
    </summary>
    
    
      <category term="文件格式" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 6</title>
    <link href="http://yoursite.com/2019/10/21/CSAPP-learning-note-6/"/>
    <id>http://yoursite.com/2019/10/21/CSAPP-learning-note-6/</id>
    <published>2019-10-21T11:16:38.000Z</published>
    <updated>2019-10-24T12:39:08.615Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了CSAPP的第八章——异常控制流。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。异常有不同的种类，有中断、陷阱、故障、终止。</p><p>中断，是在CPU执行某条指令的时候，其他部件异步产生的，比如定时器芯片、磁盘控制器、网络适配器等。CPU检测到中断后，会把当前指令执行完，然后转去执行异常处理程序，接着再返回来执行下一条指令。</p><p>陷阱，是有意的异常，最常见的陷阱是系统调用。系统调用，是指从用户模式转为内核模式，以执行一些特殊的指令，比如操作I/O设备。执行完系统调用后，会返回来执行下一条指令。</p><p>故障，是指执行指令的时候遇到了意外，比如遇到了缺页、访问了未定义的虚拟内存区域等。根据故障的不同，异常处理程序执行完后可能会返回执行当前指令，也有可能会终止程序。在写程序时常常遇到的<code>Floating point exception</code>和<code>Segmentation fault</code>就属于故障，且在Linux中的处理是程序被终止。</p><p>终止，是指遇到了致命的硬件错误，必须结束程序。</p><p>因为异常种类繁多，所以计算机中有一张异常表，用来记录不同的异常及对应的异常处理程序。在CPU中，有一个特殊的寄存器——异常表基址寄存器，用来存放异常表在内存中的基址。当CPU遇到一种异常的时候，会拿到一个异常号。CPU拿着这个异常号及寄存器中的基址，便可以找到对应的异常处理程序了。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程，是执行中的程序实例，是操作系统对于程序的一种抽象。这种抽象，使得看起来进程是独占cpu和内存的。为了实现这种抽象，需要操作系统保存好进程的上下文，进行进程调度。</p><p>进程的上下文，是指进程执行的状态，包括CPU中的状态、用户模式中的状态、内核模式中的状态。具体来说，cpu中的状态，包括各种寄存器，比如通用寄存器，用来保存指令执行用到的数据，还有程序计数器，用来指明程序执行的进度。用户模式下的状态，包括用户栈等。内核模式中的状态，包括内核栈、进程已打开文件的信息的文件表、有关当前进程的信息的进程表等。</p><p>什么时候会触发进程调度呢？主要有两种情况。一种是进程执行了系统调用，阻塞住了，比如读写文件、sleep等。另一种是中断，包括IO操作完成以及时钟中断等。</p><h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><ul><li><code>PS</code>：列出当前系统中的进程。</li><li><code>TOP</code>：打印出关于当前进程资源使用的进程。</li><li><code>PMAP</code>：显示进程的内存映射。</li><li><code>STRACE</code>：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。<code>-static</code>是个实用的参数。</li><li><code>/proc</code>：一个虚拟文件系统，以ASCII文件格式输出大量内核数据结构的内容。</li></ul><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了CSAPP的第八章——异常控制流。&lt;/p&gt;
&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;p&gt;在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 5</title>
    <link href="http://yoursite.com/2019/10/18/CSAPP-learning-note-5/"/>
    <id>http://yoursite.com/2019/10/18/CSAPP-learning-note-5/</id>
    <published>2019-10-18T14:27:36.000Z</published>
    <updated>2019-10-21T11:17:03.860Z</updated>
    
    <content type="html"><![CDATA[<p>这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。</p><p><img src="https://s2.ax1x.com/2019/10/18/KeyBvV.png" alt="第六章存储器层次结构"></p><h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><p>存储器有着很多的种类，比如CPU的寄存器、高速缓存，主存（内存）的DRAM，机械硬盘、固态硬盘、U盘、SD卡、磁带等。不同的存储器，会用到不同的存储技术。其中寄存器的存储技术从性能上看是最好的，同时价格也最昂贵的，因此寄存器的大小相比于其他存储器，少得可怜，比如一般来说，通用寄存器只有16个，而1个寄存器只能存储64个bit。高速缓存采用的是SRAM，而主存用的是DRAM。SRAM用到了多个晶体管，比DRAM要快得多，会更加稳定，同时成本也更高。一般来说，高速缓存是几M的量级，而主存是以几G的量级，可见两者的价格差异。RAM有一个特点是断电后内容会丢失。</p><p>我们常用的U盘、SD卡等，并不是基于RAM，而是基于ROM。所谓ROM，翻译成中文便是只读存储器。个人觉得这个名字有点歧义，容易让人误解成数据不可更改。但实际上，ROM也有多个种类，我们常用的U盘基于EEPROM（电子可擦写只读存储器），是可以进行擦写的。而固态硬盘，基于闪存，它也是可擦写的。以前给手机刷机的时候，常常会听到ROM和固件这两个名词。所谓固件，是指写入到ROM中的程序。</p><p>机械硬盘，常常会听到一个参数叫转数。这个参数表示盘片旋转速度的速度。这个参数虽然重要，但却非影响硬盘随机IO时间的最重要因素。磁盘访问数据，由三个部分的时间组成，即寻道时间、旋转时间、传送时间。寻道时间是磁头定位到对应磁道的时间，这个时间平均占比是最大的，通常可占到整体时间的1/2以上，所以我们可以用两倍寻道时间来估计总时间。磁头定位到对应磁道，有专门的寻道算法，比如电梯算法。</p><p>固态硬盘，是近些年流行起来的存储器。其性能、价格皆介于主存和机械硬盘之间。由于固态硬盘采用了闪存，避免了机械硬盘缓慢的寻道和旋转，所以速度更快，特别是在随机IO的表现上。</p><p>根据历史趋势，存储器将会访问速度越来越快，越来越大，且会越来越便宜。但是，由于CPU的性能提升要比SRAM、DRAM、磁盘的速度快，所以两者的差距在增大，这将成为计算机的瓶颈。也因此，各级缓存的必要性就体现出来了，利用局部性原理，我们可以减弱这种差距。</p><h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性分为空间局部性及时间局部性。空间局部性指的是某个位置的数据被访问后，其附近的数据将可能被访问。时间局部性指的是某个位置的数据被访问后，这个位置还将可能被再次访问。</p><p>以前对于这个概念的认识有点模糊，对其带来的性能差异没有明确的认知。我们下面通过一个程序来看一下空间局部性带来的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;    </span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当N = 20000时，在我的机器上，sum1执行的时间为2.1s，而sum2执行的时间为5.6s，两者差距两倍多。</p><p>sum1之所以性能表现比sum2优秀，是因为它访问数据时的步长为1，让计算机能更好地利用空间局部性原理。</p><h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>计算机的存储器层次结构从快到慢分为寄存器、L1高速缓存、L2高速缓存、L3高速缓存、主存、本地二级磁盘（本地磁盘）、远程二级存储（分布式文件系统、Web服务器）等。通过这样的层次结构，在大小、访问速度、价格等因素之间取得了折衷，让计算机的价格合理、访问速度较快、存储空间较大。</p><p>缓存无处不在，其目的是降低不同存储器之间速度差异带来的影响。计算机各级存储器之间，上层是下层的缓存。浏览器访问网页时，在本地磁盘有缓存，能提高用户打开同一网页的速度。Web服务器被访问的时候，本地磁盘也有缓存，能提高不同用户访问同一网页的速度。磁盘也有缓存，用于缓存磁盘扇区，提高计算机访问磁盘的速度。代理服务器，也可用来做缓存，能降低网络延迟。业务上，redis用作MySQL的缓存，是用内存来缓存磁盘的内容，缓解了随机I/O带来的性能问题。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/18/KeyBvV.png&quot; alt=&quot;第六章存储器层次结构&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;存储技术&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 4</title>
    <link href="http://yoursite.com/2019/10/15/CSAPP-learning-note-4/"/>
    <id>http://yoursite.com/2019/10/15/CSAPP-learning-note-4/</id>
    <published>2019-10-15T04:31:41.000Z</published>
    <updated>2019-10-18T14:28:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。</p><p>在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。</p><p>在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即<code>CMP</code>和<code>TEST</code>，也会设置条件码，但它们不会改变其他寄存器。</p><p>那么怎么访问这些条件寄存器呢？CPU中提供了<code>SET</code>指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应<code>SETE</code>指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应<code>SETL</code>，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。</p><p>要实现像C语言中的for语句，还需要一类指令<code>JMP</code>。它可以根据条件跳转到其他语句，而不是一直顺序执行。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。&lt;/p&gt;
&lt;p&gt;在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 3</title>
    <link href="http://yoursite.com/2019/09/29/CSAPP-learning-note-3/"/>
    <id>http://yoursite.com/2019/09/29/CSAPP-learning-note-3/</id>
    <published>2019-09-29T14:38:59.000Z</published>
    <updated>2019-09-29T15:45:45.171Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看了第三章的前面五节，对机器指令有了更进一步的认识。</p><p><img src="https://s2.ax1x.com/2019/09/29/uGR19e.png" alt="程序的机器级表示 阅读进度"></p><h1 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h1><p>Intel处理器系列俗称x86，它有着一段进化之旅。从最初的8086到i386，再到i5和i7。那么它究竟有哪些方面的提升呢？</p><ul><li>晶体管数量增加。Core i7的1.4G个晶体管，是8086芯片29K个晶体管的4.8万倍。晶体管越多，意味着芯片的电路越复杂，能力越强。</li><li>指令集变大，支持更多指令。8087在8086的基础上，建立了浮点模型。</li><li>更多的位数。Pentium 4E是Intel对AMD提出的对IA32的64位拓展的实现，我们称之为x86-64。</li><li>更多的核数。Core 2是Intel的第一个多核微处理器。</li><li>更多的技术。Pentium 4E增加了超线程，允许一个处理器上同时运行两个程序。</li></ul><p>AMD等产商的大多处理器与Intel处理器兼容，能够运行完全相同的机器级程序。</p><h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><p>什么是机器代码呢？我们知道，C语言会经过预处理、编译、汇编、链接这些过程。</p><ul><li>预编译：拓展源代码，主要处理对象是#include及#define。</li><li>编译：产生源文件的汇编代码，拓展名为.s。</li><li>汇编：产生二进制目标代码，拓展名为.o。</li><li>链接：将多个.o文件转化成一个可执行文件。</li></ul><p>所谓机器代码，第一种是指.o文件中的代码，第二种是指可执行文件中的代码。它们的区别在于前者还没有填入全局值的地址。</p><p>机器代码是一些二进制代码，不具有可读性。汇编代码非常接近机器代码，我们可通过学习汇编代码来认识机器代码。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>Intel的体系结构一直在变化，从16位到32位，再到64位，可能以后还会拓展到128位。</p><p>Intel用以下术语来表示不同的数据类型。</p><table><thead><tr><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>字节</td><td>b</td><td>1</td></tr><tr><td>字</td><td>w</td><td>2</td></tr><tr><td>双字</td><td>l</td><td>4</td></tr><tr><td>四字</td><td>q</td><td>8</td></tr><tr><td>单精度</td><td>s</td><td>4</td></tr><tr><td>双精度</td><td>l</td><td>8</td></tr></tbody></table><h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>一个CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。</p><p>我们知道，程序运行时，其数据存放在内存中。CPU需要一些指令来进行内存与寄存器间的数据转移，称为数据转移指令。</p><p>我们也知道，程序运行时，在内存中有一个对应的程序栈。CPU有专门指令进行入栈、出栈操作。可否将这些指令去掉呢？可以，存在代替指令。但是这样做，会让机器代码增多，考虑到入栈出栈操作是非常常见的，所以提供专门的指令会缩减机器代码的大小。这也就是在精简指令集上编译出来的机器代码比复杂指令集庞大的原因。</p><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>所谓算术操作，指的是加减乘除等操作。所谓逻辑操作，是指与或移位等操作。</p><p>通过学习汇编代码的算术和逻辑操作，对于高级语言的便利性有了更具体的认识。一条C语言简单的算术表达式，转化成汇编代码，会变成多条。对于一些更复杂的循环控制语句，就更复杂了。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看了第三章的前面五节，对机器指令有了更进一步的认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/29/uGR19e.png&quot; alt=&quot;程序的机器级表示 阅读进度&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;历史观点&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 2</title>
    <link href="http://yoursite.com/2019/09/15/CSAPP-learning-note-2/"/>
    <id>http://yoursite.com/2019/09/15/CSAPP-learning-note-2/</id>
    <published>2019-09-15T15:31:06.000Z</published>
    <updated>2019-09-15T16:30:27.734Z</updated>
    
    <content type="html"><![CDATA[<p>这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。</p><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>整数运算的分类主要有两个维度，一个是无符号数、有符号数，另一个是加法、乘法。</p><p>之前知道编译器会将乘法转化成加减法/移位，但始终不知所以然。这次通过阅读CSAPP，深入理解了它的原理，另外知道了还可以将除法转化为加减法/移位。</p><p>这一节讲得都是规律和证明，这里不再赘述。贴一张图进行总结，以方便以后回忆。</p><p><img src="https://s2.ax1x.com/2019/09/16/nRiAaT.png" alt="image-20190915234925595"></p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>阅读完这一节后，对于浮点数的表示、运算、舍入等有了更深入的理解。</p><p>其中，有的地方一开始不是很理解，当弄懂后，觉得这些设计很优雅、很聪明。</p><p>比如，对于IEEE非规范值得设计不是很理解，为什么要增加复杂性呢。后来，明白了非规格值的设计，使得0的表示很加自然且靠近0的浮点数分布得更均匀。</p><p>比如，一开始不太明白为什么要有偶数舍入法，直接四舍五入不行吗。后来，明白了偶数舍入法是对四舍五入的一种改进，避免了舍入所造成的统计误差。</p><p>还有浮点的运算，不遵循结合律，这是之前没有注意到但也是十分重要的知识点。</p><p><img src="https://s2.ax1x.com/2019/09/16/nRikZV.png" alt="image-20190916000251225"></p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。&lt;/p&gt;
&lt;h1 id=&quot;整数运算&quot;&gt;&lt;a href=&quot;#整数运算&quot; class=&quot;headerlink&quot; title=&quot;整数运算&quot;&gt;&lt;/a&gt;整数运算&lt;/h1&gt;&lt;p&gt;整数运算的分类主要有两
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 1</title>
    <link href="http://yoursite.com/2019/09/08/CSAPP-learning-note-1/"/>
    <id>http://yoursite.com/2019/09/08/CSAPP-learning-note-1/</id>
    <published>2019-09-08T14:18:17.000Z</published>
    <updated>2019-09-08T12:47:05.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一周看完了第一章，这一周继续看第二章。本章的内容和信息的表示和处理有关，这部分内容之前修计算机组成原理时有学习到，所以阅读起来比较顺利，预计下周能顺利读完此章。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这一章的内容分为四小节，分别是：</p><ul><li>信息存储</li><li>整数表示</li><li>整数运算</li><li>浮点数</li></ul><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p><a href="https://hyzgh.github.io/2019/08/30/CSAPP-learning-note-0/" target="_blank" rel="noopener">上篇笔记</a>谈到了信息，什么是信息？信息是数据+上下文。</p><p>在不同的上下文中，数据会有不同的含义。一个字节，既可表示一个字符，也可表示范围在[0, 256)的无符号整数，也可表示范围在[-128, 128)的有符号整数，还可以表示具有8个元素的集合，等等。</p><p>大多数机器使用8位的块，称为字节，作为最小的可寻址的内存单位，而不是直接访问内存中单独的位。字长为32位的机器，寻址的最大空间是$2^{32}$字节，而字长为64位的机器，寻址的最大空间就是$2^{64}$字节。什么是字长呢，字长用于指明指针数据的标称大小。</p><p>因为一个字节有8个位，用二进制表示起来有点冗长，而用十进制表示法的话，与位模式的互相转化会很麻烦。于是就有了十六进制数来表示位模式，在二进制和十进制取了折中，既方便表示，又不那么难读。</p><p>假如我们想要访问跨越多字节的对象，需要建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。对象地址的寻址范围根据字长而定，当字长为$w$时，可寻址空间为$2^{w}$。确定好对象的起始地址，还需要知道它有多少个字节以及如何排列这些字节。假设读取对象为<code>int</code>，有四个字节，且在内存中从低址到高址的内容为<code>0x00000001</code>，采用大端法读取就是$1$，采用小端法读取就是$2^{24}$。大端表示法比较符合人类的习惯，而小端法需要将数据按字节倒序排列。这些数据在机器中的字节排列通常对我们没有影响，但当涉及到网络编程时，就需要关注网络传输数据和机器存储数据的区别了。</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>整数在计算机中有多种表示形式，比如原码、补码、反码等。</p><p>而编程语言中遇到的整数类型，比如<code>short</code>, <code>int</code>, <code>long long</code>等，是对整数大小的限制。</p><p>而常说的有符号数、无符号数，则是在人类限制整数能否表示负数而产生。我认为有符号数和无符号数的设计其实意义不大，只用一种有符号数来表示整数就足够了。有了无符号数和有符号数，就需要用户去关注无符号数和有符号数的转化，一些隐式转化很容易引起出人意料的隐蔽错误。在Java中，并没有无符号数的概念，而在C语言中，有符号数和无符号数的转化，其实整数在底层的位表示中是不变的，只是C语言在不同的上下文中对它进行了不同的解释。</p><p>无符号数，采用简单的原码编码即可。而有符号数，一般采用补码编码，因为相对于源码、反码，它能表示更多一个数，更重要的是，机器中的位表示与整数是一个双射关系，很优雅。</p><p>无符号数和有符号数的转化，在理解了机器的位表示始终不变以及补码的相关知识后，我们可以总结出规律。我们这里假设两者的位数都为$w$。将无符号数转化为有符号数，当超过其表示范围时，需要减去$2^w$。将有符号数转化为无符号数时，负数需要加上$2^w$。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一周看完了第一章，这一周继续看第二章。本章的内容和信息的表示和处理有关，这部分内容之前修计算机组成原理时有学习到，所以阅读起来比较顺利，预
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 0</title>
    <link href="http://yoursite.com/2019/08/30/CSAPP-learning-note-0/"/>
    <id>http://yoursite.com/2019/08/30/CSAPP-learning-note-0/</id>
    <published>2019-08-29T16:08:59.000Z</published>
    <updated>2019-08-30T15:16:26.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CSAPP（深入理解计算机系统）这本书豆瓣评分接近满分，是学习计算机系统的经典教材之一。这一周开始阅读此书，并计划以后每周写一篇学习笔记。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>数据和信息是两个含义不同的词。数据是“死”的，而信息是“活”的。举个例子，阿拉伯数字8，在不同的情景下，可传递不同的信息。当电梯中可表示第8层，在桌球桌上可表示黑球8，而在聊天中可表示”拜拜”的意思。是什么赋予了它内涵？是情景，也称作上下文。在计算机系统中，数据就是比特串，是一个一个的位，再加上具体的上下文，就成为了信息。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一个C语言程序，需要经过预处理器、编译器、汇编器、链接器的翻译，才能转化成可执行目标程序。</p><p>编译是个转化数据的过程。转化前是源代码，是人类可以理解的信息。而转化后，变成了机器语言，变成了人类无法理解的信息，而机器在一定的上下文中，能够理解这些数据。机器语言是机器能够理解的信息。</p><p>学习编译系统，可以帮助我们优化程序性能、理解链接时出现的错误、避免安全漏洞等。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>编译后产生的可执行文件在磁盘里。当我们执行该文件时，计算机系统是怎么运作的呢？</p><p>假设我们是在shell执行该程序的。键盘是一个外部设备，通过系统I/O总线和其他硬件连接在一起。当我们通过键盘输入可执行文件的文件名时，字符串会通过总线被逐一读入CPU中的寄存器并送入内存，且会输出到图形适配器（所以我们才可以在屏幕上看到输入的字符）。当输入回车后，shell就会通过一系列的指令来执行该程序，将程序的文件内容装载进内存，开始子进程，将CPU让给它执行。这个过程中，不同的指令，会让数据在CPU、内存、I/O设备间流动，比如输出文字到屏幕、通过网络下载文件等。</p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>所谓高速缓存，是为了解决CPU从寄存器读取数据与从内存读取数据的速度差异问题。CPU从寄存器读取数据比从内存读取数据要高几个数量级。所以一个自然的想法是提高寄存器的容量，这是一个解决思路，但是因为寄存器的价格要比内存贵得多，大幅提高容量从经济的角度考虑不太现实。另一个解决思路是提高主存的读取速度，这很接近现在大部分计算机系统采用的方法了。根据计算机组成原理的知识，我们知道SRAM的读取性能比DRAM的快得多，且SRAM也分多种，不同的SRAM实现会有不同的性能表现，价格也有差异。因为SRAM的价格还是要比DRAM高，大量采用SRAM作为主存也不现实。因此形成了一种折中的方案，采用DRAM作为主存，SRAM作为CPU的高速缓存。当CPU执行指令时，首先会从寄存器取数据，假如取不到，再到高速缓存取，假如还取不到，才到主存取。通过引进高速缓存，缓解了CPU执行速度与从内存读取数据速度不匹配的问题。</p><p>利用局部性原理，可提高高速缓存的命中率，让CPU尽可能快地取到指令去执行，提高整体效率。至于高速缓存中的数据与内存中的数据的映射，则涉及到了计算机组成原理，这里不再深入讲述。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>所谓抽象，在生活中其实随处可见。记得《人类简史》中写到，人类区别于其他生物的重要原因便是想象力丰富。人类之间通过讲述各种故事，塑造各种抽象概念，诸如宗族、城市、国家等概念，让原本互不认识的人有了联系的纽带，共同合作，诞生了各种文明。计算机系统中也有各种抽象概念，诸如文件、虚拟内存、进程。这些抽象，在我看来，是人类设计冯诺依曼计算机的基础，没有这些概念，计算机系统便不知道从何说起。</p><p>文件时什么？文件是一些二进制位在I/O设备中的抽象。</p><p>虚拟内存是什么？虚拟内存是程序的在主存和I/O设备中的空间的抽象。</p><p>进程是什么？进程是程序在CPU、主存、I/O设备活动的抽象。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CSAPP（深入理解计算机系统）这本书豆瓣评分接近满分，是学习计算机系统的经典教材之一。这一周开始阅读此书，并计划以后每周写一篇学习笔记。&lt;
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习笔记</title>
    <link href="http://yoursite.com/2019/07/31/Go-learning-note/"/>
    <id>http://yoursite.com/2019/07/31/Go-learning-note/</id>
    <published>2019-07-31T15:59:21.000Z</published>
    <updated>2019-08-01T09:24:02.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用packages"><a href="#常用packages" class="headerlink" title="常用packages"></a>常用packages</h1><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>Printf</code></p><table><thead><tr><th>verb</th><th>描述</th></tr></thead><tbody><tr><td>%v</td><td>输出值</td></tr><tr><td>%+v</td><td>输出键-值</td></tr><tr><td>%#v</td><td>输出包名、类型名、键-值</td></tr><tr><td>%T</td><td>类型</td></tr><tr><td>%%</td><td>百分号</td></tr><tr><td>%t</td><td>布尔值</td></tr><tr><td>%b</td><td>二进制的值</td></tr><tr><td>%c</td><td>Unicode编码的字符</td></tr><tr><td>%d</td><td>十进制的值</td></tr><tr><td>%o</td><td>八进制的值</td></tr><tr><td>%x或%X</td><td>十六进制的值</td></tr><tr><td>%U</td><td>十六进制表示的Unicode值</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%p</td><td>地址</td></tr><tr><td>%f</td><td>浮点数，默认精度是小数点后6位</td></tr><tr><td>%e</td><td>浮点数，科学计数法，默认精度是小数点后6位</td></tr><tr><td>%g</td><td>浮点数，有效数字，尽可能地输出所有位数</td></tr><tr><td>+</td><td>添加正负号</td></tr><tr><td>-</td><td>设置宽度时默认在左边补全空格，该符号可设置在右边补全空格</td></tr><tr><td>0</td><td>用0代替空格进行补全</td></tr><tr><td>#</td><td>对于八进制，十六进制等，加上提示符，如八进制为0，十六进制为0x</td></tr></tbody></table><p><code>%f</code> 可指定浮点数的宽度和精度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%f     default width, default precision</span><br><span class="line">%9f    width 9, default precision</span><br><span class="line">%.2f   default width, precision 2</span><br><span class="line">%9.2f  width 9, precision 2</span><br><span class="line">%9.f   width 9, precision 0</span><br></pre></td></tr></table></figure><p><code>%g</code> 可指定浮点数的有效数字位数，对于12.345，<code>%.3g</code> 将输出 12.3</p><p>若要能对某个自定义类型输出，只要对它定义<code>String() string</code>方法即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d/%g/%q"</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当t是*T类型时，才会调用上面那个函数</span></span><br><span class="line"><span class="comment">// 若要当t是T类型和*T类型都都调用上面那个函数，需要将上面的*T改成T</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, t)</span><br></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>会将内容输出到stderr，且会增加一些信息（如日期时间）。</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>注意只有当结构体内的成员是公开时，才能在Marshal的时候被识别，成为json文件的一部分。</p><p>进行Unmarshal时，假如json中有的字段而结构体没有，则这个字段会被忽略，不影响解析。也就是说，可进行json文件的部分解析。同理，假如Marshal时，结构体中的字段不想转到JSON文件中，可以将其tag设置为”-“。</p><p>解析时，结构体的某个字段的匹配优先级为tag -&gt; 导出名精确匹配 -&gt; 导出名模糊匹配。</p><p>omitempty表示当字段为零值时忽略它，而tag为”-“表示直接忽略它。</p><p>UnmarshalText函数和UnmarshalJSON函数的区别是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当不知道json文件的格式时，可这样解析</span></span><br><span class="line">b := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is string"</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is float64"</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">      fmt.Println(k, <span class="string">"is an array:"</span>)</span><br><span class="line">      <span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">        fmt.Println(i, u)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is of a type I don't know how to handle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若将结构体的成员设置为指针类型，则若json不存在相应的字段，则为nil</span></span><br><span class="line"><span class="keyword">type</span> IncomingMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">  Cmd *Command</span><br><span class="line">  Msg *Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于流的Encoders和Decoders</span></span><br><span class="line">de := json.NewDecoder(os.Stdin)</span><br><span class="line">enc := json.NewEncoder(os.Stdout)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := dec.Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> k := <span class="keyword">range</span> v &#123;</span><br><span class="line">    <span class="keyword">if</span> k != <span class="string">"Name"</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(v, k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := enc.Encode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Basic-component"><a href="#Basic-component" class="headerlink" title="Basic component"></a>Basic component</h1><h2 id="package-import"><a href="#package-import" class="headerlink" title="package | import"></a>package | import</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何go程序都是由package组成，首个非空单词必须是package</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个import</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个import</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><p>形式：形参的标识符在前，类型在后；返回值放在最后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的主要原因是为了提高易读性，特别是在涉及函数变量（函数指针）的时候</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> <span class="title">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>同类型的形参可简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值可有多个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可给返回值命名，且return可简写，注意不要在长函数中简写，因为这样会降低可读性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="variables-constants-types"><a href="#variables-constants-types" class="headerlink" title="variables | constants | types"></a>variables | constants | types</h2><p>首字母大写的变量称为exported name</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  Address <span class="keyword">string</span>  <span class="comment">// exported name</span></span><br><span class="line">  cost <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申明格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单句</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有赋初值时，可省略类型名</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">d := <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当省略类型名时，编译器会自动推测，推测规则为：</p><ul><li>右边是变量，则和变量的类型相同</li><li>右边是常量，则有可能是int, float64, complex128</li></ul><p>基础类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>申明的变量假如没有被显式赋初值，则会被赋<code>zero value</code>，即数值为0，布尔类型为false，字符串为””，指针为nil</p><p>申明常量，用<code>const</code>，不能用<code>:=</code>，因为<code>:=</code>是和<code>var</code>关联的，而<code>var</code>代表变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">"世界"</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello"</span>, World)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有隐式类型转换，必须显式类型转换。</p><p>类型断言，用于将空接口转换为普通类型。类型断言又分为安全类型断言和非安全类型断言。</p><ul><li>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;<strong>.</strong>(目标类型)  // 安全类型断言</li><li>&lt;目标类型的值&gt; := &lt;表达式&gt;<strong>.</strong>(目标类型)  // 非安全类型断言</li></ul><p>在函数体内，变量申明了但不使用会报错。同理，import的package没用的话也会报错。</p><p>Go在函数体中定义了一个变量，然后将它的指针返回是合法的，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">// 或者将上面两行简写成return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">    <span class="comment">// 不难发现new(File)和&amp;File&#123;&#125;是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="More-types"><a href="#More-types" class="headerlink" title="More types"></a>More types</h1><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>指针，和C不一样，Go没有指针的算术运算，即不支持<code>p = p + 10</code>这样的语句</p><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>结构体，可将<code>(*p).X</code>写成<code>p.X</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// has type Vertex</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 is implicit</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 and Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// has type *Vertex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>In Go：</p><ul><li>Arrays are values. Assigning one array to another copies all the elements.</li><li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li><li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line">    fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如想要像C那样只传数组的地址，可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// Note the explicit address-of operator</span></span><br></pre></td></tr></table></figure><p>虽然可以这么写，但不推荐，因为更优雅的方法是使用slices。</p><h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>切片，本身不存储实际数据，类似于引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片数组，可以改变指向的范围</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    t := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">    r = t</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片，可省略下界或上界</p><p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p><p><code>len()</code>查看长度，即从下界到上界的个数</p><p>切片为<code>nil</code>时，<code>cap</code>和<code>len</code>都为0</p><p>使用<code>make</code>来创建一维切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line">    printSlice(<span class="string">"b"</span>, b)</span><br><span class="line"></span><br><span class="line">    c := b[:<span class="number">2</span>]</span><br><span class="line">    printSlice(<span class="string">"c"</span>, c)</span><br><span class="line"></span><br><span class="line">    d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">        s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>make</code>创建二维切片，第一种方式，该方式允许第二维大小有所变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可使用<code>append</code>函数向切片添加元素，假如切片容量不足，则容量会翻倍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>append</code>函数向切片中添加切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩减切片的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ugly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elegant，缩减了切片的cap，释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><code>maps</code>的零值为<code>nil</code>，可通过<code>make</code>创建<code>map</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化时，值的类型名可省略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入键值对，取键的值，删除键值对（可多次删除，可删除不存在的键）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map被函数调用，可被修改。</p><h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也可以作为值，可以像其他数据类型一样赋值给变量，作为实参等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function-closures"><a href="#Function-closures" class="headerlink" title="Function closures"></a>Function closures</h2><p>函数闭包，不同变量可以绑定不同的函数闭包，相互之间不影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(</span><br><span class="line">            pos(i),</span><br><span class="line">            neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Flow-control-statements"><a href="#Flow-control-statements" class="headerlink" title="Flow control statements"></a>Flow control statements</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>，可以没有<code>()</code>，但一定要有<code>{}</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>可以像<code>for</code>那样先带个statement。假如申明了变量，则只能在<code>if</code>或后续的<code>else</code>中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can't use v here, though</span></span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>，可以没有<code>()</code>，但一定要有<code>{}</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(condition)</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code>, 满足其中一个<code>case</code>即执行其中的语句，不会再执行其他case的语句，可看成自带<code>break</code>。此外，<code>case</code>不一定要接整数常量，它可以不是整数，可以不是常量。但要注意<code>case</code>后接的类型和<code>switch</code>比较的类型相同。</p><p><code>switch</code>同样可以像<code>for</code>那样先带个statement，且<code>default</code>的位置可放在首位，因为它总是会在所有条件都不匹配的时候才执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>还可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><code>defer</code> 推迟执行，具有LIFO的性质</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"1 "</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"2 "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"3 "</span>)</span><br><span class="line">    <span class="comment">// 将输出3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defer</code>还可以这样写，参数部分的函数是会先执行的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">entering: b</span></span><br><span class="line"><span class="comment">in b</span></span><br><span class="line"><span class="comment">entering: a</span></span><br><span class="line"><span class="comment">in a</span></span><br><span class="line"><span class="comment">leaving: a</span></span><br><span class="line"><span class="comment">leaving: b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="Methods-and-interfaces"><a href="#Methods-and-interfaces" class="headerlink" title="Methods and interfaces"></a>Methods and interfaces</h1><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go没有<code>class</code>，但可以给方法（函数）指定适用的类型。<code>method</code>是指定类型的<code>function</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>methord</code>指定的类型可以是基本类型，但所指定的类型必须在本<code>package</code>出现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>methord</code>指定的类型可以是指针，则我们可以修改指针指向的内容，并且不用产生拷贝开销。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口，要求使用接口的类型实现了接口中方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line">    <span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">    <span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口中的方法不需要像其他语言那样使用显式的关键字，如<code>implement</code>。</p><p>这样做可以让申明和实现分离，不需要特殊处理就可以让他们放在不同的包中。</p><p>接口可以看成是一个二元组<code>(value, type)</code>，对于一个<code>value</code>，它会调用接收了<code>type</code>的方法。</p><p>假如一个变量是接口类型的，那么它有可能<code>value</code>和<code>type</code>都为<code>nil</code>，这种情况下会RE。而当<code>type</code>不为<code>nil</code>时，它是非空的，但是<code>value</code>可能会空，因此我们需要在实现接口的方法里处理好这种情况。</p><p>空接口，用于存储任何类型的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">42</span></span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="string">"hello"</span></span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言，在断言不成立的时候应该用两个变量存储结果，否则会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// panic</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type switch</code> 可以依次进行多个类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code> 用于输出自定义类型的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years)"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">"Arthur Dent"</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">"Zaphod Beeblebrox"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Error</code> 用于输出错误信息的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">"it didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code> 用于读取数据的接口</p><p><code>func (T) Read(b []byte) (n int, err error)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Images</code> 用于处理图像的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="keyword">int</span>) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><p>Goroutines 轻型线程，它们共享同一地址的内存，需要同步控制</p><p><code>go f(x, y, z)</code> 创建一个新Goroutine运行函数<code>f</code></p><p>Channels 可用于传递数据的一种数据类型，需要用到运算符<code>&lt;-</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffered Channels 可理解为大小的Channel，满了还往里面添加的话会报错</p><p>可使用range来取出channel中的所有数据，注意channel要close</p><p><code>&lt;-ch</code>实际上会返回两个值，第二个值代表是否还有数据，即<code>false</code> 表示channel close了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code>用于多个channel的选择，哪个channel有数据就执行哪一个，假如同时有数据来了，就随机先执行其中一个</p><p><code>select</code>中的<code>default</code>在没有收到任何channel数据的时候执行</p><p><code>sync.Mutex</code>  用于互斥</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    c.v[key]++</span><br><span class="line">    c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the current value of the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Diagnostics-诊断"><a href="#Diagnostics-诊断" class="headerlink" title="Diagnostics | 诊断"></a>Diagnostics | 诊断</h1><h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起手式</span></span><br><span class="line">cpuProfile, _ := os.Create(<span class="string">"cpu_profile"</span>)</span><br><span class="line">pprof.StartCPUProfile(cpuProfile)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><p><code>go tool pprof &lt;file&gt;</code></p><p><code>web</code> 启动可视化界面</p><p><code>top</code> 列出cpu占比最高的函数</p><p><code>list &lt;function&gt;</code> 列出指定函数的数据</p><h1 id="Go-Command"><a href="#Go-Command" class="headerlink" title="Go Command"></a>Go Command</h1><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p>假如想要玩一下<code>go build</code>命令，注意加上<code>-a</code>重新全部编译，否则会因为有缓存而跳过编译过程。</p><p>假如是main，则会编译生成可执行文件。</p><p>否则，只会编译，不产生文件，用于验证代码能否编译。</p><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p>假如是main，则会在$GOPATH/bin下生成可执行文件。</p><p>否则，会在$GOPATH/pkg下生成*.a文件。</p><h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">go get -u &lt;package&gt;</span><br></pre></td></tr></table></figure><h2 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h2><p>删除编译生成的文件等等。</p><h1 id="依赖管理工具"><a href="#依赖管理工具" class="headerlink" title="依赖管理工具"></a>依赖管理工具</h1><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化，-v参数代表输出详细信息</span></span><br><span class="line">dep init -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决依赖的BUG</span></span><br><span class="line">dep ensure -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新依赖，假如总是更新失败，先dep ensure -v一下，并选择在网络空闲的时候更新</span></span><br><span class="line">dep ensure -update -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条依赖</span></span><br><span class="line">dep ensure -add github.com/bitly/go-simplejson</span><br></pre></td></tr></table></figure><h2 id="Go-Mod"><a href="#Go-Mod" class="headerlink" title="Go Mod"></a>Go Mod</h2><p>拉取速度比Dep要快很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，生成go.mod文件</span></span><br><span class="line">go mod init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后即可使用go build或go test拉取依赖</span></span><br><span class="line">go build/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级所有依赖到最新</span></span><br><span class="line">go get -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将依赖放在项目的vendor中</span></span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>假如遇到某个依赖有问题，更把那个依赖删掉，然后再<code>go get -u</code>升级所有依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用packages&quot;&gt;&lt;a href=&quot;#常用packages&quot; class=&quot;headerlink&quot; title=&quot;常用packages&quot;&gt;&lt;/a&gt;常用packages&lt;/h1&gt;&lt;h2 id=&quot;fmt&quot;&gt;&lt;a href=&quot;#fmt&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>理财入门</title>
    <link href="http://yoursite.com/2019/07/13/financial-management/"/>
    <id>http://yoursite.com/2019/07/13/financial-management/</id>
    <published>2019-07-13T13:02:59.000Z</published>
    <updated>2019-07-13T14:01:07.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理财，同时也是提高自我认知的过程。此博文记录了自己的理财学习之路，希望能对读者有些帮助。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>管理好自己的财产的第一步，是要对自己的支出收入情况有所了解。假如一个人对自己的收支情况一点不了解，就算中了百万彩票，挥金如土，也会很快被挥霍完。而假如一个人对于自己的收支情况了然于胸，量入为出，才能过得很踏实。</p><p>在这里，通过一番比较后，我选择了复式记账法，并采用了beancount和fava这两个工具。网上介绍这两个工具的好文章已有不少，这里不再赘述使用方法，而只提一下它的优点。beancount，它是开源的，它可以让你以纯文本的形式记账，并将数据保存在自己的电脑上，保证了数据的可移植性和安全性，无需支付额外费用，使用成本低。另外，利用fava可将数据可视化，可以直观地看到自己的财务情况，非常方便。</p><p>很多人之所以不能坚持记账，大多数是因为记账太过繁琐，且记账产生的数据像一潭死水，无法产生实际的指导价值。而用beancount+fava，可以克服这两个缺点。现在大多数网站，比如支付宝和微信支付，都可以导出账单，我们不难写个脚本将其转化成符合beancount语法的文本数据。fava将数据可视化后，含有损益表、资产负债表、试算表、资产、统计等界面，可以很直观地看到自己的收支情况、资产负债情况等。这些东西需要一些财务知识才能理解，我主要通过搜索引擎+看书来学习，这里推荐一本书，书名叫《给创业小白的财报书》，豆瓣评分9.0，值得一读。</p><p>我认为实现财务自由最关键的是增加收入以及通过投资来增加净资产。增加净资产，可以通过购买债券、基金、股票、房地产等方式。待所购资产实现增值后，我们的净资产也就增加了。现在我对于存款的处理方式是直接购买基金，因为比较方便。但是购买基金是一种低风险低收益的投资活动，虽然可以实现财富增长，但若想尽快实现财务自由这个目标，依靠此方式是行不通的。所以有必要去学习其他投资方式，这里挖个坑，以后学了再补上。</p><p>虽然财务自由听起来很虚幻很遥远，但是我觉得通过一定的努力是能够达到的。当然，每个人对于财务自由的定义会有所不同，我自己的要求比较低，<strong>资产所产生的收益能超过日常开销即算财务自由</strong>。共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理
      
    
    </summary>
    
    
      <category term="理财" scheme="http://yoursite.com/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>git 简明手册 | 学习笔记</title>
    <link href="http://yoursite.com/2019/07/02/git-book/"/>
    <id>http://yoursite.com/2019/07/02/git-book/</id>
    <published>2019-07-01T16:13:57.000Z</published>
    <updated>2019-07-13T14:06:01.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代记录"><a href="#迭代记录" class="headerlink" title="迭代记录"></a>迭代记录</h2><ul><li>190702 首次提交</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li><p>全局配置文件：<code>~/.gitconfig</code></p></li><li><p>项目配置文件：<code>&lt;project&gt;/.git/config</code></p></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文件到仓库</span></span><br><span class="line">git add &lt;FILE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把当前所有位置的所有文件都添加到仓库中</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定add具体哪些内容，使用?查看选项的解释</span></span><br><span class="line">git add -p</span><br></pre></td></tr></table></figure><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支+远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的分支建立追踪关系，一般是对远程分支建立追踪关系</span></span><br><span class="line">git branch --track [newBranch] [remote/branch]</span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">git branch --track mage origin/mage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间 | 已经弃用</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream [branch] [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对当前工作区文件的修改。其中--的作用是表明后面的参数是文件名，而不是分支名。</span></span><br><span class="line">git checkout -- FILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建+切换分支</span></span><br><span class="line">git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在origin/master的基础上，创建一个新分支。</span></span><br><span class="line">git checkout -b &lt;name&gt; origin/master</span><br></pre></td></tr></table></figure><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只克隆仓库的最新一个版本，对于多次提交的仓库可明显提高clone速度</span></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-o指定远程分支名，假如不指定，默认是origin</span></span><br><span class="line">git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把文件提交到仓库</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以选择部分文件commit</span></span><br><span class="line">git commit &lt;file1&gt; &lt;file2&gt;...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 它一般适用于还未提交到远程仓库的提交，也适用于gerrit，不适用于Github</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不更改评论信息</span></span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置提交代码时的用户信息。</span></span><br><span class="line">git config [--global] user.name <span class="string">"Username"</span></span><br><span class="line">git config [--global] user.email <span class="string">"email@example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前的git配置。</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件。</span></span><br><span class="line">git config -e [—global]</span><br></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以将FILE现在的状态和最近一次add到仓库的状态进行一次diff。</span></span><br><span class="line">git diff FILE</span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取回分支，但是并不合并。</span></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定取哪个分支，默认情况下会取所有分支。</span></span><br><span class="line">git fetch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程分支到本地某个分支，假如本地分支不存在，则创建。不会切换到该分支。</span></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">git fetch origin :branch2</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">git fetch origin master:branch2</span><br></pre></td></tr></table></figure><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看commit日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 某些部分可省略。</span></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，取回origin/next分支，再与当前分支合并。</span></span><br><span class="line">git pull origin next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令指定master分支追踪origin/next分支。</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream master origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，本地的当前分支自动与对应的origin主机"追踪分支"进行合并。</span></span><br><span class="line">git pull origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准格式</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地分支推送到远程主机。</span></span><br><span class="line">gut push origin &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支。</span></span><br><span class="line">git push origin --delete &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看引用日志，可以回到“未来”。</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有远程主机。</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以参看远程主机的网址。</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主机的详细信息。</span></span><br><span class="line">git remote show &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于删除远程主机。</span></span><br><span class="line">git remote rm &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于远程主机的改名。</span></span><br><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将仓库连接到远程服务器。一般是在git init后使用，绑定远程主机。</span></span><br><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销对当前缓存区的修改，相当于`git add`的反操作。</span></span><br><span class="line">git reset -- &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对当前缓存区的修改。</span></span><br><span class="line">git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让HEAD指针指到commit_id代表的状态。顺便一提，HEAD^表示上一个状态，HEAD^^表示上上个状态。</span></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程分支</span></span><br><span class="line">git revert</span><br></pre></td></tr></table></figure><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区。即删除远程文件和本地文件。</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区。即删除远程文件，但不删除本地文件。</span></span><br><span class="line">git rm --cached [file]</span><br></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看仓库当前的状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加了tag的commit就会将源码添加到打包，一般用版本号为tag命名</span></span><br><span class="line"><span class="comment"># 在Github上看到的release不是git提供的，而是代码托管网站出于满足开发者发布二进制文件的需求而开发的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代记录&quot;&gt;&lt;a href=&quot;#迭代记录&quot; class=&quot;headerlink&quot; title=&quot;迭代记录&quot;&gt;&lt;/a&gt;迭代记录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;190702 首次提交&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 题解 C++ 链表总结</title>
    <link href="http://yoursite.com/2019/03/04/leetcode-linked-list/"/>
    <id>http://yoursite.com/2019/03/04/leetcode-linked-list/</id>
    <published>2019-03-04T06:11:31.000Z</published>
    <updated>2019-10-08T07:31:25.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>有时候加个冗余头节点会大大降低实现难度，让代码变得更简洁。</li><li>做与链表相关的题目一定要在写代码前就想清楚算法的各个步骤，想好要保存哪些指针。否则很容易写乱。</li><li>要注意delete掉删除掉的节点，避免内存泄露。</li></ol><h1 id="Leetcode-2-Add-Two-Numbers"><a href="#Leetcode-2-Add-Two-Numbers" class="headerlink" title="Leetcode 2 Add Two Numbers"></a>Leetcode 2 Add Two Numbers</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>用链表存储十进制数字的各位，现在给这样的两个链表，求和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于链表头存的是最低位，所以我们可以同时扫描两个链表，模拟一下加法就行了。<br>假如用C++写的话，可以先开一个冗余头指针，方便实现。注意申请或释放内存时，应该要用new和delete而不要用malloc和free，养成良好的编程习惯。<br>假设两个链表的长度分别为n和m，那么时间复杂度和空间复杂度都是$O(n + m)$，显然空间复杂度可以优化到$O(1)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode 19 Remove Nth Node From End of List"></a>Leetcode 19 Remove Nth Node From End of List</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个链表，要求删除倒数第n个节点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这道题的边界情况是删除链表首个节点。<br>我们用两个指针指向表头，然后让其中一个指针先走n步，假如走完n步后指向了空指针，说明删除的是表头。假如走完不是空指针，则让另外一个指针开始和它一步一步走，直到前面的指针指到了最后一个节点时，后面的指针刚好指向待删除节点的前一个节点。<br>这样做的时间复杂度是$O(n)$。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *behind = head, *ahead = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ahead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(temp);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ahead-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">            behind = behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = behind-&gt;next;</span><br><span class="line">        behind-&gt;next = behind-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode 21 Merge Two Sorted Lists"></a>Leetcode 21 Merge Two Sorted Lists</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>合并两个有序链表。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接写就行了，时间复杂度为$O(n+m)$，其中n和m为两个链表的长度。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>合并k个有序链表。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>我们需要一种数据结构来较快地插入一个数，取出最小的数，删除最小的数。不难想到优先队列可以满足这些要求。<br>假设k个链表的节点个数和为n，则时间复杂度为$O(nlogk)$。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(ListNode *p, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">            <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val &gt; rhs.p-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Node&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i]) &#123;</span><br><span class="line">                que.push(Node(lists[i], i));</span><br><span class="line">                lists[i] = lists[i]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">            Node node = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (lists[node.idx] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = node.idx;</span><br><span class="line">                que.push(Node(lists[idx], idx));</span><br><span class="line">                lists[idx] = lists[idx]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = node.p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode 24 Swap Nodes in Pairs"></a>Leetcode 24 Swap Nodes in Pairs</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>两两交换链表的相邻节点。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>递归来写，分三种情况，当前节点是空节点，当前节点没有后继，当前节点有后继。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead = head-&gt;next;</span><br><span class="line">        ListNode *nex = head-&gt;next-&gt;next;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = swapPairs(nex);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-25-Reverse-Nodes-in-k-Group"><a href="#Leetcode-25-Reverse-Nodes-in-k-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in k-Group"></a>Leetcode 25 Reverse Nodes in k-Group</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>是Leetcode 24的升级版，需要将链表的每k个节点翻转。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>用迭代来写，先加个冗余头节点，方便实现。需要记录k节点组的前一个节点p，第一个节点head，最后一个节点tail。然后，我们不断地将p的后一个节点扔到tail的后面即可。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *p = dummy, *tail = dummy, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count != k &amp;&amp; tail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next != tail) &#123;</span><br><span class="line">                temp = p-&gt;next;</span><br><span class="line">                p-&gt;next = temp-&gt;next;</span><br><span class="line">                </span><br><span class="line">                temp-&gt;next = tail-&gt;next;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>回转链表，注意不是反转链表。</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>分三步，首先求出链表长度以及最后一个节点，然后找到回转后的首个节点的前继，最后修改一下它们的指针即可。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *p = head, *lastNode;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            lastNode = p;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k = len - k - <span class="number">1</span>;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode-&gt;next = head;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode 82 Remove Duplicates from Sorted List II"></a>Leetcode 82 Remove Duplicates from Sorted List II</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>删除有序链表中的重复元素。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>申请个冗余节点会比较好实现点。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *p2 = head;</span><br><span class="line">            <span class="keyword">while</span> (p2-&gt;next &amp;&amp; p2-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != p2) &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != p2) &#123;</span><br><span class="line">                    ListNode *temp = head-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span>(head);</span><br><span class="line">                    head = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                head= p2-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(p2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = head;</span><br><span class="line">                p = p-&gt;next; </span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 83 Remove Duplicates from Sorted List"></a>Leetcode 83 Remove Duplicates from Sorted List</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>删除有序链表中的多余的重复元素，即要保证每个元素最多出现一次。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>直接扫一遍就行了，注意delete掉删掉的节点。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">                ListNode *temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode 86 Partition List"></a>Leetcode 86 Partition List</h1><p>留坑待填。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;有时候加个冗余头节点会大大降低实现难度，让代码变得更简洁。&lt;/li&gt;
&lt;li&gt;做与链表相关的题目一定要在写代码前就想清楚算法的各
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 题解 C++ Two Sum | 3Sum | 4Sum</title>
    <link href="http://yoursite.com/2019/03/01/leetcode-sum/"/>
    <id>http://yoursite.com/2019/03/01/leetcode-sum/</id>
    <published>2019-03-01T03:25:58.000Z</published>
    <updated>2019-07-13T14:06:47.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1-Two-Sum"><a href="#Leetcode-1-Two-Sum" class="headerlink" title="Leetcode 1 Two Sum"></a>Leetcode 1 Two Sum</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出两个不同下标的元素，使得它们的值等于某一个值。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>法一：先排序，然后双指针扫一遍。时间复杂度是$O(nlogn)$，空间复杂度是$O(logn)$。</li><li>法二：哈希，空间换时间。时间复杂度$O(n)$，空间复杂度是$O(n)$。</li></ol><p>下面给出法二的代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.find(diff);</span><br><span class="line">            <span class="keyword">if</span> (it != m.end()) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">                ans.push_back(it-&gt;second);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15 3Sum"></a>Leetcode 15 3Sum</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出所有三个不同下标的元素，使得它们的值等于0。另外要求三元组不能重复。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>先排序，然后利用有序性，将原本需要三层循环的遍历用一层循环 + 双指针来做。时间复杂度是$O(n^2)$。<br>用C++写的话，需要注意vector的size()函数返回的是vector::size_type，一般是unsigned int。<br>因此，假如传进来的vector的元素个数少于2，那么num.size() - 2运算后得到的是一个很大的正数，造成运行错误。<br>所以，我们可以先判断一下nums.size()的大小，假如小于3，那么就直接返回了。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (nums[i] != nums[i<span class="number">-1</span>])) &#123;</span><br><span class="line">                <span class="keyword">int</span> need = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="keyword">int</span> lo = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[lo] + nums[hi] == need) &#123;</span><br><span class="line">                        ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;nums[i], nums[lo], nums[hi]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi<span class="number">-1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++, hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; need) &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-18-4Sum"><a href="#Leetcode-18-4Sum" class="headerlink" title="Leetcode 18 4Sum"></a>Leetcode 18 4Sum</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出所有四个不同下标的元素，使得它们的值等于某个值。另外要求四元组不能重复。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先排序，然后利用有序性，将原本需要四层循环的遍历用两层循环 + 双指针来做。时间复杂度是$O(n^3)$。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> lo = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> hi = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[lo] + nums[hi];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[lo], nums[hi]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++, hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-1-Two-Sum&quot;&gt;&lt;a href=&quot;#Leetcode-1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 1 Two Sum&quot;&gt;&lt;/a&gt;Leetcode 1 Two Sum&lt;/h1&gt;&lt;h2 id=&quot;题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 题解 C++ Single Number I II III</title>
    <link href="http://yoursite.com/2019/01/13/leetcode-single-number/"/>
    <id>http://yoursite.com/2019/01/13/leetcode-single-number/</id>
    <published>2019-01-13T07:37:27.000Z</published>
    <updated>2019-07-13T14:07:04.558Z</updated>
    
    <content type="html"><![CDATA[<p>在Leetcode上做了Single Number系列的三道题，都是与位运算有关的，感觉都挺巧妙。</p><h1 id="Leetcode-136-Single-Number-I"><a href="#Leetcode-136-Single-Number-I" class="headerlink" title="Leetcode 136 Single Number I"></a>Leetcode 136 Single Number I</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有一个数字是出现一次的，其他的数字都恰好出现两次，现在求只出现一次的数是多少。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据异或的性质，答案是所有的数字的异或和。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-137-Single-Number-II"><a href="#Leetcode-137-Single-Number-II" class="headerlink" title="Leetcode 137 Single Number II"></a>Leetcode 137 Single Number II</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有一个数字是出现一次的，其他的数字恰好都出现三次，现在求只出现一次的数是多少。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>显然，假如还是用上一题的做法，直接将数字异或起来，是得不到答案的。为什么上一题的答案直接异或起来就可以，因为出现两次的数字异或后等于出现零次，具体对于某一位来说，它会经过<code>0-&gt;1-&gt;0</code>这么个过程。而对于这道题，假如某个数字出现了三次，那么对于具体某一位来说，它会经过<code>0-&gt;1-&gt;0-&gt;1</code>这个过程。因此，我们应用两个位来表示具体某一位的状态变化，即让它经过<code>00-&gt;10-&gt;01-&gt;00</code>这么个过程。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            ones = (ones ^ i) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ i) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-260-Single-Number-III"><a href="#Leetcode-260-Single-Number-III" class="headerlink" title="Leetcode 260 Single Number III"></a>Leetcode 260 Single Number III</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有两个数字是出现一次的，其他的数字恰好都出现两次，现在求只出现一次的数是哪两个。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>我们先将所有数字异或起来，得到<code>c</code>。设答案为<code>a</code>和<code>b</code>，那么<code>c = a ^ b</code>。</p><p>对于这个<code>c</code>的各个位，有的是<code>0</code>，有的是<code>1</code>。值为<code>1</code>的位，意味着只属于<code>a</code>或<code>b</code>。因此，我们可以任意取<code>c</code>中一个值为<code>1</code>的位，将所有数字划分为两个可重集合，这两个集合的数字分别异或起来就是答案。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            sum ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum &amp;= -sum;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &amp; i) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] ^= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[<span class="number">1</span>] ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Leetcode上做了Single Number系列的三道题，都是与位运算有关的，感觉都挺巧妙。&lt;/p&gt;
&lt;h1 id=&quot;Leetcode-136-Single-Number-I&quot;&gt;&lt;a href=&quot;#Leetcode-136-Single-Number-I&quot; class
      
    
    </summary>
    
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>后缀自动机学习笔记</title>
    <link href="http://yoursite.com/2018/10/06/sam-learning/"/>
    <id>http://yoursite.com/2018/10/06/sam-learning/</id>
    <published>2018-10-06T13:43:55.000Z</published>
    <updated>2019-07-13T14:07:40.625Z</updated>
    
    <content type="html"><![CDATA[<p>后缀自动机(SAM)是一种用于处理字符串的高效数据结构，时间复杂度为$O(|S| * CHARSET_SIZE)$。其应用一般与子串有关，比如求解最长公共子串、求解不同子串的个数、求字典序第k小的子串。</p><p><a href="https://vjudge.net/contest/47126" target="_blank" rel="noopener">题目传送门</a></p><h1 id="SPOJ-LCS-Longest-Common-Substring"><a href="#SPOJ-LCS-Longest-Common-Substring" class="headerlink" title="SPOJ LCS Longest Common Substring"></a>SPOJ LCS Longest Common Substring</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求它们的最长公共子串。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于字符串长度上限250000，所以$O(n^2)$的算法是行不通的。<br>我们可以考虑给其中一个字符串建立后缀自动机，该自动机保存了这个字符串的所有子串。接着，我们在这个自动机上跑另一个字符串，假如匹配，就走下一步，假如不匹配，就走失配指针，直到匹配或者回到了根节点。在这个过程中，维护一下匹配的长度，不断取max即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250009</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">1</span>, le = <span class="built_in">strlen</span>(s), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; le; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][to]) &#123;</span><br><span class="line">                ans = max(ans, ++cnt);</span><br><span class="line">                now = ch[now][to];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(now &amp;&amp; !ch[now][to]) now = fail[now];</span><br><span class="line">                <span class="keyword">if</span>(now) &#123;</span><br><span class="line">                    cnt = len[now] + <span class="number">1</span>;</span><br><span class="line">                    now = ch[now][to];</span><br><span class="line">                    ans = max(ans, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = <span class="number">1</span>;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    sam.init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        sam.insert(s[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    sam.solve(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPOJ-LCS2-Longest-Common-Substring-II"><a href="#SPOJ-LCS2-Longest-Common-Substring-II" class="headerlink" title="SPOJ LCS2 Longest Common Substring II"></a>SPOJ LCS2 Longest Common Substring II</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给n($2 &lt;= n &lt;= 10$)个字符串，求它们的最长公共子串。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这一题在上一题的基础上进行了一定的拓展。我们还是给其中一个字符串建立后缀自动机，然后将其余字符串在自动机上跑一遍。在每个节点上，我们需要维护一个$f$，表示所有字符串到达该结点时的最大匹配长度，初始化为第一个字符串的在该点的$len$。当其余字符串进来匹配的时候，用当前最大匹配长度来更新这个$f$，不断取min。这里需要注意的是，某个结点$u$被访问到，但其后缀链指向的结点$v$可能没被访问到，但是，根据SAM后缀树的性质，$v$结点表示的最大子串是会被完全匹配的。所以，我们将字符串在自动机跑完一遍后，还需要根据拓扑序再反向更新一下。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], mat[MAXN], f[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            mat[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> le = <span class="built_in">strlen</span>(s), lenn = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; le; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ne = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][ne])</span><br><span class="line">                now = fail[now], lenn = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][ne]) &#123;</span><br><span class="line">                now = ch[now][ne];</span><br><span class="line">                f[now] = max(f[now], ++lenn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 这一句非常精髓啊</span></span><br><span class="line">            <span class="keyword">if</span>(f[topo[i]])</span><br><span class="line">                f[fail[topo[i]]] = len[fail[topo[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            mat[i] = min(mat[i], f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            ans = max(ans, mat[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    sam.init();</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sam.insert(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.topoSort();</span><br><span class="line">    sam.pre();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s)) &#123;</span><br><span class="line">        sam.update(s);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPOJ-NSUBSTR-Substrings"><a href="#SPOJ-NSUBSTR-Substrings" class="headerlink" title="SPOJ NSUBSTR     Substrings"></a>SPOJ NSUBSTR     Substrings</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>根据子串的长度，可将一个长为$|S|$的字符串的所有子串分到$|S|$个集合中。问在各个集合中，在母串中出现次数最多的子串的出现次数？</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>要统计某一子串出现的次数，需要按照拓扑序逆着更新。当访问到某一节点时，我们把最大长度子串所属集合的答案更新一下，然后传递一下$cntPos$给失配指针所指的结点。我们知道，一个结点表示了多个子串，为什么只更新最大长度子串所属的集合就行了呢？可以这样理解，假设某一节点的最大长度子串为$S[L…R]$，根据SAM的性质，$S[L..(R-1)]$一定不与S[L…R]$在同一结点，且它出现的次数不少于$S[L…R]$，因此，后续访问到该结点时会更新$(R-1)$的答案，而长度更短的同理，也是会被更新到。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 2 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span> len);</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        <span class="built_in">memset</span>(cntPos, <span class="number">0</span>, <span class="keyword">sizeof</span> cntPos);</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">2</span>;</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = last = sz++;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sz++; len[n] = len[v] + <span class="number">1</span>;</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans[MAXN];</span><br><span class="line">        <span class="keyword">int</span> le = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            ans[len[u]] = max(ans[len[u]], cntPos[u]);  <span class="comment">// ?</span></span><br><span class="line">            cntPos[fail[u]] += cntPos[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= le; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s)) &#123;</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.topoSort();</span><br><span class="line">    &#125;</span><br><span class="line">    sam.solve(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPOJ-SUBLEX-Lexicographical-Substring-Search"><a href="#SPOJ-SUBLEX-Lexicographical-Substring-Search" class="headerlink" title="SPOJ SUBLEX Lexicographical Substring Search"></a>SPOJ SUBLEX Lexicographical Substring Search</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，求字典序第k小的子串。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>首先给字符串建立SAM，该SAM保存该字符串的所有子串。<br>接着，从根出发，dfs一遍，对各个结点统计从该结点出发的子串数。<br>然后，我们再从根出发，贪心地走字符较小的边。假如一条边到达的结点的子串数大于等于k，那么这条边就可以走。否则，我们减去该结点的子串数，然后找另一条边。一直做下去，直到k等于0了就停止。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 3 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line">pii G[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line"><span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line"><span class="keyword">int</span> path[MAXN], p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">2</span>;</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = last = sz++;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sz++; len[n] = len[v] + <span class="number">1</span>;</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cntPath</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path[u]) <span class="keyword">return</span> path[u];</span><br><span class="line">        p[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[u][i]) &#123;</span><br><span class="line">                path[u] += cntPath(ch[u][i]);</span><br><span class="line">                G[u][p[u]++] = pii(ch[u][i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path[u]++;</span><br><span class="line">        <span class="keyword">return</span> path[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意用递归写法会超时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[u]; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = G[u][i].x;</span><br><span class="line">                <span class="keyword">if</span>(v &amp;&amp; path[v] &gt;= k) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, G[u][i].y + <span class="string">'a'</span>);</span><br><span class="line">                    k--;</span><br><span class="line">                    u = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    k -= path[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ss[N];</span><br><span class="line"><span class="keyword">int</span> q, lenn, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ss);</span><br><span class="line">    sam.init();</span><br><span class="line">    lenn = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenn; i++)</span><br><span class="line">        sam.insert(ss[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    sam.cntPath(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        sam.findK(<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPOJ-COT4-Count-on-a-trie"><a href="#SPOJ-COT4-Count-on-a-trie" class="headerlink" title="SPOJ COT4 Count on a trie"></a>SPOJ COT4 Count on a trie</h1><p>留坑待填。</p><h1 id="HDU-4416-Good-Article-Good-sentence"><a href="#HDU-4416-Good-Article-Good-sentence" class="headerlink" title="HDU 4416 Good Article Good sentence"></a>HDU 4416 Good Article Good sentence</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，可以有很多子串，记为集合A。然后再给一些字符串，同样可以有很多子串，记为集合B。现在需要求集合A和集合B的差的大小，即在A集合里出现但不在B集合里出现的元素个数。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先给第一个字符串建立SAM，然后依次将其余的字符串取更新这个SAM。<br>SAM中的各个结点需要保存一个值f，表示被其余字符串匹配到最大长度。对于某一结点u，f初始化为len[fail[u]]。<br>这里需要注意的是，同多个字符串的最长公共子串问题一样，在匹配完整个字符串后，还需要根据拓扑序逆着更新f一下。<br>最后，所有节点的len - f的和即为答案。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="keyword">int</span> f[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            f[i] = len[fail[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="built_in">strlen</span>(s), now = <span class="number">1</span>, le = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][v])</span><br><span class="line">                now = fail[now], le = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][v]) &#123;</span><br><span class="line">                now = ch[now][v];</span><br><span class="line">                vis[now] = <span class="literal">true</span>;</span><br><span class="line">                le++;</span><br><span class="line">                f[now] = max(f[now], le);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">                vis[fail[u]] = <span class="literal">true</span>;</span><br><span class="line">                f[fail[u]] = len[fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            ans += len[i] - f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, kase;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++kase);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.pre();</span><br><span class="line">        sam.topoSort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            sam.update(s);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="POJ-3415-Common-Substrings"><a href="#POJ-3415-Common-Substrings" class="headerlink" title="POJ 3415 Common Substrings"></a>POJ 3415 Common Substrings</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求所有长度大于k的公共子串的对数。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>我们知道，SAM中某个节点代表的是长度连续的数个后缀，不妨设长度为$[L, R]$。在匹配的过程中，长度会落在$[L, R]$之间，我们只需要加上$[k, R]$的这段（可能为空）。<br>另外，还需要按照拓扑序逆着更新一下，这里的更新需要是需要计数的。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cfloat&gt;//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; //ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">59</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="keyword">int</span> sum[MAXN], vis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        topoSort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            cntPos[fail[u]] += cntPos[u];</span><br><span class="line">            vis[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>, le = <span class="number">0</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, up = <span class="built_in">strlen</span>(s); i &lt; up; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][v])</span><br><span class="line">                now = fail[now], le = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][v]) &#123;</span><br><span class="line">                now = ch[now][v];</span><br><span class="line">                le++;</span><br><span class="line">                vis[now]++;</span><br><span class="line">                <span class="keyword">if</span>(le &gt;= k) &#123;</span><br><span class="line">                    ans += <span class="number">1L</span>L * cntPos[now] * (le - max(len[fail[now]] + <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">                sum[fail[u]] += vis[u];</span><br><span class="line">                vis[fail[u]] += vis[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] &gt;= k) &#123;</span><br><span class="line">                ans += <span class="number">1L</span>L * sum[i] * cntPos[i] * (len[i] - max(len[fail[i]] + <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s, t);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s); i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.solve(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HDU-3518-Boring-counting"><a href="#HDU-3518-Boring-counting" class="headerlink" title="HDU 3518 Boring counting"></a>HDU 3518 Boring counting</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>首先给字符串建立SAM，对于各个结点，需要额外维护最长子串首先出现的位置以及最后出现的位置。最后出现的位置需要按照拓扑序逆着来更新。<br>然后扫一遍，根据某个结点代表的最短字符串、最长字符串与最长子串首先出现、最后出现位置，分情况讨论一下即可。<br>一开始没有注意到出现次数大于等于2这个条件，多想了一下。假如要求出现次数大于等于k的话，那么我们可能需要维护的是各个节点的最长子串出现的具体位置，这可能需要就需要用到LCT来维护了。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 6 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], l[MAXN], r[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(l, <span class="number">-1</span>, <span class="keyword">sizeof</span> l);</span><br><span class="line">        <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="keyword">sizeof</span> r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> po)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        l[u] = r[u] = po;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            l[n] = r[n] = l[o];</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        topoSort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            r[fail[u]] = max(r[fail[u]], r[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] &lt;= r[i] - l[i]) &#123;</span><br><span class="line">                ans += len[i] - len[fail[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += max(<span class="number">0</span>, r[i] - l[i] - len[fail[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s) &amp;&amp; s[<span class="number">0</span>] != <span class="string">'#'</span>) &#123;</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, up = <span class="built_in">strlen</span>(s); i &lt; up; i++) &#123;</span><br><span class="line">            sam.insert(s[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HDU-4622-Reincarnation"><a href="#HDU-4622-Reincarnation" class="headerlink" title="HDU 4622 Reincarnation"></a>HDU 4622 Reincarnation</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，然后有$Q$次询问，求该字符串$[L, R]$本质不同的字符串个数。</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>首先建立SAM，然后对于每次询问，分别处理，维护的是最大匹配长度。<br>然后，扫一遍各个节点，累加最大匹配长度 - 最小字符串 + 1 即可。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2009</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 7 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>, le = <span class="number">0</span>, f[MAXN];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            now = ch[now][v];</span><br><span class="line">            le++;</span><br><span class="line">            f[now] = max(f[now], le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(f[u]) &#123;</span><br><span class="line">                f[fail[u]] = len[fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            ans += max(<span class="number">0</span>, f[i] - len[fail[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, l, r;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s); i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.topoSort();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            sam.solve(s, l - <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HDU-4436-str2int"><a href="#HDU-4436-str2int" class="headerlink" title="HDU 4436 str2int"></a>HDU 4436 str2int</h1><p>留坑待填。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;后缀自动机(SAM)是一种用于处理字符串的高效数据结构，时间复杂度为$O(|S| * CHARSET_SIZE)$。其应用一般与子串有关，比如求解最长公共子串、求解不同子串的个数、求字典序第k小的子串。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://vjudge.net/
      
    
    </summary>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="SAM" scheme="http://yoursite.com/tags/SAM/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>四则运算项目折腾笔记</title>
    <link href="http://yoursite.com/2018/09/30/arithmetic-problems-generator/"/>
    <id>http://yoursite.com/2018/09/30/arithmetic-problems-generator/</id>
    <published>2018-09-30T02:00:00.000Z</published>
    <updated>2019-07-13T14:08:33.055Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/hyzgh/arithmetic-problems-generator" target="_blank" rel="noopener">Github项目地址传送门</a></p><h1 id="项目相关要求"><a href="#项目相关要求" class="headerlink" title="项目相关要求"></a>项目相关要求</h1><blockquote><ol><li>(完成)使用 -n 参数控制生成题目的个数。</li><li>(完成)使用 -r 参数控制题目中数值（自然数、真分数和真分数分母）的范围。该参数可以设置为1或其他自然数。该参数必须给定，否则程序报错并给出帮助信息。</li><li>(完成)生成的题目中计算过程不能产生负数，也就是说算术表达式中如果存在形如e1 − e2的子表达式，那么e1 ≥ e2。</li><li>(完成)生成的题目中如果存在形如e1 ÷ e2的子表达式，那么其结果应是真分数。</li><li>(完成)每道题目中出现的运算符个数不超过3个。</li><li>(完成)程序一次运行生成的题目不能重复，即任何两道题目不能通过有限次交换+和×左右的算术表达式变换为同一道题目。例如，23 + 45 = 和45 + 23 = 是重复的题目，6 × 8 = 和8 × 6 = 也是重复的题目。3+(2+1)和1+2+3这两个题目是重复的，由于+是左结合的，1+2+3等价于(1+2)+3，也就是3+(1+2)，也就是3+(2+1)。但是1+2+3和3+2+1是不重复的两道题，因为1+2+3等价于(1+2)+3，而3+2+1等价于(3+2)+1，它们之间不能通过有限次交换变成同一个题目。生成的题目存入执行程序的当前目录下的Exercises.txt文件。</li><li>(完成)在生成题目的同时，计算出所有题目的答案，并存入执行程序的当前目录下的Answers.txt文件。</li><li>(完成)程序应能支持一万道题目的生成。</li><li>(完成)程序支持对给定的题目文件和答案文件，判定答案中的对错并进行数量统计， 统计结果输出到文件Grade.txt。</li></ol></blockquote><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><p>本次项目的代码遵循了谷歌代码规范(C++)，但由于谷歌代码规范篇幅太多，所以我们目前只遵循了其中的部分规范，具体如下：</p><ol><li>禁止使用宏</li><li>分号以前不加空格</li><li>行宽原则上不超过80</li><li>一行只定义一个变量</li><li>左大括号前保留一个空格</li><li>if, else前后都要一个空格</li><li>for, while后要有一个空格</li><li>return 后面的数值不加 ( )</li><li>每个文件应该含有版权信息及作者</li><li>左圆括号之后和右圆括号之前无空格</li><li>函数参数过多时，每行的参数变量对齐</li><li>一目运算符与变量之间不加空格符隔开</li><li>禁止使用 using 指示（using-directive） </li><li>禁止使用C++的流，而是用printf之类的替代</li><li>要么函数名与参数同行，要么所有参数并排分行</li><li>换行代码缩进2个空格，并且使用两个空格符取代制表符</li><li>二目以上的运算符与变量，常量之间用空格隔开（各类括号除外）</li><li>不论控制语句，循环语句后面的循环体有多少行，都必须使用花括号</li><li>普通函数，类型（含类与结构体，枚举类型），常量等使用大小写混合，不含下划线</li><li>除函数定义的左大括号可置于行首以外，包括函数/类/结构体/枚举声明，各种语句的左大括号必须置于行末，所有右大括号独立成行</li></ol><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145059141-655290070.png" alt></p><h1 id="具体设计-amp-关键代码"><a href="#具体设计-amp-关键代码" class="headerlink" title="具体设计&amp;关键代码"></a>具体设计&amp;关键代码</h1><h2 id="ImproperFraction类"><a href="#ImproperFraction类" class="headerlink" title="ImproperFraction类"></a>ImproperFraction类</h2><p>构建一个ImproperFraction的类，然后重载这个类的四种运算 <strong>+-x÷</strong> 以及以及六种逻辑关系<strong>‘&lt;’  ‘==’  ‘&lt;=’  ‘!=’  ‘&gt;’  ‘&gt;=’</strong>判断，在后续的代码编写之中都是基于这个类进行运算</p><p>核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImproperFraction</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span> :</span><br><span class="line">  ImproperFraction()&#123;&#125;</span><br><span class="line">  ImproperFraction (<span class="keyword">int</span> Mole, <span class="keyword">int</span> Deno, <span class="keyword">int</span> Coef = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="built_in">std</span>::__gcd (Mole, Deno);</span><br><span class="line">    g = <span class="built_in">std</span>::max(g, <span class="number">1</span>);</span><br><span class="line">    mole = (Mole + Coef * Deno) / g;</span><br><span class="line">    deno = Deno / g;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> + (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.deno + rhs.mole * deno;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> - (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.deno - rhs.mole * deno;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> * (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.mole;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> / (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.mole;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.deno;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mole * rhs.deno &lt; rhs.mole * deno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mole * rhs.deno == rhs.mole * deno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(mole * rhs.deno == rhs.mole * deno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>) &lt; rhs || (*<span class="keyword">this</span>) == rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !((*<span class="keyword">this</span>) &lt;= rhs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>) &gt; rhs || (*<span class="keyword">this</span>) == rhs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> :</span><br><span class="line">  <span class="keyword">int</span> mole = <span class="number">0</span>; <span class="comment">// 分子</span></span><br><span class="line">  <span class="keyword">int</span> deno = <span class="number">1</span>; <span class="comment">// 分母 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题集的生成"><a href="#题集的生成" class="headerlink" title="题集的生成"></a>题集的生成</h2><h3 id="表达式的生成"><a href="#表达式的生成" class="headerlink" title="表达式的生成"></a>表达式的生成</h3><p>在这里选择的是rand() 随机生成 运算符个数，类型以及每个被运算的数值。</p><h3 id="表达式的合法性判断"><a href="#表达式的合法性判断" class="headerlink" title="表达式的合法性判断"></a><strong>表达式的合法性判断</strong></h3><p> 在生成过程之中，有两个要点会导致表达式非法<br>1.运算过程中出现负值<br>2.在÷运算后面出现0</p><p><strong>解决办法：</strong>两个特殊判断即可</p><h3 id="表达式的去重"><a href="#表达式的去重" class="headerlink" title="表达式的去重"></a><strong>表达式的去重</strong></h3><p>表达式的重复有两种情况:<br>1.完完全全的重复，如出现两个1 + 2 + 3 的表达式<br>2.运算顺序上的重复，如:</p><blockquote><p>1 + 2 + 3 和 2 + 1 + 3重复<br>2 + 3 x 4 和 4 x 3 + 2重复</p></blockquote><p><strong>解决办法：</strong><br>对于(1)的情况只需要将生成的表达式保存进C++STL的set之中即可自动去重。<br>对于(2)的情况，则是按照一定规则生成表达式来避免这一情况，规则如下：</p><blockquote><p>1.默认左边的运算符的优先度高于右边<br>2.第一个数字一定不小于第二个数值<br>因此1 + 2 + 3和2 + 3 x 4不会被生成，而只会生成2 + 1 + 3和4 x 3 + 2</p></blockquote><h3 id="题集无法生成要求的数量"><a href="#题集无法生成要求的数量" class="headerlink" title="题集无法生成要求的数量"></a><strong>题集无法生成要求的数量</strong></h3><p> 例如：<br>传入的参数是 -n 10000 -r 1 的时候，很明显无法生成10000道题目，因此陷入死循环的生成中</p><p><strong>解决办法：</strong><br>设置一个时间戳time，当生成表达式的部分循环了1000000次之后自动跳出循环，终止生成表达式 </p><h3 id="答案的生成"><a href="#答案的生成" class="headerlink" title="答案的生成"></a><strong>答案的生成</strong></h3><p> 在表的是合法性判断的时候，会判断最终的数值是否小于0，在这里就已经计算标准答案，保存并打印到answer.txt即可</p><p>核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">questionSetGenerate</span> <span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;expressions;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;exercise;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImproperFraction&gt;answer;</span><br><span class="line">  ImproperFraction zero = ImproperFraction(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (expressions.size() &lt; number &amp;&amp; time &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">    time ++;</span><br><span class="line">    <span class="keyword">int</span> sz = expressions.size();</span><br><span class="line">    <span class="comment">// 运算符的个数</span></span><br><span class="line">    <span class="keyword">int</span> opnumber = rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    ImproperFraction a[<span class="number">5</span>];</span><br><span class="line">    ImproperFraction res = ImproperFraction(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> ImproperFraction zero = ImproperFraction(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 随机生成数值和运算符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= opnumber; i++) &#123;</span><br><span class="line">      a[i] = ImproperFraction(rand() % (limit * limit), <span class="built_in">std</span>::max(<span class="number">1</span>, rand() % limit));</span><br><span class="line">      <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        op[i] = oper[rand() % <span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">exp</span> = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::swap (a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算答案,并检查中途出现非法情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= opnumber; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">          res = res + a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">          res = res * a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">          res = res - a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (a[i] == zero) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          res = res / a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span> + op[i];</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="string">' '</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = res + a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将分数转化为字符串</span></span><br><span class="line">      fractionToString(a[i], <span class="built_in">exp</span>);</span><br><span class="line">      <span class="keyword">if</span> (res.getdeno() &lt; <span class="number">0</span> || res.getmole() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      expressions.insert(<span class="built_in">exp</span>);</span><br><span class="line">      <span class="keyword">if</span> (expressions.size() &gt; sz) &#123;</span><br><span class="line">        <span class="comment">//保存题集和答案</span></span><br><span class="line">        exercise.push_back(addbrackets(<span class="built_in">exp</span>));</span><br><span class="line">        answer.push_back(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="答案正确性的检测"><a href="#答案正确性的检测" class="headerlink" title="答案正确性的检测"></a>答案正确性的检测</h2><p>用户通过参数-e exercises.txt -a answers.txt，传进来了题目文件的名称和答案文件的名称。<br>首先，由于文件可能不存在或者没有访问的权限，我们需要对此进行检查，假如有错误，则进行报错，没有异常才进行下一步。<br>第二步，我们需要对exercises.txt文件中的题目计算一遍，然后再和answers.txt文件中的答案进行比较。题目的计算分两步进行，即先将中缀表达式转化为后缀表达式，然后计算后缀表达式的答案。<br>对于这个函数，我们考虑了exercises.txt行数和answers.txt行数不相等的情况，此时我们将以exercises.txt的行数为准，假如answers.txt行数过少，那么将视为错误答案，假如过多，那么将被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkAnswer</span><span class="params">(FILE *exerciseFile, FILE *answerFile)</span> </span>&#123;</span><br><span class="line">  FILE *pFile = getPointerToGradeFile();</span><br><span class="line">  <span class="keyword">int</span> problemID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> answer[<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">char</span> exercise[<span class="number">256</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; wrongID;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; correctID;</span><br><span class="line">  <span class="comment">// 答案的行数可能不等于题目的行数</span></span><br><span class="line">  <span class="keyword">while</span> (fgets(answer, <span class="number">256</span>, answerFile)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fgets(exercise, <span class="number">256</span>, exerciseFile)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    problemID++;</span><br><span class="line">    removeRedundantPart(answer, exercise);</span><br><span class="line">    handleDivideEncoding(exercise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getInfixExpressionAnswer(exercise) == stringToImproperFraction(answer)</span><br><span class="line">       ) &#123;</span><br><span class="line">      correctID.push_back(problemID);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wrongID.push_back(problemID);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fgets(exercise, <span class="number">256</span>, exerciseFile)) &#123;</span><br><span class="line">    problemID++;</span><br><span class="line">    wrongID.push_back(problemID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printID(pFile, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"Correct"</span>), correctID);</span><br><span class="line">  printID(pFile, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"Wrong"</span>), wrongID);</span><br><span class="line">  fclose(pFile);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Check answer done!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; transformInfixExprToSuffixExpr(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;InfixExpression) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; temp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; InfixExpression.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> cc = InfixExpression[i];</span><br><span class="line">    <span class="keyword">if</span> (cc == <span class="string">' '</span>) &#123;  <span class="comment">// 假如遇到空格就跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">'('</span>) &#123;  <span class="comment">// 遇到左括号就直接入栈</span></span><br><span class="line">      temp.push(cc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">')'</span>) &#123;  <span class="comment">// 遇到右括号就弹出栈里面的所有运算符，直到遇到左括号</span></span><br><span class="line">      <span class="keyword">char</span> c;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        c = temp.top();</span><br><span class="line">        temp.pop();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span>) &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (c != <span class="string">'('</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">'+'</span> || cc == <span class="string">'-'</span>) &#123;</span><br><span class="line">      <span class="comment">// 遇到加号减号也弹出栈顶的所有运算符，直到遇到左括号或者为栈为空</span></span><br><span class="line">      <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = temp.top();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span>) &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">          temp.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.push(cc);  <span class="comment">// 然后将加号入栈</span></span><br><span class="line">    &#125; else if (cc == 'x' || cc == '\xc3') &#123;</span><br><span class="line">      <span class="comment">// 假如遇到所有乘号除号，就弹出栈顶的乘号除号，知道遇到加号减号或者左括号或者栈为空</span></span><br><span class="line">      i += cc == '\xc3';</span><br><span class="line">      <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = temp.top();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'x'</span>) &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">          temp.pop();</span><br><span class="line">        &#125; else if (c == '\xc3') &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">          temp.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.push(cc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 假如遇到数字，那就直接输出</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; InfixExpression.length()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = InfixExpression[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">'/'</span> || c == <span class="string">'\''</span>) &#123;</span><br><span class="line">          s += c;</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把栈里面剩余的东西输出</span></span><br><span class="line">  <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = temp.top();</span><br><span class="line">    temp.pop();</span><br><span class="line">    result.push(charToString(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算后缀表达式的答案</span></span><br><span class="line"><span class="function">ImproperFraction <span class="title">getSuffixExpressionAnswer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; suffixExpression)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ImproperFraction&gt; sta;</span><br><span class="line">  <span class="keyword">while</span> (!suffixExpression.empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = suffixExpression.front();</span><br><span class="line">    suffixExpression.pop();</span><br><span class="line">    <span class="keyword">if</span> (isOperator(s)) &#123;</span><br><span class="line">      <span class="comment">// 假如遇到运算符，就取出栈顶元素进行计算</span></span><br><span class="line">      ImproperFraction a = sta.top();</span><br><span class="line">      sta.pop();</span><br><span class="line">      ImproperFraction b = sta.top();</span><br><span class="line">      sta.pop();</span><br><span class="line">      <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'x'</span>) &#123;</span><br><span class="line">        sta.push(a * b);</span><br><span class="line">      &#125; else if (s[0] == '\xc3') &#123;</span><br><span class="line">        sta.push(b / a);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        sta.push(a + b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sta.push(b - a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 假如遇到数字，就直接进栈</span></span><br><span class="line">      sta.push(stringToImproperFraction(s));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sta.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><h2 id="首先是各种参数错误的测试"><a href="#首先是各种参数错误的测试" class="headerlink" title="首先是各种参数错误的测试"></a><strong>首先是各种参数错误的测试</strong></h2><p><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145152174-840362064.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145220286-2085095778.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145231725-1173918739.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145237511-1881695301.png" alt></p><h2 id="接着是传入正确的参数的测试"><a href="#接着是传入正确的参数的测试" class="headerlink" title="接着是传入正确的参数的测试"></a><strong>接着是传入正确的参数的测试</strong></h2><p>生成题集的测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145300636-1176994323.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145309201-925214622.png" alt></p><p>给定的题目文件和答案文件，判定答案中的对错测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145337222-2053419510.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145345693-634194743.png" alt></p><h1 id="效能分析"><a href="#效能分析" class="headerlink" title="效能分析"></a>效能分析</h1><p>本程序主要由生成运算题目和检查答案正确性两个模块，因此效能分析也主要针对这两个模块进行。<br><strong>1. 生成运算题目</strong><br>生成一百万条题目时候的时间占比情况：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145401885-266275327.png" alt></p><p>由上图看出了，占用时间最多的前五个函数为</p><ol><li>questionSetGenerate</li><li>gcd</li><li>addbrackets</li><li>digToString</li><li>ImproperFraction</li></ol><p>其中，questionSetGenerate是生成运算题目的函数入口，占用时间最长。gcd是在题目运算过程，分数通分时进行调用的，具体实现是辗转相除法。addbrackets是在生成题目的过程给表达式添加括号。digTostring是在生成题目的过程将数字转化为字符串。ImproperFraction是真分数的类名，由于生成的表达式中普遍含有真分数，所以多次调用了它的构造函数。</p><p><strong>2. 检查答案正确性</strong><br>检查五十万条题目时的时间占比情况：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145411370-99124462.png" alt></p><p>由上图可以看出，占用时间最多的前五个函数为：</p><ol><li>gcd</li><li>stringToImproperFraction</li><li>__deque_buf_size</li><li>transformInfixExprToSuffixExpr</li><li>_Deque_base</li></ol><p>其中，gcd用于运算过程的通分，stringToImproperFraction用于将字符串转化为真分数， transformInfixExprToSuffixExpr用于将中缀表达式转化为后缀表达式。另外两个函数是系统函数。</p><p>因此，假如要优化效能的话，可以优先在源代码追踪一下上述函数，看能否减少这些函数的调用或者优化其实现方式。</p><h1 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h1><table><thead><tr><th>PSP2.1</th><th>Personal Software Process Stages</th><th>预估耗时（分钟）</th><th>实际耗时（分钟）</th></tr></thead><tbody><tr><td>Planning</td><td>计划</td><td>60</td><td>50</td></tr><tr><td>· Estimate</td><td>· 估计这个任务需要多少时间</td><td>60</td><td>50</td></tr><tr><td>Development</td><td>开发</td><td>965</td><td>1545</td></tr><tr><td>· Analysis</td><td>· 需求分析 (包括学习新技术)</td><td>50</td><td>100</td></tr><tr><td>· Design Spec</td><td>· 生成设计文档</td><td>25</td><td>35</td></tr><tr><td>· Design Review</td><td>· 设计复审 (和同事审核设计文档)</td><td>25</td><td>35</td></tr><tr><td>· Coding Standard</td><td>· 代码规范 (为目前的开发制定合适的规范)</td><td>25</td><td>65</td></tr><tr><td>· Design</td><td>· 具体设计</td><td>60</td><td>80</td></tr><tr><td>· Coding</td><td>· 具体编码</td><td>360</td><td>415</td></tr><tr><td>· Code Review</td><td>· 代码复审</td><td>60</td><td>150</td></tr><tr><td>· Test</td><td>· 测试（自我测试，修改代码，提交修改）</td><td>360</td><td>665</td></tr><tr><td>Reporting</td><td>报告</td><td>110</td><td>130</td></tr><tr><td>· Test Report</td><td>· 测试报告</td><td>60</td><td>80</td></tr><tr><td>· Size Measurement</td><td>· 计算工作量</td><td>25</td><td>25</td></tr><tr><td>· Postmortem &amp; Process Improvement Plan</td><td>· 事后总结, 并提出过程改进计划</td><td>25</td><td>25</td></tr><tr><td>合计</td><td></td><td>1135</td><td>1725</td></tr></tbody></table><h1 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h1><p><strong>有待改进的地方</strong></p><p>   溢出问题：当给定r过大的时候，将会导致最终运算结构的分母溢出，而造成的数据错误<br>   目前方案：检查溢出，将发生了溢出的表达式删除<br>   更佳方案：使用大数的运算，就可以完美避免数据溢出的问题</p><p> 生成题目不够友好：当给定数据范围r稍稍有点大的时候，最终答案的分母可能超过一亿<br> 目前方案：不处理<br> 更佳方案: 暂无</p><p> 死循环生成题目: 当给定题数过大且给定限制太小时,无法生成要求的题目数量, 导致进入死循环<br> 目前方案: 设置时间戳time,只生成1000000次表达式,再进行合法性判断,但也导致有可能无法生成要求题目数量<br> 更佳方案: 暂无</p><h2 id="开发项目中发生的问题"><a href="#开发项目中发生的问题" class="headerlink" title="开发项目中发生的问题"></a><strong>开发项目中发生的问题</strong></h2><ol><li>一开始的时候是选择暴力深搜生成题集,再随机选取表达式输出,但是生成的效果来看,题目并不是很随机,例如前两个数字是固定死的,思前想后,觉得还是使用rand()随机生成效果更佳</li><li>在最开始设计方案的时候,还是思虑的不够多,以至于后面的代码复审(Debug)工作做了很多,远超过代码编写部分</li><li>还有各种人性化的设置,如参数错误提示,程序运行结果显示之类话语并没有想到,但是一个软件,一个项目最终都是面向于人群大众,人性化的设置是必须的</li></ol><h2 id="团队之中的闪光点"><a href="#团队之中的闪光点" class="headerlink" title="团队之中的闪光点"></a><strong>团队之中的闪光点</strong></h2><ol><li>良好的代码风格: 在一开始我们就约束好了团队的代码风格,在后续的代码编写之中我们也能够很好的参照代码风格进行书写,因此在代码复审的时候我们也能够很好的查阅对方的代码</li><li>不错的代码能力: 想定思路学习知识之后,可直接进行代码的实现,基本上不会出现一些逻辑错误.后面出现的bug也是因为设计的时候稍稍不够考虑细节,一旦出现bug,都能够立马找到bug和想到相应的修复方案</li><li>互帮互助: 在一开始我们就进行了分工,一个人主要负责对给定的题目文件和答案文件进行答案校对、参数组合正确性的检测，另一个人负责了题集的生成部分。并且在最后，一起测试并撰写了博客。<br>通过这次项目，我们实践了结对编程，提高了沟通能力，加强了团队合作的能力。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/hyzgh/arithmetic-problems-generator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github项目地址传送门&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;项目相关要求&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>wc项目折腾笔记</title>
    <link href="http://yoursite.com/2018/09/07/word-count/"/>
    <id>http://yoursite.com/2018/09/07/word-count/</id>
    <published>2018-09-07T07:09:53.000Z</published>
    <updated>2019-07-13T14:08:13.639Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/hyzgh/wordCount" target="_blank" rel="noopener">Github项目地址传送门</a></p><h1 id="项目相关要求"><a href="#项目相关要求" class="headerlink" title="项目相关要求"></a>项目相关要求</h1><ul><li><p>基本功能</p><ul><li>统计C语言源文件的字符数（完成）</li><li>统计C语言源文件的词的数目（完成）</li><li>统计C语言源文件的行数（完成）</li></ul></li><li><p>拓展功能</p><ul><li>递归处理目录下符合条件的文件（完成）</li><li>返回更复杂的数据（代码行 / 空行 / 注释行）（完成）</li><li>支持各种文件的通配符（*,?）（完成）</li></ul></li><li><p>高级功能</p><ul><li>实现图形界面（待完成）</li></ul></li></ul><p>首先，我们需要明确一下“字符”，“词”，“行”，“代码行”，“空行”，“注释行”的定义。<br>字符：一个ASCII字符，包括控制字符和可打印字符。<br>词：一个由空白字符（不仅指空格，还指’\f’,’\v’,’\n’,’\r’这些控制字符）分隔的非空字符串。<br>行：一个由换行符分隔的字符串，可以为空。一行结束的标志是换行符。</p><blockquote></blockquote><p>代码行：本行包括多于一个字符的代码。<br>空行：本行全部是空格或格式控制字符，如果包括代码，则只有不超过一个可显示的字符，例如“{”。<br>注释行：本行不是代码行，并且本行包括注释。</p><p>以上代码行、空行、注释行的说明摘自项目说明。</p><p>为了消除歧义，特提出以下补充说明：<br>1.项目说明指出了下面第一行是注释行，类似的，第二行和第三行也是项目行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="comment">//注释</span></span><br><span class="line">&#123; <span class="comment">//注释</span></span><br><span class="line">; <span class="comment">//注释</span></span><br></pre></td></tr></table></figure><p>2.按照定义，下面这一行是代码行，但不是注释行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, world"</span>); <span class="comment">//say "Hello, world"</span></span><br></pre></td></tr></table></figure><p>3.按照定义，第一行是代码行，但不是注释行。第二行和第三行是注释行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, world"</span>); <span class="comment">/*say "Hello, world"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                         */</span></span><br></pre></td></tr></table></figure><p>4.第二行不是空白行。第一行到第三行都是注释行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The next line is a comment line.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于字符数的统计，每读取一个字符，让<code>chracters</code>加一即可。<br>对于词数的统计，需要一个标记，用于记录前面一个字符是不是空白字符，假如前面一个字符是空白字符且当前字符是可显示字符，那么让<code>words</code>加一。<br>对于行数的统计，每读取到一个换行符，让<code>lines</code>加一即可。<br>对于空白行、代码行、注释行的统计，需要用到一个块注释标记和一些正则表达式，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> blankLineRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)"</span>;</span><br><span class="line"><span class="built_in">string</span> lineCommentRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)"</span>;</span><br><span class="line"><span class="built_in">string</span> blockCommentStartFlagRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line"><span class="built_in">string</span> blockCommentStartFlag1Regex = <span class="string">"(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line"><span class="built_in">string</span> blockCommentCloseFlagRegex = <span class="string">"(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"</span>;</span><br></pre></td></tr></table></figure><ol><li>每读取一行，首先需要判断当前行是不是位于块注释中，假如是，让注释行加一，否则进行2</li><li>使用blankLineRegex这个正则表达式判断当前行是不是空白行，假如是，让空白行加一，否则进行3</li><li>使用lineCommentRegex判断当前行是不是行注释，假如是，让注释行加一，否则进行4</li><li>使用blockCommentStartFlagRegex判断当前行是不是含有块注释开始的标志且为注释行，假如是，把blockCommentFlag改为true，并将注释行加一，否则进行5</li><li>使用blockCommentStartFlag1Regex判断当前行是不是含有块注释开始的标志且为代码行，假如是，把blockCommentFlag改为true，并将代码行加一，否则进行6</li><li>假如以上情况都不是，那么说明该行是代码行，让代码行加一，并结束该行的判断</li></ol><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>File类：</p><ul><li>变量：<code>characters, words, lines, blankLines, codeLines, commentLines</code>.</li><li>方法：<ul><li><code>countBasic</code>：统计字符数、词数、行数。</li><li><code>countSpecialLines</code>：统计空白行、代码行、注释行。</li><li><code>print</code>：输出统计结果。</li></ul></li></ul><p><code>setMode</code>函数：根据输入参数设置模式。<br><code>readFile</code>函数：处理一个文件。<br><code>recursiveReadFiles</code>函数：处理一个目录。</p><p>主要流程就是读取命令行参数，然后调用<code>setMode</code>设置参数，接着根据对象是文件还是目录，分别调用<code>readFile</code>或<code>recursiveReadFiles</code>。<code>readFile</code>接着又会调用<code>countBasic</code>和<code>countSpecialLines</code>，执行程序的核心部分，进行统计。接着调用print输出结果。</p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p>1.统计字符、词、行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countBasic</span><span class="params">(FILE *pFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">bool</span> spaceFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(pFile)) != EOF) &#123;</span><br><span class="line">        characters++;</span><br><span class="line"></span><br><span class="line">        words += (spaceFlag == <span class="literal">true</span> &amp;&amp; <span class="built_in">isgraph</span>(c));</span><br><span class="line">        spaceFlag = <span class="built_in">isspace</span>(c);</span><br><span class="line"></span><br><span class="line">        lines += c == <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.统计空白行、代码行、注释行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 要确定一行是不是空白行，只要通过判断该行的可打印字符个数是否不超过1个即可。另外还要注意，该行不能在块注释中。</span></span><br><span class="line"><span class="comment"> * 要确定一行是不是代码行，只要判断该行的可打印字符个数是否超过1个即可。另外还要注意，改行不在块注释中。</span></span><br><span class="line"><span class="comment"> * 假如一行是注释行，那么该行首先必须不是代码行，其次，需要有注释标志。</span></span><br><span class="line"><span class="comment"> * 根据以上信息，可写出正则表达式进行匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSpecialLines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> blankLineRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> lineCommentRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> blockCommentStartFlagRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> blockCommentStartFlag1Regex = <span class="string">"(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> blockCommentCloseFlagRegex = <span class="string">"(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(file, line)) &#123; <span class="keyword">if</span>(blockCommentFlag) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">            <span class="keyword">if</span>(regex_match(line, regex(blockCommentCloseFlagRegex))) &#123;</span><br><span class="line">                blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(blankLineRegex))) &#123;</span><br><span class="line">            blankLines++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(lineCommentRegex))) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(blockCommentStartFlagRegex))) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">            blockCommentFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(blockCommentStartFlag1Regex))) &#123;</span><br><span class="line">            codeLines++;</span><br><span class="line">            blockCommentFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            codeLines++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.根据参数输出统计结果，注意输出顺序是有规律的，依次为字符数 词数 行数 空白行数 代码行数 注释行数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'c'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d"</span>, characters);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'w'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d"</span>, words);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'l'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d"</span>, lines);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'a'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d%6d%6d"</span>, blankLines, codeLines, commentLines);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>首先我制作了几个经典的测试样例以及对应的参考统计结果，另外，为了节省测试时间，我还写了一个脚本来进行自动化测试。<br>假如所有的测试样例都通过了，则会提示ok，如下：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205421076-284872409.png" alt="ok"><br>假如有些样例没有通过，则会提示wrong，并指出错在哪里，如下：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205428881-788451626.png" alt="wrong"><br>我构造的测试样例及测试结果如下：</p><ol><li>空文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205439689-254256383.png" alt="空文件"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205923166-1878202581.png" alt></li></ol><p><strong>这里输出的依次是字符数、词数、行数、空行数、代码行数、注释行数。下面的也一样。</strong><br>之所以这么输出，是模仿了Linux系统下自带的wc命令。一开始我也不太理解wc命令输出的东西哪个是字符数、哪个是单词数，所以阅读了一下文档，找到了输出的规则，理解了输出的含义。<br>所以，我这里也用了这种实现方式，这样做能减少输出冗余信息，减少用户的阅读负担，让用户更快地获得想要的信息。</p><ol start="2"><li>一个字符的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205912825-488820294.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205958319-1399208864.png" alt></li><li>一个单词的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210007243-239773037.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210013271-1946409668.png" alt></li><li>一行的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210114455-1151020509.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210119963-1429841711.png" alt></li><li>典型的C源文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210126528-40224607.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210131462-486603797.png" alt></li><li>另一个典型的C源文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210153931-1158546205.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210159342-1826726136.png" alt></li></ol><p>除了测试这些样例，我还测试了非法输入的情况，如下：</p><ol><li>没有输入参数<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210210247-1688868089.png" alt></li><li>参数非法<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210225526-1188622487.png" alt></li><li>文件或目录不存在<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210231620-1867302132.png" alt></li><li>在未输入s参数的情况下查询目录<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210246330-568258736.png" alt></li></ol><p>拓展功能的查询更复杂信息和查询目录的测试：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210335631-1210398873.png" alt></p><p>支持各种文件的通配符（*,?）的测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180915090044777-1329710180.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180915090113262-414065472.png" alt></p><h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><p>博主使用了gcov与lcov进行代码覆盖率的测试。经过测试发现，行覆盖率为91.5%，函数覆盖率为100%。<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911234128799-238501992.png" alt></p><h1 id="遇到的困难及解决方法"><a href="#遇到的困难及解决方法" class="headerlink" title="遇到的困难及解决方法"></a>遇到的困难及解决方法</h1><ol><li>之前很少用C++写与文件操作相关的代码，所以对于实现-s这个参数的时候无从下手，最后，通过搜索引擎，查阅官方文档和他人的博客，学习到了新知识，顺利地解决了这个问题。</li><li>实现-a这个参数，需要统计空行、代码行、注释行。一开始，我的想法是逐个读取字符，进行相关变量的更新，并进行状态转化。但是，这样实现的话，会需要很多的标记，让代码晦涩难懂。而且由于这个状态机的状态很多，状态之间的转化也相当复杂。所以，最后我放弃了这种实现方式，改用正则表达式来实现，这样会简单很多。这启发我，在具体实现前，最好先比较一下各种实现方式的难易程度，再选择一种比较容易的来写。</li></ol><h1 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h1><table><thead><tr><th>PSP2.1</th><th>Personal Software Process Stages</th><th>预估耗时（分钟）</th><th>实际耗时（分钟）</th></tr></thead><tbody><tr><td>Planning</td><td>计划</td><td>25</td><td>50</td></tr><tr><td>· Estimate</td><td>· 估计这个任务需要多少时间</td><td>25</td><td>50</td></tr><tr><td>Development</td><td>开发</td><td>525</td><td>600</td></tr><tr><td>· Analysis</td><td>· 需求分析 (包括学习新技术)</td><td>75</td><td>75</td></tr><tr><td>· Design Spec</td><td>· 生成设计文档</td><td>25</td><td>0</td></tr><tr><td>· Design Review</td><td>· 设计复审 (和同事审核设计文档)</td><td>0</td><td>0</td></tr><tr><td>· Coding Standard</td><td>· 代码规范 (为目前的开发制定合适的规范)</td><td>25</td><td>0</td></tr><tr><td>· Design</td><td>· 具体设计</td><td>25</td><td>50</td></tr><tr><td>· Coding</td><td>· 具体编码</td><td>325</td><td>425</td></tr><tr><td>· Code Review</td><td>· 代码复审</td><td>25</td><td>25</td></tr><tr><td>· Test</td><td>· 测试（自我测试，修改代码，提交修改）</td><td>25</td><td>25</td></tr><tr><td>Reporting</td><td>报告</td><td>100</td><td>100</td></tr><tr><td>· Test Report</td><td>· 测试报告</td><td>50</td><td>50</td></tr><tr><td>· Size Measurement</td><td>· 计算工作量</td><td>25</td><td>25</td></tr><tr><td>· Postmortem &amp; Process Improvement Plan</td><td>· 事后总结, 并提出过程改进计划</td><td>25</td><td>25</td></tr><tr><td>合计</td><td></td><td>650</td><td>750</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一开始没有认真分析需求，没有想好就开始动手编码实现，中途停停顿顿，浪费了不少时间。从上面的PSP也可以看出，我花了很少时间在“生成设计文档”、“设计复审”、“代码规范”这三个环节上，导致我后面“具体编码”的环节花的时间比预估的时间长了很多。后来，我重新阅读了项目文件，明确了需求，并进行了相关设计，然后就实现得比较顺利了。这启发我，在开始动手编码前，应该先想好思路，并设计好模块，磨刀不误砍柴工嘛。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://magustest.com/2010/09/12/using-gcov-lcov/" target="_blank" rel="noopener">C/C++代码覆盖工具gcov与lcov入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/hyzgh/wordCount&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github项目地址传送门&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;项目相关要求&quot;&gt;&lt;a href=&quot;#项目相关要求&quot; class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回文自动机学习笔记</title>
    <link href="http://yoursite.com/2018/09/04/palindromic-tree-learning/"/>
    <id>http://yoursite.com/2018/09/04/palindromic-tree-learning/</id>
    <published>2018-09-04T15:56:17.000Z</published>
    <updated>2019-07-13T14:08:03.902Z</updated>
    
    <content type="html"><![CDATA[<p>回文自动机是一种可以处理回文符问题的优雅高效的数据结构。</p><h1 id="URAL-1960-Palindromes-and-Super-Abilities"><a href="#URAL-1960-Palindromes-and-Super-Abilities" class="headerlink" title="URAL 1960 Palindromes and Super Abilities"></a>URAL 1960 Palindromes and Super Abilities</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求各前缀的所有子串中的回文串种类。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>依次插入字符，每插入完一个字符，假如last指针所指的节点是新增的，那么答案加一。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 0 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN] ;<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN] ;<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN] ; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN] ; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN] ;<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN] ;<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last ;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n ;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p ;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span> <span class="params">( <span class="keyword">int</span> l )</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NN ; ++ i ) next[p][i] = <span class="number">0</span> ;</span><br><span class="line">        cnt[p] = <span class="number">0</span> ;</span><br><span class="line">        num[p] = <span class="number">0</span> ;</span><br><span class="line">        len[p] = l ;</span><br><span class="line">        <span class="keyword">return</span> p ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span> ;</span><br><span class="line">        newnode (  <span class="number">0</span> ) ;</span><br><span class="line">        newnode ( <span class="number">-1</span> ) ;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        n = <span class="number">0</span> ;</span><br><span class="line">        S[n] = <span class="number">-1</span> ;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span> ( S[n - len[x] - <span class="number">1</span>] != S[n] ) x = fail[x] ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> c )</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span> ;</span><br><span class="line">        S[++ n] = c ;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail ( last ) ;<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> ( !next[cur][c] ) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode ( len[cur] + <span class="number">2</span> ) ;<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail ( fail[cur] )][c] ;<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now ;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c] ;</span><br><span class="line">        cnt[last] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i ) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pt.add(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(pt.cnt[pt.last] == <span class="number">1</span>)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans, <span class="string">" \n"</span>[i == len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tsinsen-A1280-最长双回文串"><a href="#Tsinsen-A1280-最长双回文串" class="headerlink" title="Tsinsen A1280 最长双回文串"></a>Tsinsen A1280 最长双回文串</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个字符串，在中间某个位置切开，能形成两个回文串，则称这个回文串为双回文串。现在需要求最长双回文串。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令a[i]表示以i结束的最长回文串长度，b[i]表示从i开始的最长回文串长度。<br>每插入一个字符，就更新这两个数组，最后扫一遍，取a[i] + b[i+1]的最大值。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 2 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN] ;<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN] ;<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN] ; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN] ; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN] ;<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN] ;<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last ;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n ;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p ;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span> <span class="params">( <span class="keyword">int</span> l )</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NN ; ++ i ) next[p][i] = <span class="number">0</span> ;</span><br><span class="line">        cnt[p] = <span class="number">0</span> ;</span><br><span class="line">        num[p] = <span class="number">0</span> ;</span><br><span class="line">        len[p] = l ;</span><br><span class="line">        <span class="keyword">return</span> p ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span> ;</span><br><span class="line">        newnode (  <span class="number">0</span> ) ;</span><br><span class="line">        newnode ( <span class="number">-1</span> ) ;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        n = <span class="number">0</span> ;</span><br><span class="line">        S[n] = <span class="number">-1</span> ;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span> ( S[n - len[x] - <span class="number">1</span>] != S[n] ) x = fail[x] ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> c )</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span> ;</span><br><span class="line">        S[++ n] = c ;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail ( last ) ;<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> ( !next[cur][c] ) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode ( len[cur] + <span class="number">2</span> ) ;<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail ( fail[cur] )][c] ;<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now ;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c] ;</span><br><span class="line">        a[id] = len[last];</span><br><span class="line">        b[id - len[last] + <span class="number">1</span>] = max(b[id - len[last] + <span class="number">1</span>], len[last]);</span><br><span class="line">        cnt[last] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i ) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pt.add(i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans = max(ans, a[i] + b[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tsinsen-A1255-拉拉队排练"><a href="#Tsinsen-A1255-拉拉队排练" class="headerlink" title="Tsinsen A1255 拉拉队排练"></a>Tsinsen A1255 拉拉队排练</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>求前k大奇数长度的回文串的乘积。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先建回文自动机，然后dfs奇根节点，找出奇数长度的回文串的长度和个数，放到容器，排个序贪心取出来即可。注意不能直接递归dfs，会爆栈，需要用stack。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/STACK:1024000000,1024000000"</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">19930726</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;<span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line">pii a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; v;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    que.push(u);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = pt.next[u][i];</span><br><span class="line">            <span class="keyword">if</span>(t) &#123;</span><br><span class="line">                sum += pt.cnt[t];</span><br><span class="line">                que.push(t);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">                v.push_back(pii(pt.len[t], pt.cnt[t]));</span><br><span class="line">                <span class="comment">//dfs(t);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a, pii b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) (ans *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pt.add(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pt.count();</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(v.begin(), v.end(), cmp);</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: v) &#123;</span><br><span class="line">            ll num = min(<span class="number">1L</span>L * i.y, k);</span><br><span class="line">            (ans *= ksm(i.x, num)) %= mod;</span><br><span class="line">            k -= i.y;</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tsinsen-A1393-Palisection"><a href="#Tsinsen-A1393-Palisection" class="headerlink" title="Tsinsen A1393 Palisection"></a>Tsinsen A1393 Palisection</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>求相交回文串的对数。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>直接求相交回文串的对数的话，不好求。经过思考，发现所有回文串对数以及不相交回文串的对数比较好求，而这两者相减就是答案，得解。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">51123987</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;<span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">        <span class="keyword">return</span> num[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll sum[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        (sum[i+<span class="number">1</span>] = sum[i] + pt.add(s[i])) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    (ans = <span class="number">1L</span>L * sum[n] * (sum[n] - <span class="number">1</span>) / <span class="number">2</span>) %= mod;</span><br><span class="line">    reverse(s, s + n);</span><br><span class="line">    pt.init();</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        t = pt.add(s[i]);</span><br><span class="line">        ans -= t * sum[n - i - <span class="number">1</span>];</span><br><span class="line">        (ans += mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Gym-100548G-The-Problem-to-Slow-Down-You"><a href="#Gym-100548G-The-Problem-to-Slow-Down-You" class="headerlink" title="Gym 100548G The Problem to Slow Down You"></a>Gym 100548G The Problem to Slow Down You</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求两个字符串中相同回文串的对数。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先分别给两个字符串建立回文自动机，然后分别dfs一下奇偶根节点，累加两个回文自动机相同位置的节点的cnt乘积即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;<span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> len[<span class="number">2</span>], kase;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u0, <span class="keyword">int</span> u1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t0 = pt[<span class="number">0</span>].next[u0][i];</span><br><span class="line">        <span class="keyword">int</span> t1 = pt[<span class="number">1</span>].next[u1][i];</span><br><span class="line">        <span class="keyword">if</span>(t0 &amp;&amp; t1) &#123;</span><br><span class="line">            ans += <span class="number">1L</span>L * pt[<span class="number">0</span>].cnt[t0] * pt[<span class="number">1</span>].cnt[t1];</span><br><span class="line">            dfs(t0, t1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">            len[k] = <span class="built_in">strlen</span>(s[k]);</span><br><span class="line">            pt[k].init();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len[k]; i++) &#123;</span><br><span class="line">                pt[k].add(s[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            pt[k].count();</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回文自动机是一种可以处理回文符问题的优雅高效的数据结构。&lt;/p&gt;
&lt;h1 id=&quot;URAL-1960-Palindromes-and-Super-Abilities&quot;&gt;&lt;a href=&quot;#URAL-1960-Palindromes-and-Super-Abilities&quot; 
      
    
    </summary>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回文自动机" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
</feed>
