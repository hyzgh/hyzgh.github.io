<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hyz&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyzgh.github.io/"/>
  <updated>2020-05-10T09:57:50.832Z</updated>
  <id>https://hyzgh.github.io/</id>
  
  <author>
    <name>hyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《微习惯》读书笔记</title>
    <link href="https://hyzgh.github.io/2020/05/10/Mini-Habits-reading-note/"/>
    <id>https://hyzgh.github.io/2020/05/10/Mini-Habits-reading-note/</id>
    <published>2020-05-10T08:23:52.000Z</published>
    <updated>2020-05-10T09:57:50.832Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/26877306/" target="_blank" rel="noopener">豆瓣链接</a></p><p>本书主要写了微习惯是什么，以及通过微习惯来培养好习惯的依据和规则。</p><h1 id="第一章-微习惯是什么"><a href="#第一章-微习惯是什么" class="headerlink" title="第一章 微习惯是什么"></a>第一章 微习惯是什么</h1><p>小决心优于大决心。许多人拥有大决心，但是却不去执行，效果是零。有小决心的人，更容易执行某件事情，虽然单次的收益比较小，但远大于不执行。日积月累，小决心产生的收益会很大。</p><p>拥有大决心而不执行，原因是大脑觉得这次行动很难，因此会选择逃避。拥有小决心，就不太会存在这个问题。小决心是为了让大脑接受这次行动。通常来讲，在开始后，会想花更多的时间在上面。</p><p>微习惯就是将较大的行动拆分成容易执行的小行动。比如，每天写3000字可以改成每天写50字，每天锻炼1小时可以改成每天锻炼5分钟。</p><p>养成一个习惯，需要的天数会受各种因素影响。我们假如想要养成一个习惯，不必在意需要的天数，因为重要的是坚持。当连续做某件事情时，大脑的抵触情绪会越来越低，会自然地养成习惯。当有某天没有坚持习惯时，不用气馁，一天的堕落从整个过程上看并不会影响习惯的养成，我们需要做的是克服心理上的自暴自弃。</p><h1 id="第二章-大脑的工作原理"><a href="#第二章-大脑的工作原理" class="headerlink" title="第二章 大脑的工作原理"></a>第二章 大脑的工作原理</h1><p>可以将大脑粗分为潜意识部分和意识部分。从大脑的角度看，改变习惯的两个关键点是重复和回报。如果有回报，大脑会更愿意重复一件事情。重复是潜意识大脑使用的语言，潜意识大脑喜欢效率，这是我们能养成习惯的原因。</p><p>大脑是变化缓慢、状态稳定的，因此习惯的养成过程是缓慢的，习惯的保持是稳定的。</p><p>习惯改变涉及到大脑的两个部分：前额皮层和基底神经节。前额皮层是大脑的意识部分，是管理者，负责让大脑其他部分喜欢上自己想要的东西，用于习惯的执行。基底神经节是大脑的潜意识部分，没有思想，只会一味重复，能够探测都模式，用于新习惯的重复和养成。</p><h1 id="第三章-动力VS意志力"><a href="#第三章-动力VS意志力" class="headerlink" title="第三章 动力VS意志力"></a>第三章 动力VS意志力</h1><p>动力越高，做某件事情所需的意志力就越少。假如动力是满分，那么几乎不需要意志力就会去做某件事情。而假如动力为零，那么就需要很强的意志力才能去做某件事情。</p><p>有些人会使用“激发动力”策略来养成习惯。虽然动力确实有利于执行某件事情，但是它存在诸多问题。第一，动力难以永久保持高昂，容易导致习惯在养成的过程中断。第二，动力的影响因素多，不稳定。第三，不会每次都愿意激发动力。第四，根据热情递减原则，动力会减少，假如只依靠动力，那么会动力不足。</p><p>当连续执行某个行动后，我们会注意到心中不再充满动力。这可能是更稳定和自动的基底神经节正在夺取控制权，我们应该做的是利用微习惯继续执行下去，渡过这个艰难期，迎来新习惯。</p><p>动力并不是行动的唯一基础，我们还可以依靠意志力、习惯等。动力是好东西，只是不可靠。假如我们可以借助意志力，那么动力会变得更加可靠。如果先采取行动，动力会被迅速地激发。</p><p>使用意志力来采取行动远比努力激发动力靠谱。第一，意志力很可靠。第二，意志力可以被强化。第三，意志力策略可以通过计划执行。</p><p>意志力的工作原理是什么？意志力是有阈值的，并不是取之不尽用之不竭的。引起意志力损耗的五大主要因素有努力程度、感知程度、消极情绪、主观疲劳和血糖水平。抵抗诱惑，做决定等行为都会引起意志力的损耗。</p><p>我们需要克服这五大障碍，合理使用意志力，养成习惯。</p><h1 id="第四章-微习惯策略"><a href="#第四章-微习惯策略" class="headerlink" title="第四章 微习惯策略"></a>第四章 微习惯策略</h1><p>微习惯策略就是强迫自己每天实施1到4个“小得到不可思议”的计划好的行动。这些运动小得到不会失败，小到不会因为特殊情况就被自己轻易放弃。它们有双重作用——激励自己继续做下去，并会成为微习惯。</p><p>以微习惯方式运用意志力，可以有效地减少意志力的损耗。因为微习惯的努力程度要求小、感知难度小、消极情绪低、主观疲劳小、血糖水平降低少。</p><p>微习惯能更科学地拓宽我们的舒适区。因为大脑是抗拒改变的，因此大幅度的改变会让大脑抗议，而微习惯因其微小而成之。</p><h1 id="第五章-微习惯的独特之处"><a href="#第五章-微习惯的独特之处" class="headerlink" title="第五章 微习惯的独特之处"></a>第五章 微习惯的独特之处</h1><p>微习惯能与现有习惯一较高下。大脑会抗拒大幅度改变，但是微习惯很小，被抗拒的程度会很小。</p><p>有些人在养成习惯的时候，会给自己设置一个期限。但是这是不科学的，因为习惯的形成因习惯、个体而定。微习惯策略没有截止时间，因为我们不知道需要多少时间，但是我们要寻找养成习惯的信号。</p><p>自我效能感是指对自己影响事件结果的能力的信念。微习惯能提升自我效能感。</p><p>微习惯能给我们更多的自主权，潜意识会恐惧控制，而微习惯通过将行动微小化，让潜意识意识到自己的控制权仍在，从而接受微小的变化。</p><p>微习惯能帮助自己远离恐惧、怀疑、胆怯或犹豫。行动是克服这些消极情绪的最佳武器，而微习惯能帮助自己行动。</p><p>正念是指对自己思维和行动有着清醒认识。正念是目标清晰地活着和敷衍地活着之间的区别。微习惯能让自己意识到在做什么，能培养自己的正念。</p><h1 id="第六章-彻底改变只需八步"><a href="#第六章-彻底改变只需八步" class="headerlink" title="第六章 彻底改变只需八步"></a>第六章 彻底改变只需八步</h1><ol><li>选择适合你的微习惯和计划<ul><li>不超过四个</li><li>微习惯要小到即使精疲力尽也可以执行</li><li>写下来</li></ul></li><li>挖掘每个微习惯的内在价值<ul><li>不断问自己为什么要养成这个习惯，寻找依据</li></ul></li><li>明确习惯依据，将其纳入日程<ul><li>根据时间制定</li><li>根据行为方式制定</li><li>非具体习惯</li></ul></li><li>创建奖励机制，以奖励提升成就感<ul><li>奖励，关联美好事物，比如npy、大声微笑、唱歌、吃东西、休息一下等</li><li>奖励时间点：在取得一定里程碑时，给自己奖励。在坚持不下去时，给自己奖励</li><li>奖励能提升意志力</li></ul></li><li>记录与追踪完成情况<ul><li>研究表明，把想法写在纸上时，会让其在大脑中更加突出，而打字就不具备同样的效应</li><li>可以采用纸质日历、电子数据等方式来追踪，关注自己在意的数据，比如完成天数/总天数</li></ul></li><li>微量开始，超额完成<ul><li>强化意志力</li><li>当下就取得进步</li><li>不耗尽意志力</li></ul></li><li>服从计划安排，摆脱高期待值<ul><li>我们常常在执行的过程会超额完成目标，可以记录这些数据</li><li>要把期待值和精力放在坚持目标上，而不要对任务量抱有较高的期待</li></ul></li><li>留意习惯养成的标志<ul><li>没有抵触情绪，做起来容易，不做反而更难</li><li>认同身份，比如我常运动，我喜欢阅读</li><li>行动无需考虑，不再担心，常态化</li><li>很无聊，好的习惯并不会让人兴奋，它们只是对我们有好处而已</li></ul></li></ol><h1 id="第七章-微习惯策略的八大规则"><a href="#第七章-微习惯策略的八大规则" class="headerlink" title="第七章 微习惯策略的八大规则"></a>第七章 微习惯策略的八大规则</h1><ol><li>绝不要自欺欺人。不要偷偷要求自己做得更多，要真正的微习惯</li><li>满意每一个进步。要满意，但别满足</li><li>经常回报自己，尤其在完成微习惯之后</li><li>保持头脑清醒。不管情绪是兴奋的，还是低落的，都要记住，要完成微习惯</li><li>感到强烈抵触时，后退并缩小目标。缩小目标，有利于降低意志力损耗，有利于行动的执行，开始执行要优于不执行，执行的过程会带来动力，形成正反馈</li><li>提醒自己这件事很轻松、很有趣。大脑喜欢轻松、有趣的事情</li><li>绝不要小看微步骤。不积跬步无以至千里</li><li>用多余精力超额完成任务，而不是制定更大目标</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26877306/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;豆瓣链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本书主要写了微习惯是什么，以及通过微习惯来培养好习惯的依据和规则。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://hyzgh.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题6 Group Anagrams</title>
    <link href="https://hyzgh.github.io/2020/04/06/leetcode-exercise-per-day-6-Group-Anagrams/"/>
    <id>https://hyzgh.github.io/2020/04/06/leetcode-exercise-per-day-6-Group-Anagrams/</id>
    <published>2020-04-06T08:30:17.000Z</published>
    <updated>2020-04-06T08:47:15.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，起元素为只包含英文小写字母的单词。</p><p>要求分组输出使用了相同字符构造的单词，比如tea和eat就是同类单词。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将所有的单词遍历一遍，将同类单词放到同一个位置中去，关键是这个映射要怎么实现。对于一个长度为m的单词，我们可以用O(m)的时间遍历出各字符的使用次数。接着，我们将其转化成字符串，对于某个字符，其出现次数可以编码成cnt + char，然后按照英文字母表顺序连接起来。比如，teaa编码成2a1e1t。</p><p>上面的编码使用了一个优化，即对于出现次数的0的字母，不编码到字符串中。</p><p>假如追求极致，还可以对编码继续优化。</p><ul><li>对于出现次数为1的字母，可以不写上cnt。比如teaa可以写成2aet。</li><li>当cnt很大时，可以使用整形来表示。比如250，使用char来表示需要3个字节，使用整形只要1个字节。</li></ul><p>编码是个很有趣的知识点，上面的编码方式似乎都有专门的名称，以后有空的话专门写篇博客总结一下，这里留个坑:)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; v;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: strs) &#123;</span><br><span class="line">            m[hashWord(i)].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it: m) &#123;</span><br><span class="line">            v.push_back(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">hashWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            hash += <span class="built_in">string</span>(cnt[i], <span class="string">'a'</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给一个数组，起元素为只包含英文小写字母的单词。&lt;/p&gt;
&lt;p&gt;要求分组输出使用了相同字符构造的单词，比如tea和eat就是同类单词。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题5 Best Time to Buy and Sell Stock II</title>
    <link href="https://hyzgh.github.io/2020/04/05/leetcode-exercise-per-day-5-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>https://hyzgh.github.io/2020/04/05/leetcode-exercise-per-day-5-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2020-04-05T09:29:37.000Z</published>
    <updated>2020-04-05T09:39:09.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，表示每天的股票股价。可以进行无数次交易，但同一时刻只能持有一股的股票。求最大收益。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假如股价在未来是涨的，那么就应该购买。假如是跌的，就不购买。</p><p>因此，我们扫描一遍数组，维护当前最低的股价，假如遇到较高的股价，就卖出，并更新最低股价。时间复杂度为O(n)，空间复杂度为O(1)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - mi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += prices[i] - mi;</span><br><span class="line">                mi = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            mi = min(mi, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给一个数组，表示每天的股票股价。可以进行无数次交易，但同一时刻只能持有一股的股票。求最大收益。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题4 Move Zeroes</title>
    <link href="https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-4-Move-Zeroes/"/>
    <id>https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-4-Move-Zeroes/</id>
    <published>2020-04-04T09:45:48.000Z</published>
    <updated>2020-04-04T09:51:00.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3286/" target="_blank" rel="noopener">Move Zeroes</a></p></blockquote><p>给一个数组，通过交换将所有非零元素放置在前面，将所有零元素放置在后面。</p><p>要求In-place，即不能使用额外的空间存放数组元素。</p><p>另外还要求交换次数最少。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>为了满足题目要求，我们可以使用双指针法，找到一个零元素，以及在它后面的非零元素，将两者交换，不断重复这个过程。</p><p>假如不需要交换次数最少，有种更简洁的写法，即两次for循环，第一个for循环将非零元素放在数组前面，第二次for循环将非零元素放在数组后面。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pZero = findNextZeroIndex(nums, <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pNonZero = findNextNonZeroIndex(nums, pZero);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pZero &lt; nums.size() &amp;&amp; pNonZero &lt; nums.size()) &#123;</span><br><span class="line">            swap(nums[pNonZero], nums[pZero]);</span><br><span class="line">            pZero = findNextZeroIndex(nums, pZero);</span><br><span class="line">            pNonZero = findNextNonZeroIndex(nums, pZero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNextZeroIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> pZero)</span> </span>&#123;</span><br><span class="line">        pZero++;</span><br><span class="line">        <span class="keyword">while</span> (pZero &lt; nums.size() &amp;&amp; nums[pZero] != <span class="number">0</span>) &#123;</span><br><span class="line">            pZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pZero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNextNonZeroIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> pNonZero)</span> </span>&#123;</span><br><span class="line">        pNonZero++;</span><br><span class="line">        <span class="keyword">while</span> (pNonZero &lt; nums.size() &amp;&amp; nums[pNonZero] == <span class="number">0</span>) &#123;</span><br><span class="line">            pNonZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNonZero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/explore/featured/card/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题3 Maximum Subarray</title>
    <link href="https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-3-Maximum-Subarray/"/>
    <id>https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-3-Maximum-Subarray/</id>
    <published>2020-04-04T09:03:51.000Z</published>
    <updated>2020-04-04T09:19:47.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3285/" target="_blank" rel="noopener">Maximum Subarray</a></p></blockquote><p>给一个数组，求该数组的最大子数组和。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>解法1：从左到右遍历一次，累加，若sum比现有的答案大，则更新。若sum为负数，则放弃这一段的元素，置为0。时间复杂度为O(n)，空间复杂度为O(1)。</p><p>解法2：分治法。若我们将一个数组从中间分隔成两个数组，则它的答案是max(左数组的答案, 右数组的答案, 左数组的最大后缀和+右数组的最大前缀和+中间元素)。时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>解法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = LONG_LONG_MIN;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; ans)</span><br><span class="line">                ans = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">return</span> maxSubArrayCore(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArrayCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>, sum = <span class="number">0</span>; i &gt;= l; i--) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            leftMax = max(leftMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            rightMax = max(rightMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(leftMax + rightMax + nums[mid],</span><br><span class="line">                max(maxSubArrayCore(nums, l, mid), maxSubArrayCore(nums, mid + <span class="number">1</span>, r)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/explore/featured/card/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题2 Happy Number</title>
    <link href="https://hyzgh.github.io/2020/04/02/leetcode-exercise-per-day-2-Happy-Number/"/>
    <id>https://hyzgh.github.io/2020/04/02/leetcode-exercise-per-day-2-Happy-Number/</id>
    <published>2020-04-02T08:35:01.000Z</published>
    <updated>2020-04-02T08:52:39.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3284/" target="_blank" rel="noopener">Happy Number</a></p></blockquote><p>给一个数字，判断它是不是Happy Number。假如一个数是Happy Number，则可以通过不断取各数位的平方和得到1。而假如不是Happy Number，则会陷入循环，不会得到1。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题的关键在于怎么知道发生了循环，并在发生循环的时候及时结束。弗洛伊德判圈法(Floyd Cycle detection algorithm)是可以在O(1)的空间复杂度和O(n)的时间复杂度内，判断是否发生循环的一种算法，其中n是循环的次数。其思想是维护两个指针，令它们一开始都指向最开始的位置，然后进行<code>do while</code>循环，让其中一个指针一次走两步，另一个一次走一步，直到两者相等，就可以判定存在圈。</p><p>这道题一定存在循环，Happy Number在找到圈的时候，指向的数为1，而非Happy Number指向的数非1，得解。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow, fast;</span><br><span class="line">        slow = fast = n;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = getSum(slow);</span><br><span class="line">            fast = getSum(fast);</span><br><span class="line">            fast = getSum(fast);</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (d) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = d % <span class="number">10</span>;</span><br><span class="line">            d /= <span class="number">10</span>;</span><br><span class="line">            sum += mod * mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/explore/featured/card/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题01 Single Number</title>
    <link href="https://hyzgh.github.io/2020/04/01/leetcode-exercise-per-day-1-Single-Number/"/>
    <id>https://hyzgh.github.io/2020/04/01/leetcode-exercise-per-day-1-Single-Number/</id>
    <published>2020-04-01T09:03:20.000Z</published>
    <updated>2020-04-02T08:35:50.929Z</updated>
    
    <content type="html"><![CDATA[<p>最近Leetcode举办了一个为期一个月的活动，每天会推出一道题目。最近这段时间正好有空，所以打算跟着参加一下，顺便写一下题解。使用的语言为C++。</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p> 题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3283/" target="_blank" rel="noopener">Single Number</a></p></blockquote><p>给一个非空的数组，其中有1个元素出现了1次，其他的都出现2次。时间要求为线性，不允许使用额外内存，求出现1次的元素。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目保证数组非空，所以不需要特殊处理。</p><p>两个相同的数异或等于0，因此我们可以将数组所有元素异或起来，最后得到的值即为出现1次的元素。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近Leetcode举办了一个为期一个月的活动，每天会推出一道题目。最近这段时间正好有空，所以打算跟着参加一下，顺便写一下题解。使用的语言为C++。&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go Lang slice 学习笔记</title>
    <link href="https://hyzgh.github.io/2020/01/27/go-slice-learning-note/"/>
    <id>https://hyzgh.github.io/2020/01/27/go-slice-learning-note/</id>
    <published>2020-01-27T13:48:29.000Z</published>
    <updated>2020-01-27T14:07:05.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h1><p>切片，本身不存储实际数据。切片的数据结构，也被称为slice header，包含指向首元素的指针、切片长度、切片容量：</p><p><img src="https://s2.ax1x.com/2020/01/27/1uWu2n.png" alt="img"></p><p>当将切片作为实参时，只会传递slice header。这个传递是值传递，这意味着：</p><ul><li>假如在函数里面对slice的元素作赋值操作，由于有指针指着元素，所以原有slice指向的元素也会被改变。</li><li>假如在函数里面reslice，并不会影响原slice。</li></ul><p>假如想要改变原有slice，有两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种，将返回值赋值给原slice，这种方式也就是append的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubtractOneFromLength</span><span class="params">(slice []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSlice := SubtractOneFromLength(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，用slice指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrSubtractOneFromLength</span><span class="params">(slicePtr *[]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    slice := *slicePtr</span><br><span class="line">    *slicePtr = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这引发了另一个需要注意的点，对于slice的方法，假如需要reslice，要用slice指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> path []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *path)</span> <span class="title">TruncateAtFinalSlash</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := bytes.LastIndex(*p, []<span class="keyword">byte</span>(<span class="string">"/"</span>))</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        *p = (*p)[<span class="number">0</span>:i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pathName := path(<span class="string">"/usr/bin/tso"</span>) <span class="comment">// Conversion from string to path.</span></span><br><span class="line">    pathName.TruncateAtFinalSlash()</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, pathName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片，可以改变指向的范围，这是成本很低的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片，可以切片，即<code>s := s[[begin]:[end]]</code>，其中begin和end可以省略。当end超过实际cap时，会panic。</p><p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p><p><code>len()</code>查看长度，即从下界到上界的个数</p><p>切片的零值为<code>nil</code>，此时<code>cap</code>和<code>len</code>都为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span>  <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><h1 id="切片的append"><a href="#切片的append" class="headerlink" title="切片的append"></a>切片的append</h1><p>可使用<code>append</code>函数向切片添加元素，对nil切片进行<code>append</code>是正确的。</p><p>当append超过切片容量时，会将容量翻倍，且利用内置函数copy进行数据的拷贝，该函数在切片重叠的情况下也可以保证正确拷贝。注意只有被append的slice的指针会指向这块新的区域，基于这个slice的其他slice并不会更新指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>append</code>函数向切片中添加切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><h1 id="切片的内存管理"><a href="#切片的内存管理" class="headerlink" title="切片的内存管理"></a>切片的内存管理</h1><p>注意只要有一个slice使用着底层slice，即使这个上层slice只包含了很少的元素，底层slice的内存也不会被释放掉。这时候假如为了释放不必要的内存占用，需要将上层slice指向的数据拷贝到新的区域：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个文件的字节都被加载进去了，且不释放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝到c，释放多余的占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h1><p>使用<code>make</code>来创建一维切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a) == cap(a) == 5</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b) == 0, cap(b) == 5</span></span><br></pre></td></tr></table></figure><p>使用<code>make</code>创建二维切片</p><p>第一种方式，该方式允许第二维大小有所变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h1><p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的技巧"><a href="#切片的技巧" class="headerlink" title="切片的技巧"></a>切片的技巧</h1><p>优雅地往slice插入一个value：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert inserts the value into the slice at the specified index,</span></span><br><span class="line"><span class="comment">// which must be in range.</span></span><br><span class="line"><span class="comment">// The slice must have room for the new element.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(slice []<span class="keyword">int</span>, index, value <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// Grow the slice by one element.</span></span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)+<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// Use copy to move the upper part of the slice out of the way and open a hole.</span></span><br><span class="line">    <span class="built_in">copy</span>(slice[index+<span class="number">1</span>:], slice[index:])</span><br><span class="line">    <span class="comment">// Store the new value.</span></span><br><span class="line">    slice[index] = value</span><br><span class="line">    <span class="comment">// Return the result.</span></span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅地合并两个切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">string</span>&#123;<span class="string">"John"</span>, <span class="string">"Paul"</span>&#125;</span><br><span class="line">b := []<span class="keyword">string</span>&#123;<span class="string">"George"</span>, <span class="string">"Ringo"</span>, <span class="string">"Pete"</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a, b...) <span class="comment">// equivalent to "append(a, b[0], b[1], b[2])"</span></span><br><span class="line"><span class="comment">// a == []string&#123;"John", "Paul", "George", "Ringo", "Pete"&#125;</span></span><br></pre></td></tr></table></figure><p>优雅地copy：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">b = <span class="built_in">append</span>([]T(<span class="literal">nil</span>), a...)</span><br></pre></td></tr></table></figure><p>cut，优雅地删除掉slice中的某一个区间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通版，对于元素为指针或者结构中含有指针，会存在内存泄漏，因为被删掉的元素仍属于slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级版，将指针设为nil，减少了内存泄漏，但是还是有元素属于slice</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:], a[j:])</span><br><span class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ &#123;</span><br><span class="line">    a[k] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</span><br></pre></td></tr></table></figure><p>filter：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> keep(x) &#123;</span><br><span class="line">            a[n] = x</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a[:n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reverse:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    opp := <span class="built_in">len</span>(a)<span class="number">-1</span>-i</span><br><span class="line">    a[i], a[opp] = a[opp], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shuffling:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">    j := rand.Intn(i + <span class="number">1</span>)</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接用math/rand.Shuffle</span></span><br><span class="line"><span class="comment">// 使用了Fisher–Yates算法</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;切片的数据结构&quot;&gt;&lt;a href=&quot;#切片的数据结构&quot; class=&quot;headerlink&quot; title=&quot;切片的数据结构&quot;&gt;&lt;/a&gt;切片的数据结构&lt;/h1&gt;&lt;p&gt;切片，本身不存储实际数据。切片的数据结构，也被称为slice header，包含指向首元素的指针、切
      
    
    </summary>
    
    
      <category term="Go" scheme="https://hyzgh.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Lang GC 学习笔记</title>
    <link href="https://hyzgh.github.io/2020/01/11/go-garbage-collector-learning-note/"/>
    <id>https://hyzgh.github.io/2020/01/11/go-garbage-collector-learning-note/</id>
    <published>2020-01-11T15:42:50.000Z</published>
    <updated>2020-01-11T15:51:57.048Z</updated>
    
    <content type="html"><![CDATA[<p>GC的具体实现一直在改变，但是其模型是相对稳定的。</p><p>collection的三个阶段：</p><ul><li>Mark Setup - STW</li><li>Marking - Concurrent</li><li>Mark Termination - STW</li></ul><p>Mark Setup：当进行gc时，为了保证数据完整性，需要设置Write Barrier，这要求将所有的goroutine停止，正常情况下这个时间平均为10-30ms。但是当goroutine停止不下时，会让这个时间变长。调度器目前停止goroutine的时机是在goroutine执行函数调用的时候，因为这样做才能保证安全。假如某个goroutine一直在执行循环，而不执行函数调用，它就无法被停止，这不仅会耽误gc第一个阶段的完成，还会造成其他goroutine停止着。将在Go1.14引入 <a href="https://github.com/golang/go/issues/24543" target="_blank" rel="noopener">preemptive</a> techniques 尝试对此进行优化。</p><p>Marking - Concurrent：当设置好Write Barrier后，collector会拿走25%可用的CPU，用于mark操作。mark操作，会遍历所有goroutine的栈，寻找指针指向的heap内存，将仍在使用的内存标记一下。这个时候，goroutine是可以并发执行的。在mark的过程，其他正在运行的goroutine可以分配内存，这可能导致内存不够用，这时候需要Mark Assits。Mark Assits，是指短暂停止正在运行的goroutine，让它们来帮忙mark，加快mark的进度。当然，这会影响这些goroutine的执行，collector的目标是尽可能减少Mark Assits的需要。</p><p>Mark Termination - STW：Mark完成后，需要关闭Write Barrier，进行多项清理工作，设定下次collection的目标。在进行这些工作前，仍要求所有的goroutine停止。这些工作平均持续60~90ms。虽然也可以设计成边Termination边正常运行一些gorutine的模式，但是设计者认为这样得到的收益很小，而增加的复杂性较高，所以选择了这种STW的实现方式。当Termination工作完成后，回到正常状态。</p><p>在collection完成后，会进行sweeping。</p><p>sweep是指将那些没有标记为使用的heap内存回收，它不是发生在一次collection中，而是被均摊到每次分配内存的时候。</p><p>以上所有行为只有在GC开始且正在进行的时候发生，GC Percentage对collection有很大影响。GC Pencentage，默认是100%。将GC Pencentage设置为100%，意味着下次GC会在heap达到当前GC的mark live内存的2倍时进行。</p><p>GC trace可用于追踪collection。<code>GODEBUG=gctrace=1 ./app</code>可查看GC信息，输出到<code>stderr</code>。</p><p>GC trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设置环境变量查看GC trace</span></span><br><span class="line">GODEBUG=gctrace=1 ./app</span><br><span class="line"></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8-&gt;11-&gt;6 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8-&gt;14-&gt;8 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC trace含义</span></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">// General</span><br><span class="line">gc 1404     : The 1404 GC run since the program started</span><br><span class="line">@6.068s     : Six seconds since the program started</span><br><span class="line">11%         : Eleven percent of the available CPU so far has been spent <span class="keyword">in</span> GC</span><br><span class="line"></span><br><span class="line">// Wall-Clock</span><br><span class="line">0.058ms     : STW        : Mark Start       - Write Barrier on</span><br><span class="line">1.2ms       : Concurrent : Marking</span><br><span class="line">0.083ms     : STW        : Mark Termination - Write Barrier off and clean up</span><br><span class="line"></span><br><span class="line">// CPU Time</span><br><span class="line">0.70ms      : STW        : Mark Start</span><br><span class="line">2.5ms       : Concurrent : Mark - Assist Time (GC performed <span class="keyword">in</span> line with allocation)</span><br><span class="line">1.5ms       : Concurrent : Mark - Background GC time</span><br><span class="line">0ms         : Concurrent : Mark - Idle GC time</span><br><span class="line">0.99ms      : STW        : Mark Term</span><br><span class="line"></span><br><span class="line">// Memory</span><br><span class="line">7MB         : Heap memory <span class="keyword">in</span>-use before the Marking started</span><br><span class="line">11MB        : Heap memory <span class="keyword">in</span>-use after the Marking finished</span><br><span class="line">6MB         : Heap memory marked as live after the Marking finished</span><br><span class="line">10MB        : Collection goal <span class="keyword">for</span> heap memory <span class="keyword">in</span>-use after Marking finished</span><br><span class="line"></span><br><span class="line">// Threads</span><br><span class="line">12P         : Number of logical processors or threads used to run Goroutines</span><br></pre></td></tr></table></figure><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GC的具体实现一直在改变，但是其模型是相对稳定的。&lt;/p&gt;
&lt;p&gt;collection的三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mark Setup - STW&lt;/li&gt;
&lt;li&gt;Marking - Concurrent&lt;/li&gt;
&lt;li&gt;Mark Termination -
      
    
    </summary>
    
    
      <category term="Go" scheme="https://hyzgh.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>perl 学习笔记</title>
    <link href="https://hyzgh.github.io/2019/12/18/null/"/>
    <id>https://hyzgh.github.io/2019/12/18/null/</id>
    <published>2019-12-18T15:09:06.000Z</published>
    <updated>2019-12-18T15:58:07.610Z</updated>
    
    <content type="html"><![CDATA[<p>Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。</p><p>Perl的强大之处，在于它具有sed和awk的全部功能，以及众多语言的语法特性，以及非常强大的正则表达式，等等。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h1><p>Perl的Hello, World：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'print("Hello, World\n")'</span></span><br></pre></td></tr></table></figure><p>在安装了perl的计算机上，直接执行上述代码，即可输出<code>Hello, World</code>。</p><p>也可以将perl代码写在文件，以重复执行，具体可以这样写：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 "Hello, World"</span></span><br><span class="line"><span class="keyword">print</span>(<span class="string">"Hello, World\n"</span>);</span><br></pre></td></tr></table></figure><p>将上述代码保存成<code>learn.pl</code>后，加下执行权限，然后执行<code>./learn.pl</code>，可输出<code>Hello, World</code>。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Perl的正式表达式非常强大，是常用编程语言里最顶尖的之一。下面来看几个例子。</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p><code>echo box.svc.content | perl -p -e &#39;s/\.+/\//g&#39;</code></p><p>将会输出<code>box/svc/content</code>。</p><p>解析：</p><p><code>-p</code>参数会将结果输出出来。</p><p>这里用到了一个常用的<strong>替换</strong>句型，<code>s/old/new/parameters</code>，表示将<code>old</code>替换成<code>new</code>。</p><p><code>s/\.+/\//g</code>的<code>s</code>表示替换，<code>\.+</code>表示至少一个<code>.</code>，<code>\/</code>表示一个<code>/</code>，<code>g</code>表示全局匹配。</p><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"></span><br><span class="line">$string = <span class="string">'welcome to w3cschool site.'</span>;</span><br><span class="line">$string =~ <span class="regexp">tr/a-z/A-z/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$string\n"</span>;</span><br></pre></td></tr></table></figure><p>上面的代码将会输出<code>WELCOME TO W3CSCHOOL SITE.</code>。</p><p>这里用到了一个常用的<strong>转化</strong>句型，<code>tr/old/new/parameters</code>。表示将<code>old</code>转化成<code>new</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.w3cschool.cn/perl/perl-regular-expressions.html" target="_blank" rel="noopener">Perl 正则表达式 - W3Cschool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。&lt;/p&gt;
&lt;p&gt;Perl的强大之处，在于它具有sed和a
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://hyzgh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>图片文件格式 学习笔记</title>
    <link href="https://hyzgh.github.io/2019/12/07/null/"/>
    <id>https://hyzgh.github.io/2019/12/07/null/</id>
    <published>2019-12-07T08:07:02.000Z</published>
    <updated>2019-12-07T08:32:39.020Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。</p><p>一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过<code>ImageMagick</code>这个程序来解析图片文件。</p><p>分辨率，比如1920x1080，是指图片的一行具有1920个像素，一列具有1080个像素。</p><p>色彩空间，是指描述一个像素点的方式。比如RGB，是指一个像素点用red, green, blue各8bit一共24bit来描述。而YUV，是指Y表示亮度，U和V一起表示色调和饱和度。</p><p>在互联网上最常见的大概是jpeg类的文件。jpeg文件之所以适合在互联网上传播，是因为它的压缩比较高，且能在压缩和图片还原度上保持平衡，使得一张图片既有小巧的体积，又能在肉眼级别上有良好的清晰度。</p><p>但是jpeg文件并不适合保存图标等图像内容，因为它不具有alpha通道，不能用来表示透明的背景。一般会用png来保存图标。由于png是无损压缩存储图片的，所以会比jpeg文件要大一些，也适合对于图像质量要求较高的情况。</p><p>bmp文件，它也是无损不压缩的，所以会比较大，比较少见。</p><p>git文件，可以存储动图，但是由于它只用了8bit来描述一个像素点，所以可用的色彩并不多，色彩丰富度低。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。&lt;/p&gt;
&lt;p&gt;一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过&lt;code&gt;ImageMagick&lt;/code&gt;这个程序来解析图片文件。&lt;/p&gt;
&lt;p&gt;分辨率，比如1920x1080，是指图
      
    
    </summary>
    
    
      <category term="文件格式" scheme="https://hyzgh.github.io/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 6</title>
    <link href="https://hyzgh.github.io/2019/10/21/CSAPP-learning-note-6/"/>
    <id>https://hyzgh.github.io/2019/10/21/CSAPP-learning-note-6/</id>
    <published>2019-10-21T11:16:38.000Z</published>
    <updated>2019-10-24T12:39:08.615Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了CSAPP的第八章——异常控制流。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。异常有不同的种类，有中断、陷阱、故障、终止。</p><p>中断，是在CPU执行某条指令的时候，其他部件异步产生的，比如定时器芯片、磁盘控制器、网络适配器等。CPU检测到中断后，会把当前指令执行完，然后转去执行异常处理程序，接着再返回来执行下一条指令。</p><p>陷阱，是有意的异常，最常见的陷阱是系统调用。系统调用，是指从用户模式转为内核模式，以执行一些特殊的指令，比如操作I/O设备。执行完系统调用后，会返回来执行下一条指令。</p><p>故障，是指执行指令的时候遇到了意外，比如遇到了缺页、访问了未定义的虚拟内存区域等。根据故障的不同，异常处理程序执行完后可能会返回执行当前指令，也有可能会终止程序。在写程序时常常遇到的<code>Floating point exception</code>和<code>Segmentation fault</code>就属于故障，且在Linux中的处理是程序被终止。</p><p>终止，是指遇到了致命的硬件错误，必须结束程序。</p><p>因为异常种类繁多，所以计算机中有一张异常表，用来记录不同的异常及对应的异常处理程序。在CPU中，有一个特殊的寄存器——异常表基址寄存器，用来存放异常表在内存中的基址。当CPU遇到一种异常的时候，会拿到一个异常号。CPU拿着这个异常号及寄存器中的基址，便可以找到对应的异常处理程序了。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程，是执行中的程序实例，是操作系统对于程序的一种抽象。这种抽象，使得看起来进程是独占cpu和内存的。为了实现这种抽象，需要操作系统保存好进程的上下文，进行进程调度。</p><p>进程的上下文，是指进程执行的状态，包括CPU中的状态、用户模式中的状态、内核模式中的状态。具体来说，cpu中的状态，包括各种寄存器，比如通用寄存器，用来保存指令执行用到的数据，还有程序计数器，用来指明程序执行的进度。用户模式下的状态，包括用户栈等。内核模式中的状态，包括内核栈、进程已打开文件的信息的文件表、有关当前进程的信息的进程表等。</p><p>什么时候会触发进程调度呢？主要有两种情况。一种是进程执行了系统调用，阻塞住了，比如读写文件、sleep等。另一种是中断，包括IO操作完成以及时钟中断等。</p><h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><ul><li><code>PS</code>：列出当前系统中的进程。</li><li><code>TOP</code>：打印出关于当前进程资源使用的进程。</li><li><code>PMAP</code>：显示进程的内存映射。</li><li><code>STRACE</code>：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。<code>-static</code>是个实用的参数。</li><li><code>/proc</code>：一个虚拟文件系统，以ASCII文件格式输出大量内核数据结构的内容。</li></ul><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了CSAPP的第八章——异常控制流。&lt;/p&gt;
&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;p&gt;在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 5</title>
    <link href="https://hyzgh.github.io/2019/10/18/CSAPP-learning-note-5/"/>
    <id>https://hyzgh.github.io/2019/10/18/CSAPP-learning-note-5/</id>
    <published>2019-10-18T14:27:36.000Z</published>
    <updated>2019-10-21T11:17:03.860Z</updated>
    
    <content type="html"><![CDATA[<p>这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。</p><p><img src="https://s2.ax1x.com/2019/10/18/KeyBvV.png" alt="第六章存储器层次结构"></p><h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><p>存储器有着很多的种类，比如CPU的寄存器、高速缓存，主存（内存）的DRAM，机械硬盘、固态硬盘、U盘、SD卡、磁带等。不同的存储器，会用到不同的存储技术。其中寄存器的存储技术从性能上看是最好的，同时价格也最昂贵的，因此寄存器的大小相比于其他存储器，少得可怜，比如一般来说，通用寄存器只有16个，而1个寄存器只能存储64个bit。高速缓存采用的是SRAM，而主存用的是DRAM。SRAM用到了多个晶体管，比DRAM要快得多，会更加稳定，同时成本也更高。一般来说，高速缓存是几M的量级，而主存是以几G的量级，可见两者的价格差异。RAM有一个特点是断电后内容会丢失。</p><p>我们常用的U盘、SD卡等，并不是基于RAM，而是基于ROM。所谓ROM，翻译成中文便是只读存储器。个人觉得这个名字有点歧义，容易让人误解成数据不可更改。但实际上，ROM也有多个种类，我们常用的U盘基于EEPROM（电子可擦写只读存储器），是可以进行擦写的。而固态硬盘，基于闪存，它也是可擦写的。以前给手机刷机的时候，常常会听到ROM和固件这两个名词。所谓固件，是指写入到ROM中的程序。</p><p>机械硬盘，常常会听到一个参数叫转数。这个参数表示盘片旋转速度的速度。这个参数虽然重要，但却非影响硬盘随机IO时间的最重要因素。磁盘访问数据，由三个部分的时间组成，即寻道时间、旋转时间、传送时间。寻道时间是磁头定位到对应磁道的时间，这个时间平均占比是最大的，通常可占到整体时间的1/2以上，所以我们可以用两倍寻道时间来估计总时间。磁头定位到对应磁道，有专门的寻道算法，比如电梯算法。</p><p>固态硬盘，是近些年流行起来的存储器。其性能、价格皆介于主存和机械硬盘之间。由于固态硬盘采用了闪存，避免了机械硬盘缓慢的寻道和旋转，所以速度更快，特别是在随机IO的表现上。</p><p>根据历史趋势，存储器将会访问速度越来越快，越来越大，且会越来越便宜。但是，由于CPU的性能提升要比SRAM、DRAM、磁盘的速度快，所以两者的差距在增大，这将成为计算机的瓶颈。也因此，各级缓存的必要性就体现出来了，利用局部性原理，我们可以减弱这种差距。</p><h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性分为空间局部性及时间局部性。空间局部性指的是某个位置的数据被访问后，其附近的数据将可能被访问。时间局部性指的是某个位置的数据被访问后，这个位置还将可能被再次访问。</p><p>以前对于这个概念的认识有点模糊，对其带来的性能差异没有明确的认知。我们下面通过一个程序来看一下空间局部性带来的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;    </span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当N = 20000时，在我的机器上，sum1执行的时间为2.1s，而sum2执行的时间为5.6s，两者差距两倍多。</p><p>sum1之所以性能表现比sum2优秀，是因为它访问数据时的步长为1，让计算机能更好地利用空间局部性原理。</p><h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>计算机的存储器层次结构从快到慢分为寄存器、L1高速缓存、L2高速缓存、L3高速缓存、主存、本地二级磁盘（本地磁盘）、远程二级存储（分布式文件系统、Web服务器）等。通过这样的层次结构，在大小、访问速度、价格等因素之间取得了折衷，让计算机的价格合理、访问速度较快、存储空间较大。</p><p>缓存无处不在，其目的是降低不同存储器之间速度差异带来的影响。计算机各级存储器之间，上层是下层的缓存。浏览器访问网页时，在本地磁盘有缓存，能提高用户打开同一网页的速度。Web服务器被访问的时候，本地磁盘也有缓存，能提高不同用户访问同一网页的速度。磁盘也有缓存，用于缓存磁盘扇区，提高计算机访问磁盘的速度。代理服务器，也可用来做缓存，能降低网络延迟。业务上，redis用作MySQL的缓存，是用内存来缓存磁盘的内容，缓解了随机I/O带来的性能问题。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/18/KeyBvV.png&quot; alt=&quot;第六章存储器层次结构&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;存储技术&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 4</title>
    <link href="https://hyzgh.github.io/2019/10/15/CSAPP-learning-note-4/"/>
    <id>https://hyzgh.github.io/2019/10/15/CSAPP-learning-note-4/</id>
    <published>2019-10-15T04:31:41.000Z</published>
    <updated>2019-10-18T14:28:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。</p><p>在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。</p><p>在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即<code>CMP</code>和<code>TEST</code>，也会设置条件码，但它们不会改变其他寄存器。</p><p>那么怎么访问这些条件寄存器呢？CPU中提供了<code>SET</code>指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应<code>SETE</code>指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应<code>SETL</code>，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。</p><p>要实现像C语言中的for语句，还需要一类指令<code>JMP</code>。它可以根据条件跳转到其他语句，而不是一直顺序执行。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。&lt;/p&gt;
&lt;p&gt;在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 3</title>
    <link href="https://hyzgh.github.io/2019/09/29/CSAPP-learning-note-3/"/>
    <id>https://hyzgh.github.io/2019/09/29/CSAPP-learning-note-3/</id>
    <published>2019-09-29T14:38:59.000Z</published>
    <updated>2019-09-29T15:45:45.171Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看了第三章的前面五节，对机器指令有了更进一步的认识。</p><p><img src="https://s2.ax1x.com/2019/09/29/uGR19e.png" alt="程序的机器级表示 阅读进度"></p><h1 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h1><p>Intel处理器系列俗称x86，它有着一段进化之旅。从最初的8086到i386，再到i5和i7。那么它究竟有哪些方面的提升呢？</p><ul><li>晶体管数量增加。Core i7的1.4G个晶体管，是8086芯片29K个晶体管的4.8万倍。晶体管越多，意味着芯片的电路越复杂，能力越强。</li><li>指令集变大，支持更多指令。8087在8086的基础上，建立了浮点模型。</li><li>更多的位数。Pentium 4E是Intel对AMD提出的对IA32的64位拓展的实现，我们称之为x86-64。</li><li>更多的核数。Core 2是Intel的第一个多核微处理器。</li><li>更多的技术。Pentium 4E增加了超线程，允许一个处理器上同时运行两个程序。</li></ul><p>AMD等产商的大多处理器与Intel处理器兼容，能够运行完全相同的机器级程序。</p><h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><p>什么是机器代码呢？我们知道，C语言会经过预处理、编译、汇编、链接这些过程。</p><ul><li>预编译：拓展源代码，主要处理对象是#include及#define。</li><li>编译：产生源文件的汇编代码，拓展名为.s。</li><li>汇编：产生二进制目标代码，拓展名为.o。</li><li>链接：将多个.o文件转化成一个可执行文件。</li></ul><p>所谓机器代码，第一种是指.o文件中的代码，第二种是指可执行文件中的代码。它们的区别在于前者还没有填入全局值的地址。</p><p>机器代码是一些二进制代码，不具有可读性。汇编代码非常接近机器代码，我们可通过学习汇编代码来认识机器代码。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>Intel的体系结构一直在变化，从16位到32位，再到64位，可能以后还会拓展到128位。</p><p>Intel用以下术语来表示不同的数据类型。</p><table><thead><tr><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>字节</td><td>b</td><td>1</td></tr><tr><td>字</td><td>w</td><td>2</td></tr><tr><td>双字</td><td>l</td><td>4</td></tr><tr><td>四字</td><td>q</td><td>8</td></tr><tr><td>单精度</td><td>s</td><td>4</td></tr><tr><td>双精度</td><td>l</td><td>8</td></tr></tbody></table><h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>一个CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。</p><p>我们知道，程序运行时，其数据存放在内存中。CPU需要一些指令来进行内存与寄存器间的数据转移，称为数据转移指令。</p><p>我们也知道，程序运行时，在内存中有一个对应的程序栈。CPU有专门指令进行入栈、出栈操作。可否将这些指令去掉呢？可以，存在代替指令。但是这样做，会让机器代码增多，考虑到入栈出栈操作是非常常见的，所以提供专门的指令会缩减机器代码的大小。这也就是在精简指令集上编译出来的机器代码比复杂指令集庞大的原因。</p><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>所谓算术操作，指的是加减乘除等操作。所谓逻辑操作，是指与或移位等操作。</p><p>通过学习汇编代码的算术和逻辑操作，对于高级语言的便利性有了更具体的认识。一条C语言简单的算术表达式，转化成汇编代码，会变成多条。对于一些更复杂的循环控制语句，就更复杂了。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看了第三章的前面五节，对机器指令有了更进一步的认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/29/uGR19e.png&quot; alt=&quot;程序的机器级表示 阅读进度&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;历史观点&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 2</title>
    <link href="https://hyzgh.github.io/2019/09/15/CSAPP-learning-note-2/"/>
    <id>https://hyzgh.github.io/2019/09/15/CSAPP-learning-note-2/</id>
    <published>2019-09-15T15:31:06.000Z</published>
    <updated>2019-09-15T16:30:27.734Z</updated>
    
    <content type="html"><![CDATA[<p>这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。</p><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>整数运算的分类主要有两个维度，一个是无符号数、有符号数，另一个是加法、乘法。</p><p>之前知道编译器会将乘法转化成加减法/移位，但始终不知所以然。这次通过阅读CSAPP，深入理解了它的原理，另外知道了还可以将除法转化为加减法/移位。</p><p>这一节讲得都是规律和证明，这里不再赘述。贴一张图进行总结，以方便以后回忆。</p><p><img src="https://s2.ax1x.com/2019/09/16/nRiAaT.png" alt="image-20190915234925595"></p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>阅读完这一节后，对于浮点数的表示、运算、舍入等有了更深入的理解。</p><p>其中，有的地方一开始不是很理解，当弄懂后，觉得这些设计很优雅、很聪明。</p><p>比如，对于IEEE非规范值得设计不是很理解，为什么要增加复杂性呢。后来，明白了非规格值的设计，使得0的表示很加自然且靠近0的浮点数分布得更均匀。</p><p>比如，一开始不太明白为什么要有偶数舍入法，直接四舍五入不行吗。后来，明白了偶数舍入法是对四舍五入的一种改进，避免了舍入所造成的统计误差。</p><p>还有浮点的运算，不遵循结合律，这是之前没有注意到但也是十分重要的知识点。</p><p><img src="https://s2.ax1x.com/2019/09/16/nRikZV.png" alt="image-20190916000251225"></p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。&lt;/p&gt;
&lt;h1 id=&quot;整数运算&quot;&gt;&lt;a href=&quot;#整数运算&quot; class=&quot;headerlink&quot; title=&quot;整数运算&quot;&gt;&lt;/a&gt;整数运算&lt;/h1&gt;&lt;p&gt;整数运算的分类主要有两
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 1</title>
    <link href="https://hyzgh.github.io/2019/09/08/CSAPP-learning-note-1/"/>
    <id>https://hyzgh.github.io/2019/09/08/CSAPP-learning-note-1/</id>
    <published>2019-09-08T14:18:17.000Z</published>
    <updated>2019-09-08T12:47:05.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一周看完了第一章，这一周继续看第二章。本章的内容和信息的表示和处理有关，这部分内容之前修计算机组成原理时有学习到，所以阅读起来比较顺利，预计下周能顺利读完此章。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这一章的内容分为四小节，分别是：</p><ul><li>信息存储</li><li>整数表示</li><li>整数运算</li><li>浮点数</li></ul><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p><a href="https://hyzgh.github.io/2019/08/30/CSAPP-learning-note-0/">上篇笔记</a>谈到了信息，什么是信息？信息是数据+上下文。</p><p>在不同的上下文中，数据会有不同的含义。一个字节，既可表示一个字符，也可表示范围在[0, 256)的无符号整数，也可表示范围在[-128, 128)的有符号整数，还可以表示具有8个元素的集合，等等。</p><p>大多数机器使用8位的块，称为字节，作为最小的可寻址的内存单位，而不是直接访问内存中单独的位。字长为32位的机器，寻址的最大空间是$2^{32}$字节，而字长为64位的机器，寻址的最大空间就是$2^{64}$字节。什么是字长呢，字长用于指明指针数据的标称大小。</p><p>因为一个字节有8个位，用二进制表示起来有点冗长，而用十进制表示法的话，与位模式的互相转化会很麻烦。于是就有了十六进制数来表示位模式，在二进制和十进制取了折中，既方便表示，又不那么难读。</p><p>假如我们想要访问跨越多字节的对象，需要建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。对象地址的寻址范围根据字长而定，当字长为$w$时，可寻址空间为$2^{w}$。确定好对象的起始地址，还需要知道它有多少个字节以及如何排列这些字节。假设读取对象为<code>int</code>，有四个字节，且在内存中从低址到高址的内容为<code>0x00000001</code>，采用大端法读取就是$1$，采用小端法读取就是$2^{24}$。大端表示法比较符合人类的习惯，而小端法需要将数据按字节倒序排列。这些数据在机器中的字节排列通常对我们没有影响，但当涉及到网络编程时，就需要关注网络传输数据和机器存储数据的区别了。</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>整数在计算机中有多种表示形式，比如原码、补码、反码等。</p><p>而编程语言中遇到的整数类型，比如<code>short</code>, <code>int</code>, <code>long long</code>等，是对整数大小的限制。</p><p>而常说的有符号数、无符号数，则是在人类限制整数能否表示负数而产生。我认为有符号数和无符号数的设计其实意义不大，只用一种有符号数来表示整数就足够了。有了无符号数和有符号数，就需要用户去关注无符号数和有符号数的转化，一些隐式转化很容易引起出人意料的隐蔽错误。在Java中，并没有无符号数的概念，而在C语言中，有符号数和无符号数的转化，其实整数在底层的位表示中是不变的，只是C语言在不同的上下文中对它进行了不同的解释。</p><p>无符号数，采用简单的原码编码即可。而有符号数，一般采用补码编码，因为相对于源码、反码，它能表示更多一个数，更重要的是，机器中的位表示与整数是一个双射关系，很优雅。</p><p>无符号数和有符号数的转化，在理解了机器的位表示始终不变以及补码的相关知识后，我们可以总结出规律。我们这里假设两者的位数都为$w$。将无符号数转化为有符号数，当超过其表示范围时，需要减去$2^w$。将有符号数转化为无符号数时，负数需要加上$2^w$。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一周看完了第一章，这一周继续看第二章。本章的内容和信息的表示和处理有关，这部分内容之前修计算机组成原理时有学习到，所以阅读起来比较顺利，预
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 0</title>
    <link href="https://hyzgh.github.io/2019/08/30/CSAPP-learning-note-0/"/>
    <id>https://hyzgh.github.io/2019/08/30/CSAPP-learning-note-0/</id>
    <published>2019-08-29T16:08:59.000Z</published>
    <updated>2019-08-30T15:16:26.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CSAPP（深入理解计算机系统）这本书豆瓣评分接近满分，是学习计算机系统的经典教材之一。这一周开始阅读此书，并计划以后每周写一篇学习笔记。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>数据和信息是两个含义不同的词。数据是“死”的，而信息是“活”的。举个例子，阿拉伯数字8，在不同的情景下，可传递不同的信息。当电梯中可表示第8层，在桌球桌上可表示黑球8，而在聊天中可表示”拜拜”的意思。是什么赋予了它内涵？是情景，也称作上下文。在计算机系统中，数据就是比特串，是一个一个的位，再加上具体的上下文，就成为了信息。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一个C语言程序，需要经过预处理器、编译器、汇编器、链接器的翻译，才能转化成可执行目标程序。</p><p>编译是个转化数据的过程。转化前是源代码，是人类可以理解的信息。而转化后，变成了机器语言，变成了人类无法理解的信息，而机器在一定的上下文中，能够理解这些数据。机器语言是机器能够理解的信息。</p><p>学习编译系统，可以帮助我们优化程序性能、理解链接时出现的错误、避免安全漏洞等。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>编译后产生的可执行文件在磁盘里。当我们执行该文件时，计算机系统是怎么运作的呢？</p><p>假设我们是在shell执行该程序的。键盘是一个外部设备，通过系统I/O总线和其他硬件连接在一起。当我们通过键盘输入可执行文件的文件名时，字符串会通过总线被逐一读入CPU中的寄存器并送入内存，且会输出到图形适配器（所以我们才可以在屏幕上看到输入的字符）。当输入回车后，shell就会通过一系列的指令来执行该程序，将程序的文件内容装载进内存，开始子进程，将CPU让给它执行。这个过程中，不同的指令，会让数据在CPU、内存、I/O设备间流动，比如输出文字到屏幕、通过网络下载文件等。</p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>所谓高速缓存，是为了解决CPU从寄存器读取数据与从内存读取数据的速度差异问题。CPU从寄存器读取数据比从内存读取数据要高几个数量级。所以一个自然的想法是提高寄存器的容量，这是一个解决思路，但是因为寄存器的价格要比内存贵得多，大幅提高容量从经济的角度考虑不太现实。另一个解决思路是提高主存的读取速度，这很接近现在大部分计算机系统采用的方法了。根据计算机组成原理的知识，我们知道SRAM的读取性能比DRAM的快得多，且SRAM也分多种，不同的SRAM实现会有不同的性能表现，价格也有差异。因为SRAM的价格还是要比DRAM高，大量采用SRAM作为主存也不现实。因此形成了一种折中的方案，采用DRAM作为主存，SRAM作为CPU的高速缓存。当CPU执行指令时，首先会从寄存器取数据，假如取不到，再到高速缓存取，假如还取不到，才到主存取。通过引进高速缓存，缓解了CPU执行速度与从内存读取数据速度不匹配的问题。</p><p>利用局部性原理，可提高高速缓存的命中率，让CPU尽可能快地取到指令去执行，提高整体效率。至于高速缓存中的数据与内存中的数据的映射，则涉及到了计算机组成原理，这里不再深入讲述。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>所谓抽象，在生活中其实随处可见。记得《人类简史》中写到，人类区别于其他生物的重要原因便是想象力丰富。人类之间通过讲述各种故事，塑造各种抽象概念，诸如宗族、城市、国家等概念，让原本互不认识的人有了联系的纽带，共同合作，诞生了各种文明。计算机系统中也有各种抽象概念，诸如文件、虚拟内存、进程。这些抽象，在我看来，是人类设计冯诺依曼计算机的基础，没有这些概念，计算机系统便不知道从何说起。</p><p>文件时什么？文件是一些二进制位在I/O设备中的抽象。</p><p>虚拟内存是什么？虚拟内存是程序的在主存和I/O设备中的空间的抽象。</p><p>进程是什么？进程是程序在CPU、主存、I/O设备活动的抽象。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CSAPP（深入理解计算机系统）这本书豆瓣评分接近满分，是学习计算机系统的经典教材之一。这一周开始阅读此书，并计划以后每周写一篇学习笔记。&lt;
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习笔记</title>
    <link href="https://hyzgh.github.io/2019/07/31/Go-learning-note/"/>
    <id>https://hyzgh.github.io/2019/07/31/Go-learning-note/</id>
    <published>2019-07-31T15:59:21.000Z</published>
    <updated>2019-08-01T09:24:02.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用packages"><a href="#常用packages" class="headerlink" title="常用packages"></a>常用packages</h1><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>Printf</code></p><table><thead><tr><th>verb</th><th>描述</th></tr></thead><tbody><tr><td>%v</td><td>输出值</td></tr><tr><td>%+v</td><td>输出键-值</td></tr><tr><td>%#v</td><td>输出包名、类型名、键-值</td></tr><tr><td>%T</td><td>类型</td></tr><tr><td>%%</td><td>百分号</td></tr><tr><td>%t</td><td>布尔值</td></tr><tr><td>%b</td><td>二进制的值</td></tr><tr><td>%c</td><td>Unicode编码的字符</td></tr><tr><td>%d</td><td>十进制的值</td></tr><tr><td>%o</td><td>八进制的值</td></tr><tr><td>%x或%X</td><td>十六进制的值</td></tr><tr><td>%U</td><td>十六进制表示的Unicode值</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%p</td><td>地址</td></tr><tr><td>%f</td><td>浮点数，默认精度是小数点后6位</td></tr><tr><td>%e</td><td>浮点数，科学计数法，默认精度是小数点后6位</td></tr><tr><td>%g</td><td>浮点数，有效数字，尽可能地输出所有位数</td></tr><tr><td>+</td><td>添加正负号</td></tr><tr><td>-</td><td>设置宽度时默认在左边补全空格，该符号可设置在右边补全空格</td></tr><tr><td>0</td><td>用0代替空格进行补全</td></tr><tr><td>#</td><td>对于八进制，十六进制等，加上提示符，如八进制为0，十六进制为0x</td></tr></tbody></table><p><code>%f</code> 可指定浮点数的宽度和精度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%f     default width, default precision</span><br><span class="line">%9f    width 9, default precision</span><br><span class="line">%.2f   default width, precision 2</span><br><span class="line">%9.2f  width 9, precision 2</span><br><span class="line">%9.f   width 9, precision 0</span><br></pre></td></tr></table></figure><p><code>%g</code> 可指定浮点数的有效数字位数，对于12.345，<code>%.3g</code> 将输出 12.3</p><p>若要能对某个自定义类型输出，只要对它定义<code>String() string</code>方法即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d/%g/%q"</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当t是*T类型时，才会调用上面那个函数</span></span><br><span class="line"><span class="comment">// 若要当t是T类型和*T类型都都调用上面那个函数，需要将上面的*T改成T</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, t)</span><br></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>会将内容输出到stderr，且会增加一些信息（如日期时间）。</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>注意只有当结构体内的成员是公开时，才能在Marshal的时候被识别，成为json文件的一部分。</p><p>进行Unmarshal时，假如json中有的字段而结构体没有，则这个字段会被忽略，不影响解析。也就是说，可进行json文件的部分解析。同理，假如Marshal时，结构体中的字段不想转到JSON文件中，可以将其tag设置为”-“。</p><p>解析时，结构体的某个字段的匹配优先级为tag -&gt; 导出名精确匹配 -&gt; 导出名模糊匹配。</p><p>omitempty表示当字段为零值时忽略它，而tag为”-“表示直接忽略它。</p><p>UnmarshalText函数和UnmarshalJSON函数的区别是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当不知道json文件的格式时，可这样解析</span></span><br><span class="line">b := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is string"</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is float64"</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">      fmt.Println(k, <span class="string">"is an array:"</span>)</span><br><span class="line">      <span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">        fmt.Println(i, u)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is of a type I don't know how to handle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若将结构体的成员设置为指针类型，则若json不存在相应的字段，则为nil</span></span><br><span class="line"><span class="keyword">type</span> IncomingMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">  Cmd *Command</span><br><span class="line">  Msg *Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于流的Encoders和Decoders</span></span><br><span class="line">de := json.NewDecoder(os.Stdin)</span><br><span class="line">enc := json.NewEncoder(os.Stdout)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := dec.Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> k := <span class="keyword">range</span> v &#123;</span><br><span class="line">    <span class="keyword">if</span> k != <span class="string">"Name"</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(v, k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := enc.Encode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Basic-component"><a href="#Basic-component" class="headerlink" title="Basic component"></a>Basic component</h1><h2 id="package-import"><a href="#package-import" class="headerlink" title="package | import"></a>package | import</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何go程序都是由package组成，首个非空单词必须是package</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个import</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个import</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><p>形式：形参的标识符在前，类型在后；返回值放在最后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的主要原因是为了提高易读性，特别是在涉及函数变量（函数指针）的时候</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> <span class="title">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>同类型的形参可简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值可有多个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可给返回值命名，且return可简写，注意不要在长函数中简写，因为这样会降低可读性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="variables-constants-types"><a href="#variables-constants-types" class="headerlink" title="variables | constants | types"></a>variables | constants | types</h2><p>首字母大写的变量称为exported name</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  Address <span class="keyword">string</span>  <span class="comment">// exported name</span></span><br><span class="line">  cost <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申明格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单句</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有赋初值时，可省略类型名</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">d := <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当省略类型名时，编译器会自动推测，推测规则为：</p><ul><li>右边是变量，则和变量的类型相同</li><li>右边是常量，则有可能是int, float64, complex128</li></ul><p>基础类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>申明的变量假如没有被显式赋初值，则会被赋<code>zero value</code>，即数值为0，布尔类型为false，字符串为””，指针为nil</p><p>申明常量，用<code>const</code>，不能用<code>:=</code>，因为<code>:=</code>是和<code>var</code>关联的，而<code>var</code>代表变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">"世界"</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello"</span>, World)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有隐式类型转换，必须显式类型转换。</p><p>类型断言，用于将空接口转换为普通类型。类型断言又分为安全类型断言和非安全类型断言。</p><ul><li>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;<strong>.</strong>(目标类型)  // 安全类型断言</li><li>&lt;目标类型的值&gt; := &lt;表达式&gt;<strong>.</strong>(目标类型)  // 非安全类型断言</li></ul><p>在函数体内，变量申明了但不使用会报错。同理，import的package没用的话也会报错。</p><p>Go在函数体中定义了一个变量，然后将它的指针返回是合法的，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">// 或者将上面两行简写成return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">    <span class="comment">// 不难发现new(File)和&amp;File&#123;&#125;是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="More-types"><a href="#More-types" class="headerlink" title="More types"></a>More types</h1><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>指针，和C不一样，Go没有指针的算术运算，即不支持<code>p = p + 10</code>这样的语句</p><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>结构体，可将<code>(*p).X</code>写成<code>p.X</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// has type Vertex</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 is implicit</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 and Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// has type *Vertex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>In Go：</p><ul><li>Arrays are values. Assigning one array to another copies all the elements.</li><li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li><li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line">    fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如想要像C那样只传数组的地址，可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// Note the explicit address-of operator</span></span><br></pre></td></tr></table></figure><p>虽然可以这么写，但不推荐，因为更优雅的方法是使用slices。</p><h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>切片，本身不存储实际数据，类似于引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片数组，可以改变指向的范围</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    t := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">    r = t</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片，可省略下界或上界</p><p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p><p><code>len()</code>查看长度，即从下界到上界的个数</p><p>切片为<code>nil</code>时，<code>cap</code>和<code>len</code>都为0</p><p>使用<code>make</code>来创建一维切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line">    printSlice(<span class="string">"b"</span>, b)</span><br><span class="line"></span><br><span class="line">    c := b[:<span class="number">2</span>]</span><br><span class="line">    printSlice(<span class="string">"c"</span>, c)</span><br><span class="line"></span><br><span class="line">    d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">        s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>make</code>创建二维切片，第一种方式，该方式允许第二维大小有所变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可使用<code>append</code>函数向切片添加元素，假如切片容量不足，则容量会翻倍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>append</code>函数向切片中添加切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩减切片的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ugly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elegant，缩减了切片的cap，释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><code>maps</code>的零值为<code>nil</code>，可通过<code>make</code>创建<code>map</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化时，值的类型名可省略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入键值对，取键的值，删除键值对（可多次删除，可删除不存在的键）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map被函数调用，可被修改。</p><h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也可以作为值，可以像其他数据类型一样赋值给变量，作为实参等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function-closures"><a href="#Function-closures" class="headerlink" title="Function closures"></a>Function closures</h2><p>函数闭包，不同变量可以绑定不同的函数闭包，相互之间不影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(</span><br><span class="line">            pos(i),</span><br><span class="line">            neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Flow-control-statements"><a href="#Flow-control-statements" class="headerlink" title="Flow control statements"></a>Flow control statements</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>，可以没有<code>()</code>，但一定要有<code>{}</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>可以像<code>for</code>那样先带个statement。假如申明了变量，则只能在<code>if</code>或后续的<code>else</code>中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can't use v here, though</span></span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>，可以没有<code>()</code>，但一定要有<code>{}</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(condition)</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code>, 满足其中一个<code>case</code>即执行其中的语句，不会再执行其他case的语句，可看成自带<code>break</code>。此外，<code>case</code>不一定要接整数常量，它可以不是整数，可以不是常量。但要注意<code>case</code>后接的类型和<code>switch</code>比较的类型相同。</p><p><code>switch</code>同样可以像<code>for</code>那样先带个statement，且<code>default</code>的位置可放在首位，因为它总是会在所有条件都不匹配的时候才执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>还可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><code>defer</code> 推迟执行，具有LIFO的性质</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"1 "</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"2 "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"3 "</span>)</span><br><span class="line">    <span class="comment">// 将输出3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defer</code>还可以这样写，参数部分的函数是会先执行的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">entering: b</span></span><br><span class="line"><span class="comment">in b</span></span><br><span class="line"><span class="comment">entering: a</span></span><br><span class="line"><span class="comment">in a</span></span><br><span class="line"><span class="comment">leaving: a</span></span><br><span class="line"><span class="comment">leaving: b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="Methods-and-interfaces"><a href="#Methods-and-interfaces" class="headerlink" title="Methods and interfaces"></a>Methods and interfaces</h1><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go没有<code>class</code>，但可以给方法（函数）指定适用的类型。<code>method</code>是指定类型的<code>function</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>methord</code>指定的类型可以是基本类型，但所指定的类型必须在本<code>package</code>出现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>methord</code>指定的类型可以是指针，则我们可以修改指针指向的内容，并且不用产生拷贝开销。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口，要求使用接口的类型实现了接口中方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line">    <span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">    <span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口中的方法不需要像其他语言那样使用显式的关键字，如<code>implement</code>。</p><p>这样做可以让申明和实现分离，不需要特殊处理就可以让他们放在不同的包中。</p><p>接口可以看成是一个二元组<code>(value, type)</code>，对于一个<code>value</code>，它会调用接收了<code>type</code>的方法。</p><p>假如一个变量是接口类型的，那么它有可能<code>value</code>和<code>type</code>都为<code>nil</code>，这种情况下会RE。而当<code>type</code>不为<code>nil</code>时，它是非空的，但是<code>value</code>可能会空，因此我们需要在实现接口的方法里处理好这种情况。</p><p>空接口，用于存储任何类型的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">42</span></span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="string">"hello"</span></span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言，在断言不成立的时候应该用两个变量存储结果，否则会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// panic</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type switch</code> 可以依次进行多个类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code> 用于输出自定义类型的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years)"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">"Arthur Dent"</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">"Zaphod Beeblebrox"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Error</code> 用于输出错误信息的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">"it didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code> 用于读取数据的接口</p><p><code>func (T) Read(b []byte) (n int, err error)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Images</code> 用于处理图像的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="keyword">int</span>) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><p>Goroutines 轻型线程，它们共享同一地址的内存，需要同步控制</p><p><code>go f(x, y, z)</code> 创建一个新Goroutine运行函数<code>f</code></p><p>Channels 可用于传递数据的一种数据类型，需要用到运算符<code>&lt;-</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffered Channels 可理解为大小的Channel，满了还往里面添加的话会报错</p><p>可使用range来取出channel中的所有数据，注意channel要close</p><p><code>&lt;-ch</code>实际上会返回两个值，第二个值代表是否还有数据，即<code>false</code> 表示channel close了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code>用于多个channel的选择，哪个channel有数据就执行哪一个，假如同时有数据来了，就随机先执行其中一个</p><p><code>select</code>中的<code>default</code>在没有收到任何channel数据的时候执行</p><p><code>sync.Mutex</code>  用于互斥</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    c.v[key]++</span><br><span class="line">    c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the current value of the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Diagnostics-诊断"><a href="#Diagnostics-诊断" class="headerlink" title="Diagnostics | 诊断"></a>Diagnostics | 诊断</h1><h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起手式</span></span><br><span class="line">cpuProfile, _ := os.Create(<span class="string">"cpu_profile"</span>)</span><br><span class="line">pprof.StartCPUProfile(cpuProfile)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><p><code>go tool pprof &lt;file&gt;</code></p><p><code>web</code> 启动可视化界面</p><p><code>top</code> 列出cpu占比最高的函数</p><p><code>list &lt;function&gt;</code> 列出指定函数的数据</p><h1 id="Go-Command"><a href="#Go-Command" class="headerlink" title="Go Command"></a>Go Command</h1><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p>假如想要玩一下<code>go build</code>命令，注意加上<code>-a</code>重新全部编译，否则会因为有缓存而跳过编译过程。</p><p>假如是main，则会编译生成可执行文件。</p><p>否则，只会编译，不产生文件，用于验证代码能否编译。</p><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p>假如是main，则会在$GOPATH/bin下生成可执行文件。</p><p>否则，会在$GOPATH/pkg下生成*.a文件。</p><h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">go get -u &lt;package&gt;</span><br></pre></td></tr></table></figure><h2 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h2><p>删除编译生成的文件等等。</p><h1 id="依赖管理工具"><a href="#依赖管理工具" class="headerlink" title="依赖管理工具"></a>依赖管理工具</h1><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化，-v参数代表输出详细信息</span></span><br><span class="line">dep init -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决依赖的BUG</span></span><br><span class="line">dep ensure -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新依赖，假如总是更新失败，先dep ensure -v一下，并选择在网络空闲的时候更新</span></span><br><span class="line">dep ensure -update -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条依赖</span></span><br><span class="line">dep ensure -add github.com/bitly/go-simplejson</span><br></pre></td></tr></table></figure><h2 id="Go-Mod"><a href="#Go-Mod" class="headerlink" title="Go Mod"></a>Go Mod</h2><p>拉取速度比Dep要快很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，生成go.mod文件</span></span><br><span class="line">go mod init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后即可使用go build或go test拉取依赖</span></span><br><span class="line">go build/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级所有依赖到最新</span></span><br><span class="line">go get -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将依赖放在项目的vendor中</span></span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>假如遇到某个依赖有问题，更把那个依赖删掉，然后再<code>go get -u</code>升级所有依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用packages&quot;&gt;&lt;a href=&quot;#常用packages&quot; class=&quot;headerlink&quot; title=&quot;常用packages&quot;&gt;&lt;/a&gt;常用packages&lt;/h1&gt;&lt;h2 id=&quot;fmt&quot;&gt;&lt;a href=&quot;#fmt&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Go" scheme="https://hyzgh.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>理财入门</title>
    <link href="https://hyzgh.github.io/2019/07/13/financial-management/"/>
    <id>https://hyzgh.github.io/2019/07/13/financial-management/</id>
    <published>2019-07-13T13:02:59.000Z</published>
    <updated>2019-07-13T14:01:07.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理财，同时也是提高自我认知的过程。此博文记录了自己的理财学习之路，希望能对读者有些帮助。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>管理好自己的财产的第一步，是要对自己的支出收入情况有所了解。假如一个人对自己的收支情况一点不了解，就算中了百万彩票，挥金如土，也会很快被挥霍完。而假如一个人对于自己的收支情况了然于胸，量入为出，才能过得很踏实。</p><p>在这里，通过一番比较后，我选择了复式记账法，并采用了beancount和fava这两个工具。网上介绍这两个工具的好文章已有不少，这里不再赘述使用方法，而只提一下它的优点。beancount，它是开源的，它可以让你以纯文本的形式记账，并将数据保存在自己的电脑上，保证了数据的可移植性和安全性，无需支付额外费用，使用成本低。另外，利用fava可将数据可视化，可以直观地看到自己的财务情况，非常方便。</p><p>很多人之所以不能坚持记账，大多数是因为记账太过繁琐，且记账产生的数据像一潭死水，无法产生实际的指导价值。而用beancount+fava，可以克服这两个缺点。现在大多数网站，比如支付宝和微信支付，都可以导出账单，我们不难写个脚本将其转化成符合beancount语法的文本数据。fava将数据可视化后，含有损益表、资产负债表、试算表、资产、统计等界面，可以很直观地看到自己的收支情况、资产负债情况等。这些东西需要一些财务知识才能理解，我主要通过搜索引擎+看书来学习，这里推荐一本书，书名叫《给创业小白的财报书》，豆瓣评分9.0，值得一读。</p><p>我认为实现财务自由最关键的是增加收入以及通过投资来增加净资产。增加净资产，可以通过购买债券、基金、股票、房地产等方式。待所购资产实现增值后，我们的净资产也就增加了。现在我对于存款的处理方式是直接购买基金，因为比较方便。但是购买基金是一种低风险低收益的投资活动，虽然可以实现财富增长，但若想尽快实现财务自由这个目标，依靠此方式是行不通的。所以有必要去学习其他投资方式，这里挖个坑，以后学了再补上。</p><p>虽然财务自由听起来很虚幻很遥远，但是我觉得通过一定的努力是能够达到的。当然，每个人对于财务自由的定义会有所不同，我自己的要求比较低，<strong>资产所产生的收益能超过日常开销即算财务自由</strong>。共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理
      
    
    </summary>
    
    
      <category term="理财" scheme="https://hyzgh.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
</feed>
