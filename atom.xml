<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hyz&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyzgh.github.io/"/>
  <updated>2020-09-13T14:56:32.644Z</updated>
  <id>https://hyzgh.github.io/</id>
  
  <author>
    <name>hyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活记录-拔智齿</title>
    <link href="https://hyzgh.github.io/2020/09/13/life-record-wisdom-tooth/"/>
    <id>https://hyzgh.github.io/2020/09/13/life-record-wisdom-tooth/</id>
    <published>2020-09-13T09:20:30.000Z</published>
    <updated>2020-09-13T14:56:32.644Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间去体检的时候，医生建议我把左边的下智齿给拔了，原因是长得不好，牙齿间有较大空隙，会藏食物，不好清理。其实之前去洁牙的时候有拍片，也建议我把它拔了，但是由于某些原因没有拔。一是因为除了清理比较麻烦外，暂时没有造成实际的影响（比如疼痛）。二是因为在深圳广州拔牙很贵，那时不确定学校的医保给不给报销，就拖到了现在。</p><p>前些天深圳的社保卡刚办理好，于是打算去把这颗智齿拔了，防止它藏食物所造成的潜在口腔疾病风险。</p><p>在出发前，查了一些资料，以及从同事那里获取了一些信息。得知拔阻生齿是可以走医保统筹报销以及商业保险的，但是实际上并不是所有拔牙都可以这样。事后推测同事应该是因为是手术才可以走医保统筹报销。正常的话，拔牙只能走医保个人账户以及商业保险。</p><p>在深圳，医保根据缴纳比例的不同，分成一二三档。对于不同档的参保者，有不同的医保待遇。通过查询公司的文档，我得知公司给我缴纳的是一档医保。</p><p>通过查询资料，学习了一下针对深圳一档参保者的知识点，摘抄如下：</p><ul><li>需要到定点医疗机构就医才能享受医疗保险待遇。</li><li>走统筹报销的，由市社会保险机构与定点医疗机构或定点零售药店按协议约定结算。</li><li>走个人账户支付的，由本市定点医疗机构或定点零售药店从参保人的个人账户中划扣，个人账户不足支付的，应当由参保人现金支付。</li><li>在非本市定点医疗机构发生的医疗费用，由参保人先行支付后向市社会保险机构申请报销，市社会保险机构按本办法的规定予以审核，符合条件的予以支付。参保人先行支付医疗费用的，应在费用发生或出院之日起十二个月内申请报销，逾期不予报销。</li><li>参保单位、参保人中断缴交医疗保险费的，自中断缴交的次月1日起，停止享受医疗保险统筹基金支付的医疗保险待遇，但其个人账户余额可继续使用。<strong>注意不要断保。</strong></li><li>基本医疗保险药品、诊疗项目、服务设施标准的目录按照国家及广东省公布的目录执行。可参考：<a href="http://www.nhsa.gov.cn/art/2019/8/20/art_37_1666.html" target="_blank" rel="noopener">《国家基本医疗保险、工伤保险和生育保险药品目录》</a>。<strong>一般也不需要特别关注这个目录，假如能走统筹报销的话，支持的时候自然也会走报销。假如想要省钱的话，可以在就医时，告诉医生尽量用目录里的药物。另外在去药店买药时，也可以查一查这个目录，在这个目录再去买，否则网上买可能实惠些。</strong></li><li>基本医疗保险一档参保人个人账户用于支付参保人门诊基本医疗费用、地方补充医疗费用、在定点零售药店凭本市市内定点医疗机构医生开具的处方购买医疗保险目录范围内药品的费用，个人账户不足支付部分由个人自付。基本医疗保险一档参保人连续参保满一年，在同一医疗保险年度内个人自付的门诊基本医疗费用和地方补充医疗费用超过本市上年度在岗职工平均工资5%的，超过部分由基本医疗保险大病统筹基金或地方补充医疗保险基金按规定支付70%，参保人年满70周岁以上的支付80%。</li><li>基本医疗保险一档参保人个人账户积累额超过本市上年度在岗职工平均工资5%的，超过部分可以用于买药、给家人用等。</li><li>基本医疗保险一档参保人在本市定点社康中心发生的基本医疗费用和地方补充医疗费用，70%由其个人账户支付，30%由基本医疗保险大病统筹基金、地方补充医疗保险基金按规定支付。但不包括<strong>口腔科治疗费用</strong>、康复理疗费用、大型医疗设备检查治疗费用等。</li><li>基本医疗保险一档参保人在本市定点医疗机构门诊做大型医疗设备检查和治疗所发生的基本医疗费用、地方补充医疗费用，80%由基本医疗保险大病统筹基金、地方补充医疗保险基金按规定支付。</li><li>统筹基金、地方补充医疗保险基金存在支付限额，连续参保时间越久，限额越高。连续三个月断保需要重新计算，<strong>因此注意不要断保。</strong></li></ul><p>我这次选择了去北京大学深圳医院的口腔科拔牙，在深圳，这家医院的实力是最顶尖的之一。口腔科下也细分了许多科室，需要注意不要挂错科室了。拔牙需要挂牙槽外科。因为新冠病毒的原因，需要在医护人员的引导下填写一张表单。中途等号的时候有点担心需要做完新冠病毒检测才能拔牙，时间可能不够。实际上并不需要做检测就可以拔牙了。</p><p>就诊医生有点迟到，但是我来得比较早，很快就排到我了。医生肉眼检查了一下我的智齿，发现看得不是很清楚，并且我也无法提供拍片的照片，因此建议我先去拍片。于是我听从医生的吩咐，排了较长的队拍了个片。回来后医生很快就根据拍片单做出判断，跟我说明下面的左右各一颗智齿都需要拔掉，因为继续长的话会顶到其他牙齿，建议这次只拔一颗。我选择了拔左下角的那颗智齿。医生很专业，给我的左下角口腔打上麻醉，然后上电钻、钳子等各种工具，行云流水地一顿操作，感觉不到十分钟就拔完了。结束时，医生还让我看了眼自己的牙齿，挺大的完整两瓣，含着血丝。不知道能不能带走纪念，本来想问问的，但是口腔上了麻醉说话有点困难，就没问了。最后，医生问我有没有布洛芬、头孢这些药，那时候我不知道这是啥药，当然回答没有。他给我开了一些药，然后我记了下注意事项后就去付款了。感觉自己对于常见的药物并不熟悉，家里也没有备药的习惯，以后有空可以了解一下常用的药。另外做得不好的一点是，忘了询问医生药要吃多久了，以后就医的时候要问清楚用药持续时间。</p><p>接下来到了手术付款时间，花了大概1300元，不能走统筹，全部走了个人医保账户。第一次用医保，当时也不是很清楚个人账户和统筹账户的区别，后来查资料发现，统筹才是医保报销，个人医保是个人支付的。</p><p>虽然是走的个人支付，但是好在公司有商业保险，能报销90%，最后相当于自己花了100多拔了一颗智齿。感觉商业保险还是很有用的，有空可以给家人看看有什么保险可以购买，提高家庭的抗风险能力。</p><p>接下来还有另外一颗智齿要拔，由于医保账户的余额不是很够，假如现在拔的话需要走现金支付，考虑到医保一般用不完，所以有点亏。于是打算医保余额足够了，再去拔另外一颗智齿吧。</p><p>北京大学深圳医院虽然离自己住的地方有点远，并且挂号困难，但是还是值得的，因为它拥有很专业的医生。专业度这点是非常珍贵的，假如经验不足，那么可能需要花费更多的时间、做出不合适的判断、甚至在手术过程造成失误等。这一点我深有感触，由于拔完牙后还需要再去拆线，这次给我拆线的是一个实习生，给我的感觉是拆得有点艰难，耗费的时间比拔牙还要久= =、</p><p>这次拔牙，还学到了一个生活经验，即有疑问可以找有关部门咨询，这样获取信息的效率很高。比如我对于拔牙不能走统筹保险这一点比较疑惑，通过网上一顿搜索都没有找到合理的解释，最后在网上发现可以打社保局的电话（12333）咨询，于是就打电话问问。最终得到了满意的答复，解答了心中的疑惑，发现去医院做门诊一般是需要个人账户支付的，除非门诊一年累计支付超过了一定额度，才能走70%的统筹报销。其实生活中是有许多部门很有用的，包括社保局、监管部门、工信部、公安局等，有空可以多了解一下他们的职责，以便在需要的时候用上。</p><p>参考：</p><ul><li><a href="http://www.gd.gov.cn/zwgk/wjk/zcfgk/content/post_2530804.html" target="_blank" rel="noopener">深圳市社会医疗保险办法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间去体检的时候，医生建议我把左边的下智齿给拔了，原因是长得不好，牙齿间有较大空隙，会藏食物，不好清理。其实之前去洁牙的时候有拍片，也建议我把它拔了，但是由于某些原因没有拔。一是因为除了清理比较麻烦外，暂时没有造成实际的影响（比如疼痛）。二是因为在深圳广州拔牙很贵，那时
      
    
    </summary>
    
    
      <category term="life" scheme="https://hyzgh.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 7 虚拟内存</title>
    <link href="https://hyzgh.github.io/2020/08/29/CSAPP-learning-note-7/"/>
    <id>https://hyzgh.github.io/2020/08/29/CSAPP-learning-note-7/</id>
    <published>2020-08-29T09:13:37.000Z</published>
    <updated>2020-08-29T10:45:54.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没看CSAPP这本书了。最近在学习redis的AOF重写过程，发现对于涉及的一些概念有些模糊，比如fork、页表、虚拟内存、物理内存等。而且，最近在工作中也经常遇到和内存相关的问题，在利用top命令来排查内存问题的过程中，发现手册里提到的一些内存的概念，自己都不甚清晰。</p><p>于是很有必要重新捡起这本书看看，梳理一下书中第9章虚拟内存的相关知识，巩固一下基础。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>操作系统的内存是由许多进程共享的，假如进程之间内存没有独立开来，那么很有可能导致进程崩溃。</p><p>虚拟内存是现代系统提供的一种对主存的抽象概念，用于将进程间的内存空间相互独立开来。</p><blockquote><p> 现代操作系统都使用的是按需页面调度的方式。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久没看CSAPP这本书了。最近在学习redis的AOF重写过程，发现对于涉及的一些概念有些模糊，比如fork、页表、虚拟内存、物理内存等。
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《刻意练习》读书笔记</title>
    <link href="https://hyzgh.github.io/2020/06/19/PEAK-Secrets-from-the-New-Science-of-Expertise-reding-note/"/>
    <id>https://hyzgh.github.io/2020/06/19/PEAK-Secrets-from-the-New-Science-of-Expertise-reding-note/</id>
    <published>2020-06-19T03:47:33.000Z</published>
    <updated>2020-06-19T03:48:56.991Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/26895993/" target="_blank" rel="noopener">《刻意练习》</a>这本书的前半部分讲述了刻意练习是什么，为什么管用，以及杰出人物如何运用它来发展杰出的能力，后半部分讲述了如何运用刻意练习。</p><h1 id="文前页"><a href="#文前页" class="headerlink" title="文前页"></a>文前页</h1><p>提高生活技能、工作能力，都离不开大量的练习。</p><p>练习不是不断的重复，正确的练习需要好导师、有目标、有反馈等。</p><p>一万小时定律并不严谨，它存在以下几个问题：</p><ul><li>不同专业领域的技能习得时间与练习时间并不存在一个一万小时的最低阈值。</li><li>成功与练习时间并不完全成正比，天赋虽然在其中不起决定性作用，但也会是一大影响因子。</li><li>练习的成果并不与时间呈正相关，它也取决于练习方法。</li></ul><p>刻意练习的核心观点是，那些处于中上水平的人们，拥有一种较强的记忆能力：长时记忆。长时记忆正是区分卓越者与一般人的一个重要能力，它才是刻意练习的指向与本质。</p><p>通过怎样刻意练习才能够获得优秀的长时记忆呢？刻意练习的任务难度要适中，能收到反馈，有足够的次数重复练习，学习者能够纠正自己的错误。</p><p>长时记忆的培养要点：</p><ul><li>赋予意义，精细编码：能非常快地明白自己领域的单词与术语，在存储信息的时候，可以有意识地采取元认知的各项加工策略。</li><li>提取结构或模式：往往需要将专业领域的知识、提取结构或者模式以更好的方式存储。</li><li>加快速度、增加连接：在编码和提取过程方面很快，增加长时记忆与工作记忆之间的各种通路。</li></ul><h1 id="引言-天才存在吗"><a href="#引言-天才存在吗" class="headerlink" title="引言 天才存在吗"></a>引言 天才存在吗</h1><p>基因确实会在很多方面影响我们，但是，要想成为人们口中的天才，通常需要通过大量的、正确的练习。</p><h1 id="第一章-有目的的练习"><a href="#第一章-有目的的练习" class="headerlink" title="第一章 有目的的练习"></a>第一章 有目的的练习</h1><p>一个工作20年的老师并不一定比工作5年的老师有经验，通过有目的的练习，后者可以超越前者。</p><p>有目的的练习，有以下几个特点：</p><ul><li>具有定义明确的特定目标</li><li>保持专注</li><li>包含反馈</li><li>走出舒适区</li></ul><p>当遇到瓶颈时，应该鼓励自己尽力克服它，并尝试各种不同的办法，不达目的不罢休。</p><p>当实在坚持不下去的时候，可以加强自己的动机，或者降低要求（降低意志力损耗）。</p><p>在练习的过程中，要学会总结出背后的模式，在更高的层次上去掌握它。</p><h1 id="第二章-大脑的适应能力"><a href="#第二章-大脑的适应能力" class="headerlink" title="第二章 大脑的适应能力"></a>第二章 大脑的适应能力</h1><p>大脑的适应能力很强，不要给自己设限。实际上，人类身体各部位适应能力都很强。据称，最多次数的俯卧撑是46001个，最多次数的引体向上是4654个。</p><p>人类的身体有一种偏爱稳定性的倾向。因此，改变是缓慢痛苦的，但身体会适应这个过程，最终重新达成平衡，变得稳定。</p><p>经常性的训练会让大脑受到训练挑战的区域发生改变，大脑通过自身重新布线的方式来适应这些挑战。</p><p>三个重要细节：</p><ul><li>年轻的大脑适应能力更强</li><li>训练发展大脑中的某些部位，可能会对其他部位产生负面影响</li><li>由训练引起的认知和生理变化需要继续保持训练</li></ul><h1 id="第三章-心理表征"><a href="#第三章-心理表征" class="headerlink" title="第三章 心理表征"></a>第三章 心理表征</h1><p>研究表明，国际象棋大师在记忆有意义的棋盘时表现得新手好得多，但是在记忆无意义的棋盘时并不比新手好多少。同理，人们记忆有意义句子的能力，要比记忆无意义句子的能力强得多。之所以有这种现象，是因为心理表征在起作用。</p><p>国际大师心理表征的强大之处，在于他可以对棋盘进行有效地编码，记住棋子的位置和它们之间的相互关系，记住在这种局面下有效的招法，另外，还能将注意力集中在单个棋子上，并且在心理上“移动”它们，以观察对棋局的影响。简单地说，心理表征使得大师即可看到一片森林，也可以观察一棵树。</p><p>心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或其他任何事物相对应的心理结构，或具体，或抽象。</p><p>刻意练习包括创建心理表征。由于各个行业或领域之间心理表征的细节具有极大差异，我们难以给出一个十分清晰的顶层定义，但基本上，这些表征是信息预先存在的模式（比如事实、图片、规则、关系等等），这些模式保存在长时记忆中，可以用于有效且快速地顺应某些类型的局面。</p><p>心理表征的作用：</p><ul><li>有助于找出规律，进而预测未来，进行无意识决策等。比如攀援运动员可以快速选择石头。</li><li>有助于解释信息。比如一名资深足球球迷在阅读一篇足球赛的文章时，会理解得更好并记住得更多。</li><li>有助于组织信息。比如专业医生能够考虑大量的事实，根据心理表征做出诊断。</li><li>有助于制订计划。比如外科医生在第一次拿起手术刀之前，就会想象整个手术该怎么样进行，以及如何应对手术过程中出现某些意料之外的事情和潜在的风险时，应该怎么办。</li><li>有助于高效学习。比如专业音乐家在练习某件新作品时，对好的演奏有清晰的认识，进而指导自己的练习。并且，它们可以更好地认识自己犯下的错误。</li></ul><p>刻意练习的主要目的在于创建有效的心理表征。</p><h1 id="第四章-黄金标准"><a href="#第四章-黄金标准" class="headerlink" title="第四章 黄金标准"></a>第四章 黄金标准</h1><p>可以进行刻意练习的行业或领域的特点：</p><ol><li>对于绩效的衡量，总是存在客观的方面。比如象棋比赛的输赢，唱歌比赛的专家评价等。</li><li>这些行业或领域往往具有足够的竞争性，以至于从业人员有强烈的动机来训练和提高。</li><li>这些行业或领域通常都是已经形成规模，相关的技能已得到数十年甚至数世纪的培养。</li><li>这些行业或领域中，有一些从业人员还担任导师和教练，发展出一整套训练方法。</li></ol><p>刻意练习与有目的的练习，在两个重要方面上存在差别：</p><ol><li>它需要一个已经得到合理发展的行业或领域，也就是说，最杰出的从业者已达到一定程度的表现水平，使他们与其他刚刚进入的从业者明显地区分开来。</li><li>它需要一位能够布置练习作业的导师，以帮助学生提高他的水平。</li></ol><p>刻意练习的特点：</p><ul><li>刻意练习发展的技能，是已经拥有一整套行之有效的训练方法的技能。</li><li>刻意练习发生在舒适圈之外。</li><li>刻意练习包含得到良好定义的特定目标。</li><li>刻意练习是有目的的，需要人们完全的关注和有意识的行动。</li><li>刻意练习包含反馈，以及为应对那些反馈而就行调整的努力。反馈可以是来自他人或自己。</li><li>刻意练习既产生有效的心理表征，又依靠有效的心理表征。</li></ul><p>如何运用刻意练习：</p><ul><li>寻找行业中最优秀的人，推测他们为何如此优秀，向他们学习训练方法。</li><li>最佳方法是寻找一位优秀的导师，让他帮忙制定训练计划，给予自己指导和反馈。</li></ul><h1 id="第五章-在工作中运用刻意练习原则"><a href="#第五章-在工作中运用刻意练习原则" class="headerlink" title="第五章 在工作中运用刻意练习原则"></a>第五章 在工作中运用刻意练习原则</h1><p>美国的王牌飞行员计划告诉我们，可以想办法来辩认某个领域或行业中的杰出人物，然后训练其他那些表现不太出色的人，并且尽可能使后者达到前者的水平。</p><p>辨认并拒绝两种错误思想：</p><ul><li>认为某人的能力通常受到基因特征的限制。正确的做法是摆正心态。</li><li>如果足够长时间地做某件事情，一定会更擅长。正确的做法是找到不足，挖掘进步的点，寻找正确的训练方法。</li></ul><p>知识和技能是存在区别的。传统的教学方法总是强调传授更多的知识，而不是培养技能。</p><p>包含某些互动因子的方法，比如费曼学习法，有更好的效果。</p><h1 id="第六章-在生活中运用刻意练习原则"><a href="#第六章-在生活中运用刻意练习原则" class="headerlink" title="第六章 在生活中运用刻意练习原则"></a>第六章 在生活中运用刻意练习原则</h1><ul><li>找位好导师，导师的水平比自己高，并且最好是一对一指导。好的导师，他的教学和辅导应该足够高效，可以帮助自己更快地建立心理表征。</li><li>如果练习的时候在走神，或者很放松，或者只是为了好玩，那么可能不会进步。不专注，练习是没效果的，专注和投入至关重要。好的练习，应该在练习后会让自己感到大脑被掏空。</li><li>假如没有导师，自己也可以帮助自己更好地练习。在练习过程，应该思考优秀的人会怎么做，优秀的标准是怎么样的，自己与优秀的差距在哪里，最好是能通过每次练习得到反馈，看到自己的进步。</li><li>用三个F建立有效的心理表征：focus, feedback, fix.</li><li>当觉得自己停滞不前时，可以尝试不同的方式挑战自己、攻克特定的弱点等。</li><li>保持动机也许是每个投入到有目的的训练或者刻意练习中的人最终要面对的最大问题。保持动机可以从两个角度入手。<ul><li>弱化停下脚步的理由。最有效的方式是留出固定的时间来练习，不受所有其他事情所干扰。</li><li>增强继续前行的倾向。鼓励自己，精心设置目标，看到自己的进步。</li></ul></li></ul><h1 id="第七章-成为杰出人物的路线图"><a href="#第七章-成为杰出人物的路线图" class="headerlink" title="第七章 成为杰出人物的路线图"></a>第七章 成为杰出人物的路线图</h1><p>成为杰出人物通常有四个阶段：</p><ol><li>产生兴趣</li><li>变得认真。一开始，需要父母和导师以多种方式鼓励孩子，让他充满动力。在最后，孩子开始体会刻意练习带来的回报，变得越来越能够自我激励。</li><li>全力投入。学生通常会寻找最好的导师来指导自己的练习。在这个阶段，动机完全靠学生自己来保持，但家人依然能够发挥重要的支持作用。为了得到优秀的训练资源，通常要求家庭有一定的经济条件。</li><li>开拓创新。这些人所在的贡献，彻底改变了他们所在的领域或行业。他们是引领整个时代的人进入全新世界的开拓者。创新，离不开刻意练习，它需要大量的刻意练习作为基础。</li></ol><h1 id="第八章-怎样解释天生才华"><a href="#第八章-怎样解释天生才华" class="headerlink" title="第八章 怎样解释天生才华"></a>第八章 怎样解释天生才华</h1><p>杰出人物通过年复一年的刻意练习，在漫长而艰苦的过程中一步一步改进，终于练就了他们杰出的能力，没有捷径可走。</p><p>作者通过帕格尼尼、莫扎特等人的例子，表达了天才也需要大量的刻意练习。</p><p>莫扎特的父亲是一个不得志的音乐家，希望将莫扎特培养成杰出的音乐家。他在莫扎特很小的时候，就让他练习各种乐器，投入了很大的精力。莫扎特也付出了大量时间去练习，才得以成为“神童”，成为杰出的音乐家。在现代，得益于日益进步的训练资源，网上存在不少“神童”的视频，比成年人还要强。</p><p>“自闭症奇才”的能力通常在非常特定的领域或行业中出现。他们更有可能比不具备奇才的普通自闭症孩子更加注重细节，而且更倾向于反复的行为。当某件事情引起他的注意时，他们会将注意力全部集中在那件事上面，因此，他们很可能是通过大量的刻意练习培养出来的才能。</p><p>有些人会认为自己缺乏某方面的才华，比如五音不全、不擅长数学等。研究表明，这是可以通常刻意练习改进的。</p><p>智商高的人确实在一开始可能会有更好的表现，但是想变得真正杰出，训练时间比智商更重要。研究表明，国际象棋大师的智商并不比普通人高。也就是说，真正起决定性因素的是训练，而不是智商。</p><p>人的基因确实会对我们有各种影响，这目前还不明确。而且，基因我们也无法改变。唯一能做的，只是通过后天的努力来达成自己的目标。</p><h1 id="第九章-用刻意练习创造全新的世界"><a href="#第九章-用刻意练习创造全新的世界" class="headerlink" title="第九章 用刻意练习创造全新的世界"></a>第九章 用刻意练习创造全新的世界</h1><p>作者主要阐述了刻意练习的作用和影响。</p><p>作者还提到了要给各行各业的人建立心理表征，以帮助他们更好地训练。以我的理解，这里的心理表征，是一种大局观，知道杰出的人物和自己的差距在哪里，知道自己的技能树是怎么样的，知道有哪些方式可以有效提高自己的技能。当存在有效的心理表征后，就应该不断通过自身的努力来提高、完善和改进自己。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26895993/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《刻意练习》&lt;/a&gt;这本书的前半部分讲述了刻意练习是什么，为什么管用，以及杰出人物如何运用它来发展杰出的能力
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://hyzgh.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《微习惯》读书笔记</title>
    <link href="https://hyzgh.github.io/2020/05/10/Mini-Habits-reading-note/"/>
    <id>https://hyzgh.github.io/2020/05/10/Mini-Habits-reading-note/</id>
    <published>2020-05-10T08:23:52.000Z</published>
    <updated>2020-05-10T09:57:50.832Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/26877306/" target="_blank" rel="noopener">豆瓣链接</a></p><p>本书主要写了微习惯是什么，以及通过微习惯来培养好习惯的依据和规则。</p><h1 id="第一章-微习惯是什么"><a href="#第一章-微习惯是什么" class="headerlink" title="第一章 微习惯是什么"></a>第一章 微习惯是什么</h1><p>小决心优于大决心。许多人拥有大决心，但是却不去执行，效果是零。有小决心的人，更容易执行某件事情，虽然单次的收益比较小，但远大于不执行。日积月累，小决心产生的收益会很大。</p><p>拥有大决心而不执行，原因是大脑觉得这次行动很难，因此会选择逃避。拥有小决心，就不太会存在这个问题。小决心是为了让大脑接受这次行动。通常来讲，在开始后，会想花更多的时间在上面。</p><p>微习惯就是将较大的行动拆分成容易执行的小行动。比如，每天写3000字可以改成每天写50字，每天锻炼1小时可以改成每天锻炼5分钟。</p><p>养成一个习惯，需要的天数会受各种因素影响。我们假如想要养成一个习惯，不必在意需要的天数，因为重要的是坚持。当连续做某件事情时，大脑的抵触情绪会越来越低，会自然地养成习惯。当有某天没有坚持习惯时，不用气馁，一天的堕落从整个过程上看并不会影响习惯的养成，我们需要做的是克服心理上的自暴自弃。</p><h1 id="第二章-大脑的工作原理"><a href="#第二章-大脑的工作原理" class="headerlink" title="第二章 大脑的工作原理"></a>第二章 大脑的工作原理</h1><p>可以将大脑粗分为潜意识部分和意识部分。从大脑的角度看，改变习惯的两个关键点是重复和回报。如果有回报，大脑会更愿意重复一件事情。重复是潜意识大脑使用的语言，潜意识大脑喜欢效率，这是我们能养成习惯的原因。</p><p>大脑是变化缓慢、状态稳定的，因此习惯的养成过程是缓慢的，习惯的保持是稳定的。</p><p>习惯改变涉及到大脑的两个部分：前额皮层和基底神经节。前额皮层是大脑的意识部分，是管理者，负责让大脑其他部分喜欢上自己想要的东西，用于习惯的执行。基底神经节是大脑的潜意识部分，没有思想，只会一味重复，能够探测都模式，用于新习惯的重复和养成。</p><h1 id="第三章-动力VS意志力"><a href="#第三章-动力VS意志力" class="headerlink" title="第三章 动力VS意志力"></a>第三章 动力VS意志力</h1><p>动力越高，做某件事情所需的意志力就越少。假如动力是满分，那么几乎不需要意志力就会去做某件事情。而假如动力为零，那么就需要很强的意志力才能去做某件事情。</p><p>有些人会使用“激发动力”策略来养成习惯。虽然动力确实有利于执行某件事情，但是它存在诸多问题。第一，动力难以永久保持高昂，容易导致习惯在养成的过程中断。第二，动力的影响因素多，不稳定。第三，不会每次都愿意激发动力。第四，根据热情递减原则，动力会减少，假如只依靠动力，那么会动力不足。</p><p>当连续执行某个行动后，我们会注意到心中不再充满动力。这可能是更稳定和自动的基底神经节正在夺取控制权，我们应该做的是利用微习惯继续执行下去，渡过这个艰难期，迎来新习惯。</p><p>动力并不是行动的唯一基础，我们还可以依靠意志力、习惯等。动力是好东西，只是不可靠。假如我们可以借助意志力，那么动力会变得更加可靠。如果先采取行动，动力会被迅速地激发。</p><p>使用意志力来采取行动远比努力激发动力靠谱。第一，意志力很可靠。第二，意志力可以被强化。第三，意志力策略可以通过计划执行。</p><p>意志力的工作原理是什么？意志力是有阈值的，并不是取之不尽用之不竭的。引起意志力损耗的五大主要因素有努力程度、感知程度、消极情绪、主观疲劳和血糖水平。抵抗诱惑，做决定等行为都会引起意志力的损耗。</p><p>我们需要克服这五大障碍，合理使用意志力，养成习惯。</p><h1 id="第四章-微习惯策略"><a href="#第四章-微习惯策略" class="headerlink" title="第四章 微习惯策略"></a>第四章 微习惯策略</h1><p>微习惯策略就是强迫自己每天实施1到4个“小得到不可思议”的计划好的行动。这些运动小得到不会失败，小到不会因为特殊情况就被自己轻易放弃。它们有双重作用——激励自己继续做下去，并会成为微习惯。</p><p>以微习惯方式运用意志力，可以有效地减少意志力的损耗。因为微习惯的努力程度要求小、感知难度小、消极情绪低、主观疲劳小、血糖水平降低少。</p><p>微习惯能更科学地拓宽我们的舒适区。因为大脑是抗拒改变的，因此大幅度的改变会让大脑抗议，而微习惯因其微小而成之。</p><h1 id="第五章-微习惯的独特之处"><a href="#第五章-微习惯的独特之处" class="headerlink" title="第五章 微习惯的独特之处"></a>第五章 微习惯的独特之处</h1><p>微习惯能与现有习惯一较高下。大脑会抗拒大幅度改变，但是微习惯很小，被抗拒的程度会很小。</p><p>有些人在养成习惯的时候，会给自己设置一个期限。但是这是不科学的，因为习惯的形成因习惯、个体而定。微习惯策略没有截止时间，因为我们不知道需要多少时间，但是我们要寻找养成习惯的信号。</p><p>自我效能感是指对自己影响事件结果的能力的信念。微习惯能提升自我效能感。</p><p>微习惯能给我们更多的自主权，潜意识会恐惧控制，而微习惯通过将行动微小化，让潜意识意识到自己的控制权仍在，从而接受微小的变化。</p><p>微习惯能帮助自己远离恐惧、怀疑、胆怯或犹豫。行动是克服这些消极情绪的最佳武器，而微习惯能帮助自己行动。</p><p>正念是指对自己思维和行动有着清醒认识。正念是目标清晰地活着和敷衍地活着之间的区别。微习惯能让自己意识到在做什么，能培养自己的正念。</p><h1 id="第六章-彻底改变只需八步"><a href="#第六章-彻底改变只需八步" class="headerlink" title="第六章 彻底改变只需八步"></a>第六章 彻底改变只需八步</h1><ol><li>选择适合你的微习惯和计划<ul><li>不超过四个</li><li>微习惯要小到即使精疲力尽也可以执行</li><li>写下来</li></ul></li><li>挖掘每个微习惯的内在价值<ul><li>不断问自己为什么要养成这个习惯，寻找依据</li></ul></li><li>明确习惯依据，将其纳入日程<ul><li>根据时间制定</li><li>根据行为方式制定</li><li>非具体习惯</li></ul></li><li>创建奖励机制，以奖励提升成就感<ul><li>奖励，关联美好事物，比如npy、大声微笑、唱歌、吃东西、休息一下等</li><li>奖励时间点：在取得一定里程碑时，给自己奖励。在坚持不下去时，给自己奖励</li><li>奖励能提升意志力</li></ul></li><li>记录与追踪完成情况<ul><li>研究表明，把想法写在纸上时，会让其在大脑中更加突出，而打字就不具备同样的效应</li><li>可以采用纸质日历、电子数据等方式来追踪，关注自己在意的数据，比如完成天数/总天数</li></ul></li><li>微量开始，超额完成<ul><li>强化意志力</li><li>当下就取得进步</li><li>不耗尽意志力</li></ul></li><li>服从计划安排，摆脱高期待值<ul><li>我们常常在执行的过程会超额完成目标，可以记录这些数据</li><li>要把期待值和精力放在坚持目标上，而不要对任务量抱有较高的期待</li></ul></li><li>留意习惯养成的标志<ul><li>没有抵触情绪，做起来容易，不做反而更难</li><li>认同身份，比如我常运动，我喜欢阅读</li><li>行动无需考虑，不再担心，常态化</li><li>很无聊，好的习惯并不会让人兴奋，它们只是对我们有好处而已</li></ul></li></ol><h1 id="第七章-微习惯策略的八大规则"><a href="#第七章-微习惯策略的八大规则" class="headerlink" title="第七章 微习惯策略的八大规则"></a>第七章 微习惯策略的八大规则</h1><ol><li>绝不要自欺欺人。不要偷偷要求自己做得更多，要真正的微习惯</li><li>满意每一个进步。要满意，但别满足</li><li>经常回报自己，尤其在完成微习惯之后</li><li>保持头脑清醒。不管情绪是兴奋的，还是低落的，都要记住，要完成微习惯</li><li>感到强烈抵触时，后退并缩小目标。缩小目标，有利于降低意志力损耗，有利于行动的执行，开始执行要优于不执行，执行的过程会带来动力，形成正反馈</li><li>提醒自己这件事很轻松、很有趣。大脑喜欢轻松、有趣的事情</li><li>绝不要小看微步骤。不积跬步无以至千里</li><li>用多余精力超额完成任务，而不是制定更大目标</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26877306/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;豆瓣链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本书主要写了微习惯是什么，以及通过微习惯来培养好习惯的依据和规则。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://hyzgh.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题6 Group Anagrams</title>
    <link href="https://hyzgh.github.io/2020/04/06/leetcode-exercise-per-day-6-Group-Anagrams/"/>
    <id>https://hyzgh.github.io/2020/04/06/leetcode-exercise-per-day-6-Group-Anagrams/</id>
    <published>2020-04-06T08:30:17.000Z</published>
    <updated>2020-04-06T08:47:15.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，起元素为只包含英文小写字母的单词。</p><p>要求分组输出使用了相同字符构造的单词，比如tea和eat就是同类单词。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将所有的单词遍历一遍，将同类单词放到同一个位置中去，关键是这个映射要怎么实现。对于一个长度为m的单词，我们可以用O(m)的时间遍历出各字符的使用次数。接着，我们将其转化成字符串，对于某个字符，其出现次数可以编码成cnt + char，然后按照英文字母表顺序连接起来。比如，teaa编码成2a1e1t。</p><p>上面的编码使用了一个优化，即对于出现次数的0的字母，不编码到字符串中。</p><p>假如追求极致，还可以对编码继续优化。</p><ul><li>对于出现次数为1的字母，可以不写上cnt。比如teaa可以写成2aet。</li><li>当cnt很大时，可以使用整形来表示。比如250，使用char来表示需要3个字节，使用整形只要1个字节。</li></ul><p>编码是个很有趣的知识点，上面的编码方式似乎都有专门的名称，以后有空的话专门写篇博客总结一下，这里留个坑:)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; v;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: strs) &#123;</span><br><span class="line">            m[hashWord(i)].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it: m) &#123;</span><br><span class="line">            v.push_back(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">hashWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            hash += <span class="built_in">string</span>(cnt[i], <span class="string">'a'</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给一个数组，起元素为只包含英文小写字母的单词。&lt;/p&gt;
&lt;p&gt;要求分组输出使用了相同字符构造的单词，比如tea和eat就是同类单词。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题5 Best Time to Buy and Sell Stock II</title>
    <link href="https://hyzgh.github.io/2020/04/05/leetcode-exercise-per-day-5-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>https://hyzgh.github.io/2020/04/05/leetcode-exercise-per-day-5-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2020-04-05T09:29:37.000Z</published>
    <updated>2020-04-05T09:39:09.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个数组，表示每天的股票股价。可以进行无数次交易，但同一时刻只能持有一股的股票。求最大收益。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假如股价在未来是涨的，那么就应该购买。假如是跌的，就不购买。</p><p>因此，我们扫描一遍数组，维护当前最低的股价，假如遇到较高的股价，就卖出，并更新最低股价。时间复杂度为O(n)，空间复杂度为O(1)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - mi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += prices[i] - mi;</span><br><span class="line">                mi = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            mi = min(mi, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给一个数组，表示每天的股票股价。可以进行无数次交易，但同一时刻只能持有一股的股票。求最大收益。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题4 Move Zeroes</title>
    <link href="https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-4-Move-Zeroes/"/>
    <id>https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-4-Move-Zeroes/</id>
    <published>2020-04-04T09:45:48.000Z</published>
    <updated>2020-04-04T09:51:00.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3286/" target="_blank" rel="noopener">Move Zeroes</a></p></blockquote><p>给一个数组，通过交换将所有非零元素放置在前面，将所有零元素放置在后面。</p><p>要求In-place，即不能使用额外的空间存放数组元素。</p><p>另外还要求交换次数最少。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>为了满足题目要求，我们可以使用双指针法，找到一个零元素，以及在它后面的非零元素，将两者交换，不断重复这个过程。</p><p>假如不需要交换次数最少，有种更简洁的写法，即两次for循环，第一个for循环将非零元素放在数组前面，第二次for循环将非零元素放在数组后面。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pZero = findNextZeroIndex(nums, <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pNonZero = findNextNonZeroIndex(nums, pZero);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pZero &lt; nums.size() &amp;&amp; pNonZero &lt; nums.size()) &#123;</span><br><span class="line">            swap(nums[pNonZero], nums[pZero]);</span><br><span class="line">            pZero = findNextZeroIndex(nums, pZero);</span><br><span class="line">            pNonZero = findNextNonZeroIndex(nums, pZero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNextZeroIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> pZero)</span> </span>&#123;</span><br><span class="line">        pZero++;</span><br><span class="line">        <span class="keyword">while</span> (pZero &lt; nums.size() &amp;&amp; nums[pZero] != <span class="number">0</span>) &#123;</span><br><span class="line">            pZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pZero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNextNonZeroIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> pNonZero)</span> </span>&#123;</span><br><span class="line">        pNonZero++;</span><br><span class="line">        <span class="keyword">while</span> (pNonZero &lt; nums.size() &amp;&amp; nums[pNonZero] == <span class="number">0</span>) &#123;</span><br><span class="line">            pNonZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNonZero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/explore/featured/card/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题3 Maximum Subarray</title>
    <link href="https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-3-Maximum-Subarray/"/>
    <id>https://hyzgh.github.io/2020/04/04/leetcode-exercise-per-day-3-Maximum-Subarray/</id>
    <published>2020-04-04T09:03:51.000Z</published>
    <updated>2020-04-04T09:19:47.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3285/" target="_blank" rel="noopener">Maximum Subarray</a></p></blockquote><p>给一个数组，求该数组的最大子数组和。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>解法1：从左到右遍历一次，累加，若sum比现有的答案大，则更新。若sum为负数，则放弃这一段的元素，置为0。时间复杂度为O(n)，空间复杂度为O(1)。</p><p>解法2：分治法。若我们将一个数组从中间分隔成两个数组，则它的答案是max(左数组的答案, 右数组的答案, 左数组的最大后缀和+右数组的最大前缀和+中间元素)。时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>解法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = LONG_LONG_MIN;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; ans)</span><br><span class="line">                ans = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">return</span> maxSubArrayCore(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArrayCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>, sum = <span class="number">0</span>; i &gt;= l; i--) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            leftMax = max(leftMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            rightMax = max(rightMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(leftMax + rightMax + nums[mid],</span><br><span class="line">                max(maxSubArrayCore(nums, l, mid), maxSubArrayCore(nums, mid + <span class="number">1</span>, r)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/explore/featured/card/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题2 Happy Number</title>
    <link href="https://hyzgh.github.io/2020/04/02/leetcode-exercise-per-day-2-Happy-Number/"/>
    <id>https://hyzgh.github.io/2020/04/02/leetcode-exercise-per-day-2-Happy-Number/</id>
    <published>2020-04-02T08:35:01.000Z</published>
    <updated>2020-04-02T08:52:39.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p>题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3284/" target="_blank" rel="noopener">Happy Number</a></p></blockquote><p>给一个数字，判断它是不是Happy Number。假如一个数是Happy Number，则可以通过不断取各数位的平方和得到1。而假如不是Happy Number，则会陷入循环，不会得到1。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题的关键在于怎么知道发生了循环，并在发生循环的时候及时结束。弗洛伊德判圈法(Floyd Cycle detection algorithm)是可以在O(1)的空间复杂度和O(n)的时间复杂度内，判断是否发生循环的一种算法，其中n是循环的次数。其思想是维护两个指针，令它们一开始都指向最开始的位置，然后进行<code>do while</code>循环，让其中一个指针一次走两步，另一个一次走一步，直到两者相等，就可以判定存在圈。</p><p>这道题一定存在循环，Happy Number在找到圈的时候，指向的数为1，而非Happy Number指向的数非1，得解。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow, fast;</span><br><span class="line">        slow = fast = n;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = getSum(slow);</span><br><span class="line">            fast = getSum(fast);</span><br><span class="line">            fast = getSum(fast);</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (d) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = d % <span class="number">10</span>;</span><br><span class="line">            d /= <span class="number">10</span>;</span><br><span class="line">            sum += mod * mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/explore/featured/card/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题01 Single Number</title>
    <link href="https://hyzgh.github.io/2020/04/01/leetcode-exercise-per-day-1-Single-Number/"/>
    <id>https://hyzgh.github.io/2020/04/01/leetcode-exercise-per-day-1-Single-Number/</id>
    <published>2020-04-01T09:03:20.000Z</published>
    <updated>2020-04-02T08:35:50.929Z</updated>
    
    <content type="html"><![CDATA[<p>最近Leetcode举办了一个为期一个月的活动，每天会推出一道题目。最近这段时间正好有空，所以打算跟着参加一下，顺便写一下题解。使用的语言为C++。</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><blockquote><p> 题目链接：<a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/528/week-1/3283/" target="_blank" rel="noopener">Single Number</a></p></blockquote><p>给一个非空的数组，其中有1个元素出现了1次，其他的都出现2次。时间要求为线性，不允许使用额外内存，求出现1次的元素。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目保证数组非空，所以不需要特殊处理。</p><p>两个相同的数异或等于0，因此我们可以将数组所有元素异或起来，最后得到的值即为出现1次的元素。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近Leetcode举办了一个为期一个月的活动，每天会推出一道题目。最近这段时间正好有空，所以打算跟着参加一下，顺便写一下题解。使用的语言为C++。&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hyzgh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go Lang slice 学习笔记</title>
    <link href="https://hyzgh.github.io/2020/01/27/go-slice-learning-note/"/>
    <id>https://hyzgh.github.io/2020/01/27/go-slice-learning-note/</id>
    <published>2020-01-27T13:48:29.000Z</published>
    <updated>2020-01-27T14:07:05.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h1><p>切片，本身不存储实际数据。切片的数据结构，也被称为slice header，包含指向首元素的指针、切片长度、切片容量：</p><p><img src="https://s2.ax1x.com/2020/01/27/1uWu2n.png" alt="img"></p><p>当将切片作为实参时，只会传递slice header。这个传递是值传递，这意味着：</p><ul><li>假如在函数里面对slice的元素作赋值操作，由于有指针指着元素，所以原有slice指向的元素也会被改变。</li><li>假如在函数里面reslice，并不会影响原slice。</li></ul><p>假如想要改变原有slice，有两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种，将返回值赋值给原slice，这种方式也就是append的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubtractOneFromLength</span><span class="params">(slice []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSlice := SubtractOneFromLength(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，用slice指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrSubtractOneFromLength</span><span class="params">(slicePtr *[]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    slice := *slicePtr</span><br><span class="line">    *slicePtr = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这引发了另一个需要注意的点，对于slice的方法，假如需要reslice，要用slice指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> path []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *path)</span> <span class="title">TruncateAtFinalSlash</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := bytes.LastIndex(*p, []<span class="keyword">byte</span>(<span class="string">"/"</span>))</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        *p = (*p)[<span class="number">0</span>:i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pathName := path(<span class="string">"/usr/bin/tso"</span>) <span class="comment">// Conversion from string to path.</span></span><br><span class="line">    pathName.TruncateAtFinalSlash()</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, pathName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片，可以改变指向的范围，这是成本很低的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片，可以切片，即<code>s := s[[begin]:[end]]</code>，其中begin和end可以省略。当end超过实际cap时，会panic。</p><p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p><p><code>len()</code>查看长度，即从下界到上界的个数</p><p>切片的零值为<code>nil</code>，此时<code>cap</code>和<code>len</code>都为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span>  <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><h1 id="切片的append"><a href="#切片的append" class="headerlink" title="切片的append"></a>切片的append</h1><p>可使用<code>append</code>函数向切片添加元素，对nil切片进行<code>append</code>是正确的。</p><p>当append超过切片容量时，会将容量翻倍，且利用内置函数copy进行数据的拷贝，该函数在切片重叠的情况下也可以保证正确拷贝。注意只有被append的slice的指针会指向这块新的区域，基于这个slice的其他slice并不会更新指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>append</code>函数向切片中添加切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><h1 id="切片的内存管理"><a href="#切片的内存管理" class="headerlink" title="切片的内存管理"></a>切片的内存管理</h1><p>注意只要有一个slice使用着底层slice，即使这个上层slice只包含了很少的元素，底层slice的内存也不会被释放掉。这时候假如为了释放不必要的内存占用，需要将上层slice指向的数据拷贝到新的区域：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个文件的字节都被加载进去了，且不释放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝到c，释放多余的占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h1><p>使用<code>make</code>来创建一维切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a) == cap(a) == 5</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b) == 0, cap(b) == 5</span></span><br></pre></td></tr></table></figure><p>使用<code>make</code>创建二维切片</p><p>第一种方式，该方式允许第二维大小有所变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h1><p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的技巧"><a href="#切片的技巧" class="headerlink" title="切片的技巧"></a>切片的技巧</h1><p>优雅地往slice插入一个value：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert inserts the value into the slice at the specified index,</span></span><br><span class="line"><span class="comment">// which must be in range.</span></span><br><span class="line"><span class="comment">// The slice must have room for the new element.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(slice []<span class="keyword">int</span>, index, value <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// Grow the slice by one element.</span></span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)+<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// Use copy to move the upper part of the slice out of the way and open a hole.</span></span><br><span class="line">    <span class="built_in">copy</span>(slice[index+<span class="number">1</span>:], slice[index:])</span><br><span class="line">    <span class="comment">// Store the new value.</span></span><br><span class="line">    slice[index] = value</span><br><span class="line">    <span class="comment">// Return the result.</span></span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅地合并两个切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">string</span>&#123;<span class="string">"John"</span>, <span class="string">"Paul"</span>&#125;</span><br><span class="line">b := []<span class="keyword">string</span>&#123;<span class="string">"George"</span>, <span class="string">"Ringo"</span>, <span class="string">"Pete"</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a, b...) <span class="comment">// equivalent to "append(a, b[0], b[1], b[2])"</span></span><br><span class="line"><span class="comment">// a == []string&#123;"John", "Paul", "George", "Ringo", "Pete"&#125;</span></span><br></pre></td></tr></table></figure><p>优雅地copy：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">b = <span class="built_in">append</span>([]T(<span class="literal">nil</span>), a...)</span><br></pre></td></tr></table></figure><p>cut，优雅地删除掉slice中的某一个区间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通版，对于元素为指针或者结构中含有指针，会存在内存泄漏，因为被删掉的元素仍属于slice</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级版，将指针设为nil，减少了内存泄漏，但是还是有元素属于slice</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:], a[j:])</span><br><span class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ &#123;</span><br><span class="line">    a[k] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</span><br></pre></td></tr></table></figure><p>filter：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> keep(x) &#123;</span><br><span class="line">            a[n] = x</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a[:n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reverse:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    opp := <span class="built_in">len</span>(a)<span class="number">-1</span>-i</span><br><span class="line">    a[i], a[opp] = a[opp], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shuffling:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">    j := rand.Intn(i + <span class="number">1</span>)</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接用math/rand.Shuffle</span></span><br><span class="line"><span class="comment">// 使用了Fisher–Yates算法</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;切片的数据结构&quot;&gt;&lt;a href=&quot;#切片的数据结构&quot; class=&quot;headerlink&quot; title=&quot;切片的数据结构&quot;&gt;&lt;/a&gt;切片的数据结构&lt;/h1&gt;&lt;p&gt;切片，本身不存储实际数据。切片的数据结构，也被称为slice header，包含指向首元素的指针、切
      
    
    </summary>
    
    
      <category term="Go" scheme="https://hyzgh.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Lang GC 学习笔记</title>
    <link href="https://hyzgh.github.io/2020/01/11/go-garbage-collector-learning-note/"/>
    <id>https://hyzgh.github.io/2020/01/11/go-garbage-collector-learning-note/</id>
    <published>2020-01-11T15:42:50.000Z</published>
    <updated>2020-01-11T15:51:57.048Z</updated>
    
    <content type="html"><![CDATA[<p>GC的具体实现一直在改变，但是其模型是相对稳定的。</p><p>collection的三个阶段：</p><ul><li>Mark Setup - STW</li><li>Marking - Concurrent</li><li>Mark Termination - STW</li></ul><p>Mark Setup：当进行gc时，为了保证数据完整性，需要设置Write Barrier，这要求将所有的goroutine停止，正常情况下这个时间平均为10-30ms。但是当goroutine停止不下时，会让这个时间变长。调度器目前停止goroutine的时机是在goroutine执行函数调用的时候，因为这样做才能保证安全。假如某个goroutine一直在执行循环，而不执行函数调用，它就无法被停止，这不仅会耽误gc第一个阶段的完成，还会造成其他goroutine停止着。将在Go1.14引入 <a href="https://github.com/golang/go/issues/24543" target="_blank" rel="noopener">preemptive</a> techniques 尝试对此进行优化。</p><p>Marking - Concurrent：当设置好Write Barrier后，collector会拿走25%可用的CPU，用于mark操作。mark操作，会遍历所有goroutine的栈，寻找指针指向的heap内存，将仍在使用的内存标记一下。这个时候，goroutine是可以并发执行的。在mark的过程，其他正在运行的goroutine可以分配内存，这可能导致内存不够用，这时候需要Mark Assits。Mark Assits，是指短暂停止正在运行的goroutine，让它们来帮忙mark，加快mark的进度。当然，这会影响这些goroutine的执行，collector的目标是尽可能减少Mark Assits的需要。</p><p>Mark Termination - STW：Mark完成后，需要关闭Write Barrier，进行多项清理工作，设定下次collection的目标。在进行这些工作前，仍要求所有的goroutine停止。这些工作平均持续60~90ms。虽然也可以设计成边Termination边正常运行一些gorutine的模式，但是设计者认为这样得到的收益很小，而增加的复杂性较高，所以选择了这种STW的实现方式。当Termination工作完成后，回到正常状态。</p><p>在collection完成后，会进行sweeping。</p><p>sweep是指将那些没有标记为使用的heap内存回收，它不是发生在一次collection中，而是被均摊到每次分配内存的时候。</p><p>以上所有行为只有在GC开始且正在进行的时候发生，GC Percentage对collection有很大影响。GC Pencentage，默认是100%。将GC Pencentage设置为100%，意味着下次GC会在heap达到当前GC的mark live内存的2倍时进行。</p><p>GC trace可用于追踪collection。<code>GODEBUG=gctrace=1 ./app</code>可查看GC信息，输出到<code>stderr</code>。</p><p>GC trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设置环境变量查看GC trace</span></span><br><span class="line">GODEBUG=gctrace=1 ./app</span><br><span class="line"></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8-&gt;11-&gt;6 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8-&gt;14-&gt;8 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC trace含义</span></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">// General</span><br><span class="line">gc 1404     : The 1404 GC run since the program started</span><br><span class="line">@6.068s     : Six seconds since the program started</span><br><span class="line">11%         : Eleven percent of the available CPU so far has been spent <span class="keyword">in</span> GC</span><br><span class="line"></span><br><span class="line">// Wall-Clock</span><br><span class="line">0.058ms     : STW        : Mark Start       - Write Barrier on</span><br><span class="line">1.2ms       : Concurrent : Marking</span><br><span class="line">0.083ms     : STW        : Mark Termination - Write Barrier off and clean up</span><br><span class="line"></span><br><span class="line">// CPU Time</span><br><span class="line">0.70ms      : STW        : Mark Start</span><br><span class="line">2.5ms       : Concurrent : Mark - Assist Time (GC performed <span class="keyword">in</span> line with allocation)</span><br><span class="line">1.5ms       : Concurrent : Mark - Background GC time</span><br><span class="line">0ms         : Concurrent : Mark - Idle GC time</span><br><span class="line">0.99ms      : STW        : Mark Term</span><br><span class="line"></span><br><span class="line">// Memory</span><br><span class="line">7MB         : Heap memory <span class="keyword">in</span>-use before the Marking started</span><br><span class="line">11MB        : Heap memory <span class="keyword">in</span>-use after the Marking finished</span><br><span class="line">6MB         : Heap memory marked as live after the Marking finished</span><br><span class="line">10MB        : Collection goal <span class="keyword">for</span> heap memory <span class="keyword">in</span>-use after Marking finished</span><br><span class="line"></span><br><span class="line">// Threads</span><br><span class="line">12P         : Number of logical processors or threads used to run Goroutines</span><br></pre></td></tr></table></figure><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GC的具体实现一直在改变，但是其模型是相对稳定的。&lt;/p&gt;
&lt;p&gt;collection的三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mark Setup - STW&lt;/li&gt;
&lt;li&gt;Marking - Concurrent&lt;/li&gt;
&lt;li&gt;Mark Termination -
      
    
    </summary>
    
    
      <category term="Go" scheme="https://hyzgh.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>perl 学习笔记</title>
    <link href="https://hyzgh.github.io/2019/12/18/null/"/>
    <id>https://hyzgh.github.io/2019/12/18/null/</id>
    <published>2019-12-18T15:09:06.000Z</published>
    <updated>2019-12-18T15:58:07.610Z</updated>
    
    <content type="html"><![CDATA[<p>Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。</p><p>Perl的强大之处，在于它具有sed和awk的全部功能，以及众多语言的语法特性，以及非常强大的正则表达式，等等。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h1><p>Perl的Hello, World：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'print("Hello, World\n")'</span></span><br></pre></td></tr></table></figure><p>在安装了perl的计算机上，直接执行上述代码，即可输出<code>Hello, World</code>。</p><p>也可以将perl代码写在文件，以重复执行，具体可以这样写：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 "Hello, World"</span></span><br><span class="line"><span class="keyword">print</span>(<span class="string">"Hello, World\n"</span>);</span><br></pre></td></tr></table></figure><p>将上述代码保存成<code>learn.pl</code>后，加下执行权限，然后执行<code>./learn.pl</code>，可输出<code>Hello, World</code>。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Perl的正式表达式非常强大，是常用编程语言里最顶尖的之一。下面来看几个例子。</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p><code>echo box.svc.content | perl -p -e &#39;s/\.+/\//g&#39;</code></p><p>将会输出<code>box/svc/content</code>。</p><p>解析：</p><p><code>-p</code>参数会将结果输出出来。</p><p>这里用到了一个常用的<strong>替换</strong>句型，<code>s/old/new/parameters</code>，表示将<code>old</code>替换成<code>new</code>。</p><p><code>s/\.+/\//g</code>的<code>s</code>表示替换，<code>\.+</code>表示至少一个<code>.</code>，<code>\/</code>表示一个<code>/</code>，<code>g</code>表示全局匹配。</p><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"></span><br><span class="line">$string = <span class="string">'welcome to w3cschool site.'</span>;</span><br><span class="line">$string =~ <span class="regexp">tr/a-z/A-z/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$string\n"</span>;</span><br></pre></td></tr></table></figure><p>上面的代码将会输出<code>WELCOME TO W3CSCHOOL SITE.</code>。</p><p>这里用到了一个常用的<strong>转化</strong>句型，<code>tr/old/new/parameters</code>。表示将<code>old</code>转化成<code>new</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.w3cschool.cn/perl/perl-regular-expressions.html" target="_blank" rel="noopener">Perl 正则表达式 - W3Cschool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Perl是一门解释型语言，具有动态语言的特性，可以写得很随性。缺点是由于语法灵活导致难以维护，这和Go Lang形成了强烈的对比。Go Lang很适合用来团队协作开发，因为它写法很单一固定。Perl，更像是黑客的工具。&lt;/p&gt;
&lt;p&gt;Perl的强大之处，在于它具有sed和a
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://hyzgh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>图片文件格式 学习笔记</title>
    <link href="https://hyzgh.github.io/2019/12/07/null/"/>
    <id>https://hyzgh.github.io/2019/12/07/null/</id>
    <published>2019-12-07T08:07:02.000Z</published>
    <updated>2019-12-07T08:32:39.020Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。</p><p>一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过<code>ImageMagick</code>这个程序来解析图片文件。</p><p>分辨率，比如1920x1080，是指图片的一行具有1920个像素，一列具有1080个像素。</p><p>色彩空间，是指描述一个像素点的方式。比如RGB，是指一个像素点用red, green, blue各8bit一共24bit来描述。而YUV，是指Y表示亮度，U和V一起表示色调和饱和度。</p><p>在互联网上最常见的大概是jpeg类的文件。jpeg文件之所以适合在互联网上传播，是因为它的压缩比较高，且能在压缩和图片还原度上保持平衡，使得一张图片既有小巧的体积，又能在肉眼级别上有良好的清晰度。</p><p>但是jpeg文件并不适合保存图标等图像内容，因为它不具有alpha通道，不能用来表示透明的背景。一般会用png来保存图标。由于png是无损压缩存储图片的，所以会比jpeg文件要大一些，也适合对于图像质量要求较高的情况。</p><p>bmp文件，它也是无损不压缩的，所以会比较大，比较少见。</p><p>git文件，可以存储动图，但是由于它只用了8bit来描述一个像素点，所以可用的色彩并不多，色彩丰富度低。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网中，常见的图片文件格式有jpeg, png, bmp, gif等。&lt;/p&gt;
&lt;p&gt;一副图片，具有很多的属性，比如分辨率，色彩空间等。可以通过&lt;code&gt;ImageMagick&lt;/code&gt;这个程序来解析图片文件。&lt;/p&gt;
&lt;p&gt;分辨率，比如1920x1080，是指图
      
    
    </summary>
    
    
      <category term="文件格式" scheme="https://hyzgh.github.io/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 6 异常控制流</title>
    <link href="https://hyzgh.github.io/2019/10/21/CSAPP-learning-note-6/"/>
    <id>https://hyzgh.github.io/2019/10/21/CSAPP-learning-note-6/</id>
    <published>2019-10-21T11:16:38.000Z</published>
    <updated>2020-08-29T09:16:28.468Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了CSAPP的第八章——异常控制流。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。异常有不同的种类，有中断、陷阱、故障、终止。</p><p>中断，是在CPU执行某条指令的时候，其他部件异步产生的，比如定时器芯片、磁盘控制器、网络适配器等。CPU检测到中断后，会把当前指令执行完，然后转去执行异常处理程序，接着再返回来执行下一条指令。</p><p>陷阱，是有意的异常，最常见的陷阱是系统调用。系统调用，是指从用户模式转为内核模式，以执行一些特殊的指令，比如操作I/O设备。执行完系统调用后，会返回来执行下一条指令。</p><p>故障，是指执行指令的时候遇到了意外，比如遇到了缺页、访问了未定义的虚拟内存区域等。根据故障的不同，异常处理程序执行完后可能会返回执行当前指令，也有可能会终止程序。在写程序时常常遇到的<code>Floating point exception</code>和<code>Segmentation fault</code>就属于故障，且在Linux中的处理是程序被终止。</p><p>终止，是指遇到了致命的硬件错误，必须结束程序。</p><p>因为异常种类繁多，所以计算机中有一张异常表，用来记录不同的异常及对应的异常处理程序。在CPU中，有一个特殊的寄存器——异常表基址寄存器，用来存放异常表在内存中的基址。当CPU遇到一种异常的时候，会拿到一个异常号。CPU拿着这个异常号及寄存器中的基址，便可以找到对应的异常处理程序了。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程，是执行中的程序实例，是操作系统对于程序的一种抽象。这种抽象，使得看起来进程是独占cpu和内存的。为了实现这种抽象，需要操作系统保存好进程的上下文，进行进程调度。</p><p>进程的上下文，是指进程执行的状态，包括CPU中的状态、用户模式中的状态、内核模式中的状态。具体来说，cpu中的状态，包括各种寄存器，比如通用寄存器，用来保存指令执行用到的数据，还有程序计数器，用来指明程序执行的进度。用户模式下的状态，包括用户栈等。内核模式中的状态，包括内核栈、进程已打开文件的信息的文件表、有关当前进程的信息的进程表等。</p><p>什么时候会触发进程调度呢？主要有两种情况。一种是进程执行了系统调用，阻塞住了，比如读写文件、sleep等。另一种是中断，包括IO操作完成以及时钟中断等。</p><h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><ul><li><code>PS</code>：列出当前系统中的进程。</li><li><code>TOP</code>：打印出关于当前进程资源使用的进程。</li><li><code>PMAP</code>：显示进程的内存映射。</li><li><code>STRACE</code>：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。<code>-static</code>是个实用的参数。</li><li><code>/proc</code>：一个虚拟文件系统，以ASCII文件格式输出大量内核数据结构的内容。</li></ul><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了CSAPP的第八章——异常控制流。&lt;/p&gt;
&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;p&gt;在计算机中，假如没有异常，那么指令是顺序执行的。当遇到异常时，会执行异常处理程序。
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 5 存储器层次结构</title>
    <link href="https://hyzgh.github.io/2019/10/18/CSAPP-learning-note-5/"/>
    <id>https://hyzgh.github.io/2019/10/18/CSAPP-learning-note-5/</id>
    <published>2019-10-18T14:27:36.000Z</published>
    <updated>2020-08-29T09:14:27.534Z</updated>
    
    <content type="html"><![CDATA[<p>这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。</p><p><img src="https://s2.ax1x.com/2019/10/18/KeyBvV.png" alt="第六章存储器层次结构"></p><h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><p>存储器有着很多的种类，比如CPU的寄存器、高速缓存，主存（内存）的DRAM，机械硬盘、固态硬盘、U盘、SD卡、磁带等。不同的存储器，会用到不同的存储技术。其中寄存器的存储技术从性能上看是最好的，同时价格也最昂贵的，因此寄存器的大小相比于其他存储器，少得可怜，比如一般来说，通用寄存器只有16个，而1个寄存器只能存储64个bit。高速缓存采用的是SRAM，而主存用的是DRAM。SRAM用到了多个晶体管，比DRAM要快得多，会更加稳定，同时成本也更高。一般来说，高速缓存是几M的量级，而主存是以几G的量级，可见两者的价格差异。RAM有一个特点是断电后内容会丢失。</p><p>我们常用的U盘、SD卡等，并不是基于RAM，而是基于ROM。所谓ROM，翻译成中文便是只读存储器。个人觉得这个名字有点歧义，容易让人误解成数据不可更改。但实际上，ROM也有多个种类，我们常用的U盘基于EEPROM（电子可擦写只读存储器），是可以进行擦写的。而固态硬盘，基于闪存，它也是可擦写的。以前给手机刷机的时候，常常会听到ROM和固件这两个名词。所谓固件，是指写入到ROM中的程序。</p><p>机械硬盘，常常会听到一个参数叫转数。这个参数表示盘片旋转速度的速度。这个参数虽然重要，但却非影响硬盘随机IO时间的最重要因素。磁盘访问数据，由三个部分的时间组成，即寻道时间、旋转时间、传送时间。寻道时间是磁头定位到对应磁道的时间，这个时间平均占比是最大的，通常可占到整体时间的1/2以上，所以我们可以用两倍寻道时间来估计总时间。磁头定位到对应磁道，有专门的寻道算法，比如电梯算法。</p><p>固态硬盘，是近些年流行起来的存储器。其性能、价格皆介于主存和机械硬盘之间。由于固态硬盘采用了闪存，避免了机械硬盘缓慢的寻道和旋转，所以速度更快，特别是在随机IO的表现上。</p><p>根据历史趋势，存储器将会访问速度越来越快，越来越大，且会越来越便宜。但是，由于CPU的性能提升要比SRAM、DRAM、磁盘的速度快，所以两者的差距在增大，这将成为计算机的瓶颈。也因此，各级缓存的必要性就体现出来了，利用局部性原理，我们可以减弱这种差距。</p><h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性分为空间局部性及时间局部性。空间局部性指的是某个位置的数据被访问后，其附近的数据将可能被访问。时间局部性指的是某个位置的数据被访问后，这个位置还将可能被再次访问。</p><p>以前对于这个概念的认识有点模糊，对其带来的性能差异没有明确的认知。我们下面通过一个程序来看一下空间局部性带来的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;    </span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当N = 20000时，在我的机器上，sum1执行的时间为2.1s，而sum2执行的时间为5.6s，两者差距两倍多。</p><p>sum1之所以性能表现比sum2优秀，是因为它访问数据时的步长为1，让计算机能更好地利用空间局部性原理。</p><h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>计算机的存储器层次结构从快到慢分为寄存器、L1高速缓存、L2高速缓存、L3高速缓存、主存、本地二级磁盘（本地磁盘）、远程二级存储（分布式文件系统、Web服务器）等。通过这样的层次结构，在大小、访问速度、价格等因素之间取得了折衷，让计算机的价格合理、访问速度较快、存储空间较大。</p><p>缓存无处不在，其目的是降低不同存储器之间速度差异带来的影响。计算机各级存储器之间，上层是下层的缓存。浏览器访问网页时，在本地磁盘有缓存，能提高用户打开同一网页的速度。Web服务器被访问的时候，本地磁盘也有缓存，能提高不同用户访问同一网页的速度。磁盘也有缓存，用于缓存磁盘扇区，提高计算机访问磁盘的速度。代理服务器，也可用来做缓存，能降低网络延迟。业务上，redis用作MySQL的缓存，是用内存来缓存磁盘的内容，缓解了随机I/O带来的性能问题。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周看了CSAPP第六章存储器层次结构的前三节，下面是思维笔记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/18/KeyBvV.png&quot; alt=&quot;第六章存储器层次结构&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;存储技术&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 4 程序的机器级表示</title>
    <link href="https://hyzgh.github.io/2019/10/15/CSAPP-learning-note-4/"/>
    <id>https://hyzgh.github.io/2019/10/15/CSAPP-learning-note-4/</id>
    <published>2019-10-15T04:31:41.000Z</published>
    <updated>2020-08-29T09:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。</p><p>在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。</p><p>在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即<code>CMP</code>和<code>TEST</code>，也会设置条件码，但它们不会改变其他寄存器。</p><p>那么怎么访问这些条件寄存器呢？CPU中提供了<code>SET</code>指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应<code>SETE</code>指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应<code>SETL</code>，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。</p><p>要实现像C语言中的for语句，还需要一类指令<code>JMP</code>。它可以根据条件跳转到其他语句，而不是一直顺序执行。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。&lt;/p&gt;
&lt;p&gt;在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 4 程序的机器级表示</title>
    <link href="https://hyzgh.github.io/2019/10/15/CSAPP-learning-note-4/"/>
    <id>https://hyzgh.github.io/2019/10/15/CSAPP-learning-note-4/</id>
    <published>2019-10-15T04:31:41.000Z</published>
    <updated>2020-08-29T09:15:50.544Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。</p><p>在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。</p><p>在CPU执行所有算术和逻辑运算时，都会设置条件码。此外，还有两类指令，即<code>CMP</code>和<code>TEST</code>，也会设置条件码，但它们不会改变其他寄存器。</p><p>那么怎么访问这些条件寄存器呢？CPU中提供了<code>SET</code>指令，对这些标志位进行了封装，可以更方便地获取常见的比较结果。举个例子，最简单的情况，是判断结果是否为零，对应<code>SETE</code>指令，它会读取零标志寄存器。而比较复杂的情况，判断有符号数的小于比较，对应<code>SETL</code>，它会读取符号标志寄存器和溢出标志寄存器，然后取它们的异或值。</p><p>要实现像C语言中的for语句，还需要一类指令<code>JMP</code>。它可以根据条件跳转到其他语句，而不是一直顺序执行。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看得比较少，进度缓慢，只看了第三章关于控制的一小节内容，下面简单写一写。&lt;/p&gt;
&lt;p&gt;在CPU中，维护着一组单个位的条件码寄存器，用于描述算术或逻辑操作的属性，可以通过检测这些寄存器来执行条件分支指令，最常用的条件码有进位标志、零标志、符号标志、溢出标志。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 3 程序的机器级表示</title>
    <link href="https://hyzgh.github.io/2019/09/29/CSAPP-learning-note-3/"/>
    <id>https://hyzgh.github.io/2019/09/29/CSAPP-learning-note-3/</id>
    <published>2019-09-29T14:38:59.000Z</published>
    <updated>2020-08-29T09:17:22.329Z</updated>
    
    <content type="html"><![CDATA[<p>这两周看了第三章的前面五节，对机器指令有了更进一步的认识。</p><p><img src="https://s2.ax1x.com/2019/09/29/uGR19e.png" alt="程序的机器级表示 阅读进度"></p><h1 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h1><p>Intel处理器系列俗称x86，它有着一段进化之旅。从最初的8086到i386，再到i5和i7。那么它究竟有哪些方面的提升呢？</p><ul><li>晶体管数量增加。Core i7的1.4G个晶体管，是8086芯片29K个晶体管的4.8万倍。晶体管越多，意味着芯片的电路越复杂，能力越强。</li><li>指令集变大，支持更多指令。8087在8086的基础上，建立了浮点模型。</li><li>更多的位数。Pentium 4E是Intel对AMD提出的对IA32的64位拓展的实现，我们称之为x86-64。</li><li>更多的核数。Core 2是Intel的第一个多核微处理器。</li><li>更多的技术。Pentium 4E增加了超线程，允许一个处理器上同时运行两个程序。</li></ul><p>AMD等产商的大多处理器与Intel处理器兼容，能够运行完全相同的机器级程序。</p><h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><p>什么是机器代码呢？我们知道，C语言会经过预处理、编译、汇编、链接这些过程。</p><ul><li>预编译：拓展源代码，主要处理对象是#include及#define。</li><li>编译：产生源文件的汇编代码，拓展名为.s。</li><li>汇编：产生二进制目标代码，拓展名为.o。</li><li>链接：将多个.o文件转化成一个可执行文件。</li></ul><p>所谓机器代码，第一种是指.o文件中的代码，第二种是指可执行文件中的代码。它们的区别在于前者还没有填入全局值的地址。</p><p>机器代码是一些二进制代码，不具有可读性。汇编代码非常接近机器代码，我们可通过学习汇编代码来认识机器代码。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>Intel的体系结构一直在变化，从16位到32位，再到64位，可能以后还会拓展到128位。</p><p>Intel用以下术语来表示不同的数据类型。</p><table><thead><tr><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>字节</td><td>b</td><td>1</td></tr><tr><td>字</td><td>w</td><td>2</td></tr><tr><td>双字</td><td>l</td><td>4</td></tr><tr><td>四字</td><td>q</td><td>8</td></tr><tr><td>单精度</td><td>s</td><td>4</td></tr><tr><td>双精度</td><td>l</td><td>8</td></tr></tbody></table><h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>一个CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。</p><p>我们知道，程序运行时，其数据存放在内存中。CPU需要一些指令来进行内存与寄存器间的数据转移，称为数据转移指令。</p><p>我们也知道，程序运行时，在内存中有一个对应的程序栈。CPU有专门指令进行入栈、出栈操作。可否将这些指令去掉呢？可以，存在代替指令。但是这样做，会让机器代码增多，考虑到入栈出栈操作是非常常见的，所以提供专门的指令会缩减机器代码的大小。这也就是在精简指令集上编译出来的机器代码比复杂指令集庞大的原因。</p><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>所谓算术操作，指的是加减乘除等操作。所谓逻辑操作，是指与或移位等操作。</p><p>通过学习汇编代码的算术和逻辑操作，对于高级语言的便利性有了更具体的认识。一条C语言简单的算术表达式，转化成汇编代码，会变成多条。对于一些更复杂的循环控制语句，就更复杂了。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两周看了第三章的前面五节，对机器指令有了更进一步的认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/29/uGR19e.png&quot; alt=&quot;程序的机器级表示 阅读进度&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;历史观点&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 学习笔记 2 信息的表示与处理</title>
    <link href="https://hyzgh.github.io/2019/09/15/CSAPP-learning-note-2/"/>
    <id>https://hyzgh.github.io/2019/09/15/CSAPP-learning-note-2/</id>
    <published>2019-09-15T15:31:06.000Z</published>
    <updated>2020-08-29T09:18:00.814Z</updated>
    
    <content type="html"><![CDATA[<p>这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。</p><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>整数运算的分类主要有两个维度，一个是无符号数、有符号数，另一个是加法、乘法。</p><p>之前知道编译器会将乘法转化成加减法/移位，但始终不知所以然。这次通过阅读CSAPP，深入理解了它的原理，另外知道了还可以将除法转化为加减法/移位。</p><p>这一节讲得都是规律和证明，这里不再赘述。贴一张图进行总结，以方便以后回忆。</p><p><img src="https://s2.ax1x.com/2019/09/16/nRiAaT.png" alt="image-20190915234925595"></p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>阅读完这一节后，对于浮点数的表示、运算、舍入等有了更深入的理解。</p><p>其中，有的地方一开始不是很理解，当弄懂后，觉得这些设计很优雅、很聪明。</p><p>比如，对于IEEE非规范值得设计不是很理解，为什么要增加复杂性呢。后来，明白了非规格值的设计，使得0的表示很加自然且靠近0的浮点数分布得更均匀。</p><p>比如，一开始不太明白为什么要有偶数舍入法，直接四舍五入不行吗。后来，明白了偶数舍入法是对四舍五入的一种改进，避免了舍入所造成的统计误差。</p><p>还有浮点的运算，不遵循结合律，这是之前没有注意到但也是十分重要的知识点。</p><p><img src="https://s2.ax1x.com/2019/09/16/nRikZV.png" alt="image-20190916000251225"></p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周看了第二章的剩余篇幅，关于整数运算以及浮点数。目前还未完全搞定，有很多习题待写。&lt;/p&gt;
&lt;h1 id=&quot;整数运算&quot;&gt;&lt;a href=&quot;#整数运算&quot; class=&quot;headerlink&quot; title=&quot;整数运算&quot;&gt;&lt;/a&gt;整数运算&lt;/h1&gt;&lt;p&gt;整数运算的分类主要有两
      
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://hyzgh.github.io/tags/CSAPP/"/>
    
      <category term="计算机系统" scheme="https://hyzgh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
