<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/hyzgh-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/hyzgh-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hyz&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="hyz&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hyz&#39;s blog">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>hyz's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hyz's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/31/Go-learning-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/31/Go-learning-note/" class="post-title-link" itemprop="url">Go 学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-31 23:59:21" itemprop="dateCreated datePublished" datetime="2019-07-31T23:59:21+08:00">2019-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用packages"><a href="#常用packages" class="headerlink" title="常用packages"></a>常用packages</h1><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>Printf</code></p>
<table>
<thead>
<tr>
<th>verb</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>输出值</td>
</tr>
<tr>
<td>%+v</td>
<td>输出键-值</td>
</tr>
<tr>
<td>%#v</td>
<td>输出包名、类型名、键-值</td>
</tr>
<tr>
<td>%T</td>
<td>类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
<tr>
<td>%t</td>
<td>布尔值</td>
</tr>
<tr>
<td>%b</td>
<td>二进制的值</td>
</tr>
<tr>
<td>%c</td>
<td>Unicode编码的字符</td>
</tr>
<tr>
<td>%d</td>
<td>十进制的值</td>
</tr>
<tr>
<td>%o</td>
<td>八进制的值</td>
</tr>
<tr>
<td>%x或%X</td>
<td>十六进制的值</td>
</tr>
<tr>
<td>%U</td>
<td>十六进制表示的Unicode值</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%p</td>
<td>地址</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数，默认精度是小数点后6位</td>
</tr>
<tr>
<td>%e</td>
<td>浮点数，科学计数法，默认精度是小数点后6位</td>
</tr>
<tr>
<td>%g</td>
<td>浮点数，有效数字，尽可能地输出所有位数</td>
</tr>
<tr>
<td>+</td>
<td>添加正负号</td>
</tr>
<tr>
<td>-</td>
<td>设置宽度时默认在左边补全空格，该符号可设置在右边补全空格</td>
</tr>
<tr>
<td>0</td>
<td>用0代替空格进行补全</td>
</tr>
<tr>
<td>#</td>
<td>对于八进制，十六进制等，加上提示符，如八进制为0，十六进制为0x</td>
</tr>
</tbody></table>
<p><code>%f</code> 可指定浮点数的宽度和精度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%f     default width, default precision</span><br><span class="line">%9f    width 9, default precision</span><br><span class="line">%.2f   default width, precision 2</span><br><span class="line">%9.2f  width 9, precision 2</span><br><span class="line">%9.f   width 9, precision 0</span><br></pre></td></tr></table></figure>

<p><code>%g</code> 可指定浮点数的有效数字位数，对于12.345，<code>%.3g</code> 将输出 12.3</p>
<p>若要能对某个自定义类型输出，只要对它定义<code>String() string</code>方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d/%g/%q"</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当t是*T类型时，才会调用上面那个函数</span></span><br><span class="line"><span class="comment">// 若要当t是T类型和*T类型都都调用上面那个函数，需要将上面的*T改成T</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, t)</span><br></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>会将内容输出到stderr，且会增加一些信息（如日期时间）。</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>注意只有当结构体内的成员是公开时，才能在Marshal的时候被识别，成为json文件的一部分。</p>
<p>进行Unmarshal时，假如json中有的字段而结构体没有，则这个字段会被忽略，不影响解析。也就是说，可进行json文件的部分解析。同理，假如Marshal时，结构体中的字段不想转到JSON文件中，可以将其tag设置为”-“。</p>
<p>解析时，结构体的某个字段的匹配优先级为tag -&gt; 导出名精确匹配 -&gt; 导出名模糊匹配。</p>
<p>omitempty表示当字段为零值时忽略它，而tag为”-“表示直接忽略它。</p>
<p>UnmarshalText函数和UnmarshalJSON函数的区别是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当不知道json文件的格式时，可这样解析</span></span><br><span class="line">b := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">  m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is string"</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is float64"</span>, vv)</span><br><span class="line">      <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">      fmt.Println(k, <span class="string">"is an array:"</span>)</span><br><span class="line">      <span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">        fmt.Println(i, u)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(k, <span class="string">"is of a type I don't know how to handle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若将结构体的成员设置为指针类型，则若json不存在相应的字段，则为nil</span></span><br><span class="line"><span class="keyword">type</span> IncomingMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">  Cmd *Command</span><br><span class="line">  Msg *Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于流的Encoders和Decoders</span></span><br><span class="line">de := json.NewDecoder(os.Stdin)</span><br><span class="line">enc := json.NewEncoder(os.Stdout)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := dec.Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> k := <span class="keyword">range</span> v &#123;</span><br><span class="line">    <span class="keyword">if</span> k != <span class="string">"Name"</span> &#123;</span><br><span class="line">      <span class="built_in">delete</span>(v, k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := enc.Encode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Basic-component"><a href="#Basic-component" class="headerlink" title="Basic component"></a>Basic component</h1><h2 id="package-import"><a href="#package-import" class="headerlink" title="package | import"></a>package | import</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何go程序都是由package组成，首个非空单词必须是package</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个import</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个import</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><p>形式：形参的标识符在前，类型在后；返回值放在最后面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的主要原因是为了提高易读性，特别是在涉及函数变量（函数指针）的时候</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> <span class="title">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>同类型的形参可简写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值可有多个</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可给返回值命名，且return可简写，注意不要在长函数中简写，因为这样会降低可读性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="variables-constants-types"><a href="#variables-constants-types" class="headerlink" title="variables | constants | types"></a>variables | constants | types</h2><p>首字母大写的变量称为exported name</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  Address <span class="keyword">string</span>  <span class="comment">// exported name</span></span><br><span class="line">  cost <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>申明格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单句</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有赋初值时，可省略类型名</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">d := <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当省略类型名时，编译器会自动推测，推测规则为：</p>
<ul>
<li>右边是变量，则和变量的类型相同</li>
<li>右边是常量，则有可能是int, float64, complex128</li>
</ul>
<p>基础类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure>

<p>申明的变量假如没有被显式赋初值，则会被赋<code>zero value</code>，即数值为0，布尔类型为false，字符串为””，指针为nil</p>
<p>申明常量，用<code>const</code>，不能用<code>:=</code>，因为<code>:=</code>是和<code>var</code>关联的，而<code>var</code>代表变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">"世界"</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello"</span>, World)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有隐式类型转换，必须显式类型转换。</p>
<p>类型断言，用于将空接口转换为普通类型。类型断言又分为安全类型断言和非安全类型断言。</p>
<ul>
<li>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;<strong>.</strong>(目标类型)  // 安全类型断言</li>
<li>&lt;目标类型的值&gt; := &lt;表达式&gt;<strong>.</strong>(目标类型)  // 非安全类型断言</li>
</ul>
<p>在函数体内，变量申明了但不使用会报错。同理，import的package没用的话也会报错。</p>
<p>Go在函数体中定义了一个变量，然后将它的指针返回是合法的，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">// 或者将上面两行简写成return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">    <span class="comment">// 不难发现new(File)和&amp;File&#123;&#125;是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="More-types"><a href="#More-types" class="headerlink" title="More types"></a>More types</h1><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>指针，和C不一样，Go没有指针的算术运算，即不支持<code>p = p + 10</code>这样的语句</p>
<h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>结构体，可将<code>(*p).X</code>写成<code>p.X</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// has type Vertex</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 is implicit</span></span><br><span class="line">    v3 = Vertex&#123;&#125;      <span class="comment">// X:0 and Y:0</span></span><br><span class="line">    p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// has type *Vertex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>In Go：</p>
<ul>
<li>Arrays are values. Assigning one array to another copies all the elements.</li>
<li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li>
<li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line">    fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如想要像C那样只传数组的地址，可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// Note the explicit address-of operator</span></span><br></pre></td></tr></table></figure>

<p>虽然可以这么写，但不推荐，因为更优雅的方法是使用slices。</p>
<h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>切片，本身不存储实际数据，类似于引用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片数组，可以改变指向的范围</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    t := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">    r = r[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">  # 输出[<span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span>]，即最开始的[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">    r = t</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片，可省略下界或上界</p>
<p><code>cap()</code> 查看容量，即从下界到数组最后一个元素的个数</p>
<p><code>len()</code>查看长度，即从下界到上界的个数</p>
<p>切片为<code>nil</code>时，<code>cap</code>和<code>len</code>都为0</p>
<p>使用<code>make</code>来创建一维切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line">    printSlice(<span class="string">"b"</span>, b)</span><br><span class="line"></span><br><span class="line">    c := b[:<span class="number">2</span>]</span><br><span class="line">    printSlice(<span class="string">"c"</span>, c)</span><br><span class="line"></span><br><span class="line">    d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">        s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>make</code>创建二维切片，第一种方式，该方式允许第二维大小有所变化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个位数为[dx][dy]的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式，不允许第二维大小有所变化，因为改变了就会有可能覆盖：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate the top-level slice, the same as before.</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// One row per unit of y.</span></span><br><span class="line"><span class="comment">// Allocate one large slice to hold all the pixels.</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// Has type []uint8 even though picture is [][]uint8.</span></span><br><span class="line"><span class="comment">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可使用<code>append</code>函数向切片添加元素，假如切片容量不足，则容量会翻倍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>append</code>函数向切片中添加切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>可使用<code>range</code>遍历切片，每次循环会有两个值，一个是元素的下标，一个是元素的值。可使用<code>_</code>忽略其中一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个值只会得到下标</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, pow[idx])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩减切片的大小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ugly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elegant，缩减了切片的cap，释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><code>maps</code>的零值为<code>nil</code>，可通过<code>make</code>创建<code>map</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化时，值的类型名可省略</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入键值对，取键的值，删除键值对（可多次删除，可删除不存在的键）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map被函数调用，可被修改。</p>
<h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也可以作为值，可以像其他数据类型一样赋值给变量，作为实参等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Function-closures"><a href="#Function-closures" class="headerlink" title="Function closures"></a>Function closures</h2><p>函数闭包，不同变量可以绑定不同的函数闭包，相互之间不影响</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(</span><br><span class="line">            pos(i),</span><br><span class="line">            neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Flow-control-statements"><a href="#Flow-control-statements" class="headerlink" title="Flow control statements"></a>Flow control statements</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>，可以没有<code>()</code>，但一定要有<code>{}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code>可以像<code>for</code>那样先带个statement。假如申明了变量，则只能在<code>if</code>或后续的<code>else</code>中使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can't use v here, though</span></span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>，可以没有<code>()</code>，但一定要有<code>{}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(condition)</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code>, 满足其中一个<code>case</code>即执行其中的语句，不会再执行其他case的语句，可看成自带<code>break</code>。此外，<code>case</code>不一定要接整数常量，它可以不是整数，可以不是常量。但要注意<code>case</code>后接的类型和<code>switch</code>比较的类型相同。</p>
<p><code>switch</code>同样可以像<code>for</code>那样先带个statement，且<code>default</code>的位置可放在首位，因为它总是会在所有条件都不匹配的时候才执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// freebsd, openbsd,</span></span><br><span class="line">        <span class="comment">// plan9, windows...</span></span><br><span class="line">        fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code>还可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><code>defer</code> 推迟执行，具有LIFO的性质</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"1 "</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"2 "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"3 "</span>)</span><br><span class="line">    <span class="comment">// 将输出3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>defer</code>还可以这样写，参数部分的函数是会先执行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">entering: b</span></span><br><span class="line"><span class="comment">in b</span></span><br><span class="line"><span class="comment">entering: a</span></span><br><span class="line"><span class="comment">in a</span></span><br><span class="line"><span class="comment">leaving: a</span></span><br><span class="line"><span class="comment">leaving: b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="Methods-and-interfaces"><a href="#Methods-and-interfaces" class="headerlink" title="Methods and interfaces"></a>Methods and interfaces</h1><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go没有<code>class</code>，但可以给方法（函数）指定适用的类型。<code>method</code>是指定类型的<code>function</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>methord</code>指定的类型可以是基本类型，但所指定的类型必须在本<code>package</code>出现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>methord</code>指定的类型可以是指针，则我们可以修改指针指向的内容，并且不用产生拷贝开销。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>接口，要求使用接口的类型实现了接口中方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line">    <span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">    <span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口中的方法不需要像其他语言那样使用显式的关键字，如<code>implement</code>。</p>
<p>这样做可以让申明和实现分离，不需要特殊处理就可以让他们放在不同的包中。</p>
<p>接口可以看成是一个二元组<code>(value, type)</code>，对于一个<code>value</code>，它会调用接收了<code>type</code>的方法。</p>
<p>假如一个变量是接口类型的，那么它有可能<code>value</code>和<code>type</code>都为<code>nil</code>，这种情况下会RE。而当<code>type</code>不为<code>nil</code>时，它是非空的，但是<code>value</code>可能会空，因此我们需要在实现接口的方法里处理好这种情况。</p>
<p>空接口，用于存储任何类型的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">42</span></span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="string">"hello"</span></span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型断言，在断言不成立的时候应该用两个变量存储结果，否则会报错</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// panic</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>type switch</code> 可以依次进行多个类型断言</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stringer</code> 用于输出自定义类型的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years)"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">"Arthur Dent"</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">"Zaphod Beeblebrox"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Error</code> 用于输出错误信息的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">"it didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reader</code> 用于读取数据的接口</p>
<p><code>func (T) Read(b []byte) (n int, err error)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Images</code> 用于处理图像的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span> &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y <span class="keyword">int</span>) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><p>Goroutines 轻型线程，它们共享同一地址的内存，需要同步控制</p>
<p><code>go f(x, y, z)</code> 创建一个新Goroutine运行函数<code>f</code></p>
<p>Channels 可用于传递数据的一种数据类型，需要用到运算符<code>&lt;-</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Buffered Channels 可理解为大小的Channel，满了还往里面添加的话会报错</p>
<p>可使用range来取出channel中的所有数据，注意channel要close</p>
<p><code>&lt;-ch</code>实际上会返回两个值，第二个值代表是否还有数据，即<code>false</code> 表示channel close了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>用于多个channel的选择，哪个channel有数据就执行哪一个，假如同时有数据来了，就随机先执行其中一个</p>
<p><code>select</code>中的<code>default</code>在没有收到任何channel数据的时候执行</p>
<p><code>sync.Mutex</code>  用于互斥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    c.v[key]++</span><br><span class="line">    c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the current value of the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Diagnostics-诊断"><a href="#Diagnostics-诊断" class="headerlink" title="Diagnostics | 诊断"></a>Diagnostics | 诊断</h1><h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起手式</span></span><br><span class="line">cpuProfile, _ := os.Create(<span class="string">"cpu_profile"</span>)</span><br><span class="line">pprof.StartCPUProfile(cpuProfile)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure>

<p><code>go tool pprof &lt;file&gt;</code></p>
<p><code>web</code> 启动可视化界面</p>
<p><code>top</code> 列出cpu占比最高的函数</p>
<p><code>list &lt;function&gt;</code> 列出指定函数的数据</p>
<h1 id="Go-Command"><a href="#Go-Command" class="headerlink" title="Go Command"></a>Go Command</h1><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p>假如想要玩一下<code>go build</code>命令，注意加上<code>-a</code>重新全部编译，否则会因为有缓存而跳过编译过程。</p>
<p>假如是main，则会编译生成可执行文件。</p>
<p>否则，只会编译，不产生文件，用于验证代码能否编译。</p>
<h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p>假如是main，则会在$GOPATH/bin下生成可执行文件。</p>
<p>否则，会在$GOPATH/pkg下生成*.a文件。</p>
<h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">go get -u &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h2 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h2><p>删除编译生成的文件等等。</p>
<h1 id="依赖管理工具"><a href="#依赖管理工具" class="headerlink" title="依赖管理工具"></a>依赖管理工具</h1><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化，-v参数代表输出详细信息</span></span><br><span class="line">dep init -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决依赖的BUG</span></span><br><span class="line">dep ensure -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新依赖，假如总是更新失败，先dep ensure -v一下，并选择在网络空闲的时候更新</span></span><br><span class="line">dep ensure -update -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条依赖</span></span><br><span class="line">dep ensure -add github.com/bitly/go-simplejson</span><br></pre></td></tr></table></figure>

<h2 id="Go-Mod"><a href="#Go-Mod" class="headerlink" title="Go Mod"></a>Go Mod</h2><p>拉取速度比Dep要快很多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，生成go.mod文件</span></span><br><span class="line">go mod init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后即可使用go build或go test拉取依赖</span></span><br><span class="line">go build/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级所有依赖到最新</span></span><br><span class="line">go get -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将依赖放在项目的vendor中</span></span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>

<p>假如遇到某个依赖有问题，更把那个依赖删掉，然后再<code>go get -u</code>升级所有依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/financial-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/13/financial-management/" class="post-title-link" itemprop="url">理财入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-13 21:02:59" itemprop="dateCreated datePublished" datetime="2019-07-13T21:02:59+08:00">2019-07-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间开始了实习，并拿到了人生的第一桶金。为了能够掌握好自己的财务情况，以及怀着尽快实现财务自由的目标，开始了自己理财知识学习之路。学习理财，同时也是提高自我认知的过程。此博文记录了自己的理财学习之路，希望能对读者有些帮助。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>管理好自己的财产的第一步，是要对自己的支出收入情况有所了解。假如一个人对自己的收支情况一点不了解，就算中了百万彩票，挥金如土，也会很快被挥霍完。而假如一个人对于自己的收支情况了然于胸，量入为出，才能过得很踏实。</p>
<p>在这里，通过一番比较后，我选择了复式记账法，并采用了beancount和fava这两个工具。网上介绍这两个工具的好文章已有不少，这里不再赘述使用方法，而只提一下它的优点。beancount，它是开源的，它可以让你以纯文本的形式记账，并将数据保存在自己的电脑上，保证了数据的可移植性和安全性，无需支付额外费用，使用成本低。另外，利用fava可将数据可视化，可以直观地看到自己的财务情况，非常方便。</p>
<p>很多人之所以不能坚持记账，大多数是因为记账太过繁琐，且记账产生的数据像一潭死水，无法产生实际的指导价值。而用beancount+fava，可以克服这两个缺点。现在大多数网站，比如支付宝和微信支付，都可以导出账单，我们不难写个脚本将其转化成符合beancount语法的文本数据。fava将数据可视化后，含有损益表、资产负债表、试算表、资产、统计等界面，可以很直观地看到自己的收支情况、资产负债情况等。这些东西需要一些财务知识才能理解，我主要通过搜索引擎+看书来学习，这里推荐一本书，书名叫《给创业小白的财报书》，豆瓣评分9.0，值得一读。</p>
<p>我认为实现财务自由最关键的是增加收入以及通过投资来增加净资产。增加净资产，可以通过购买债券、基金、股票、房地产等方式。待所购资产实现增值后，我们的净资产也就增加了。现在我对于存款的处理方式是直接购买基金，因为比较方便。但是购买基金是一种低风险低收益的投资活动，虽然可以实现财富增长，但若想尽快实现财务自由这个目标，依靠此方式是行不通的。所以有必要去学习其他投资方式，这里挖个坑，以后学了再补上。</p>
<p>虽然财务自由听起来很虚幻很遥远，但是我觉得通过一定的努力是能够达到的。当然，每个人对于财务自由的定义会有所不同，我自己的要求比较低，<strong>资产所产生的收益能超过日常开销即算财务自由</strong>。共勉。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/git-book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/02/git-book/" class="post-title-link" itemprop="url">git 简明手册 | 学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-02 00:13:57" itemprop="dateCreated datePublished" datetime="2019-07-02T00:13:57+08:00">2019-07-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="迭代记录"><a href="#迭代记录" class="headerlink" title="迭代记录"></a>迭代记录</h2><ul>
<li>190702 首次提交</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>全局配置文件：<code>~/.gitconfig</code></p>
</li>
<li><p>项目配置文件：<code>&lt;project&gt;/.git/config</code></p>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文件到仓库</span></span><br><span class="line">git add &lt;FILE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把当前所有位置的所有文件都添加到仓库中</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定add具体哪些内容，使用?查看选项的解释</span></span><br><span class="line">git add -p</span><br></pre></td></tr></table></figure>

<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支+远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的分支建立追踪关系，一般是对远程分支建立追踪关系</span></span><br><span class="line">git branch --track [newBranch] [remote/branch]</span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">git branch --track mage origin/mage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间 | 已经弃用</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream [branch] [remote/branch]</span><br></pre></td></tr></table></figure>

<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对当前工作区文件的修改。其中--的作用是表明后面的参数是文件名，而不是分支名。</span></span><br><span class="line">git checkout -- FILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建+切换分支</span></span><br><span class="line">git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在origin/master的基础上，创建一个新分支。</span></span><br><span class="line">git checkout -b &lt;name&gt; origin/master</span><br></pre></td></tr></table></figure>

<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>

<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只克隆仓库的最新一个版本，对于多次提交的仓库可明显提高clone速度</span></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-o指定远程分支名，假如不指定，默认是origin</span></span><br><span class="line">git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>

<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把文件提交到仓库</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以选择部分文件commit</span></span><br><span class="line">git commit &lt;file1&gt; &lt;file2&gt;...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 它一般适用于还未提交到远程仓库的提交，也适用于gerrit，不适用于Github</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不更改评论信息</span></span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure>

<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置提交代码时的用户信息。</span></span><br><span class="line">git config [--global] user.name <span class="string">"Username"</span></span><br><span class="line">git config [--global] user.email <span class="string">"email@example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前的git配置。</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件。</span></span><br><span class="line">git config -e [—global]</span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以将FILE现在的状态和最近一次add到仓库的状态进行一次diff。</span></span><br><span class="line">git diff FILE</span><br></pre></td></tr></table></figure>

<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取回分支，但是并不合并。</span></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定取哪个分支，默认情况下会取所有分支。</span></span><br><span class="line">git fetch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程分支到本地某个分支，假如本地分支不存在，则创建。不会切换到该分支。</span></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">git fetch origin :branch2</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">git fetch origin master:branch2</span><br></pre></td></tr></table></figure>

<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看commit日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>

<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 某些部分可省略。</span></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，取回origin/next分支，再与当前分支合并。</span></span><br><span class="line">git pull origin next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令指定master分支追踪origin/next分支。</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream master origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，本地的当前分支自动与对应的origin主机"追踪分支"进行合并。</span></span><br><span class="line">git pull origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准格式</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地分支推送到远程主机。</span></span><br><span class="line">gut push origin &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支。</span></span><br><span class="line">git push origin --delete &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure>

<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看引用日志，可以回到“未来”。</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有远程主机。</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以参看远程主机的网址。</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主机的详细信息。</span></span><br><span class="line">git remote show &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于删除远程主机。</span></span><br><span class="line">git remote rm &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于远程主机的改名。</span></span><br><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将仓库连接到远程服务器。一般是在git init后使用，绑定远程主机。</span></span><br><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销对当前缓存区的修改，相当于`git add`的反操作。</span></span><br><span class="line">git reset -- &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对当前缓存区的修改。</span></span><br><span class="line">git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让HEAD指针指到commit_id代表的状态。顺便一提，HEAD^表示上一个状态，HEAD^^表示上上个状态。</span></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>

<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程分支</span></span><br><span class="line">git revert</span><br></pre></td></tr></table></figure>

<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区。即删除远程文件和本地文件。</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区。即删除远程文件，但不删除本地文件。</span></span><br><span class="line">git rm --cached [file]</span><br></pre></td></tr></table></figure>

<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看仓库当前的状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加了tag的commit就会将源码添加到打包，一般用版本号为tag命名</span></span><br><span class="line"><span class="comment"># 在Github上看到的release不是git提供的，而是代码托管网站出于满足开发者发布二进制文件的需求而开发的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/leetcode-linked-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/04/leetcode-linked-list/" class="post-title-link" itemprop="url">Leetcode 题解 C++ 链表总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-04 14:11:31" itemprop="dateCreated datePublished" datetime="2019-03-04T14:11:31+08:00">2019-03-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>有时候加个冗余头节点会大大降低实现难度，让代码变得更简洁。</li>
<li>做与链表相关的题目一定要在写代码前就想清楚算法的各个步骤，想好要保存哪些指针。否则很容易写乱。</li>
<li>要注意delete掉删除掉的节点，避免内存泄露。</li>
</ol>
<h1 id="Leetcode-2-Add-Two-Numbers"><a href="#Leetcode-2-Add-Two-Numbers" class="headerlink" title="Leetcode 2 Add Two Numbers"></a>Leetcode 2 Add Two Numbers</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>用链表存储十进制数字的各位，现在给这样的两个链表，求和。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于链表头存的是最低位，所以我们可以同时扫描两个链表，模拟一下加法就行了。<br>假如用C++写的话，可以先开一个冗余头指针，方便实现。注意申请或释放内存时，应该要用new和delete而不要用malloc和free，养成良好的编程习惯。<br>假设两个链表的长度分别为n和m，那么时间复杂度和空间复杂度都是$O(n + m)$，显然空间复杂度可以优化到$O(1)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode 19 Remove Nth Node From End of List"></a>Leetcode 19 Remove Nth Node From End of List</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个链表，要求删除倒数第n个节点。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这道题的边界情况是删除链表首个节点。<br>我们用两个指针指向表头，然后让其中一个指针先走n步，假如走完n步后指向了空指针，说明删除的是表头。假如走完不是空指针，则让另外一个指针开始和它一步一步走，直到前面的指针指到了最后一个节点时，后面的指针刚好指向待删除节点的前一个节点。<br>这样做的时间复杂度是$O(n)$。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *behind = head, *ahead = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ahead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(temp);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ahead-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ahead = ahead-&gt;next;</span><br><span class="line">            behind = behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = behind-&gt;next;</span><br><span class="line">        behind-&gt;next = behind-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode 21 Merge Two Sorted Lists"></a>Leetcode 21 Merge Two Sorted Lists</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>合并两个有序链表。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接写就行了，时间复杂度为$O(n+m)$，其中n和m为两个链表的长度。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = l1 ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>合并k个有序链表。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>我们需要一种数据结构来较快地插入一个数，取出最小的数，删除最小的数。不难想到优先队列可以满足这些要求。<br>假设k个链表的节点个数和为n，则时间复杂度为$O(nlogk)$。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        Node(ListNode *p, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">            <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val &gt; rhs.p-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Node&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i]) &#123;</span><br><span class="line">                que.push(Node(lists[i], i));</span><br><span class="line">                lists[i] = lists[i]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">            Node node = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (lists[node.idx] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = node.idx;</span><br><span class="line">                que.push(Node(lists[idx], idx));</span><br><span class="line">                lists[idx] = lists[idx]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = node.p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode 24 Swap Nodes in Pairs"></a>Leetcode 24 Swap Nodes in Pairs</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>两两交换链表的相邻节点。</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>递归来写，分三种情况，当前节点是空节点，当前节点没有后继，当前节点有后继。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead = head-&gt;next;</span><br><span class="line">        ListNode *nex = head-&gt;next-&gt;next;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = swapPairs(nex);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-25-Reverse-Nodes-in-k-Group"><a href="#Leetcode-25-Reverse-Nodes-in-k-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in k-Group"></a>Leetcode 25 Reverse Nodes in k-Group</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>是Leetcode 24的升级版，需要将链表的每k个节点翻转。</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>用迭代来写，先加个冗余头节点，方便实现。需要记录k节点组的前一个节点p，第一个节点head，最后一个节点tail。然后，我们不断地将p的后一个节点扔到tail的后面即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *p = dummy, *tail = dummy, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count != k &amp;&amp; tail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next != tail) &#123;</span><br><span class="line">                temp = p-&gt;next;</span><br><span class="line">                p-&gt;next = temp-&gt;next;</span><br><span class="line">                </span><br><span class="line">                temp-&gt;next = tail-&gt;next;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>回转链表，注意不是反转链表。</p>
<h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>分三步，首先求出链表长度以及最后一个节点，然后找到回转后的首个节点的前继，最后修改一下它们的指针即可。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *p = head, *lastNode;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            lastNode = p;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k = len - k - <span class="number">1</span>;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode-&gt;next = head;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode 82 Remove Duplicates from Sorted List II"></a>Leetcode 82 Remove Duplicates from Sorted List II</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>删除有序链表中的重复元素。</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>申请个冗余节点会比较好实现点。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *p2 = head;</span><br><span class="line">            <span class="keyword">while</span> (p2-&gt;next &amp;&amp; p2-&gt;next-&gt;val == head-&gt;val) &#123;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != p2) &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != p2) &#123;</span><br><span class="line">                    ListNode *temp = head-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span>(head);</span><br><span class="line">                    head = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                head= p2-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(p2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = head;</span><br><span class="line">                p = p-&gt;next; </span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(dummy);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 83 Remove Duplicates from Sorted List"></a>Leetcode 83 Remove Duplicates from Sorted List</h1><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>删除有序链表中的多余的重复元素，即要保证每个元素最多出现一次。</p>
<h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>直接扫一遍就行了，注意delete掉删掉的节点。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">                ListNode *temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode 86 Partition List"></a>Leetcode 86 Partition List</h1><p>留坑待填。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/leetcode-sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/01/leetcode-sum/" class="post-title-link" itemprop="url">Leetcode 题解 C++ Two Sum | 3Sum | 4Sum</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-01 11:25:58" itemprop="dateCreated datePublished" datetime="2019-03-01T11:25:58+08:00">2019-03-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Leetcode-1-Two-Sum"><a href="#Leetcode-1-Two-Sum" class="headerlink" title="Leetcode 1 Two Sum"></a>Leetcode 1 Two Sum</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出两个不同下标的元素，使得它们的值等于某一个值。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>法一：先排序，然后双指针扫一遍。时间复杂度是$O(nlogn)$，空间复杂度是$O(logn)$。</li>
<li>法二：哈希，空间换时间。时间复杂度$O(n)$，空间复杂度是$O(n)$。</li>
</ol>
<p>下面给出法二的代码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = m.find(diff);</span><br><span class="line">            <span class="keyword">if</span> (it != m.end()) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">                ans.push_back(it-&gt;second);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15 3Sum"></a>Leetcode 15 3Sum</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出所有三个不同下标的元素，使得它们的值等于0。另外要求三元组不能重复。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>先排序，然后利用有序性，将原本需要三层循环的遍历用一层循环 + 双指针来做。时间复杂度是$O(n^2)$。<br>用C++写的话，需要注意vector的size()函数返回的是vector::size_type，一般是unsigned int。<br>因此，假如传进来的vector的元素个数少于2，那么num.size() - 2运算后得到的是一个很大的正数，造成运行错误。<br>所以，我们可以先判断一下nums.size()的大小，假如小于3，那么就直接返回了。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (nums[i] != nums[i<span class="number">-1</span>])) &#123;</span><br><span class="line">                <span class="keyword">int</span> need = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="keyword">int</span> lo = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[lo] + nums[hi] == need) &#123;</span><br><span class="line">                        ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;nums[i], nums[lo], nums[hi]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi<span class="number">-1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++, hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; need) &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-18-4Sum"><a href="#Leetcode-18-4Sum" class="headerlink" title="Leetcode 18 4Sum"></a>Leetcode 18 4Sum</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给一个vector，从中找出所有四个不同下标的元素，使得它们的值等于某个值。另外要求四元组不能重复。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先排序，然后利用有序性，将原本需要四层循环的遍历用两层循环 + 双指针来做。时间复杂度是$O(n^3)$。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> lo = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> hi = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[lo] + nums[hi];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[lo], nums[hi]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++, hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/leetcode-single-number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/13/leetcode-single-number/" class="post-title-link" itemprop="url">Leetcode 题解 C++ Single Number I II III</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-13 15:37:27" itemprop="dateCreated datePublished" datetime="2019-01-13T15:37:27+08:00">2019-01-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Leetcode上做了Single Number系列的三道题，都是与位运算有关的，感觉都挺巧妙。</p>
<h1 id="Leetcode-136-Single-Number-I"><a href="#Leetcode-136-Single-Number-I" class="headerlink" title="Leetcode 136 Single Number I"></a>Leetcode 136 Single Number I</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有一个数字是出现一次的，其他的数字都恰好出现两次，现在求只出现一次的数是多少。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据异或的性质，答案是所有的数字的异或和。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-137-Single-Number-II"><a href="#Leetcode-137-Single-Number-II" class="headerlink" title="Leetcode 137 Single Number II"></a>Leetcode 137 Single Number II</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有一个数字是出现一次的，其他的数字恰好都出现三次，现在求只出现一次的数是多少。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>显然，假如还是用上一题的做法，直接将数字异或起来，是得不到答案的。为什么上一题的答案直接异或起来就可以，因为出现两次的数字异或后等于出现零次，具体对于某一位来说，它会经过<code>0-&gt;1-&gt;0</code>这么个过程。而对于这道题，假如某个数字出现了三次，那么对于具体某一位来说，它会经过<code>0-&gt;1-&gt;0-&gt;1</code>这个过程。因此，我们应用两个位来表示具体某一位的状态变化，即让它经过<code>00-&gt;10-&gt;01-&gt;00</code>这么个过程。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            ones = (ones ^ i) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ i) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-260-Single-Number-III"><a href="#Leetcode-260-Single-Number-III" class="headerlink" title="Leetcode 260 Single Number III"></a>Leetcode 260 Single Number III</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>一组数中只有两个数字是出现一次的，其他的数字恰好都出现两次，现在求只出现一次的数是哪两个。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>我们先将所有数字异或起来，得到<code>c</code>。设答案为<code>a</code>和<code>b</code>，那么<code>c = a ^ b</code>。</p>
<p>对于这个<code>c</code>的各个位，有的是<code>0</code>，有的是<code>1</code>。值为<code>1</code>的位，意味着只属于<code>a</code>或<code>b</code>。因此，我们可以任意取<code>c</code>中一个值为<code>1</code>的位，将所有数字划分为两个可重集合，这两个集合的数字分别异或起来就是答案。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            sum ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum &amp;= -sum;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &amp; i) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] ^= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[<span class="number">1</span>] ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/06/sam-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/06/sam-learning/" class="post-title-link" itemprop="url">后缀自动机学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-06 21:43:55" itemprop="dateCreated datePublished" datetime="2018-10-06T21:43:55+08:00">2018-10-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>后缀自动机(SAM)是一种用于处理字符串的高效数据结构，时间复杂度为$O(|S| * CHARSET_SIZE)$。其应用一般与子串有关，比如求解最长公共子串、求解不同子串的个数、求字典序第k小的子串。</p>
<p><a href="https://vjudge.net/contest/47126" target="_blank" rel="noopener">题目传送门</a></p>
<h1 id="SPOJ-LCS-Longest-Common-Substring"><a href="#SPOJ-LCS-Longest-Common-Substring" class="headerlink" title="SPOJ LCS Longest Common Substring"></a>SPOJ LCS Longest Common Substring</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求它们的最长公共子串。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于字符串长度上限250000，所以$O(n^2)$的算法是行不通的。<br>我们可以考虑给其中一个字符串建立后缀自动机，该自动机保存了这个字符串的所有子串。接着，我们在这个自动机上跑另一个字符串，假如匹配，就走下一步，假如不匹配，就走失配指针，直到匹配或者回到了根节点。在这个过程中，维护一下匹配的长度，不断取max即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250009</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">1</span>, le = <span class="built_in">strlen</span>(s), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; le; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][to]) &#123;</span><br><span class="line">                ans = max(ans, ++cnt);</span><br><span class="line">                now = ch[now][to];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(now &amp;&amp; !ch[now][to]) now = fail[now];</span><br><span class="line">                <span class="keyword">if</span>(now) &#123;</span><br><span class="line">                    cnt = len[now] + <span class="number">1</span>;</span><br><span class="line">                    now = ch[now][to];</span><br><span class="line">                    ans = max(ans, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = <span class="number">1</span>;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    sam.init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        sam.insert(s[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    sam.solve(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPOJ-LCS2-Longest-Common-Substring-II"><a href="#SPOJ-LCS2-Longest-Common-Substring-II" class="headerlink" title="SPOJ LCS2 Longest Common Substring II"></a>SPOJ LCS2 Longest Common Substring II</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给n($2 &lt;= n &lt;= 10$)个字符串，求它们的最长公共子串。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这一题在上一题的基础上进行了一定的拓展。我们还是给其中一个字符串建立后缀自动机，然后将其余字符串在自动机上跑一遍。在每个节点上，我们需要维护一个$f$，表示所有字符串到达该结点时的最大匹配长度，初始化为第一个字符串的在该点的$len$。当其余字符串进来匹配的时候，用当前最大匹配长度来更新这个$f$，不断取min。这里需要注意的是，某个结点$u$被访问到，但其后缀链指向的结点$v$可能没被访问到，但是，根据SAM后缀树的性质，$v$结点表示的最大子串是会被完全匹配的。所以，我们将字符串在自动机跑完一遍后，还需要根据拓扑序再反向更新一下。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], mat[MAXN], f[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            mat[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> le = <span class="built_in">strlen</span>(s), lenn = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; le; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ne = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][ne])</span><br><span class="line">                now = fail[now], lenn = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][ne]) &#123;</span><br><span class="line">                now = ch[now][ne];</span><br><span class="line">                f[now] = max(f[now], ++lenn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 这一句非常精髓啊</span></span><br><span class="line">            <span class="keyword">if</span>(f[topo[i]])</span><br><span class="line">                f[fail[topo[i]]] = len[fail[topo[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            mat[i] = min(mat[i], f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            ans = max(ans, mat[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    sam.init();</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sam.insert(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.topoSort();</span><br><span class="line">    sam.pre();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s)) &#123;</span><br><span class="line">        sam.update(s);</span><br><span class="line">    &#125;</span><br><span class="line">    sam.solve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPOJ-NSUBSTR-Substrings"><a href="#SPOJ-NSUBSTR-Substrings" class="headerlink" title="SPOJ NSUBSTR     Substrings"></a>SPOJ NSUBSTR     Substrings</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>根据子串的长度，可将一个长为$|S|$的字符串的所有子串分到$|S|$个集合中。问在各个集合中，在母串中出现次数最多的子串的出现次数？</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>要统计某一子串出现的次数，需要按照拓扑序逆着更新。当访问到某一节点时，我们把最大长度子串所属集合的答案更新一下，然后传递一下$cntPos$给失配指针所指的结点。我们知道，一个结点表示了多个子串，为什么只更新最大长度子串所属的集合就行了呢？可以这样理解，假设某一节点的最大长度子串为$S[L…R]$，根据SAM的性质，$S[L..(R-1)]$一定不与S[L…R]$在同一结点，且它出现的次数不少于$S[L…R]$，因此，后续访问到该结点时会更新$(R-1)$的答案，而长度更短的同理，也是会被更新到。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 2 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span> len);</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        <span class="built_in">memset</span>(cntPos, <span class="number">0</span>, <span class="keyword">sizeof</span> cntPos);</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">2</span>;</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = last = sz++;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sz++; len[n] = len[v] + <span class="number">1</span>;</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans[MAXN];</span><br><span class="line">        <span class="keyword">int</span> le = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            ans[len[u]] = max(ans[len[u]], cntPos[u]);  <span class="comment">// ?</span></span><br><span class="line">            cntPos[fail[u]] += cntPos[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= le; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s)) &#123;</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.topoSort();</span><br><span class="line">    &#125;</span><br><span class="line">    sam.solve(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPOJ-SUBLEX-Lexicographical-Substring-Search"><a href="#SPOJ-SUBLEX-Lexicographical-Substring-Search" class="headerlink" title="SPOJ SUBLEX Lexicographical Substring Search"></a>SPOJ SUBLEX Lexicographical Substring Search</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，求字典序第k小的子串。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>首先给字符串建立SAM，该SAM保存该字符串的所有子串。<br>接着，从根出发，dfs一遍，对各个结点统计从该结点出发的子串数。<br>然后，我们再从根出发，贪心地走字符较小的边。假如一条边到达的结点的子串数大于等于k，那么这条边就可以走。否则，我们减去该结点的子串数，然后找另一条边。一直做下去，直到k等于0了就停止。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 3 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line">pii G[MAXN][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line"><span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line"><span class="keyword">int</span> path[MAXN], p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">2</span>;</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = last = sz++;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sz++; len[n] = len[v] + <span class="number">1</span>;</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cntPath</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path[u]) <span class="keyword">return</span> path[u];</span><br><span class="line">        p[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[u][i]) &#123;</span><br><span class="line">                path[u] += cntPath(ch[u][i]);</span><br><span class="line">                G[u][p[u]++] = pii(ch[u][i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path[u]++;</span><br><span class="line">        <span class="keyword">return</span> path[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意用递归写法会超时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[u]; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = G[u][i].x;</span><br><span class="line">                <span class="keyword">if</span>(v &amp;&amp; path[v] &gt;= k) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, G[u][i].y + <span class="string">'a'</span>);</span><br><span class="line">                    k--;</span><br><span class="line">                    u = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    k -= path[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ss[N];</span><br><span class="line"><span class="keyword">int</span> q, lenn, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ss);</span><br><span class="line">    sam.init();</span><br><span class="line">    lenn = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenn; i++)</span><br><span class="line">        sam.insert(ss[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    sam.cntPath(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        sam.findK(<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPOJ-COT4-Count-on-a-trie"><a href="#SPOJ-COT4-Count-on-a-trie" class="headerlink" title="SPOJ COT4 Count on a trie"></a>SPOJ COT4 Count on a trie</h1><p>留坑待填。</p>
<h1 id="HDU-4416-Good-Article-Good-sentence"><a href="#HDU-4416-Good-Article-Good-sentence" class="headerlink" title="HDU 4416 Good Article Good sentence"></a>HDU 4416 Good Article Good sentence</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，可以有很多子串，记为集合A。然后再给一些字符串，同样可以有很多子串，记为集合B。现在需要求集合A和集合B的差的大小，即在A集合里出现但不在B集合里出现的元素个数。</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先给第一个字符串建立SAM，然后依次将其余的字符串取更新这个SAM。<br>SAM中的各个结点需要保存一个值f，表示被其余字符串匹配到最大长度。对于某一结点u，f初始化为len[fail[u]]。<br>这里需要注意的是，同多个字符串的最长公共子串问题一样，在匹配完整个字符串后，还需要根据拓扑序逆着更新f一下。<br>最后，所有节点的len - f的和即为答案。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高 </span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN] = &#123;<span class="number">-1</span>&#125;, fail[MAXN], sz = <span class="number">2</span>, last = <span class="number">1</span>, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="keyword">int</span> f[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            f[i] = len[fail[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="built_in">strlen</span>(s), now = <span class="number">1</span>, le = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; up; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][v])</span><br><span class="line">                now = fail[now], le = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][v]) &#123;</span><br><span class="line">                now = ch[now][v];</span><br><span class="line">                vis[now] = <span class="literal">true</span>;</span><br><span class="line">                le++;</span><br><span class="line">                f[now] = max(f[now], le);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">                vis[fail[u]] = <span class="literal">true</span>;</span><br><span class="line">                f[fail[u]] = len[fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            ans += len[i] - f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, kase;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++kase);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.pre();</span><br><span class="line">        sam.topoSort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            sam.update(s);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="POJ-3415-Common-Substrings"><a href="#POJ-3415-Common-Substrings" class="headerlink" title="POJ 3415 Common Substrings"></a>POJ 3415 Common Substrings</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求所有长度大于k的公共子串的对数。</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>我们知道，SAM中某个节点代表的是长度连续的数个后缀，不妨设长度为$[L, R]$。在匹配的过程中，长度会落在$[L, R]$之间，我们只需要加上$[k, R]$的这段（可能为空）。<br>另外，还需要按照拓扑序逆着更新一下，这里的更新需要是需要计数的。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;		//CLOCKS_PER_SEC;clock_t t=clock();</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;		</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;	//getline(cin, line);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;	//stringstream ss(line);(ss is a stream like cin).</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cfloat&gt;	//X=FLT,DBL,LDBL;X_MANT_DIG,X_DIG,X_MIN_10_EXP,X_MIN_10_EXP,X_MIN,X_MAX,X_EPSILON</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;	//INT_MAX,LLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; 	//ios_base::sync_with_stdio(false);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">59</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="keyword">int</span> sum[MAXN], vis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        topoSort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            cntPos[fail[u]] += cntPos[u];</span><br><span class="line">            vis[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>, le = <span class="number">0</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, up = <span class="built_in">strlen</span>(s); i &lt; up; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; !ch[now][v])</span><br><span class="line">                now = fail[now], le = len[now];</span><br><span class="line">            <span class="keyword">if</span>(ch[now][v]) &#123;</span><br><span class="line">                now = ch[now][v];</span><br><span class="line">                le++;</span><br><span class="line">                vis[now]++;</span><br><span class="line">                <span class="keyword">if</span>(le &gt;= k) &#123;</span><br><span class="line">                    ans += <span class="number">1L</span>L * cntPos[now] * (le - max(len[fail[now]] + <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">                sum[fail[u]] += vis[u];</span><br><span class="line">                vis[fail[u]] += vis[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] &gt;= k) &#123;</span><br><span class="line">                ans += <span class="number">1L</span>L * sum[i] * cntPos[i] * (len[i] - max(len[fail[i]] + <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s, t);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s); i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.solve(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HDU-3518-Boring-counting"><a href="#HDU-3518-Boring-counting" class="headerlink" title="HDU 3518 Boring counting"></a>HDU 3518 Boring counting</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>首先给字符串建立SAM，对于各个结点，需要额外维护最长子串首先出现的位置以及最后出现的位置。最后出现的位置需要按照拓扑序逆着来更新。<br>然后扫一遍，根据某个结点代表的最短字符串、最长字符串与最长子串首先出现、最后出现位置，分情况讨论一下即可。<br>一开始没有注意到出现次数大于等于2这个条件，多想了一下。假如要求出现次数大于等于k的话，那么我们可能需要维护的是各个节点的最长子串出现的具体位置，这可能需要就需要用到LCT来维护了。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 6 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN], l[MAXN], r[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(l, <span class="number">-1</span>, <span class="keyword">sizeof</span> l);</span><br><span class="line">        <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="keyword">sizeof</span> r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> po)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        l[u] = r[u] = po;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            l[n] = r[n] = l[o];</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        topoSort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            r[fail[u]] = max(r[fail[u]], r[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] &lt;= r[i] - l[i]) &#123;</span><br><span class="line">                ans += len[i] - len[fail[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += max(<span class="number">0</span>, r[i] - l[i] - len[fail[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s) &amp;&amp; s[<span class="number">0</span>] != <span class="string">'#'</span>) &#123;</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, up = <span class="built_in">strlen</span>(s); i &lt; up; i++) &#123;</span><br><span class="line">            sam.insert(s[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HDU-4622-Reincarnation"><a href="#HDU-4622-Reincarnation" class="headerlink" title="HDU 4622 Reincarnation"></a>HDU 4622 Reincarnation</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，然后有$Q$次询问，求该字符串$[L, R]$本质不同的字符串个数。</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>首先建立SAM，然后对于每次询问，分别处理，维护的是最大匹配长度。<br>然后，扫一遍各个节点，累加最大匹配长度 - 最小字符串 + 1 即可。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> okd(d) cout &lt;&lt; <span class="meta-string">"ok "</span> &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2009</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 后缀自动机(Tested 7 times)</span></span><br><span class="line"><span class="comment"> * 数组实现，效率较高</span></span><br><span class="line"><span class="comment"> * 开点时才初始化，在多组样例的情况下会比直接memset整个数组快很多，比如HDU4416</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n * CHARSET_SIZE)</span></span><br><span class="line"><span class="comment"> * used variables: N, </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = N &lt;&lt; <span class="number">1</span>;  <span class="comment">// 注意在SAM里面开的数组大小应为MAXN，因为长度为n的字符串最多会有2*n个结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][CHARSET_SIZE], len[MAXN], fail[MAXN], sz, last, cntPos[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tong[MAXN], topo[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        last = newnode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> le)</span> </span>&#123;</span><br><span class="line">        len[sz] = le;</span><br><span class="line">        fail[sz] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++)</span><br><span class="line">            ch[sz][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sz++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> v = last, u = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">        last = u;</span><br><span class="line">        cntPos[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; v &amp;&amp; !ch[v][c]; v = fail[v]) ch[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span>(!v)&#123;fail[u] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> o = ch[v][c];</span><br><span class="line">        <span class="keyword">if</span>(len[v] + <span class="number">1</span> == len[o]) fail[u] = o;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = newnode(len[v] + <span class="number">1</span>);</span><br><span class="line">            cntPos[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[n], ch[o], <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">            fail[n] = fail[o];</span><br><span class="line">            fail[u] = fail[o] = n;</span><br><span class="line">            <span class="keyword">for</span>(; ch[v][c] == o; v = fail[v]) ch[v][c] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span> tong);</span><br><span class="line">        tong[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">            tong[i] += tong[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            topo[--tong[len[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>, le = <span class="number">0</span>, f[MAXN];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            now = ch[now][v];</span><br><span class="line">            le++;</span><br><span class="line">            f[now] = max(f[now], le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = topo[i];</span><br><span class="line">            <span class="keyword">if</span>(f[u]) &#123;</span><br><span class="line">                f[fail[u]] = len[fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            ans += max(<span class="number">0</span>, f[i] - len[fail[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, l, r;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s); i &lt; len; i++) &#123;</span><br><span class="line">            sam.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sam.topoSort();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            sam.solve(s, l - <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HDU-4436-str2int"><a href="#HDU-4436-str2int" class="headerlink" title="HDU 4436 str2int"></a>HDU 4436 str2int</h1><p>留坑待填。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/arithmetic-problems-generator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/30/arithmetic-problems-generator/" class="post-title-link" itemprop="url">四则运算项目折腾笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-30 10:00:00" itemprop="dateCreated datePublished" datetime="2018-09-30T10:00:00+08:00">2018-09-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/hyzgh/arithmetic-problems-generator" target="_blank" rel="noopener">Github项目地址传送门</a></p>
<h1 id="项目相关要求"><a href="#项目相关要求" class="headerlink" title="项目相关要求"></a>项目相关要求</h1><blockquote>
<ol>
<li>(完成)使用 -n 参数控制生成题目的个数。</li>
<li>(完成)使用 -r 参数控制题目中数值（自然数、真分数和真分数分母）的范围。该参数可以设置为1或其他自然数。该参数必须给定，否则程序报错并给出帮助信息。</li>
<li>(完成)生成的题目中计算过程不能产生负数，也就是说算术表达式中如果存在形如e1 − e2的子表达式，那么e1 ≥ e2。</li>
<li>(完成)生成的题目中如果存在形如e1 ÷ e2的子表达式，那么其结果应是真分数。</li>
<li>(完成)每道题目中出现的运算符个数不超过3个。</li>
<li>(完成)程序一次运行生成的题目不能重复，即任何两道题目不能通过有限次交换+和×左右的算术表达式变换为同一道题目。例如，23 + 45 = 和45 + 23 = 是重复的题目，6 × 8 = 和8 × 6 = 也是重复的题目。3+(2+1)和1+2+3这两个题目是重复的，由于+是左结合的，1+2+3等价于(1+2)+3，也就是3+(1+2)，也就是3+(2+1)。但是1+2+3和3+2+1是不重复的两道题，因为1+2+3等价于(1+2)+3，而3+2+1等价于(3+2)+1，它们之间不能通过有限次交换变成同一个题目。生成的题目存入执行程序的当前目录下的Exercises.txt文件。</li>
<li>(完成)在生成题目的同时，计算出所有题目的答案，并存入执行程序的当前目录下的Answers.txt文件。</li>
<li>(完成)程序应能支持一万道题目的生成。</li>
<li>(完成)程序支持对给定的题目文件和答案文件，判定答案中的对错并进行数量统计， 统计结果输出到文件Grade.txt。</li>
</ol>
</blockquote>
<h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><p>本次项目的代码遵循了谷歌代码规范(C++)，但由于谷歌代码规范篇幅太多，所以我们目前只遵循了其中的部分规范，具体如下：</p>
<ol>
<li>禁止使用宏</li>
<li>分号以前不加空格</li>
<li>行宽原则上不超过80</li>
<li>一行只定义一个变量</li>
<li>左大括号前保留一个空格</li>
<li>if, else前后都要一个空格</li>
<li>for, while后要有一个空格</li>
<li>return 后面的数值不加 ( )</li>
<li>每个文件应该含有版权信息及作者</li>
<li>左圆括号之后和右圆括号之前无空格</li>
<li>函数参数过多时，每行的参数变量对齐</li>
<li>一目运算符与变量之间不加空格符隔开</li>
<li>禁止使用 using 指示（using-directive） </li>
<li>禁止使用C++的流，而是用printf之类的替代</li>
<li>要么函数名与参数同行，要么所有参数并排分行</li>
<li>换行代码缩进2个空格，并且使用两个空格符取代制表符</li>
<li>二目以上的运算符与变量，常量之间用空格隔开（各类括号除外）</li>
<li>不论控制语句，循环语句后面的循环体有多少行，都必须使用花括号</li>
<li>普通函数，类型（含类与结构体，枚举类型），常量等使用大小写混合，不含下划线</li>
<li>除函数定义的左大括号可置于行首以外，包括函数/类/结构体/枚举声明，各种语句的左大括号必须置于行末，所有右大括号独立成行</li>
</ol>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145059141-655290070.png" alt></p>
<h1 id="具体设计-amp-关键代码"><a href="#具体设计-amp-关键代码" class="headerlink" title="具体设计&amp;关键代码"></a>具体设计&amp;关键代码</h1><h2 id="ImproperFraction类"><a href="#ImproperFraction类" class="headerlink" title="ImproperFraction类"></a>ImproperFraction类</h2><p>构建一个ImproperFraction的类，然后重载这个类的四种运算 <strong>+-x÷</strong> 以及以及六种逻辑关系<strong>‘&lt;’  ‘==’  ‘&lt;=’  ‘!=’  ‘&gt;’  ‘&gt;=’</strong>判断，在后续的代码编写之中都是基于这个类进行运算</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImproperFraction</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span> :</span><br><span class="line">  ImproperFraction()&#123;&#125;</span><br><span class="line">  ImproperFraction (<span class="keyword">int</span> Mole, <span class="keyword">int</span> Deno, <span class="keyword">int</span> Coef = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="built_in">std</span>::__gcd (Mole, Deno);</span><br><span class="line">    g = <span class="built_in">std</span>::max(g, <span class="number">1</span>);</span><br><span class="line">    mole = (Mole + Coef * Deno) / g;</span><br><span class="line">    deno = Deno / g;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> + (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.deno + rhs.mole * deno;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> - (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.deno - rhs.mole * deno;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> * (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.deno;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.mole;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  ImproperFraction <span class="keyword">operator</span> / (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> DENO = deno * rhs.mole;</span><br><span class="line">    <span class="keyword">int</span> MOLE = mole * rhs.deno;</span><br><span class="line">    ImproperFraction res = ImproperFraction (MOLE, DENO);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mole * rhs.deno &lt; rhs.mole * deno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mole * rhs.deno == rhs.mole * deno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(mole * rhs.deno == rhs.mole * deno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>) &lt; rhs || (*<span class="keyword">this</span>) == rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !((*<span class="keyword">this</span>) &lt;= rhs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> ImproperFraction &amp; rhs ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>) &gt; rhs || (*<span class="keyword">this</span>) == rhs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> :</span><br><span class="line">  <span class="keyword">int</span> mole = <span class="number">0</span>; <span class="comment">// 分子</span></span><br><span class="line">  <span class="keyword">int</span> deno = <span class="number">1</span>; <span class="comment">// 分母 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="题集的生成"><a href="#题集的生成" class="headerlink" title="题集的生成"></a>题集的生成</h2><h3 id="表达式的生成"><a href="#表达式的生成" class="headerlink" title="表达式的生成"></a>表达式的生成</h3><p>在这里选择的是rand() 随机生成 运算符个数，类型以及每个被运算的数值。</p>
<h3 id="表达式的合法性判断"><a href="#表达式的合法性判断" class="headerlink" title="表达式的合法性判断"></a><strong>表达式的合法性判断</strong></h3><p> 在生成过程之中，有两个要点会导致表达式非法<br>1.运算过程中出现负值<br>2.在÷运算后面出现0</p>
<p><strong>解决办法：</strong>两个特殊判断即可</p>
<h3 id="表达式的去重"><a href="#表达式的去重" class="headerlink" title="表达式的去重"></a><strong>表达式的去重</strong></h3><p>表达式的重复有两种情况:<br>1.完完全全的重复，如出现两个1 + 2 + 3 的表达式<br>2.运算顺序上的重复，如:</p>
<blockquote>
<p>1 + 2 + 3 和 2 + 1 + 3重复<br>2 + 3 x 4 和 4 x 3 + 2重复</p>
</blockquote>
<p><strong>解决办法：</strong><br>对于(1)的情况只需要将生成的表达式保存进C++STL的set之中即可自动去重。<br>对于(2)的情况，则是按照一定规则生成表达式来避免这一情况，规则如下：</p>
<blockquote>
<p>1.默认左边的运算符的优先度高于右边<br>2.第一个数字一定不小于第二个数值<br>因此1 + 2 + 3和2 + 3 x 4不会被生成，而只会生成2 + 1 + 3和4 x 3 + 2</p>
</blockquote>
<h3 id="题集无法生成要求的数量"><a href="#题集无法生成要求的数量" class="headerlink" title="题集无法生成要求的数量"></a><strong>题集无法生成要求的数量</strong></h3><p> 例如：<br>传入的参数是 -n 10000 -r 1 的时候，很明显无法生成10000道题目，因此陷入死循环的生成中</p>
<p><strong>解决办法：</strong><br>设置一个时间戳time，当生成表达式的部分循环了1000000次之后自动跳出循环，终止生成表达式 </p>
<h3 id="答案的生成"><a href="#答案的生成" class="headerlink" title="答案的生成"></a><strong>答案的生成</strong></h3><p> 在表的是合法性判断的时候，会判断最终的数值是否小于0，在这里就已经计算标准答案，保存并打印到answer.txt即可</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">questionSetGenerate</span> <span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;expressions;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;exercise;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImproperFraction&gt;answer;</span><br><span class="line">  ImproperFraction zero = ImproperFraction(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (expressions.size() &lt; number &amp;&amp; time &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">    time ++;</span><br><span class="line">    <span class="keyword">int</span> sz = expressions.size();</span><br><span class="line">    <span class="comment">// 运算符的个数</span></span><br><span class="line">    <span class="keyword">int</span> opnumber = rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    ImproperFraction a[<span class="number">5</span>];</span><br><span class="line">    ImproperFraction res = ImproperFraction(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> ImproperFraction zero = ImproperFraction(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 随机生成数值和运算符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= opnumber; i++) &#123;</span><br><span class="line">      a[i] = ImproperFraction(rand() % (limit * limit), <span class="built_in">std</span>::max(<span class="number">1</span>, rand() % limit));</span><br><span class="line">      <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        op[i] = oper[rand() % <span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">exp</span> = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; a[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::swap (a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算答案,并检查中途出现非法情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= opnumber; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">          res = res + a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">          res = res * a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">          res = res - a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (a[i] == zero) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          res = res / a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span> + op[i];</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="string">' '</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = res + a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将分数转化为字符串</span></span><br><span class="line">      fractionToString(a[i], <span class="built_in">exp</span>);</span><br><span class="line">      <span class="keyword">if</span> (res.getdeno() &lt; <span class="number">0</span> || res.getmole() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      expressions.insert(<span class="built_in">exp</span>);</span><br><span class="line">      <span class="keyword">if</span> (expressions.size() &gt; sz) &#123;</span><br><span class="line">        <span class="comment">//保存题集和答案</span></span><br><span class="line">        exercise.push_back(addbrackets(<span class="built_in">exp</span>));</span><br><span class="line">        answer.push_back(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="答案正确性的检测"><a href="#答案正确性的检测" class="headerlink" title="答案正确性的检测"></a>答案正确性的检测</h2><p>用户通过参数-e exercises.txt -a answers.txt，传进来了题目文件的名称和答案文件的名称。<br>首先，由于文件可能不存在或者没有访问的权限，我们需要对此进行检查，假如有错误，则进行报错，没有异常才进行下一步。<br>第二步，我们需要对exercises.txt文件中的题目计算一遍，然后再和answers.txt文件中的答案进行比较。题目的计算分两步进行，即先将中缀表达式转化为后缀表达式，然后计算后缀表达式的答案。<br>对于这个函数，我们考虑了exercises.txt行数和answers.txt行数不相等的情况，此时我们将以exercises.txt的行数为准，假如answers.txt行数过少，那么将视为错误答案，假如过多，那么将被忽略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkAnswer</span><span class="params">(FILE *exerciseFile, FILE *answerFile)</span> </span>&#123;</span><br><span class="line">  FILE *pFile = getPointerToGradeFile();</span><br><span class="line">  <span class="keyword">int</span> problemID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> answer[<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">char</span> exercise[<span class="number">256</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; wrongID;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; correctID;</span><br><span class="line">  <span class="comment">// 答案的行数可能不等于题目的行数</span></span><br><span class="line">  <span class="keyword">while</span> (fgets(answer, <span class="number">256</span>, answerFile)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fgets(exercise, <span class="number">256</span>, exerciseFile)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    problemID++;</span><br><span class="line">    removeRedundantPart(answer, exercise);</span><br><span class="line">    handleDivideEncoding(exercise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getInfixExpressionAnswer(exercise) == stringToImproperFraction(answer)</span><br><span class="line">       ) &#123;</span><br><span class="line">      correctID.push_back(problemID);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wrongID.push_back(problemID);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fgets(exercise, <span class="number">256</span>, exerciseFile)) &#123;</span><br><span class="line">    problemID++;</span><br><span class="line">    wrongID.push_back(problemID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printID(pFile, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"Correct"</span>), correctID);</span><br><span class="line">  printID(pFile, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"Wrong"</span>), wrongID);</span><br><span class="line">  fclose(pFile);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Check answer done!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; transformInfixExprToSuffixExpr(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;InfixExpression) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; temp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; InfixExpression.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> cc = InfixExpression[i];</span><br><span class="line">    <span class="keyword">if</span> (cc == <span class="string">' '</span>) &#123;  <span class="comment">// 假如遇到空格就跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">'('</span>) &#123;  <span class="comment">// 遇到左括号就直接入栈</span></span><br><span class="line">      temp.push(cc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">')'</span>) &#123;  <span class="comment">// 遇到右括号就弹出栈里面的所有运算符，直到遇到左括号</span></span><br><span class="line">      <span class="keyword">char</span> c;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        c = temp.top();</span><br><span class="line">        temp.pop();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span>) &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (c != <span class="string">'('</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">'+'</span> || cc == <span class="string">'-'</span>) &#123;</span><br><span class="line">      <span class="comment">// 遇到加号减号也弹出栈顶的所有运算符，直到遇到左括号或者为栈为空</span></span><br><span class="line">      <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = temp.top();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'('</span>) &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">          temp.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.push(cc);  <span class="comment">// 然后将加号入栈</span></span><br><span class="line">    &#125; else if (cc == 'x' || cc == '\xc3') &#123;</span><br><span class="line">      <span class="comment">// 假如遇到所有乘号除号，就弹出栈顶的乘号除号，知道遇到加号减号或者左括号或者栈为空</span></span><br><span class="line">      i += cc == '\xc3';</span><br><span class="line">      <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = temp.top();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'x'</span>) &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">          temp.pop();</span><br><span class="line">        &#125; else if (c == '\xc3') &#123;</span><br><span class="line">          result.push(charToString(c));</span><br><span class="line">          temp.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.push(cc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 假如遇到数字，那就直接输出</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; InfixExpression.length()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = InfixExpression[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">'/'</span> || c == <span class="string">'\''</span>) &#123;</span><br><span class="line">          s += c;</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把栈里面剩余的东西输出</span></span><br><span class="line">  <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = temp.top();</span><br><span class="line">    temp.pop();</span><br><span class="line">    result.push(charToString(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算后缀表达式的答案</span></span><br><span class="line"><span class="function">ImproperFraction <span class="title">getSuffixExpressionAnswer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; suffixExpression)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ImproperFraction&gt; sta;</span><br><span class="line">  <span class="keyword">while</span> (!suffixExpression.empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = suffixExpression.front();</span><br><span class="line">    suffixExpression.pop();</span><br><span class="line">    <span class="keyword">if</span> (isOperator(s)) &#123;</span><br><span class="line">      <span class="comment">// 假如遇到运算符，就取出栈顶元素进行计算</span></span><br><span class="line">      ImproperFraction a = sta.top();</span><br><span class="line">      sta.pop();</span><br><span class="line">      ImproperFraction b = sta.top();</span><br><span class="line">      sta.pop();</span><br><span class="line">      <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'x'</span>) &#123;</span><br><span class="line">        sta.push(a * b);</span><br><span class="line">      &#125; else if (s[0] == '\xc3') &#123;</span><br><span class="line">        sta.push(b / a);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        sta.push(a + b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sta.push(b - a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 假如遇到数字，就直接进栈</span></span><br><span class="line">      sta.push(stringToImproperFraction(s));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sta.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><h2 id="首先是各种参数错误的测试"><a href="#首先是各种参数错误的测试" class="headerlink" title="首先是各种参数错误的测试"></a><strong>首先是各种参数错误的测试</strong></h2><p><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145152174-840362064.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145220286-2085095778.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145231725-1173918739.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145237511-1881695301.png" alt></p>
<h2 id="接着是传入正确的参数的测试"><a href="#接着是传入正确的参数的测试" class="headerlink" title="接着是传入正确的参数的测试"></a><strong>接着是传入正确的参数的测试</strong></h2><p>生成题集的测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145300636-1176994323.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145309201-925214622.png" alt></p>
<p>给定的题目文件和答案文件，判定答案中的对错测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145337222-2053419510.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145345693-634194743.png" alt></p>
<h1 id="效能分析"><a href="#效能分析" class="headerlink" title="效能分析"></a>效能分析</h1><p>本程序主要由生成运算题目和检查答案正确性两个模块，因此效能分析也主要针对这两个模块进行。<br><strong>1. 生成运算题目</strong><br>生成一百万条题目时候的时间占比情况：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145401885-266275327.png" alt></p>
<p>由上图看出了，占用时间最多的前五个函数为</p>
<ol>
<li>questionSetGenerate</li>
<li>gcd</li>
<li>addbrackets</li>
<li>digToString</li>
<li>ImproperFraction</li>
</ol>
<p>其中，questionSetGenerate是生成运算题目的函数入口，占用时间最长。gcd是在题目运算过程，分数通分时进行调用的，具体实现是辗转相除法。addbrackets是在生成题目的过程给表达式添加括号。digTostring是在生成题目的过程将数字转化为字符串。ImproperFraction是真分数的类名，由于生成的表达式中普遍含有真分数，所以多次调用了它的构造函数。</p>
<p><strong>2. 检查答案正确性</strong><br>检查五十万条题目时的时间占比情况：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180930145411370-99124462.png" alt></p>
<p>由上图可以看出，占用时间最多的前五个函数为：</p>
<ol>
<li>gcd</li>
<li>stringToImproperFraction</li>
<li>__deque_buf_size</li>
<li>transformInfixExprToSuffixExpr</li>
<li>_Deque_base</li>
</ol>
<p>其中，gcd用于运算过程的通分，stringToImproperFraction用于将字符串转化为真分数， transformInfixExprToSuffixExpr用于将中缀表达式转化为后缀表达式。另外两个函数是系统函数。</p>
<p>因此，假如要优化效能的话，可以优先在源代码追踪一下上述函数，看能否减少这些函数的调用或者优化其实现方式。</p>
<h1 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h1><table>
<thead>
<tr>
<th>PSP2.1</th>
<th>Personal Software Process Stages</th>
<th>预估耗时（分钟）</th>
<th>实际耗时（分钟）</th>
</tr>
</thead>
<tbody><tr>
<td>Planning</td>
<td>计划</td>
<td>60</td>
<td>50</td>
</tr>
<tr>
<td>· Estimate</td>
<td>· 估计这个任务需要多少时间</td>
<td>60</td>
<td>50</td>
</tr>
<tr>
<td>Development</td>
<td>开发</td>
<td>965</td>
<td>1545</td>
</tr>
<tr>
<td>· Analysis</td>
<td>· 需求分析 (包括学习新技术)</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>· Design Spec</td>
<td>· 生成设计文档</td>
<td>25</td>
<td>35</td>
</tr>
<tr>
<td>· Design Review</td>
<td>· 设计复审 (和同事审核设计文档)</td>
<td>25</td>
<td>35</td>
</tr>
<tr>
<td>· Coding Standard</td>
<td>· 代码规范 (为目前的开发制定合适的规范)</td>
<td>25</td>
<td>65</td>
</tr>
<tr>
<td>· Design</td>
<td>· 具体设计</td>
<td>60</td>
<td>80</td>
</tr>
<tr>
<td>· Coding</td>
<td>· 具体编码</td>
<td>360</td>
<td>415</td>
</tr>
<tr>
<td>· Code Review</td>
<td>· 代码复审</td>
<td>60</td>
<td>150</td>
</tr>
<tr>
<td>· Test</td>
<td>· 测试（自我测试，修改代码，提交修改）</td>
<td>360</td>
<td>665</td>
</tr>
<tr>
<td>Reporting</td>
<td>报告</td>
<td>110</td>
<td>130</td>
</tr>
<tr>
<td>· Test Report</td>
<td>· 测试报告</td>
<td>60</td>
<td>80</td>
</tr>
<tr>
<td>· Size Measurement</td>
<td>· 计算工作量</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>· Postmortem &amp; Process Improvement Plan</td>
<td>· 事后总结, 并提出过程改进计划</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>合计</td>
<td></td>
<td>1135</td>
<td>1725</td>
</tr>
</tbody></table>
<h1 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h1><p><strong>有待改进的地方</strong></p>
<p>   溢出问题：当给定r过大的时候，将会导致最终运算结构的分母溢出，而造成的数据错误<br>   目前方案：检查溢出，将发生了溢出的表达式删除<br>   更佳方案：使用大数的运算，就可以完美避免数据溢出的问题</p>
<p> 生成题目不够友好：当给定数据范围r稍稍有点大的时候，最终答案的分母可能超过一亿<br> 目前方案：不处理<br> 更佳方案: 暂无</p>
<p> 死循环生成题目: 当给定题数过大且给定限制太小时,无法生成要求的题目数量, 导致进入死循环<br> 目前方案: 设置时间戳time,只生成1000000次表达式,再进行合法性判断,但也导致有可能无法生成要求题目数量<br> 更佳方案: 暂无</p>
<h2 id="开发项目中发生的问题"><a href="#开发项目中发生的问题" class="headerlink" title="开发项目中发生的问题"></a><strong>开发项目中发生的问题</strong></h2><ol>
<li>一开始的时候是选择暴力深搜生成题集,再随机选取表达式输出,但是生成的效果来看,题目并不是很随机,例如前两个数字是固定死的,思前想后,觉得还是使用rand()随机生成效果更佳</li>
<li>在最开始设计方案的时候,还是思虑的不够多,以至于后面的代码复审(Debug)工作做了很多,远超过代码编写部分</li>
<li>还有各种人性化的设置,如参数错误提示,程序运行结果显示之类话语并没有想到,但是一个软件,一个项目最终都是面向于人群大众,人性化的设置是必须的</li>
</ol>
<h2 id="团队之中的闪光点"><a href="#团队之中的闪光点" class="headerlink" title="团队之中的闪光点"></a><strong>团队之中的闪光点</strong></h2><ol>
<li>良好的代码风格: 在一开始我们就约束好了团队的代码风格,在后续的代码编写之中我们也能够很好的参照代码风格进行书写,因此在代码复审的时候我们也能够很好的查阅对方的代码</li>
<li>不错的代码能力: 想定思路学习知识之后,可直接进行代码的实现,基本上不会出现一些逻辑错误.后面出现的bug也是因为设计的时候稍稍不够考虑细节,一旦出现bug,都能够立马找到bug和想到相应的修复方案</li>
<li>互帮互助: 在一开始我们就进行了分工,一个人主要负责对给定的题目文件和答案文件进行答案校对、参数组合正确性的检测，另一个人负责了题集的生成部分。并且在最后，一起测试并撰写了博客。<br>通过这次项目，我们实践了结对编程，提高了沟通能力，加强了团队合作的能力。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/word-count/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/07/word-count/" class="post-title-link" itemprop="url">wc项目折腾笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-07 15:09:53" itemprop="dateCreated datePublished" datetime="2018-09-07T15:09:53+08:00">2018-09-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/hyzgh/wordCount" target="_blank" rel="noopener">Github项目地址传送门</a></p>
<h1 id="项目相关要求"><a href="#项目相关要求" class="headerlink" title="项目相关要求"></a>项目相关要求</h1><ul>
<li><p>基本功能</p>
<ul>
<li>统计C语言源文件的字符数（完成）</li>
<li>统计C语言源文件的词的数目（完成）</li>
<li>统计C语言源文件的行数（完成）</li>
</ul>
</li>
<li><p>拓展功能</p>
<ul>
<li>递归处理目录下符合条件的文件（完成）</li>
<li>返回更复杂的数据（代码行 / 空行 / 注释行）（完成）</li>
<li>支持各种文件的通配符（*,?）（完成）</li>
</ul>
</li>
<li><p>高级功能</p>
<ul>
<li>实现图形界面（待完成）</li>
</ul>
</li>
</ul>
<p>首先，我们需要明确一下“字符”，“词”，“行”，“代码行”，“空行”，“注释行”的定义。<br>字符：一个ASCII字符，包括控制字符和可打印字符。<br>词：一个由空白字符（不仅指空格，还指’\f’,’\v’,’\n’,’\r’这些控制字符）分隔的非空字符串。<br>行：一个由换行符分隔的字符串，可以为空。一行结束的标志是换行符。</p>
<blockquote>
</blockquote>
<p>代码行：本行包括多于一个字符的代码。<br>空行：本行全部是空格或格式控制字符，如果包括代码，则只有不超过一个可显示的字符，例如“{”。<br>注释行：本行不是代码行，并且本行包括注释。</p>
<p>以上代码行、空行、注释行的说明摘自项目说明。</p>
<p>为了消除歧义，特提出以下补充说明：<br>1.项目说明指出了下面第一行是注释行，类似的，第二行和第三行也是项目行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="comment">//注释</span></span><br><span class="line">&#123; <span class="comment">//注释</span></span><br><span class="line">; <span class="comment">//注释</span></span><br></pre></td></tr></table></figure>

<p>2.按照定义，下面这一行是代码行，但不是注释行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, world"</span>); <span class="comment">//say "Hello, world"</span></span><br></pre></td></tr></table></figure>

<p>3.按照定义，第一行是代码行，但不是注释行。第二行和第三行是注释行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, world"</span>); <span class="comment">/*say "Hello, world"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                         */</span></span><br></pre></td></tr></table></figure>

<p>4.第二行不是空白行。第一行到第三行都是注释行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The next line is a comment line.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于字符数的统计，每读取一个字符，让<code>chracters</code>加一即可。<br>对于词数的统计，需要一个标记，用于记录前面一个字符是不是空白字符，假如前面一个字符是空白字符且当前字符是可显示字符，那么让<code>words</code>加一。<br>对于行数的统计，每读取到一个换行符，让<code>lines</code>加一即可。<br>对于空白行、代码行、注释行的统计，需要用到一个块注释标记和一些正则表达式，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> blankLineRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)"</span>;</span><br><span class="line"><span class="built_in">string</span> lineCommentRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)"</span>;</span><br><span class="line"><span class="built_in">string</span> blockCommentStartFlagRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line"><span class="built_in">string</span> blockCommentStartFlag1Regex = <span class="string">"(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line"><span class="built_in">string</span> blockCommentCloseFlagRegex = <span class="string">"(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>每读取一行，首先需要判断当前行是不是位于块注释中，假如是，让注释行加一，否则进行2</li>
<li>使用blankLineRegex这个正则表达式判断当前行是不是空白行，假如是，让空白行加一，否则进行3</li>
<li>使用lineCommentRegex判断当前行是不是行注释，假如是，让注释行加一，否则进行4</li>
<li>使用blockCommentStartFlagRegex判断当前行是不是含有块注释开始的标志且为注释行，假如是，把blockCommentFlag改为true，并将注释行加一，否则进行5</li>
<li>使用blockCommentStartFlag1Regex判断当前行是不是含有块注释开始的标志且为代码行，假如是，把blockCommentFlag改为true，并将代码行加一，否则进行6</li>
<li>假如以上情况都不是，那么说明该行是代码行，让代码行加一，并结束该行的判断</li>
</ol>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>File类：</p>
<ul>
<li>变量：<code>characters, words, lines, blankLines, codeLines, commentLines</code>.</li>
<li>方法：<ul>
<li><code>countBasic</code>：统计字符数、词数、行数。</li>
<li><code>countSpecialLines</code>：统计空白行、代码行、注释行。</li>
<li><code>print</code>：输出统计结果。</li>
</ul>
</li>
</ul>
<p><code>setMode</code>函数：根据输入参数设置模式。<br><code>readFile</code>函数：处理一个文件。<br><code>recursiveReadFiles</code>函数：处理一个目录。</p>
<p>主要流程就是读取命令行参数，然后调用<code>setMode</code>设置参数，接着根据对象是文件还是目录，分别调用<code>readFile</code>或<code>recursiveReadFiles</code>。
<code>readFile</code>接着又会调用<code>countBasic</code>和<code>countSpecialLines</code>，执行程序的核心部分，进行统计。接着调用print输出结果。</p>
<h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p>1.统计字符、词、行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countBasic</span><span class="params">(FILE *pFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">bool</span> spaceFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(pFile)) != EOF) &#123;</span><br><span class="line">        characters++;</span><br><span class="line"></span><br><span class="line">        words += (spaceFlag == <span class="literal">true</span> &amp;&amp; <span class="built_in">isgraph</span>(c));</span><br><span class="line">        spaceFlag = <span class="built_in">isspace</span>(c);</span><br><span class="line"></span><br><span class="line">        lines += c == <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.统计空白行、代码行、注释行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 要确定一行是不是空白行，只要通过判断该行的可打印字符个数是否不超过1个即可。另外还要注意，该行不能在块注释中。</span></span><br><span class="line"><span class="comment"> * 要确定一行是不是代码行，只要判断该行的可打印字符个数是否超过1个即可。另外还要注意，改行不在块注释中。</span></span><br><span class="line"><span class="comment"> * 假如一行是注释行，那么该行首先必须不是代码行，其次，需要有注释标志。</span></span><br><span class="line"><span class="comment"> * 根据以上信息，可写出正则表达式进行匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSpecialLines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> blankLineRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> lineCommentRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(//)(.*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> blockCommentStartFlagRegex = <span class="string">"(\\s*)([&#123;&#125;;]?)(\\s*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> blockCommentStartFlag1Regex = <span class="string">"(.*)(/&#123;1&#125;)(\\*&#123;1&#125;)(.*)"</span>;</span><br><span class="line">    <span class="built_in">string</span> blockCommentCloseFlagRegex = <span class="string">"(.*)(\\*&#123;1&#125;)(/&#123;1&#125;)(\\s*)"</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(file, line)) &#123; <span class="keyword">if</span>(blockCommentFlag) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">            <span class="keyword">if</span>(regex_match(line, regex(blockCommentCloseFlagRegex))) &#123;</span><br><span class="line">                blockCommentFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(blankLineRegex))) &#123;</span><br><span class="line">            blankLines++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(lineCommentRegex))) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(blockCommentStartFlagRegex))) &#123;</span><br><span class="line">            commentLines++;</span><br><span class="line">            blockCommentFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(regex_match(line, regex(blockCommentStartFlag1Regex))) &#123;</span><br><span class="line">            codeLines++;</span><br><span class="line">            blockCommentFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            codeLines++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.根据参数输出统计结果，注意输出顺序是有规律的，依次为字符数 词数 行数 空白行数 代码行数 注释行数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'c'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d"</span>, characters);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'w'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d"</span>, words);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'l'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d"</span>, lines);</span><br><span class="line">    <span class="keyword">if</span>(mode[<span class="string">'a'</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d%6d%6d"</span>, blankLines, codeLines, commentLines);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>首先我制作了几个经典的测试样例以及对应的参考统计结果，另外，为了节省测试时间，我还写了一个脚本来进行自动化测试。<br>假如所有的测试样例都通过了，则会提示ok，如下：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205421076-284872409.png" alt="ok"><br>假如有些样例没有通过，则会提示wrong，并指出错在哪里，如下：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205428881-788451626.png" alt="wrong"><br>我构造的测试样例及测试结果如下：</p>
<ol>
<li>空文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205439689-254256383.png" alt="空文件"><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205923166-1878202581.png" alt></li>
</ol>
<p><strong>这里输出的依次是字符数、词数、行数、空行数、代码行数、注释行数。下面的也一样。</strong><br>之所以这么输出，是模仿了Linux系统下自带的wc命令。一开始我也不太理解wc命令输出的东西哪个是字符数、哪个是单词数，所以阅读了一下文档，找到了输出的规则，理解了输出的含义。<br>所以，我这里也用了这种实现方式，这样做能减少输出冗余信息，减少用户的阅读负担，让用户更快地获得想要的信息。</p>
<ol start="2">
<li>一个字符的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205912825-488820294.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911205958319-1399208864.png" alt></li>
<li>一个单词的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210007243-239773037.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210013271-1946409668.png" alt></li>
<li>一行的文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210114455-1151020509.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210119963-1429841711.png" alt></li>
<li>典型的C源文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210126528-40224607.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210131462-486603797.png" alt></li>
<li>另一个典型的C源文件<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210153931-1158546205.png" alt><br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210159342-1826726136.png" alt></li>
</ol>
<p>除了测试这些样例，我还测试了非法输入的情况，如下：</p>
<ol>
<li>没有输入参数<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210210247-1688868089.png" alt></li>
<li>参数非法<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210225526-1188622487.png" alt></li>
<li>文件或目录不存在<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210231620-1867302132.png" alt></li>
<li>在未输入s参数的情况下查询目录<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210246330-568258736.png" alt></li>
</ol>
<p>拓展功能的查询更复杂信息和查询目录的测试：<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911210335631-1210398873.png" alt></p>
<p>支持各种文件的通配符（*,?）的测试：<br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180915090044777-1329710180.png" alt><br><img src="https://img2018.cnblogs.com/blog/1484352/201809/1484352-20180915090113262-414065472.png" alt></p>
<h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><p>博主使用了gcov与lcov进行代码覆盖率的测试。经过测试发现，行覆盖率为91.5%，函数覆盖率为100%。<br><img src="https://images2018.cnblogs.com/blog/1484352/201809/1484352-20180911234128799-238501992.png" alt></p>
<h1 id="遇到的困难及解决方法"><a href="#遇到的困难及解决方法" class="headerlink" title="遇到的困难及解决方法"></a>遇到的困难及解决方法</h1><ol>
<li>之前很少用C++写与文件操作相关的代码，所以对于实现-s这个参数的时候无从下手，最后，通过搜索引擎，查阅官方文档和他人的博客，学习到了新知识，顺利地解决了这个问题。</li>
<li>实现-a这个参数，需要统计空行、代码行、注释行。一开始，我的想法是逐个读取字符，进行相关变量的更新，并进行状态转化。但是，这样实现的话，会需要很多的标记，让代码晦涩难懂。而且由于这个状态机的状态很多，状态之间的转化也相当复杂。所以，最后我放弃了这种实现方式，改用正则表达式来实现，这样会简单很多。这启发我，在具体实现前，最好先比较一下各种实现方式的难易程度，再选择一种比较容易的来写。</li>
</ol>
<h1 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h1><table>
<thead>
<tr>
<th>PSP2.1</th>
<th>Personal Software Process Stages</th>
<th>预估耗时（分钟）</th>
<th>实际耗时（分钟）</th>
</tr>
</thead>
<tbody><tr>
<td>Planning</td>
<td>计划</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>· Estimate</td>
<td>· 估计这个任务需要多少时间</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>Development</td>
<td>开发</td>
<td>525</td>
<td>600</td>
</tr>
<tr>
<td>· Analysis</td>
<td>· 需求分析 (包括学习新技术)</td>
<td>75</td>
<td>75</td>
</tr>
<tr>
<td>· Design Spec</td>
<td>· 生成设计文档</td>
<td>25</td>
<td>0</td>
</tr>
<tr>
<td>· Design Review</td>
<td>· 设计复审 (和同事审核设计文档)</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>· Coding Standard</td>
<td>· 代码规范 (为目前的开发制定合适的规范)</td>
<td>25</td>
<td>0</td>
</tr>
<tr>
<td>· Design</td>
<td>· 具体设计</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>· Coding</td>
<td>· 具体编码</td>
<td>325</td>
<td>425</td>
</tr>
<tr>
<td>· Code Review</td>
<td>· 代码复审</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>· Test</td>
<td>· 测试（自我测试，修改代码，提交修改）</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>Reporting</td>
<td>报告</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>· Test Report</td>
<td>· 测试报告</td>
<td>50</td>
<td>50</td>
</tr>
<tr>
<td>· Size Measurement</td>
<td>· 计算工作量</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>· Postmortem &amp; Process Improvement Plan</td>
<td>· 事后总结, 并提出过程改进计划</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>合计</td>
<td></td>
<td>650</td>
<td>750</td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一开始没有认真分析需求，没有想好就开始动手编码实现，中途停停顿顿，浪费了不少时间。从上面的PSP也可以看出，我花了很少时间在“生成设计文档”、“设计复审”、“代码规范”这三个环节上，导致我后面“具体编码”的环节花的时间比预估的时间长了很多。后来，我重新阅读了项目文件，明确了需求，并进行了相关设计，然后就实现得比较顺利了。这启发我，在开始动手编码前，应该先想好思路，并设计好模块，磨刀不误砍柴工嘛。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://magustest.com/2010/09/12/using-gcov-lcov/" target="_blank" rel="noopener">C/C++代码覆盖工具gcov与lcov入门</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/palindromic-tree-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hyzgh-128x128.png">
      <meta itemprop="name" content="hyz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hyz's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/04/palindromic-tree-learning/" class="post-title-link" itemprop="url">回文自动机学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-04 23:56:17" itemprop="dateCreated datePublished" datetime="2018-09-04T23:56:17+08:00">2018-09-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>回文自动机是一种可以处理回文符问题的优雅高效的数据结构。</p>
<h1 id="URAL-1960-Palindromes-and-Super-Abilities"><a href="#URAL-1960-Palindromes-and-Super-Abilities" class="headerlink" title="URAL 1960 Palindromes and Super Abilities"></a>URAL 1960 Palindromes and Super Abilities</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求各前缀的所有子串中的回文串种类。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>依次插入字符，每插入完一个字符，假如last指针所指的节点是新增的，那么答案加一。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 0 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN] ;<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN] ;<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN] ; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN] ; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN] ;<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN] ;<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last ;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n ;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p ;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span> <span class="params">( <span class="keyword">int</span> l )</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NN ; ++ i ) next[p][i] = <span class="number">0</span> ;</span><br><span class="line">        cnt[p] = <span class="number">0</span> ;</span><br><span class="line">        num[p] = <span class="number">0</span> ;</span><br><span class="line">        len[p] = l ;</span><br><span class="line">        <span class="keyword">return</span> p ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span> ;</span><br><span class="line">        newnode (  <span class="number">0</span> ) ;</span><br><span class="line">        newnode ( <span class="number">-1</span> ) ;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        n = <span class="number">0</span> ;</span><br><span class="line">        S[n] = <span class="number">-1</span> ;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span> ( S[n - len[x] - <span class="number">1</span>] != S[n] ) x = fail[x] ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> c )</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span> ;</span><br><span class="line">        S[++ n] = c ;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail ( last ) ;<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> ( !next[cur][c] ) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode ( len[cur] + <span class="number">2</span> ) ;<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail ( fail[cur] )][c] ;<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now ;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c] ;</span><br><span class="line">        cnt[last] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i ) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pt.add(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(pt.cnt[pt.last] == <span class="number">1</span>)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans, <span class="string">" \n"</span>[i == len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tsinsen-A1280-最长双回文串"><a href="#Tsinsen-A1280-最长双回文串" class="headerlink" title="Tsinsen A1280 最长双回文串"></a>Tsinsen A1280 最长双回文串</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个字符串，在中间某个位置切开，能形成两个回文串，则称这个回文串为双回文串。现在需要求最长双回文串。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令a[i]表示以i结束的最长回文串长度，b[i]表示从i开始的最长回文串长度。<br>每插入一个字符，就更新这两个数组，最后扫一遍，取a[i] + b[i+1]的最大值。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 2 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN] ;<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN] ;<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN] ; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN] ; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN] ;<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN] ;<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last ;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n ;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p ;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span> <span class="params">( <span class="keyword">int</span> l )</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NN ; ++ i ) next[p][i] = <span class="number">0</span> ;</span><br><span class="line">        cnt[p] = <span class="number">0</span> ;</span><br><span class="line">        num[p] = <span class="number">0</span> ;</span><br><span class="line">        len[p] = l ;</span><br><span class="line">        <span class="keyword">return</span> p ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span> ;</span><br><span class="line">        newnode (  <span class="number">0</span> ) ;</span><br><span class="line">        newnode ( <span class="number">-1</span> ) ;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        n = <span class="number">0</span> ;</span><br><span class="line">        S[n] = <span class="number">-1</span> ;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span> ( S[n - len[x] - <span class="number">1</span>] != S[n] ) x = fail[x] ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> c )</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span> ;</span><br><span class="line">        S[++ n] = c ;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail ( last ) ;<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span> ( !next[cur][c] ) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode ( len[cur] + <span class="number">2</span> ) ;<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail ( fail[cur] )][c] ;<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now ;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c] ;</span><br><span class="line">        a[id] = len[last];</span><br><span class="line">        b[id - len[last] + <span class="number">1</span>] = max(b[id - len[last] + <span class="number">1</span>], len[last]);</span><br><span class="line">        cnt[last] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i ) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pt.add(i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans = max(ans, a[i] + b[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tsinsen-A1255-拉拉队排练"><a href="#Tsinsen-A1255-拉拉队排练" class="headerlink" title="Tsinsen A1255 拉拉队排练"></a>Tsinsen A1255 拉拉队排练</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>求前k大奇数长度的回文串的乘积。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先建回文自动机，然后dfs奇根节点，找出奇数长度的回文串的长度和个数，放到容器，排个序贪心取出来即可。注意不能直接递归dfs，会爆栈，需要用stack。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/STACK:1024000000,1024000000"</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">19930726</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;	<span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line">pii a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; v;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    que.push(u);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = pt.next[u][i];</span><br><span class="line">            <span class="keyword">if</span>(t) &#123;</span><br><span class="line">                sum += pt.cnt[t];</span><br><span class="line">                que.push(t);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">                v.push_back(pii(pt.len[t], pt.cnt[t]));</span><br><span class="line">                <span class="comment">//dfs(t);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii a, pii b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) (ans *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pt.add(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pt.count();</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(v.begin(), v.end(), cmp);</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: v) &#123;</span><br><span class="line">            ll num = min(<span class="number">1L</span>L * i.y, k);</span><br><span class="line">            (ans *= ksm(i.x, num)) %= mod;</span><br><span class="line">            k -= i.y;</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Tsinsen-A1393-Palisection"><a href="#Tsinsen-A1393-Palisection" class="headerlink" title="Tsinsen A1393 Palisection"></a>Tsinsen A1393 Palisection</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>求相交回文串的对数。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>直接求相交回文串的对数的话，不好求。经过思考，发现所有回文串对数以及不相交回文串的对数比较好求，而这两者相减就是答案，得解。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">51123987</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 5 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;	<span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">        <span class="keyword">return</span> num[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll sum[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s);</span><br><span class="line">    pt.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        (sum[i+<span class="number">1</span>] = sum[i] + pt.add(s[i])) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    (ans = <span class="number">1L</span>L * sum[n] * (sum[n] - <span class="number">1</span>) / <span class="number">2</span>) %= mod;</span><br><span class="line">    reverse(s, s + n);</span><br><span class="line">    pt.init();</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        t = pt.add(s[i]);</span><br><span class="line">        ans -= t * sum[n - i - <span class="number">1</span>];</span><br><span class="line">        (ans += mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Gym-100548G-The-Problem-to-Slow-Down-You"><a href="#Gym-100548G-The-Problem-to-Slow-Down-You" class="headerlink" title="Gym 100548G The Problem to Slow Down You"></a>Gym 100548G The Problem to Slow Down You</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给两个字符串，求两个字符串中相同回文串的对数。</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先分别给两个字符串建立回文自动机，然后分别dfs一下奇偶根节点，累加两个回文自动机相同位置的节点的cnt乘积即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ok cout &lt;&lt; <span class="meta-string">"ok"</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = <span class="number">9223372036854775807</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">/* 回文自动机：解决一类回文字符串问题(Tested 4 times)</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(|S| * log(字符集个数))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">26</span>;	<span class="comment">//字符集个数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[MAXN][NN];<span class="comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXN];<span class="comment">//fail指针，失配后跳转到fail指针指向的节点</span></span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN]; <span class="comment">//cnt[i]表示i表示的回文字符串在整个字符串中出现了多少次</span></span><br><span class="line">    <span class="keyword">int</span> num[MAXN]; <span class="comment">//num[i]表示i表示的回文字符串中有多少个本质不同的字符串（包括本身）</span></span><br><span class="line">    <span class="keyword">int</span> len[MAXN];<span class="comment">//len[i]表示节点i表示的回文串的长度</span></span><br><span class="line">    <span class="keyword">int</span> S[MAXN];<span class="comment">//存放添加的字符</span></span><br><span class="line">    <span class="keyword">int</span> last;<span class="comment">//指向上一个字符所在的节点，方便下一次add</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//字符数组指针</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;<span class="comment">//新建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) next[p][i] = <span class="number">0</span>;</span><br><span class="line">        cnt[p] = <span class="number">0</span>;</span><br><span class="line">        num[p] = <span class="number">0</span>;</span><br><span class="line">        len[p] = l;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        S[n] = <span class="number">-1</span>;<span class="comment">//开头放一个字符集中没有的字符，减少特判</span></span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//和KMP一样，失配后找一个尽量最长的</span></span><br><span class="line">        <span class="keyword">while</span>(S[n - len[x] - <span class="number">1</span>] != S[n]) x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的是字符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        c -= <span class="string">'a'</span>;</span><br><span class="line">        S[++ n] = c;</span><br><span class="line">        <span class="keyword">int</span> cur = get_fail(last);<span class="comment">//通过上一个回文串找这个回文串的匹配位置</span></span><br><span class="line">        <span class="keyword">if</span>(!next[cur][c]) &#123;<span class="comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></span><br><span class="line">            <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);<span class="comment">//新建节点</span></span><br><span class="line">            fail[now] = next[get_fail(fail[cur])][c];<span class="comment">//和AC自动机一样建立fail指针，以便失配后跳转</span></span><br><span class="line">            next[cur][c] = now;</span><br><span class="line">            num[now] = num[fail[now]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cnt[fail[i]] += cnt[i];</span><br><span class="line">        <span class="comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> len[<span class="number">2</span>], kase;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u0, <span class="keyword">int</span> u1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t0 = pt[<span class="number">0</span>].next[u0][i];</span><br><span class="line">        <span class="keyword">int</span> t1 = pt[<span class="number">1</span>].next[u1][i];</span><br><span class="line">        <span class="keyword">if</span>(t0 &amp;&amp; t1) &#123;</span><br><span class="line">            ans += <span class="number">1L</span>L * pt[<span class="number">0</span>].cnt[t0] * pt[<span class="number">1</span>].cnt[t1];</span><br><span class="line">            dfs(t0, t1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fopen(<span class="string">"in"</span>, <span class="string">"r"</span>)!=<span class="literal">NULL</span>) &#123;freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);&#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">            len[k] = <span class="built_in">strlen</span>(s[k]);</span><br><span class="line">            pt[k].init();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len[k]; i++) &#123;</span><br><span class="line">                pt[k].add(s[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            pt[k].count();</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hyz"
      src="/images/hyzgh-128x128.png">
  <p class="site-author-name" itemprop="name">hyz</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hyzgh" title="GitHub → https://github.com/hyzgh" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-male"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hyz</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
